/*******************************************************************************
Copyright (C) Autelan Technology


This software file is owned and distributed by Autelan Technology 
********************************************************************************


THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
********************************************************************************
* ACDbus_handler.c
*
*
* CREATOR:
* autelan.software.wireless-control. team
*
* DESCRIPTION:
* wid module
*
*
*******************************************************************************/
#include <string.h>
#include <dbus/dbus.h>
#include <stdbool.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h> 
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <sys/un.h>
#include <dirent.h>
#include "CWAC.h"
#include "CWCommon.h"
#include "ACMultiHomedSocket.h"
#include "dbus/wcpss/ACDbusDef1.h"
#include "dbus/asd/ASDDbusDef1.h"
#include "hmd/hmdpub.h"
#include "CWStevens.h"
#include "wcpss/waw.h"
#include "wcpss/wid/WID.h"
#include "wcpss/asd/asd.h"
#include "ACDbus_handler.h"
#include "ACDbus.h"
#include "iplist.h"
#include "ACBak.h"
#include "ACIPv6Addr.h"
#include "ACLoadbanlance.h"
#include <syslog.h>
#include "AC.h"
#include <math.h>
#include "sysdef/returncode.h"
#include <iconv.h>

APScanningSetting gapscanset = {0};
int wids_judge_policy = 7;
white_mac_list *pwhite_mac_list = NULL;
white_mac_list *pblack_mac_list = NULL;
unsigned char wirelessdata_switch = 0;
unsigned char wireddata_switch = 0;
unsigned char apstatistics = 0;
unsigned int apstatisticsinterval = 1800;
unsigned char aphotreboot = 0;
wid_wids_set gwids = {0};

unsigned char gwidsinterval = 1;
unsigned char gprobethreshold = 0;
unsigned char gotherthreshold = 30;
unsigned int glasttimeinblack = 300;

update_wtp_list * updatewtplist = NULL;
unsigned int checkwtpcount = 0;
int gtrapflag = 1;
int gtrap_ap_run_quit_trap_switch = 0;
int gtrap_ap_cpu_trap_switch = 0;
int gtrap_ap_mem_trap_switch = 0;
int gtrap_rrm_change_trap_switch = 0;
int gtrap_flash_write_fail_trap_switch = 0;
int gtrap_channel_device_ap_switch = 0; /*zhaoruijia,tranlate  neighbor_channel_interference to 1.3,start*/
int gtrap_channel_device_interference_switch = 0;
int gtrap_channel_terminal_interference_switch = 0;
int gtrap_rogue_ap_threshold_switch = 0;
int gtrap_wireless_interface_down_switch = 0;
int gtrap_channel_count_minor_switch = 0;
int gtrap_channel_change_switch = 0;
unsigned char updatemaxfailcount = 1;
unsigned char gwidspolicy = 0;
wid_wids_device *wids_ignore_list = NULL;
unsigned char countermeasurecount = 0;
unsigned char sta_deauth_message_reportswitch = 0;
unsigned char sta_flow_information_reportswitch  = 0;


int istryreadipv6addr = 0;
int istrybindipv6addr = 0;
unsigned char gmacfilterflag = 0;
unsigned char gessidfilterflag = 0;
extern unsigned int sample_infor_interval;
int wid_dbug_trap_ssid_key_conflict(unsigned int wtpid,unsigned char radio_l_id, unsigned char wlan1, unsigned char wlan2);

#define CFDISK_MIN_MEM (1000)
#define SYSTEM_MIN_MEM (300000)
#define DYNAMIC_VLAN_MAX_ID 4095
#define DYNAMIC_VLAN_MAX_AMOUNT 1024

extern enum wtp_upgrade_mode g_wtp_upgrade_mode;
extern CWConfigVersionXml SOFT_XMLINFO[CW_MODEL_COUNT];

int ACDBUS_MSGQ;
extern enum wtp_rogue_mode g_wtp_rogue_mode;

//xm add
OUI_LIST_S 			g_oui_list = {0,NULL};
ESSID_LIST_S 		g_essid_list = {0,NULL};
ATTACK_MAC_LIST_S	g_attack_mac_list = {0,NULL};
int setWtpNoRespToStaProReq(unsigned int wtpid,unsigned char l_radioid,unsigned char wlanid,unsigned int policy);
int setWtpUniMutiBroCastIsolation(unsigned int wtpid,unsigned char radioid,unsigned char wlanid,unsigned char policy);
int setWtpUniMutiBroCastRate(unsigned int wtpid,unsigned char radioid,unsigned char wlanid,unsigned int rate);
void free_maclist(struct acl_config *conf, struct maclist *list);

CWBool check_wtpid_func(unsigned int WTPID){
	if(WTPID >= WTP_NUM){
		return CW_FALSE;
	}else{
		return CW_TRUE;
	}
}
CWBool check_wlanid_func(unsigned int WLANID){
	if(WLANID >= WLAN_NUM){
		return CW_FALSE;
	}else{
		return CW_TRUE;
	}
}
CWBool check_bssid_func(unsigned int BSSID)
{
	if((BSSID >= BSS_NUM) || (BSSID < L_RADIO_NUM * L_BSS_NUM))
	{
		return CW_FALSE;
	}
	else if(AC_BSS[BSSID] == NULL)
	{
		return CW_FALSE;
	}
	else
	{
		return CW_TRUE;
	}
}

CWBool check_g_radioid_func(unsigned int RADIOID)
{
	if (RADIOID >= G_RADIO_NUM)
	{
		return CW_FALSE;
	}
	else
	{
		return CW_TRUE;
	}
}

CWBool check_l_radioid_func(unsigned int RADIOID)
{
	if (RADIOID >= L_RADIO_NUM)
	{
		return CW_FALSE;
	}
	else
	{
		return CW_TRUE;
	}
}

void wid_apstatsinfo_init(unsigned int WTPID)
{
	int i = 0;
	
	for (i = 0; i < TOTAL_AP_IF_NUM; i++)
	{
		AC_WTP[WTPID]->apstatsinfo[i].radioId = TOTAL_AP_IF_NUM+1;
		AC_WTP[WTPID]->apstatsinfo[i].type = TOTAL_AP_IF_NUM+1;
		AC_WTP[WTPID]->apstatsinfo[i].wlanId = 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_bytes = 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_bytes = 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_drop = 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_drop = 0;

		
		AC_WTP[WTPID]->apstatsinfo[i].rx_packets = 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_packets = 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_errors = 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_errors = 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_rate = 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_rate = 0;
		AC_WTP[WTPID]->apstatsinfo[i].ast_rx_crcerr = 0;
		AC_WTP[WTPID]->apstatsinfo[i].ast_rx_badcrypt = 0;
		AC_WTP[WTPID]->apstatsinfo[i].ast_rx_badmic = 0;
		AC_WTP[WTPID]->apstatsinfo[i].ast_rx_phyerr = 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_frame = 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_frame = 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_error_frame = 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_error_frame = 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_drop_frame = 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_drop_frame = 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_band= 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_band= 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_unicast= 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_unicast= 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_broadcast= 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_broadcast= 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_multicast= 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_multicast= 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_pkt_unicast= 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_pkt_unicast = 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_pkt_broadcast= 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_pkt_broadcast = 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_pkt_multicast= 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_pkt_multicast = 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_pkt_retry = 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_pkt_retry = 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_retry = 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_retry = 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_pkt_mgmt =0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_pkt_mgmt =0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_mgmt =0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_mgmt =0;
		AC_WTP[WTPID]->apstatsinfo[i].is_refuse_lowrssi = 0;  //fengwenchao add  for chinamobile-177,20111122
	}
}

int mac_format_check(char *str, int len) 
{
	int i = 0;
	unsigned int result = 0;
	char c = 0;
	
	if (17 != len)
	{
		return -1;
	}
	
	for (; i < len; i++)
	{
		c = str[i];
		if ((2 == i) || (5 == i) || (8 == i) || (11 == i) || (14 == i))
		{
			if ((':' != c) && ('-' != c))
			{
				return -1;
			}
		}
		else if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))
		{
			continue;
		}
		else
		{
			result = -1;
			return result;
		}
	}
	
	if ((str[2] != str[5]) || (str[2] != str[8]) || (str[2] != str[11])
		|| (str[2] != str[14]) || (str[5] != str[8]) || (str[5] != str[11])
		|| (str[5] != str[14]) || (str[8] != str[11]) || (str[8] != str[14]))
	{
		result = -1;
		return result;
	}
	
	return result;
}

int parse_mac_addr(char *input, MACADDR *macAddr)
{
	int i = 0;
	char cur = 0,value = 0;
	
	if ((NULL == input) || (NULL == macAddr))
	{
		return -1;
	}
	if (-1 == mac_format_check(input,strlen(input)))
	{
		return -1;
	}
	
	for (i = 0; i < 6; i++)
	{
		cur = *(input++);
		if ((cur == ':') || (cur == '-'))
		{
			i--;
			continue;
		}
		if ((cur >= '0') && (cur <= '9'))
		{
			value = cur - '0';
		}
		else if((cur >= 'A') &&(cur <='F'))
		{
			value = cur - 'A';
			value += 0xa;
		}
		else if ((cur >= 'a') && (cur <= 'f'))
		{
			value = cur - 'a';
			value += 0xa;
		}
		macAddr->arEther[i] = value;
		cur = *(input++);	
		if ((cur >= '0') && (cur <= '9'))
		{
			value = cur - '0';
		}
		else if ((cur >= 'A') && (cur <= 'F'))
		{
			value = cur - 'A';
			value += 0xa;
		}
		else if ((cur >= 'a') && (cur <= 'f'))
		{
			value = cur - 'a';
			value += 0xa;
		}
		macAddr->arEther[i] = (macAddr->arEther[i]<< 4)|value;
	}
	
	return 0;
} 


char *wid_opcode2string(unsigned int opcode)
{
	switch (opcode) 
	{
		case WID_DBUS_SUCCESS:								/* 0 */
			return "Command operate successfully.";

		case WID_DBUS_ERROR:								/* 1 */
			return "%% Operation fail.";

		case SYSTEM_CMD_ERROR:								/* 2 */
			return "%% System cmd error.";

		case UNKNOWN_ERROR: 								/* 3 */
			return "%% unkonwn error.";

		case MALLOC_ERROR: 									/* 4 */
			return "%% Out of memory.";

		case PARAM_NULL_POINTER:							/* 5 */
			return "%% Parameter null pointer.";
			

		case WLAN_ID_BE_USED:								/* 6 */
			return "%% Wlan id exist.";

		case WLAN_ID_NOT_EXIST: 							/* 7 */
			return "%% Wlan id does not exist.";

		case WLAN_ID_LARGE_THAN_MAX: 						/* 8 */
			return "%% Wlan id is larger than max.";

		case WLAN_APPLY_SECURITY_FIRST:						/* 9 */
			return "%% Wlan should first apply security ID";

		case SECURITYINDEX_IS_SAME:							/* 10 */
			return  "%% Radio apply bingding securityindex is same with other.";


		case WLAN_NOT_BINDING_IF:							/* 11 */
			return "%% Wlan not bind interface.";

		case Wlan_IF_NOT_BE_BINDED:							/* 12 */
			return  "%% Wlan not bind interface.";

		case WLAN_BE_ENABLE: 								/* 13 */
			return "%% Wlan is enable, you should disable it first.";
			
		case WLAN_BE_DISABLE:								/* 14 */
			return "%% Wlan is disable, you should enable it first.";

		case WLAN_NOT_NEED_NAS: 							/* 15 */
			return "%% No nas_id needed,please use <wlan apply interface IFNAME>,without nas_identifier.";
				

		case WLAN_CREATE_BR_FAIL:							/* 16 */
			return "%% Wlan bridge error.";

		case WLAN_DELETE_BR_FAIL: 							/* 17 */
			return "%% Wlan delelte L3 bridge interface failed.";

		case WLAN_CREATE_L3_INTERFACE_FAIL: 				/* 18 */
			return	"%% Wlan crete wlan create layer3 interface failed.";
		
		case WLAN_DELETE_L3_INTERFACE_FAIL: 				/* 19 */
			return "%% Wlan delelte L3 interface failed.";

		case WID_BINDING_WLAN:								/* 20 */
			return "%% Before change binding interface, please delete binding wlan id first.";


		case WLAN_NOT_BINDING_VLAN:							/* 21 */
			return "%% Wlan has not binding vlan.";

		case WLAN_BINDING_VLAN:								/* 22 */
			return "%% Wlan have already binding vlan,please undo wlan-vlan binding first.";

		case WLAN_SERVICE_CONTROL_BE_USED:					/* 23 */
			return "%% Wlan starttimer or stoptimer should be disabled.";

		case WLAN_UPLINK_ALREADY:							/* 24 */
			return "%% ";
			
		case WLAN_UPLINK_IS_ENABLE:							/* 25 */
			return "%% Uplink check working,please disable first.";

	
		case WLAN_IF_NOT_BE_TUNNELMODE: 					/* 26 */
			return "%% "; 

		case RAOMING_DISABLE_FIRST: 						/* 27 */
			return "%% Roaming should be disable first.";

		case ISOLATION_CONFLICT:							/* 28 */
			return "%% Sameportswitch and isolation are conflict,disable sameportswitch first.";	

		case WDS_MODE_BE_USED: 								/* 29 */
			return "%% Another WDS mode be used, disable first.";

		case WTP_ID_BE_USED:								/* 30 */
			return "%% Wtp is used, should unused it first.";


		case WTP_ID_NOT_EXIST:								/* 31 */
			return "%% Wtp id does not exist.";
			
		case WTP_ID_LARGE_THAN_MAX: 						/* 32 */
			return "%% Wtp id larger than max.";

		case WTP_OVER_MAX_NUM: 								/* 33 */
			return "%% Create wtp count reach to max wtp count.";

		case WTP_MAC_BE_USED: 								/* 34 */
			return "%% Wtp mac exist.";
					
		case WTP_SN_BE_USED:								/* 35 */
			return "%% Wtp sn exist.";


		case WTP_BE_USING:									/* 36 */
			return "%% This wtp is used and active, unused it first.";

		case WTP_IS_NOT_BINDING_WLAN_ID:					/* 37 */
			return  "%% wtp is not bound to wlan.";

		case WTP_CLEAR_BINDING_WLAN_SUCCESS:				/* 38 */
			return "%% Clear wtp binding wlan list successfully.";

		case WTP_WLAN_BINDING_NOT_MATCH:					/* 39 */
			return  "%% Wtp wlan binding interface not match.";			

		case WTP_IF_NOT_BE_BINDED:							/* 40 */
			return  "%% Wtp not bind interface.";

			
		case WTP_NOT_IN_RUN_STATE:							/* 41 */
			return "%% Wtp is not in run state.";

		case WTP_NO_SURPORT_TYPE:							/* 42 */
			return "%% Radio type conflict, please check it first.";

		case WTP_NO_SURPORT_Rate:							/* 43 */
			return "%% Wtp mode conflict, does not support this rate.";

		case WTP_LESS_THAN_STATIC_WTP: 						/* 44 */
			return "%% Set max wtp must over current static wtp.";			

		case WTP_OVER_MAX_BSS_NUM:							/* 45 */
			return  "%% Bss num is already 32.";


		case WTP_WEP_NUM_OVER:								/* 46 */
			return  "%% Wtp over max wep wlan count 4 or wep index conflict.";
			
		case WTP_NO_NEIGHBORAP: 							/* 47 */
			return "%% No ap have neighbor ap.";

		case WID_NO_SURPORT_MODEL:							/* 48 */
			return "%% System does not surport this model.";

		case WTP_NO_SURPORT_CHANNEL: 						/* 49 */
			return "%% Radio type doesn't support this channel.";		

		case WID_AP_NO_STATICS: 							/* 50 */
			return "%% AP have not statistics information.";


		case NO_WTP_IN_RUN_STATE:							/* 51 */
			return	"%% No wtp in run state.";
				
		case WID_AP_SCANNING_DISABLE:						/* 52 */
			return "%% Radio resource managment is disable, enable it first.";

		case WID_WTP_LOCATION_NOT_SET: 						/* 53 */
			return "%% Wtp does not set location.";

		case MODEL_NO_EXIST: 								/* 54 */
			return "%% Model doesn't exist.";

		case MODEL_NO_CONFIG: 								/* 55 */
			return "%% The model is not configuration please change others.";


		case SUPPORT_VERSION_NOT_EXIST:						/* 56 */
			return "%% AC support model does not set.";

		case VERSION_NOT_SUPPORTED: 						/* 57 */
			return "%% This model does not supportted, set it first.";

		case SAMPLE_THROUGHPUT_NOT_ENABLE: 					/* 58 */
			return "%% Sample switch disable,enable it first.";

		case WID_NO_WHITELIST:								/* 59 */
			return "%% ";

		case WID_NO_BLACKLIST:								/* 60 */
			return "%% There is no black list.";


		case WID_TRANSMIT_POWER_CONTROL_DISABLE:			/* 61 */
			return "%% tTransmit power control is disable, enable first";
			
		case AP_L2_ISOLATION_ENABLE_OR_DIS_ALREADY: 		/* 62 */
			return "%% wlan l2 isolation does not need to repeat settings.";

		case MODEL_BIND_EVER:								/* 63 */
			return "%% This model has been bound ever.";

		case MODEL_BIND_NEVER:								/* 64 */
			return "%% This model hasn't been bound ever, make sure it first.";

		case UPDATE_CONFIG_FAIL: 							/* 65 */
			return "%% ";
			

		case UPDATE_PROCESS:								/* 66 */
			return "%% Update is process,please wait several minutes.";

		case NO_WIDS_DEVICE: 								/* 67 */
			return "%% There is no wids device.";

		case AUTO_AP_LOGIN_INTERFACE_ERROR: 				/* 68 */
			return "%% This interface is not auto login interface.";
	
		case AUTO_AP_LOGIN_INTERFACE_NOT_SET:				/* 69 */
			return "%% Auto ap login interface not set.";
	
		case AUTO_AP_LOGIN_WLAN_NOT_SET:					/* 70 */
			return "%% ";
	

		case AUTO_AP_LOGIN_SWITCH_IS_DISABLE:				/* 71 */
			return "%% Auto ap login switch is enable,you should disable it first.";
			
		case AUTO_AP_LOGIN_SWITCH_HAS_ALREADY_SETTED:		/* 72 */
			return "%% ";	

		case RADIO_ID_BE_USED:								/* 73 */
			return "%% Radio id exist.";

		case RADIO_ID_NOT_EXIST:							/* 74 */
			return "%% Radio id does not exist.";

		case RADIO_ID_LARGE_THAN_MAX:						/* 75 */
			return "%% Radio id is larger than max.";


		case RADIO_NO_BINDING_WLAN:							/* 76 */
			return "%% Radio is not bound to wlan.";

		case RADIO_IS_DISABLE:								/* 77 */
			return "%% Radio is disable, please enable it first.";

		case RADIO_NOT_SUPPORT_COMMAND: 					/* 78 */
			return "%% Radio not support this command.";

		case RADIO_SUPPORT_RATE_EMPTY:						/* 79 */
			return "%% Radio list is empty.";

		case RADIO_SUPPORT_RATE_ONE:						/* 80 */
			return "%% ";


		case RADIO_SUPPORT_RATE_EXIST:						/* 81 */
			return "%% ";

		case RADIO_SUPPORT_RATE_NOT_EXIST:					/* 82 */
			return "%% Radio support rate does not exist.";

		case RADIO_SUPPORT_RATE_CONFLICT: 					/* 83 */
			return "%% Radio type is conflict, please check it first.";

		case RADIO_SUPPORT_MAX_RATE_NOT_ONE:				/* 84 */
			return "%% ";			

		case RADIO_MODE_IS_11N:								/* 85 */
			return "%% Radio mode is not 11N or 11AC, don't support this command.";


		case RADIO_MODE_IS_PURE_N: 							/* 86 */
			return "%% Radio mode is an or gn, belong to puren, can't set to mixed.";

		case RADIO_ENCRYPTION_NO_MATCH:						/* 87 */
			return "%% Radio encryption type not match.";

		case RADIO_BRMAC_NOT_EXIST:							/* 88 */
			return "%% The mac not in radio rbmac list.";

		case RADIO_SECTOR_DISABLE:							/* 89 */
			return "%% Some of sectors is disable,enable it/them first.";
			
		case RADIO_AMPDU_DISABLE: 							/* 90 */
			return "%% Ampdu is disable, enable it frist.";


		case RADIO_11N_AMPDU_MUTEX:							/* 91 */
			return "%% Ampdu switch is enable, please disable it first.";

		case RADIO_11N_AMSDU_MUTEX:							/* 92 */
			return "%% Amsdu switch is enable, please disable it first.";

		case RADIO_CHANNEL_OFFSET_NEED_BE_RESET:			/* 93 */
			return "%% Channel offset should be set none.";
		
		case RADIO_HT_IS_NOT_40:							/* 94 */
			return "%% Radio channel bandwidth is not 40,don't support this command.";		

		case RADIO_IN_EBR: 									/* 95 */
			return "%% Radio interface is in ebr,please delete it from ebr first.";


		case RADIO_CHAINMASK_NUM_1: 						/* 96 */
			return "%% Radio chainmask number is 1, only support single flow.";
	
		case RADIO_CHAINMASK_NUM_2: 						/* 97 */
			return "%% Radio chainmask number is 2, only support single flow or double flow.";
	
		case RADIO_CHAINMASK_NUM_3: 						/* 98 */
			return "%% Radio chainmask number is 3, only support single flow, double flow or three flow.";

		case MCS_CROSS_THE_BORDER:							/* 99 */
			return "%% mcs cross the border, if your stream is one,mcs should be 0~7,if your stream is two,mcs should be 8~15,and if your stream is three,mcs should be 16~23";

		case MAC_MPDU_MSDU_MODE:							/* 100 */
			return "%% ";


		case RADIO_NO_BINDING_WQOS:							/* 101 */
			return "%% Radio has no binding qos.";
			
		case RADIO_SERVICE_CONTROL_BE_USED: 				/* 102 */
			return "%% Radio Service timer control be used, disable it first.";

		case TXPOWER_OVER_TW: 								/* 103 */
			return "%% This radio max txpower is 20.";

		case TXPOWER_OVER_TW_THREE:							/* 104 */
			return "%% This radio max txpower is 27.";
			
		case TXPOWEROFF_LARGER_THAN_MAX: 					/* 105 */
			return "%% Txpoweroffset is larger than max txpower! Please checkout txpowerstep!";


		case RADIO_SET_TXPOF_COUNTRY_CODE_ERROR: 			/* 106 */
			return "%% ";

		case CHECK_CHANNEL_CWMODE_FAIL:						/* 107 */
			return "%% ";

		case CHECK_COUNTRY_CODE_FAIL:						/* 108 */
			return "%% ";
						
		case BSS_ID_LARGE_THAN_MAX: 						/* 109 */
			return "%% The bssindex is larger than the maximum.";
	
		case BSS_NOT_EXIST:									/* 110 */
			return "%% Bss not exist";


		case BSS_NOT_ENABLE:								/* 111 */
			return "%% ";

		case BSS_BE_ENABLE:									/* 112 */
			return  "bss is enable, if you want to operate this, please disable it first.";

		case BSS_IF_NEED_CREATE:							/* 113 */
			return "%% BSS Interface does not exist, needs to be created.";
			
		case BSS_IF_NEED_DELETE: 							/* 114 */
			return  "%% BSS L3 interface is exist, you should delete this interface first.";

		case BSS_CREATE_L3_INTERFACE_FAIL:					/* 115 */
			return  "%% BSS create L3 interface fail.";


		case BSS_DELETE_L3_INTERFACE_FAIL:					/* 116 */
			return  "%% BSS delete L3 interface fail.";

		case BSS_L3_INTERFACE_ADD_BR_FAIL: 					/* 117 */
			return  "%% Add bss interface to wlan bridge fail.";
			
		case BSS_L3_INTERFACE_DEL_BR_FAIL:					/* 118 */
			return  "%% Remove bss interface from wlan bridge fail.";

		case SET_MAX_STANUM_SMALLER_THAN_CURRENT_STANUM:	/* 119 */
			return "%% Set max_stanum smaller than current stanum.";

		case NO_SURPPORT_IPIP:								/* 120 */
			return "%% Bridge mode cann't config ipip, change forward mode route first.";


		case PAST_L3_INTERFACE_ERROE:						/* 121 */
			return "%% ";

		case APPLY_IF_FAIL:									/* 122 */
			return "%% Interface is wrong, there is no index or flag or interface down.";
			
		case L3_INTERFACE_ERROR:							/* 123 */
			return "%% Map layer3 interace failed.";
		
		case ETH_NOT_EXIST: 								/* 124 */
			return "%% The eth interface does not exist.";

		case WID_EBR_IF_NOEXIT: 							/* 125 */
			return "%% Interface does not add to br or br uplink.";
			

		case BINDING_IPV6_ADDRE_RROR:						/* 126 */
			return "%% Bingding ipv6 addr error make sure interface have ipv6 address";

		case INTERFACE_NOT_BE_BINDED:               		/* 127 */
			return "%% Should apply interface first.";

		case INTERFACE_NOT_EXIST:       					/* 128 */
			return "%% Interface %s does not exist.";

		case INTERFACE_HAVE_NO_IP_ADDR:       	 			/* 129 */
			return "%% Interface have no ip address,please binding ip address first!!";
			
		case WID_ADD_RADIO_IF_FAIL: 						/* 130 */
			return "%% ";


		case INTERFACE_NOT_L3_IF:							/* 131 */
			return "%% This interface is not L3 interface.";

		case IF_BINDING_FLAG:								/* 132 */
			return	"%% Interface has be binded in other hansi.";
			
		case IF_POLICY_CONFLICT:							/* 133 */
			return "%% ";	

		case MORE_THAN_ONE_IF:								/* 134 */
			return "%% There is the same IP address of the interface.";		
			
		case IF_HAS_BEEN_LISTENNING:						/* 135 */
			return "%% ";
			

		case NO_IF_HAS_THIS_IP:								/* 136 */
			return "%% There is no have the IP address of the interface.";

		case WID_INTERFACE_NOT_BE_LOCAL_BOARD:				/* 137 */
			return "%% The interface is not local interface, permission denial.";
			
		case WID_QOS_BE_USED:								/* 138 */
			return "%% Qos id exist.";	

		case WID_QOS_NOT_EXIST:								/* 139 */
			return "%% Qos profile does not exist.";
			
		case WID_QOS_RADIO_SHOULD_BE_DISABLE: 				/* 140 */
			return "%% This qos profile is used by some radios, disable them first.";


		case WID_QOS_WMM_MAP_DISABLE:						/* 141 */
			return "%% This qos map is disable,please enable it first.";

		case WID_QOS_STREAM_ERROR:							/* 142 */
			return "%% ";

		case WID_QOS_PARAMETER_ERROR:						/* 143 */
			return "%% ";

		case WID_QOS_PARAMETER_VALUE_ERROR: 				/* 144 */
			return "%% ";
			
		case WID_QOS_BE_USED_BY_RADIO: 						/* 145 */
			return "%% This qos used by some radios, you can use <delete radio with wireless qos profile ID> command delete them.";	


		case WID_EBR_ERROR:									/* 146 */
			return "%% ebr interface error";

		case WID_EBR_BE_USED:								/* 147 */
			return "%% ebr id exist.";

		case WID_EBR_NOT_EXIST:								/* 148 */
			return "%% ebr id does not exist.";

		case WID_EBR_SHOULD_BE_DISABLE:						/* 149 */
			return "%% ebr is enable, should disable it first.";			

		case WID_EBR_IFLIST_EMPTY: 							/* 150 */
			return "%% ";


		case SWITCH_IS_DISABLE: 							/* 151 */
			return "%% The switch is enable, should disable it first.";

		case SWITCH_HAS_ALREADY_SETTED:						/* 152 */
			return "%% ";			

		case AC_IP_EXIST:									/* 153 */
			return "%% ";		

		case AC_IP_NOT_EXIST:								/* 154 */
			return "%% ";

		case AC_IP_BIND_IF_EXIST:							/* 155 */
			return "%% ";


		case AC_BALANCE_STATE:								/* 156 */
			return "%% ";

		case AC_BALANCE_FLOW:								/* 157 */
			return "%% ";

		case AC_BALANCE_NUM:								/* 158 */
			return "%% ";
			
		case WID_NEED_REBOOT:								/* 159 */
			return "%% ";

		case GROUP_ID_EXIST:								/* 160 */
			return  "%% Group id is exist.";


		case GROUP_ID_NOT_EXIST:							/* 161 */
			return "%% Group id is not exist.";

		case GROUP_ID_OVER_MAX: 							/* 162 */
			return	"%% Group id is larger than max.";

		case INVALID_LICENSE_TYPE: 							/* 163 */
			return "%% It's tohansi invalid license type.";			
			
		case WRONG_LICENSE_LIST:							/* 164 */
			return "%% Wrong license type list!";
			
		case LICENSE_NUM_LARGER_THAN_MAX:					/* 165 */
			return "%% Exceed the max number of license type.";


		case LICENSE_NUM_LESS_THAN_TWO: 					/* 166 */
			return "%% The number of license type should be more than one.";

		case LICENSE_NOT_EXIST: 							/* 167 */
			return "%% The license type doesn't exist.";

		case LICENSE_TYPE_DUPLICATED: 						/* 168 */
			return "%% Duplicated license type.";	

		case LICENSE_TYPE_BINDED:							/* 169 */
			return "%% The license type has been binded.";
			
		case LICENSE_NO_BINDING_SUCCESS:					/* 170 */
			return "%% Set license nobinding successfully.";


		case LICENSE_NOT_BINDED: 							/* 171 */
			return "%% The license type has not been binded.";

		case LICENSE_BINDED_ANOTHER: 						/* 172 */
			return "%% The license type wasn't been binded the same!";

		case CURRENT_NUM_MORE_THAN_MAX:						/* 173 */
			return "%% ";

		case FLOW_CHECK_BE_DISABLE: 						/* 174 */
			return "%% ";		

		case ACCOUNT_AFTER_AUTHORIZE:						/* 175 */
			return "%% ";


		case WID_MAC_ADD_ALREADY:							/* 176 */
			return "%% Mac add already!";

		case WID_UPGRADE_NUM_OVERFLOW: 						/* 177 */
			return "%% ";
				
		case MAC_DOESNOT_EXIT: 								/* 178 */
			return "%% SRC MAC isn't exist.";

		case MAC_ALREADY_EXIT:								/* 179 */
			return "%% DST MAC already in list.";
			
		case ESSID_IS_EXIST:								/* 180 */
			return	"%% Essid already exist.";
			

		case ESSID_NOT_EXIST:								/* 181 */
			return	"%% Essid not exist.";

		case ESSID_LIST_IS_NULL:							/* 182 */
			return "%% The essid list is null,there is no essid!";

		case WID_STATE_BE_SAME:							 	/* 183 */
			return "%% ";

		case WID_ADD_BLACK_WHITE_OUI_MAC_ERR:				/* 184 */
			return "%% ";

		case WID_DEL_BLACK_WHITE_OUI_MAC_ERR:				/* 185 */
			return "%% ";			


		case INVALID_TYPE:							 		/* 186 */
			return "%% ";

		case WID_UNKNOWN_ID:								/* 187 */
			return "%% ";
			
		case WID_ILLEGAL_INPUT: 							/* 188 */
			return "%% Illegal input:Input exceeds the maximum value of the parameter type.";

		case VALUE_OUT_OF_RANGE:							/* 189 */
			return  "%% Input out of legal range.";

		case MIN_LARGER_THAN_MAX: 							/* 190 */
			return  "%% ";


		case VALUE_IS_NONEED_TO_CHANGE:						/* 191 */
			return "%% The value is no need to change.";
			
		case MAC_GROUP_EXIST: 								/* 192 */
			return	"%% The macgroup id is exist.";

		case MAC_GROUP_NOT_EXIST:							/* 193 */
			return	"%% The macgroup id is not exist.";	
				
		case MAC_IN_LIST:									/* 194 */
			return	"%% The mac already in macgroup.";

	 	case MAC_NOT_IN_LIST:								/* 195 */
		 	return  "%% The mac not in macgroup.";
			
		 
		case RADIO_NO_BINDING_MACGROUP:					 	/* 196 */
			return  "%% .";
			 
		case GROUP_ID_LARGE_THAN_MAX:						/* 197 */
			return  "%% Input macgroup id should be 1 to 128.";
			 
		case MACGRP_IS_BINDED:					 			/* 198 */
			return  "%% The macgroup is binded,please unbind first.";

		case WTP_BIND_MACGRP:					 			/* 199 */
			return  "%% The wtp already bind macgroup.";

		case WLAN_BIND_MACGRP:					 			/* 200 */
			return  "%% The wlan already bind macgroup.";
			

	 	case MAC_LIST_IS_FULL: 				 				/* 201 */
		 	return  "%% Mac count over 128.";
			
		case WLAN_CTR_LIST_ENABLE:							/* 202 */
			return "%% WLAN control list is enable, disable it first.";
			
		case RADIO_SA_IS_ENABLE:							/* 203 */
			return "%% Spectrum-analysis service is enable, disable it first.";

		case RADIO_SA_PARA_INVALID:							/* 204 */
			return "%% Spectrum-analysis invalid parameter.";
			
		case UPGRADE_IS_WORKING:                            /* 205 */
			return  "%% Upgrade is working.";


		case VLAN_GROUP_ID_LARGE_THAN_MAX:                  /* 206 */
			return  "%% Vlan group id is larger than max.";			

        case VLAN_GROUP_SERVICE_ENABLE:                     /* 207 */
            return  "%% Vlan group service is enable, disable it first."; 
            
        case VLAN_GROUP_SERVICE_DISABLE:                    /* 208 */
            return  "%% Vlan group service already disable."; 
            
        case GROUP_MEMBER_OVER_MAX_NUM:                     /* 209 */
            return  "%% Add group member count reach to max count.";
            
        case RADIO_ID_NOT_IN_VLANGRP:                       /* 210 */
            return  "%% Radio id not in group.";

           
        case VLAN_ID_NOT_EXIST:                             /* 211 */
            return  "%% Vlan id is not exist.";
        
        case NO_SET_VLANGRP_WLAN:                           /* 212 */
            return  "%% Not set vlan group wlan.";
        
        case NO_SET_VLANGRP_VLAN:                           /* 213 */
            return  "%% Not set vlan group vlan.";
           
        case BSS_IN_OTHER_VLANGRP:                          /* 214 */
            return  "%% The bss has been set vlan in the other vlan group.";            
        
        case DYNAMIC_VLAN_NOT_DISABLE:                      /* 215 */
            return  "%% Dynamic-vlan not disable.";
        
        
        case DYNAMIC_VLAN_PARAMTER_ERROR:                   /* 216 */
            return  "%% input illegal dynamic-vlan list.";
        
        case DYNAMIC_VLAN_DELETE_ERROR:                     /* 217 */
            return  "%% can't delete dynamic-vlan id which is not existed.";
        
        case DYNAMIC_VLAN_ADD_ERROR:                        /* 218 */
            return  "%% amount of dynamic-vlan id can't more than 1024.";
           
        case WID_PARA_RANGE_INVALID:                        /* 219 */
            return  "%% Invalid parameter.";
            
        case NO_SET_GROUP_RADIO_MEMBER:                     /* 220 */
            return  "%% Not set group radio member.";

           
        case FAILED_GET_REPLY:                              /* 221 */
            return  "%% Failed to get reply..."; 
				 	
		case WID_QOS_DEFAULT: 				 				/* 222 */
		 	return  "%% The default created the qos and cannot be deleted.";
		
		case WTP_NO_ROGUEAP:								/* 223 */
			return  "%% Good luck there is no rogue ap.";	
		
		case MAC_IN_ROGUE_WHITELIST: 						/* 224 */
			return "%% mac has in white list";
		
		case MAC_IN_ROGUE_BLACKLIST: 						/* 225 */
			return "%% mac has in black list";

		
		case WID_AP_SCANNING_COUNTERMEASURES_DISABLE: 		/* 226 */
			return "%% Radio resource managment countermeasures is disable enable first.";
			
		case RADIO_MODE_IS_NOT_11AC:  					    /* 227 */
			return "%% Radio mode is not 11AC, don't support this command.";
		
		default :
			return "%% command operate failed.";
	}

	/* never get here */
	return NULL;
}

int wid_update_bss_to_wifi(unsigned int bssindex,unsigned int WTPIndex,unsigned char flag)
{
	if(1)//((AC_BSS[bssindex]->BSS_IF_POLICY == BSS_INTERFACE)||(AC_BSS[bssindex]->BSS_IF_POLICY == WLAN_INTERFACE))
	{
		struct sockaddr *sa = NULL;
		struct sockaddr *sa2 = NULL;
		int ret = -1;									
		IF_info ifinfo;
		unsigned char wlan_id = 0;
		int fd = open("/dev/wifi0", O_RDWR);
		wid_syslog_debug_debug(WID_DEFAULT,"***%s, fd:%d,flag=%d. ***\n",__func__,fd,flag);
	
		if(fd < 0)
		{
			wid_syslog_err("*** open /dev/wifi0 fail ret:%d ***\n",fd);
			return -1;//create failure
		}
		sa = (struct sockaddr *)&gWTPs[WTPIndex].address;
		sa2 = (struct sockaddr*)&(gInterfaces[gWTPs[WTPIndex].interfaceIndex].addr);
		memset(&ifinfo, 0, sizeof(IF_info));
		ifinfo.apip = ((struct sockaddr_in *)sa)->sin_addr.s_addr;
		ifinfo.apport = ((struct sockaddr_in *)sa)->sin_port +1;
		ifinfo.acport = htons(5247);
		ifinfo.BSSIndex = bssindex;
		if(flag == 0)
		{
			ifinfo.WLANID = 0;/*resolve send capwap message,before ath be created*/	
		}
		else
		{
			ifinfo.WLANID = AC_BSS[bssindex]->WlanID;	
		}
		wlan_id = AC_BSS[bssindex]->WlanID; 
		if((AC_WLAN[wlan_id] != NULL)&&(AC_WLAN[wlan_id]->SecurityType == OPEN)&&(AC_WLAN[wlan_id]->EncryptionType == NONE))
		{
			ifinfo.protect_type = 0;
		}
		else
		{
			ifinfo.protect_type = 1;
			if(AC_WLAN[wlan_id] == NULL)
				wid_syslog_warning("<warning>,%s,%d,wlanid  is  NULL!\n",__func__,__LINE__);
		}  //fengwenchao add 20111220
		if(AC_BSS[bssindex]->vlanid != 0){
			ifinfo.vlanid = AC_BSS[bssindex]->vlanid;
		}else if(AC_BSS[bssindex]->wlan_vlanid != 0){
			ifinfo.vlanid = AC_BSS[bssindex]->wlan_vlanid;
		}else{
			ifinfo.vlanid = 0;
		}
		ifinfo.vrid = local*MAX_INSTANCE +vrrid;

#if DYNAMIC_VLAN_SUPPORT		
		ifinfo.dyvlanid = AC_BSS[bssindex]->dyvlanid;
		wid_syslog_debug_debug(WID_DEFAULT, "%s wtp%d bss %d dyvlanid %d ", 
									__func__, WTPIndex, bssindex, AC_BSS[bssindex]->dyvlanid);
#endif
		if(AC_BSS[bssindex]->BSS_TUNNEL_POLICY == CW_802_DOT_3_TUNNEL){
				ifinfo.f802_3 = 1;
			wid_syslog_info("%s,ifinfo.f802_3 = %d.\n",__func__,ifinfo.f802_3);
		}else{
			ifinfo.f802_3 = 0;
			wid_syslog_info("%s,AC_BSS[%d]->BSS_TUNNEL_POLICY =%d, not dot3,set ifinfo.f802_3 = %d.\n",__func__,bssindex,AC_BSS[bssindex]->BSS_TUNNEL_POLICY,ifinfo.f802_3);
		}
		ifinfo.wsmswitch = wsmswitch;
		ifinfo.vlanSwitch = vlanSwitch;
		if((AC_BSS[bssindex]->BSS_IF_POLICY == BSS_INTERFACE)||(AC_BSS[bssindex]->BSS_IF_POLICY == WLAN_INTERFACE))
			ifinfo.if_policy = 1;
		else
			ifinfo.if_policy = 0;
		memcpy(ifinfo.apmac, AC_WTP[WTPIndex]->WTPMAC, MAC_LEN);
		memcpy(ifinfo.bssid,  AC_BSS[bssindex]->BSSID, MAC_LEN);
		memcpy(ifinfo.ifname, AC_WTP[WTPIndex]->BindingIFName,strlen(AC_WTP[WTPIndex]->BindingIFName));
		memcpy(ifinfo.apname,AC_WTP[WTPIndex]->WTPNAME,strlen(AC_WTP[WTPIndex]->WTPNAME));		
		if (AC_WLAN[wlan_id] != NULL)
		{
			if (AC_WLAN[wlan_id]->ESSID != NULL)
			{
				memcpy(ifinfo.essid, AC_WLAN[wlan_id]->ESSID, strlen((char *)AC_WLAN[wlan_id]->ESSID));
			}
			ifinfo.Eap1XServerSwitch = AC_WLAN[wlan_id]->eap_mac_switch;
			memset(ifinfo.Eap1XServerMac,0,MAC_LEN);
			memcpy(ifinfo.Eap1XServerMac,AC_WLAN[wlan_id]->eap_mac2,MAC_LEN);
#if WIFI_QOS_SUPPORT
			memcpy(ifinfo.qos_11e_to_1p, AC_WLAN[wlan_id]->qos_ac_11e_to_1p, MAX_QOS_11E_VAL+1);
			memcpy(ifinfo.qos_dscp_to_1p, AC_WLAN[wlan_id]->qos_ac_dscp_to_1p, MAX_QOS_DSCP_VAL+1);
			memcpy(ifinfo.qos_dscp_to_dscp, AC_WLAN[wlan_id]->qos_ac_dscp_to_dscp, MAX_QOS_DSCP_VAL+1);
#endif	
		}
		else
		{
			ifinfo.Eap1XServerSwitch = 0;
			memset(ifinfo.Eap1XServerMac,0,MAC_LEN);
			wid_syslog_warning("<warning>,%s,%d,wlanid  is NULL!\n",__func__,__LINE__);
		}
		char __str[128];			
		memset(__str,0,128);
		char *str = "lo";	//fengwenchao modify 20110525
		str = sock_ntop_r(((struct sockaddr*)&(gInterfaces[gWTPs[WTPIndex].interfaceIndex].addr)), __str);
		wid_syslog_info("WTP %d on Interface %s (%d)\n",WTPIndex, str, gWTPs[WTPIndex].interfaceIndex);
		if(sa->sa_family != AF_INET6){										
			ifinfo.isIPv6 = 0;
			ifinfo.apip = ((struct sockaddr_in *)sa)->sin_addr.s_addr;
			ifinfo.apport = ((struct sockaddr_in *)sa)->sin_port +1;
			struct sockaddr_in	*sin = (struct sockaddr_in *) sa2;
			unsigned int v_ip = sin->sin_addr.s_addr;
			wid_syslog_info("v_ip %d.%d.%d.%d.\n", \
						(v_ip >> 24) & 0xFF, (v_ip >> 16) & 0xFF,(v_ip >> 8) & 0xFF, v_ip & 0xFF);
			ifinfo.acip = v_ip;
		}else{
			ifinfo.isIPv6 = 1;
			memcpy(ifinfo.apipv6,&((struct sockaddr_in6 *) sa)->sin6_addr,sizeof(struct in6_addr));
			ifinfo.apport = ((struct sockaddr_in6 *)sa)->sin6_port +1;
			memcpy(ifinfo.acipv6,&((struct sockaddr_in6 *) sa2)->sin6_addr,sizeof(struct in6_addr));
		}
		
		ret = ioctl(fd, WIFI_IOC_IF_UPDATE, &ifinfo);
		
		wid_syslog_debug_debug(WID_DEFAULT,"*** update_BSS_L3_Interface ret:%d ***\n",ret);
		close(fd);
		if(ret < 0)
		{
			wid_syslog_err("*** update_BSS_L3_Interface fail ret:%d ***\n",ret);
			return -1;
		}
	
	}
	return 0;

}
/*fengwenchao add 20111219*/
int wid_update_wtp_bss_infov2(int wtpid,unsigned int BSSIndex)
{
//	int m =0;int n = 0;
	if(AC_WTP[wtpid] != NULL)
	{	
		if((check_bssid_func(BSSIndex))&&(AC_BSS[BSSIndex] != NULL)&&(AC_WTP[wtpid] != NULL))
		{
			wid_update_bss_to_wifi(BSSIndex,wtpid,1);/*resolve send capwap message,before ath be created*/	
		}
	}
	return 0;
}

/*fengwenchao add end*/
/*fengwenchao add 20111028*/
int check_whether_in_ebr(unsigned int index,int wtpid, unsigned int radioid,unsigned char wlanid, int *ebr_id)
{
#define PATH_MAX_LEN 256  
	//#define SYSFS_CLASS_NET "/sys/class/net/"
	//#define DEV_BRIDGE_IFINDEX "brport/bridge/ifindex"
	unsigned int ret = 0;
	char br_ifindex_str[PATH_MAX_LEN] = {0};
	char bppath[PATH_MAX_LEN] = {0};
	char ifpath[PATH_MAX_LEN] = {0};
	char ifname[PATH_MAX_LEN] = {0};
//	FILE *fd =NULL;
	int slot_id = 0;

#if NOSOFTAC
	fd = fopen("/dbm/local_board/slot_id", "r");
	if (fd == NULL)
	{
		wid_syslog_debug_debug(WID_DEFAULT, "<error>:open /dbm/local_board/slot_id failed\n");
		return SYSTEM_CMD_ERROR;
	}
	fscanf(fd, "%d", &slot_id);
	fclose(fd);
#else
	local = 1;
#endif

	if(local)
	{
		sprintf(ifname,"r%d-%d-%d.%d",index,wtpid,radioid,wlanid);
	}
	else
	{
		sprintf(ifname,"r%d-%d-%d-%d.%d",slot_id,index,wtpid,radioid,wlanid);
	}

	wid_syslog_debug_debug(WID_DEFAULT,"%s:%d slot_id = %d ifname = %s\n", __func__, __LINE__, slot_id, ifname);
	DIR * dir = NULL;
	FILE *f = NULL;
	/* if(!ifname || !ebr_id) return INTERFACE_RETURN_CODE_ERROR;
	*ebr_id = 0;*/
	sprintf(bppath,"/sys/class/net/%s/brport", ifname);
	dir = opendir(bppath);

	if (dir)
	{
		sprintf(ifpath,"/sys/class/net/%s/brport/bridge/ifindex", ifname);
		f = fopen(ifpath, "r");
		/*read first,check and write back and append */
		if(f)
		{
			if(fgets(br_ifindex_str,256,f))
			{
				//printf("br_ifindex_str  =  %s\n", br_ifindex_str);
				*ebr_id = strtoul(br_ifindex_str, NULL, 10);
				//printf("the interface is member of br, ebr_id (%#x)\n", *ebr_id);
			}
			fclose(f);
		}

		closedir(dir);  
	}

	char ifindex_name[256] = {0};
	if((*ebr_id > 0)&&(if_indextoname(*ebr_id,ifindex_name)))
	{
		if(!strncasecmp(ifindex_name,"ebr",3))
		{
			ret = RADIO_IN_EBR;
			wid_syslog_debug_debug(WID_DEFAULT,"<error>%s:%d radio%d-%d in ebr%s\n", __func__, __LINE__, wtpid,radioid, ifindex_name);
		}
	}

	return ret;
}
/*fengwenchao add end*/

int set_balance_probe_extension_command(int wtpid, char * command)
{//xm add 09.5.13
	msgq msg;
	struct msgqlist *elem = NULL;

	WID_CHECK_WTP_STANDARD_RET(wtpid, WTP_ID_NOT_EXIST);
	
	CW_FREE_OBJECT(AC_WTP[wtpid]->WTP_Radio[0]->excommand);

	AC_WTP[wtpid]->WTP_Radio[0]->excommand = (char*)malloc(strlen(command)+1);
	memset(AC_WTP[wtpid]->WTP_Radio[0]->excommand, 0, strlen(command)+1);
	memcpy(AC_WTP[wtpid]->WTP_Radio[0]->excommand, command, strlen(command));
	
	memset((char*)&msg, 0, sizeof(msg));
	msg.mqid = wtpid%THREAD_NUM +1;
	msg.mqinfo.WTPID = wtpid;
	msg.mqinfo.type = CONTROL_TYPE;
	msg.mqinfo.subtype = WTP_S_TYPE;
	msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_EXTEND_CMD;
	memcpy(msg.mqinfo.u.WtpInfo.value, command, strlen(command));

	if (AC_WTP[wtpid]->WTPStat == WID_RUN)
	{
		if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
		{
			wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			perror("msgsnd");
		}
	}
	else
	{
		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if (elem == NULL)
		{			
			wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
			perror("malloc");
			return 0;
		}
		memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
		elem->next = NULL;
		memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
		WID_INSERT_CONTROL_LIST(wtpid, elem);
	}

	return 0;	
}

int wid_set_balance_probe(unsigned char wlanid)
{
	int ret = 0;
	int i = 0;
	int j = 0;

	WID_CHECK_WLAN_EXIST_RET(wlanid, WLAN_ID_NOT_EXIST);

	for (i = 1; i < WTP_NUM; i++)
	{
		if (AC_WTP[i] == NULL)
		{
			continue;
		}

		for (j = 0; j < AC_WTP[i]->RadioCount; j++)
		{
			unsigned int bssindex = AC_WLAN[wlanid]->S_WTP_BSS_List[i][j];
			if ((bssindex != 0)
				&& (check_bssid_func(bssindex))
				&& (AC_WTP[i] != NULL))
			{											
				ret = wid_bss_balance_switch(i, j, wlanid);										
			}			
		}		
	}

	return ret;
}

/* delete for balance config use capwap packet */
#if 0
int balance_probe_extend_command(unsigned char wlanid,unsigned char state){
//xm add 09.5.13
	int i=0,j=0;
	unsigned int wtpid=0;
	char *command=NULL;
	
    /*coverity-CID: 10833, Out-of-bounds read*/
	if(wlanid<1||wlanid>=WLAN_NUM)
		return -1;
	
	if(state!=0&&state!=1)
		return -1;

	if(AC_WLAN[wlanid]==NULL)
		return -1;

	command = (char *)malloc(sizeof(char)*50);
	memset(command,0,50);

	if(state==1)
		strncpy(command,"echo 1 > /proc/sys/dev/wifi0/traffic_balance",44);
	else if(state==0)
		strncpy(command,"echo 0 > /proc/sys/dev/wifi0/traffic_balance",44);
	else
		return -1;

	for(i=0;i<WTP_NUM;i++)
		for(j=0;j<L_RADIO_NUM;j++){
			if(AC_WLAN[wlanid]->S_WTP_BSS_List[i][j]!=0){
				
				wtpid=AC_WLAN[wlanid]->S_WTP_BSS_List[i][j]/(L_BSS_NUM*L_RADIO_NUM);
				set_balance_probe_extension_command(wtpid,command);
			}
		}
		
	free(command);	

	return 0;
}
#endif


int wid_trap_remote_restart(unsigned int wtpid);
void wid_init_wtp_info_in_create(unsigned int WTPID);
int wid_radio_set_chainmask(unsigned int RadioID, unsigned char type); // zhangshu add for set chainmask
int wid_set_ap_eth_if_mtu(unsigned int wtpid,unsigned char eth_index);   //fengwenchao add 20110126 for XJDEV-32  from 2.0

int WID_INIT_WLAN(unsigned char WlanID, char *ESSID)
{	
	int i = 0, j = 0;
	int cnFlag = 0;
    char s1[8] = {0};
	char ssid[ESSID_LENGTH] = {0};
	unsigned char ssidbuffer[DEFAULT_LEN] = {0}; 
	unsigned char ESSID_UTF8[ESSID_UTF8_DEFAULT_LEN];	
	char essid_str2[ESSID_UTF8_DEFAULT_LEN*2+1];
	
	if (WlanID >= WLAN_NUM || !ESSID)
	{
		return 1;
	}
	
	for (i = 0; i < strlen(ESSID); i++)
	{
		wid_syslog_debug_debug(WID_DEFAULT, WAI_FUNC_LINE_FMT"essid[%d] %02x\n", WAI_FUNC_LINE_LITERAL, i, (unsigned char)ESSID[i]);
		if ((unsigned char)ESSID[i] > 0x80)
		{
			cnFlag = 1;
			break;
		}
	}
	
	if (1 == cnFlag)
	{
		wid_hex_dump_essid((unsigned char *)ESSID, strlen(ESSID), ssidbuffer);
		wid_syslog_debug_debug(WID_DEFAULT, WAI_FUNC_LINE_FMT"hex essid %slen %d\n", WAI_FUNC_LINE_LITERAL, ssidbuffer, strlen(ESSID));
		
		memset(essid_str2, 0, ESSID_UTF8_DEFAULT_LEN*2+1);
		memset(ESSID_UTF8, 0, ESSID_UTF8_DEFAULT_LEN);
		memcpy(ssid, ESSID, strlen((char*)ESSID)+1);
		
		g2u((char*)ssid, (size_t)ESSID_DEFAULT_LEN, (char*)ESSID_UTF8, (size_t)ESSID_UTF8_DEFAULT_LEN);
		
		for (j = 0; j < ESSID_UTF8_DEFAULT_LEN*2; j++)
		{
			if ((j > 0) && (ESSID[j] == 0))
			{
				break;
			}
			else
			{
				memset(s1, 0, 8);
				sprintf(s1, "%02x", (unsigned char)ESSID[j]);
				wid_syslog_debug_debug(WID_DEFAULT, WAI_FUNC_LINE_FMT"essid[%d] %x utf8-essid[%d] %x\n", WAI_FUNC_LINE_LITERAL, j, (unsigned char)ESSID[j], j, (unsigned char)ESSID_UTF8[j]);
				
				strncat(essid_str2, s1, strlen(s1));    
			}
		}
		
		wid_syslog_debug_debug(WID_DEFAULT, WAI_FUNC_LINE_FMT"%sessid utf8 str %s len %d\n", WAI_FUNC_LINE_LITERAL, (1 == cnFlag)? "china":"", essid_str2, strlen(essid_str2));
	}
	else
	{
		wid_syslog_debug_debug(WID_DEFAULT, WAI_FUNC_LINE_FMT"essid %s len %d\n", WAI_FUNC_LINE_LITERAL, ESSID, strlen(ESSID));
	}
	
	memset(AC_WLAN[WlanID]->ESSID, 0, ESSID_LENGTH);
	memset(AC_WLAN[WlanID]->ESSID_CN_STR, 0, ESSID_LENGTH);
	if (strlen((char*)ESSID) < ESSID_LENGTH)
	{
		strncpy((char*)AC_WLAN[WlanID]->ESSID, (char*)ESSID, strlen((char*)ESSID)+1);
	}
	else
	{
		strncpy((char*)AC_WLAN[WlanID]->ESSID, (char*)ESSID, (ESSID_LENGTH-1));
	}
	
	AC_WLAN[WlanID]->chinaEssid = cnFlag;
	if (cnFlag == 1)
    {
		if (strlen((char *)essid_str2) < ESSID_LENGTH)
		{
			memcpy(AC_WLAN[WlanID]->ESSID_CN_STR, essid_str2, strlen((char *)essid_str2));
		}
		else
		{
			memcpy(AC_WLAN[WlanID]->ESSID_CN_STR, essid_str2, (ESSID_LENGTH-1));
		}
    }

	AC_WLAN[WlanID]->AAW = 1;
	
	for (i = 0; i < WTP_MAX_MAX_NUM; i++)
	{
		for (j = 0; j < L_RADIO_NUM; j++)
		{
		    AC_WLAN[WlanID]->S_WTP_BSS_List[i][j] = 0;
		}
	}	
	//memset(AC_WLAN[WlanID]->S_WTP_BSS_List, 0, WTP_NUM);
	AC_WLAN[WlanID]->D_WTPADD_List[0] = 0;
	AC_WLAN[WlanID]->L3_IF_Index[0] = 0;
	AC_WLAN[WlanID]->Status = 1;
	AC_WLAN[WlanID]->ifcount = 0;
	AC_WLAN[WlanID]->Wlan_Ifi = NULL;
	AC_WLAN[WlanID]->CMD = 1;
	AC_WLAN[WlanID]->confschemeid = 0;
	AC_WLAN[WlanID]->forward_mode = 0;
	AC_WLAN[WlanID]->guest_flag = 0;
	AC_WLAN[WlanID]->SecurityID = 0;
	AC_WLAN[WlanID]->HideESSid = 0;
	AC_WLAN[WlanID]->wlan_if_policy = NO_INTERFACE;
	memset(AC_WLAN[WlanID]->WlanL3IFName,0, ETH_IF_NAME_LEN);
	AC_WLAN[WlanID]->SecurityType = 0;
	AC_WLAN[WlanID]->EncryptionType = 0;
	AC_WLAN[WlanID]->asic_hex = 0;
	AC_WLAN[WlanID]->KeyLen = 0;
	AC_WLAN[WlanID]->SecurityIndex = 1;
	memset(AC_WLAN[WlanID]->WlanKey, 0, DEFAULT_LEN);
	AC_WLAN[WlanID]->IpLen = 0;
	memset(AC_WLAN[WlanID]->AsIp, 0, DEFAULT_LEN);
	AC_WLAN[WlanID]->AECerLen = 0;
	memset(AC_WLAN[WlanID]->AECerPath, 0, DEFAULT_LEN);
	AC_WLAN[WlanID]->ASCerLen = 0;
	memset(AC_WLAN[WlanID]->ASCerPath, 0, DEFAULT_LEN);
	AC_WLAN[WlanID]->wlan_max_allowed_sta_num = 65536;
	AC_WLAN[WlanID]->wlan_balance_triger_num = 1;
	AC_WLAN[WlanID]->balance_para = ac_flow_num_balance_flag.num_balance_para;
	AC_WLAN[WlanID]->flow_balance_para = ac_flow_num_balance_flag.flow_balance_para;
	AC_WLAN[WlanID]->wlan_send_traffic_limit = 0;
	AC_WLAN[WlanID]->wlan_traffic_limit = 0;
	AC_WLAN[WlanID]->multi_user_optimize_switch = 0;
	AC_WLAN[WlanID]->wlan_station_average_traffic_limit = 0;
	AC_WLAN[WlanID]->wlan_station_average_send_traffic_limit = 0;

	if (ac_flow_num_balance_flag.state != 0)
	{
		AC_WLAN[WlanID]->balance_switch = 1;
		AC_WLAN[WlanID]->balance_method = ac_flow_num_balance_flag.state;
		//balance_probe_extend_command(WlanID,1);
		wid_set_balance_probe(WlanID);
	}
	else
	{
		AC_WLAN[WlanID]->balance_switch = 0;
		AC_WLAN[WlanID]->balance_method = 0;
	}

	AC_WLAN[WlanID]->Roaming_Policy = 0;
	AC_WLAN[WlanID]->isolation_policy = 1;
	AC_WLAN[WlanID]->multicast_isolation_policy = 1;
	AC_WLAN[WlanID]->bridge_mcast_solicit_stat = 1;
	AC_WLAN[WlanID]->bridge_ucast_solicit_stat = 1;
	AC_WLAN[WlanID]->sameportswitch = 0;
	AC_WLAN[WlanID]->vlanid = 0;
	AC_WLAN[WlanID]->wlan_1p_priority = 0;
	AC_WLAN[WlanID]->tunnel_wlan_vlan = NULL;
	AC_WLAN[WlanID]->WDSStat = 0;
	AC_WLAN[WlanID]->wds_mesh = 0;
	AC_WLAN[WlanID]->StartService.times = -1;	
	AC_WLAN[WlanID]->StopService.times = -1;
	
	AC_WLAN[WlanID]->hotspot_id = 0;
	AC_WLAN[WlanID]->flow_check = 0;
	AC_WLAN[WlanID]->no_flow_time = 900;
	AC_WLAN[WlanID]->limit_flow = 10240;
	AC_WLAN[WlanID]->eap_mac_switch = 0;
	AC_WLAN[WlanID]->eap_mac = (unsigned char*)malloc(18);
	memset(AC_WLAN[WlanID]->eap_mac, 0, 18);
	memcpy(AC_WLAN[WlanID]->eap_mac, "0", 1);
	AC_WLAN[WlanID]->wlan_muti_rate = gWLAN_UNI_MUTI_BRO_CAST.rate;
	AC_WLAN[WlanID]->wlan_noResToStaProReqSW = 0;
	AC_WLAN[WlanID]->wlan_muti_bro_cast_sw = gWLAN_UNI_MUTI_BRO_CAST.multicast_broadcast_policy;
	AC_WLAN[WlanID]->wlan_unicast_sw = gWLAN_UNI_MUTI_BRO_CAST.unicast_policy;
	AC_WLAN[WlanID]->wlan_wifi_sw = gWLAN_UNI_MUTI_BRO_CAST.wifi_policy;
	AC_WLAN[WlanID]->bss_allow_max_sta_num = gWLAN_MAX_ALLOWED_STA_NUM_FOR_BSS;
	AC_WLAN[WlanID]->wlan_ath_l2_isolation = gWLAN_ATH_L2_ISOLATION;
	AC_WLAN[WlanID]->wlan_sta_static_arp_policy = gWLAN_STA_STATIC_ARP_POLICY.policy;
	memset(AC_WLAN[WlanID]->wlan_arp_ifname, 0, ETH_IF_NAME_LEN);
	AC_WLAN[WlanID]->wlan_limit_sta_rssi = gWLAN_LIMIT_STA_RSSI;
	AC_WLAN[WlanID]->WLAN_TUNNEL_POLICY = CW_802_DOT_11_TUNNEL;
	
	/* ENR-17 */
	AC_WLAN[WlanID]->ctr_head.enable = 0;
	AC_WLAN[WlanID]->ctr_head.activities_effective_time = CTR_LIST_DEFAULT_EFFECTIVE_TIME;
	AC_WLAN[WlanID]->ctr_head.session_time = CTR_LIST_DEFAULT_SESSION_TIME;
	
	/* xingqj add for qos map info */
	memcpy(AC_WLAN[WlanID]->qos_ac_11e_to_1p, QOS_AC_11E_TO_1P_DEFAULT, MAX_QOS_11E_VAL+1);
	memcpy(AC_WLAN[WlanID]->qos_ac_dscp_to_1p, QOS_AC_DSCP_TO_1P_DEFAULT, MAX_QOS_DSCP_VAL+1);
	memcpy(AC_WLAN[WlanID]->qos_ac_dscp_to_dscp, QOS_AC_DSCP_TO_DSCP_DEFAULT, MAX_QOS_DSCP_VAL+1);
	memcpy(AC_WLAN[WlanID]->qos_ap_11e_to_1p, QOS_AP_11E_TO_1P_DEFAULT, MAX_QOS_11E_VAL+1);
	memcpy(AC_WLAN[WlanID]->qos_ap_11e_to_dscp, QOS_AP_11E_TO_DSCP_DEFAULT, MAX_QOS_11E_VAL+1);
	memcpy(AC_WLAN[WlanID]->qos_ap_dscp_to_11e, QOS_AP_DSCP_TO_11E_DEFAULT, MAX_QOS_DSCP_VAL+1);
	memcpy(AC_WLAN[WlanID]->qos_ap_1p_to_11e, QOS_AP_1P_TO_11E_DEFAULT, MAX_QOS_1P_VAL+1);
	/****qos map end **********/

	AC_WLAN[WlanID]->used = 1;

	wid_syslog_debug_debug(WID_DEFAULT,"%s create a new wlan %d name:%s ssid:%s AAW:%d L3_IFIndex:%d Status:%s(%d)\n",
			__func__,AC_WLAN[WlanID]->WlanID,AC_WLAN[WlanID]->WlanName,AC_WLAN[WlanID]->ESSID,AC_WLAN[WlanID]->AAW,
			AC_WLAN[WlanID]->L3_IF_Index[0],(AC_WLAN[WlanID]->Status)? "disable":"enable",AC_WLAN[WlanID]->Status);

	return 0;
}


int WID_CREATE_NEW_WLAN(char *WlanName, unsigned char WlanID,unsigned char *ESSID,unsigned char *ESSID_STR,unsigned char cnFlag)
{
	int i = 0, j = 0;
#if 0
	unsigned int essid_len = 0;

	AC_WLAN[WlanID] = (WID_WLAN*)malloc(sizeof(WID_WLAN));
	memset(AC_WLAN[WlanID], 0 ,sizeof(WID_WLAN));
	AC_WLAN[WlanID]->WlanName = (char*)malloc(strlen(WlanName)+1);
	memset(AC_WLAN[WlanID]->WlanName,0,strlen(WlanName)+1);
	memcpy(AC_WLAN[WlanID]->WlanName,WlanName,strlen(WlanName));
	essid_len = strlen((char *)ESSID);

	if(essid_len <= ESSID_LENGTH){  //fengwenchao modify 20111013 for AXSSZFI-477,AUTELAN-2546
		AC_WLAN[WlanID]->ESSID = (char*)malloc(essid_len + 1);	
		memset(AC_WLAN[WlanID]->ESSID,0,essid_len + 1);
		memcpy(AC_WLAN[WlanID]->ESSID,ESSID,essid_len);
	}
	else{
		AC_WLAN[WlanID]->ESSID = (char*)malloc(ESSID_LENGTH);	
		memset(AC_WLAN[WlanID]->ESSID,0,ESSID_LENGTH);
		memcpy(AC_WLAN[WlanID]->ESSID,ESSID,(ESSID_LENGTH-1));
	}

	AC_WLAN[WlanID]->chinaEssid = cnFlag;
	if(cnFlag == 1){
		if(strlen((char *)ESSID_STR)< ESSID_DEFAULT_LEN){
			AC_WLAN[WlanID]->ESSID_CN_STR = (unsigned char*)malloc(ESSID_DEFAULT_LEN);	
			memset(AC_WLAN[WlanID]->ESSID_CN_STR,0,ESSID_DEFAULT_LEN);
			memcpy(AC_WLAN[WlanID]->ESSID_CN_STR,ESSID_STR,strlen((char *)ESSID_STR));
		}else{
			AC_WLAN[WlanID]->ESSID_CN_STR = (unsigned char*)malloc(strlen((char *)ESSID_STR)+1);	
			memset(AC_WLAN[WlanID]->ESSID_CN_STR,0,strlen((char *)ESSID_STR)+1);
			memcpy(AC_WLAN[WlanID]->ESSID_CN_STR,ESSID_STR,strlen((char *)ESSID_STR));
		}
	}

#endif
	AC_WLAN[WlanID]->WlanID = WlanID;
	AC_WLAN[WlanID]->AAW = 1;
	for (i = 0; i < WTP_MAX_MAX_NUM; i++)
	{
		for (j = 0; j < L_RADIO_NUM; j++)
		{
			AC_WLAN[WlanID]->S_WTP_BSS_List[i][j] = 0;
		}
	}
	//memset(AC_WLAN[WlanID]->S_WTP_BSS_List, 0, WTP_NUM);
	AC_WLAN[WlanID]->D_WTPADD_List[0] = 0;
	AC_WLAN[WlanID]->L3_IF_Index[0] = 0;
	AC_WLAN[WlanID]->Status = 1;
	AC_WLAN[WlanID]->ifcount = 0;
	AC_WLAN[WlanID]->Wlan_Ifi = NULL;
	AC_WLAN[WlanID]->CMD = 1;
	AC_WLAN[WlanID]->SecurityID = 0;
	AC_WLAN[WlanID]->HideESSid = 0;
	AC_WLAN[WlanID]->wlan_if_policy = NO_INTERFACE;
	memset(AC_WLAN[WlanID]->WlanL3IFName,0, ETH_IF_NAME_LEN);
	AC_WLAN[WlanID]->SecurityType = 0;
	AC_WLAN[WlanID]->EncryptionType = 0;
	AC_WLAN[WlanID]->asic_hex = 0;
	AC_WLAN[WlanID]->KeyLen = 0;
	AC_WLAN[WlanID]->SecurityIndex= 1;
	memset(AC_WLAN[WlanID]->WlanKey, 0, DEFAULT_LEN);
	AC_WLAN[WlanID]->IpLen = 0;
	memset(AC_WLAN[WlanID]->AsIp, 0, DEFAULT_LEN);
	AC_WLAN[WlanID]->AECerLen = 0;
	memset(AC_WLAN[WlanID]->AECerPath, 0, DEFAULT_LEN);
	AC_WLAN[WlanID]->ASCerLen = 0;
	memset(AC_WLAN[WlanID]->ASCerPath, 0, DEFAULT_LEN);
	AC_WLAN[WlanID]->wlan_max_allowed_sta_num=65536;
	AC_WLAN[WlanID]->wlan_balance_triger_num = 1;
	AC_WLAN[WlanID]->balance_para=ac_flow_num_balance_flag.num_balance_para;
	AC_WLAN[WlanID]->flow_balance_para=ac_flow_num_balance_flag.flow_balance_para;
	AC_WLAN[WlanID]->wlan_send_traffic_limit = 0;
	AC_WLAN[WlanID]->wlan_traffic_limit = 0;
	AC_WLAN[WlanID]->multi_user_optimize_switch = 0;
	AC_WLAN[WlanID]->wlan_station_average_traffic_limit = 0;
	AC_WLAN[WlanID]->wlan_station_average_send_traffic_limit = 0;

	if (ac_flow_num_balance_flag.state != 0)
	{
		AC_WLAN[WlanID]->balance_switch = 1;
		AC_WLAN[WlanID]->balance_method = ac_flow_num_balance_flag.state;
		//balance_probe_extend_command(WlanID,1);
		wid_set_balance_probe(WlanID);
	}
	else
	{
		AC_WLAN[WlanID]->balance_switch = 0;
		AC_WLAN[WlanID]->balance_method = 0;
	}

	AC_WLAN[WlanID]->Roaming_Policy = 0;
	AC_WLAN[WlanID]->isolation_policy = 1;
	AC_WLAN[WlanID]->multicast_isolation_policy = 1;
	AC_WLAN[WlanID]->bridge_mcast_solicit_stat = 1;
	AC_WLAN[WlanID]->bridge_ucast_solicit_stat = 1;
	AC_WLAN[WlanID]->sameportswitch = 0;
	AC_WLAN[WlanID]->vlanid = 0;
	AC_WLAN[WlanID]->wlan_1p_priority = 0;
	AC_WLAN[WlanID]->tunnel_wlan_vlan = NULL;
	AC_WLAN[WlanID]->WDSStat = 0;
	AC_WLAN[WlanID]->wds_mesh = 0;
	AC_WLAN[WlanID]->StartService.times = -1;	
	AC_WLAN[WlanID]->StopService.times = -1;
	
	AC_WLAN[WlanID]->hotspot_id = 0;
	//weichao add 2011.10.31
	AC_WLAN[WlanID]->flow_check = 0;
	AC_WLAN[WlanID]->no_flow_time = 900;
	AC_WLAN[WlanID]->limit_flow = 10240;
	/* zhangshu add for eap mac initial,2010-10-22 */
	AC_WLAN[WlanID]->eap_mac_switch = 0;
	AC_WLAN[WlanID]->eap_mac = (unsigned char*)malloc(18);
	memset(AC_WLAN[WlanID]->eap_mac, 0, 18);
	memcpy(AC_WLAN[WlanID]->eap_mac, "0", 1);
	AC_WLAN[WlanID]->wlan_muti_rate = gWLAN_UNI_MUTI_BRO_CAST.rate;
	AC_WLAN[WlanID]->wlan_noResToStaProReqSW = 0;
	AC_WLAN[WlanID]->wlan_muti_bro_cast_sw = gWLAN_UNI_MUTI_BRO_CAST.multicast_broadcast_policy;
	AC_WLAN[WlanID]->wlan_unicast_sw = gWLAN_UNI_MUTI_BRO_CAST.unicast_policy;
	AC_WLAN[WlanID]->wlan_wifi_sw = gWLAN_UNI_MUTI_BRO_CAST.wifi_policy;
	AC_WLAN[WlanID]->bss_allow_max_sta_num = gWLAN_MAX_ALLOWED_STA_NUM_FOR_BSS;
	AC_WLAN[WlanID]->wlan_ath_l2_isolation = gWLAN_ATH_L2_ISOLATION;
	AC_WLAN[WlanID]->wlan_sta_static_arp_policy = gWLAN_STA_STATIC_ARP_POLICY.policy;
	memset(AC_WLAN[WlanID]->wlan_arp_ifname, 0, ETH_IF_NAME_LEN);
	AC_WLAN[WlanID]->wlan_limit_sta_rssi = gWLAN_LIMIT_STA_RSSI;
	AC_WLAN[WlanID]->WLAN_TUNNEL_POLICY = CW_802_DOT_11_TUNNEL;
	
	/* ENR-17 */
	AC_WLAN[WlanID]->ctr_head.enable = 0;
	AC_WLAN[WlanID]->ctr_head.activities_effective_time = CTR_LIST_DEFAULT_EFFECTIVE_TIME;
	AC_WLAN[WlanID]->ctr_head.session_time = CTR_LIST_DEFAULT_SESSION_TIME;
	
	/* xingqj add for qos map info */
	memcpy(AC_WLAN[WlanID]->qos_ac_11e_to_1p, QOS_AC_11E_TO_1P_DEFAULT, MAX_QOS_11E_VAL+1);
	memcpy(AC_WLAN[WlanID]->qos_ac_dscp_to_1p, QOS_AC_DSCP_TO_1P_DEFAULT, MAX_QOS_DSCP_VAL+1);
	memcpy(AC_WLAN[WlanID]->qos_ac_dscp_to_dscp, QOS_AC_DSCP_TO_DSCP_DEFAULT, MAX_QOS_DSCP_VAL+1);
	memcpy(AC_WLAN[WlanID]->qos_ap_11e_to_1p, QOS_AP_11E_TO_1P_DEFAULT, MAX_QOS_11E_VAL+1);
	memcpy(AC_WLAN[WlanID]->qos_ap_11e_to_dscp, QOS_AP_11E_TO_DSCP_DEFAULT, MAX_QOS_11E_VAL+1);
	memcpy(AC_WLAN[WlanID]->qos_ap_dscp_to_11e, QOS_AP_DSCP_TO_11E_DEFAULT, MAX_QOS_DSCP_VAL+1);
	memcpy(AC_WLAN[WlanID]->qos_ap_1p_to_11e, QOS_AP_1P_TO_11E_DEFAULT, MAX_QOS_1P_VAL+1);
	/****qos map end **********/

	wid_syslog_debug_debug(WID_DEFAULT, WAI_FUNC_LINE_FMT"create a new wlan[%d] name:%s essid:%s AAW:%d L3_IF_Index:%d Status:%d\n",
			WAI_FUNC_LINE_LITERAL, AC_WLAN[WlanID]->WlanID, AC_WLAN[WlanID]->WlanName, AC_WLAN[WlanID]->ESSID,
			AC_WLAN[WlanID]->AAW, AC_WLAN[WlanID]->L3_IF_Index[0], AC_WLAN[WlanID]->Status);

	return 0;
}


int WID_DELETE_WLAN(unsigned char WlanID)
{
	int i = 0, j = 0, ret = 0;
	unsigned int radioid = 0;
	unsigned char aclgrpid = 0;
	unsigned char usergrpid = 0;
	
	WID_CHECK_WLAN_EXIST_RET(WlanID,WLAN_ID_NOT_EXIST);
	
	if (AC_WLAN[WlanID]->Status == 0)
	{
		return WLAN_BE_ENABLE;
	}

	for (i = 1; i <= VLAN_GROUP_NUM; i++)
	{
		if ((VLAN_GROUP[i] != NULL)
		    && (VLAN_GROUP[i]->wlan_id == WlanID)
		    && (VLAN_GROUP[i]->service_policy == 1))
        {
			return VLAN_GROUP_SERVICE_ENABLE;
		}
	}
	
	/*fengwenchao add 20120509 for onlinebug-271*/
	for (i = 0; i < WTP_NUM; i++)
	{
		if (AC_WTP[i] != NULL)
		{
			for (j = 0; j < AC_WTP[i]->RadioCount; j++)
			{
				if (AC_WLAN[WlanID]->S_WTP_BSS_List[i][j] != 0)
				{
					radioid = i*L_RADIO_NUM+j;
					ret = DELETE_WLAN_CHECK_APPLY_RADIO(radioid,WlanID);
					if (ret != 0)
					{
						return ret;
					}
				}
			}
		}
	}
	/*fengwenchao add end*/
	
	for (i = 0; i < WTP_NUM; i++)
	{
		if (AC_WTP[i] != NULL)
		{
			WID_DELETE_WLAN_APPLY_WTP(i, WlanID);
		}
	}

	if (AC_WLAN[WlanID]->wlan_if_policy == WLAN_INTERFACE)
	{
		//delete 3L interface
		//Delete_Wlan_L3_Interface(WlanID);
		Delete_Wlan_L3_BR_Interface(WlanID);
	}

	wid_auto_ap_if *iflist = NULL;
	iflist = g_auto_ap_login.auto_ap_if;
	while (iflist != NULL)
	{
		for (i = 0; i < L_BSS_NUM; i++)
		{
			if (WlanID == iflist->wlanid[i])
			{
				iflist->wlanid[i] = 0;
				
				for (j = i; j < (iflist->wlannum); j++)
				{
					if (j != (iflist->wlannum-1))
					{
						iflist->wlanid[j] = iflist->wlanid[j+1];
					}
					else
					{
						iflist->wlanid[j] = 0;
					}
				}
				iflist->wlannum--;
				
				select_sort_array(iflist->wlanid, L_BSS_NUM);
				
				wid_syslog_debug_debug(WID_DEFAULT,"%s: after delete wlan %d iflist->wlannum is %d\n", __func__,WlanID,iflist->wlannum);
				break;
			}
		}	
		iflist = iflist->ifnext;
	}
	
	aclgrpid = AC_WLAN[WlanID]->aclgrp_id;
	AC_WLAN[WlanID]->aclgrp_id = 0;
	if ((STA_ACL_GROUP[aclgrpid] != NULL) && (STA_ACL_GROUP[aclgrpid]->WlanList != NULL))
	{
	    STA_ACL_GROUP[aclgrpid]->WlanList = delete_wlan_from_aclgrp(STA_ACL_GROUP[aclgrpid]->WlanList, WlanID);
	}
	
	usergrpid = AC_WLAN[WlanID]->usergrp_id;
	AC_WLAN[WlanID]->usergrp_id = 0;
	if (USER_GROUP[usergrpid] != NULL)
	{
		USER_GROUP[usergrpid]->apply_wlan_num--;
		USER_GROUP[usergrpid]->apply_wlanid[WlanID] = 0;
	}

	for (i = 1; i <= VLAN_GROUP_NUM; i++)
	{
		if ((VLAN_GROUP[i] != NULL)
			&& (VLAN_GROUP[i]->wlan_id == WlanID)
			&& (VLAN_GROUP[i]->service_policy == 0))
		{
			VLAN_GROUP[i]->wlan_id = 0;
			
			if (VLAN_GROUP[i]->radio_num != 0)
			{
				wid_syslog_debug_debug(WID_DBUS,"%s: destroy vlan group %d member\n", __func__,i);
				CWThreadMutexLock(&VLAN_GROUP[i]->radioListMutex);
				destroy_vlan_group_member(VLAN_GROUP[i]->radio_member);
				VLAN_GROUP[i]->radio_member = NULL;
				CWThreadMutexUnlock(&VLAN_GROUP[i]->radioListMutex);
				VLAN_GROUP[i]->radio_num = 0;
			}
		}
	}
	
	//AsdWsm_WLANOp(WlanID, WID_DEL, 0);

	wid_wlan_deinit(WlanID);
	
	return 0;
}


int WID_INIT_USER_GROUP(unsigned char groupid, char *groupname)
{		
	if (groupid >= USER_GROUP_NUM || !groupname)
	{
		return 1;
	}
	
	memset(USER_GROUP[groupid]->grpnmame, 0, NAME_LEN);

	if (strlen(groupname) < NAME_LEN)
	{
		strncpy((char *)USER_GROUP[groupid]->grpnmame, groupname, strlen(groupname));
	}
	else
	{
		strncpy((char *)USER_GROUP[groupid]->grpnmame, groupname, NAME_LEN -1);
	}

	USER_GROUP[groupid]->apply_wlan_num = 0;
	memset(USER_GROUP[groupid]->apply_wlanid, 0, WLAN_NUM);
	USER_GROUP[groupid]->send_traffic_limit = 0;
	USER_GROUP[groupid]->traffic_limit = 0;

	USER_GROUP[groupid]->used = 1;

	wid_syslog_debug_debug(WID_DEFAULT,"%s create a new user group %d name:%s\n",
			__func__, groupid, USER_GROUP[groupid]->grpnmame);

	return 0;
}

int WID_CREATE_NEW_MACGROUP(char *groupname, unsigned int groupid)
{	
	WID_MAC_GROUP *tmp_group = NULL;
	char *tmp_name = NULL;
	
	if(NULL == groupname)
	{
		return PARAM_NULL_POINTER;
	}
	if ((1 > groupid) || (MAC_GROUP_NUM <= groupid))
	{
		return GROUP_ID_LARGE_THAN_MAX;
	}
	
	if(NULL != MAC_GROUP[groupid])
	{
		return MAC_GROUP_EXIST;
	}

	/* create  WID_MAC_GROUP */
	tmp_group = (WID_MAC_GROUP *)malloc(sizeof(WID_MAC_GROUP));
	if(NULL == tmp_group)
	{
		wid_syslog_info("malloc error,%s %d", __func__, __LINE__);
		return MALLOC_ERROR;
	}
	memset(tmp_group, 0, sizeof(WID_MAC_GROUP));
	MAC_GROUP[groupid] = tmp_group;
	MAC_GROUP[groupid]->macgroupID = groupid;
	
	tmp_name = (char *)malloc(strlen(groupname)+1);
	if(NULL == tmp_name)
	{
		CW_FREE_OBJECT(MAC_GROUP[groupid]);
		wid_syslog_info("malloc error,%s %d", __func__, __LINE__);
		return MALLOC_ERROR;
	}
	memset(tmp_name, 0, strlen(groupname)+1);
	memcpy(tmp_name, groupname, strlen(groupname));
	MAC_GROUP[groupid]->name = tmp_name;

	wid_syslog_debug_debug(WID_DEFAULT, "create mac-group %d %s\n",
										groupid, MAC_GROUP[groupid]->name); 
	return 	0;
}

int WID_DELETE_MACGROUP(unsigned int groupid)
{
	MAC_list *maclist = NULL;
	MAC_list *mactemp = NULL;

	if ((1 > groupid) || (MAC_GROUP_NUM <= groupid))
	{
		return GROUP_ID_LARGE_THAN_MAX;
	}

	if (NULL == MAC_GROUP[groupid])
	{
		return MAC_GROUP_NOT_EXIST;
	}

	if((MAC_GROUP[groupid]->WTPList != NULL) || (MAC_GROUP[groupid]->WLANList != NULL))
	{
		return MACGRP_IS_BINDED;
	}

	if (MAC_GROUP[groupid]->macList)
	{
		CWThreadMutexLock(&MAC_GROUP[groupid]->macListMutex);
		maclist = MAC_GROUP[groupid]->macList;
		while (maclist)
		{
			mactemp = maclist->next;
			CW_FREE_OBJECT(maclist);
			maclist = mactemp;
			MAC_GROUP[groupid]->count--;
		}
		MAC_GROUP[groupid]->macList= NULL;
		CWThreadMutexUnlock(&MAC_GROUP[groupid]->macListMutex);
	}
	CW_FREE_OBJECT(MAC_GROUP[groupid]->name);
	CW_FREE_OBJECT(MAC_GROUP[groupid]);
	wid_syslog_debug_debug(WID_DEFAULT, "delete mac-group %d successfully\n", groupid); 
	return 	0;
}

int wid_add_mac_to_macgroup(unsigned int groupid, char *mac)
{
	MAC_list *list = NULL;
	MAC_list *temp = NULL;
	WTPlist *wtplist = NULL;
	WLANlist *wlanlist = NULL;
	unsigned char operate = OP_ADD;

	/* check param */
	if (NULL == mac)
	{
		return PARAM_NULL_POINTER;
	}
	
	if ((1 > groupid) || (MAC_GROUP_NUM <= groupid))
	{
		return GROUP_ID_LARGE_THAN_MAX;
	}

	/* check if mac-group is exist */
	if (NULL == MAC_GROUP[groupid])
	{
		return MAC_GROUP_NOT_EXIST;
	}

	/* check if mac list is full */
	if (GROUP_MAC_COUNT < MAC_GROUP[groupid]->count)
	{
		wid_syslog_debug_debug(WID_DEFAULT, "MAC_GROUP[%d] max count 128 now %d\n", 
											MAC_GROUP[groupid]->count);
		return MAC_LIST_IS_FULL;
	}

	/* create MAC_list node */
	temp = (MAC_list *)malloc(sizeof(MAC_list));
	if (NULL == temp)
	{
		wid_syslog_info("malloc error,%s %d", __func__, __LINE__);
		return MALLOC_ERROR;
	}
	memset(temp, 0, sizeof(MAC_list));
	temp->next = NULL;
	memcpy(temp->mac, mac, sizeof(temp->mac));

	/* check if mac is in list, if true,return; if not, insert to tail */
	CWThreadMutexLock(&MAC_GROUP[groupid]->macListMutex);
	if (NULL == MAC_GROUP[groupid]->macList)
	{
		MAC_GROUP[groupid]->macList = temp;	
		wid_syslog_debug_debug(WID_DEFAULT, "mac-group %d maclist null, now insert mac "MACSTR"\n", 
											groupid, MAC2STR(MAC_GROUP[groupid]->macList->mac));
	}
	else
	{
		list = MAC_GROUP[groupid]->macList;
		while (NULL != list)
		{
			if (!memcmp(list->mac,mac,sizeof(list->mac)))
			{
				free(temp);
				temp = NULL;
				CWThreadMutexUnlock(&MAC_GROUP[groupid]->macListMutex);
				wid_syslog_debug_debug(WID_DEFAULT, "mac "MACSTR" already in mac-group %d maclist\n", MAC2STR(list->mac), groupid);
				return MAC_IN_LIST;
			}
			list = list->next;
		}

		list = MAC_GROUP[groupid]->macList;
		while(NULL != list->next)
		{
			list = list->next;
		}
		list->next = temp;
		wid_syslog_debug_debug(WID_DEFAULT, "mac-group %d insert mac "MACSTR"\n", groupid, MAC2STR(temp->mac));
	}
	MAC_GROUP[groupid]->count++;
	wid_syslog_debug_debug(WID_DEFAULT, "mac-group %d mac count %d\n", groupid, MAC_GROUP[groupid]->count);
	CWThreadMutexUnlock(&MAC_GROUP[groupid]->macListMutex);

	/* notice the wtp chain */
	if (NULL != MAC_GROUP[groupid]->WTPList)
	{
		wtplist = MAC_GROUP[groupid]->WTPList;		

		while (wtplist)
		{
			notice_wtp_macgrp_chg(wtplist->WTPIndex,temp,operate);
			wtplist = wtplist->next;
		}
	}

	/* notice the wlan chain */
	if (NULL != MAC_GROUP[groupid]->WLANList)
	{
		wlanlist = MAC_GROUP[groupid]->WLANList;

		while (wlanlist)
		{
			notice_wlan_macgrp_chg(wlanlist->WlanID,temp,operate);
			wlanlist = wlanlist->next;
		}
	}

	return 	0;
}

int wid_del_mac_from_macgroup(unsigned int groupid, char *mac)
{
	MAC_list *list = NULL;	
	MAC_list *temp = NULL;
	WTPlist *wtplist = NULL;
	WLANlist *wlanlist = NULL;
	unsigned char operate = OP_DEL;
	
	/* check param */
	if (NULL == mac)
	{
		return PARAM_NULL_POINTER;
	}
	
	if ((1 > groupid) || (MAC_GROUP_NUM <= groupid))
	{
		return GROUP_ID_LARGE_THAN_MAX;
	}

	/* check if mac-group is exist */
	if (NULL == MAC_GROUP[groupid])
	{
		return MAC_GROUP_NOT_EXIST;
	}

	wid_syslog_debug_debug(WID_DEFAULT, "%s, mac-group %d mac count %d\n", 
										__func__, groupid, MAC_GROUP[groupid]->count);

	CWThreadMutexLock(&MAC_GROUP[groupid]->macListMutex);
		
	if (NULL == MAC_GROUP[groupid]->macList)
	{
		CWThreadMutexUnlock(&MAC_GROUP[groupid]->macListMutex);
		wid_syslog_debug_debug(WID_DEFAULT, "%s, mac-group %d maclist null\n");
		return MAC_NOT_IN_LIST;
	}
	else if (!memcmp(MAC_GROUP[groupid]->macList->mac, mac, sizeof(MAC_GROUP[groupid]->macList->mac)))
	{
		temp = MAC_GROUP[groupid]->macList;
		MAC_GROUP[groupid]->macList = MAC_GROUP[groupid]->macList->next;
		MAC_GROUP[groupid]->count--;
		wid_syslog_debug_debug(WID_DEFAULT, "mac-group %d found mac "MACSTR" in the list first, delete id now mac count %d\n", 
											groupid, MAC2STR(mac), MAC_GROUP[groupid]->count);
	}
	else
	{
		list = MAC_GROUP[groupid]->macList;
		while(NULL != list->next)
		{
			if(!memcmp(list->next->mac,mac,sizeof(list->next->mac)))
			{
				temp = list->next;
				list->next = list->next->next;
				MAC_GROUP[groupid]->count--;
				wid_syslog_debug_debug(WID_DEFAULT, "mac-group %d delete mac "MACSTR" now mac count %d\n",
				                        groupid, MAC2STR(temp->mac), MAC_GROUP[groupid]->count);
				break;
			}
			list = list->next;
		}		
	}
	CWThreadMutexUnlock(&MAC_GROUP[groupid]->macListMutex);

	if (temp)
	{
		/* notice the wtp chain */
		if (NULL != MAC_GROUP[groupid]->WTPList)
		{
			wtplist = MAC_GROUP[groupid]->WTPList;			
		
			while(wtplist)
			{
				notice_wtp_macgrp_chg(wtplist->WTPIndex,temp,operate);
				wtplist = wtplist->next;
			}
		}
		
		/* notice the wlan chain */
		if (NULL != MAC_GROUP[groupid]->WLANList)
		{
			wlanlist = MAC_GROUP[groupid]->WLANList;			
		
			while (wlanlist)
			{
				notice_wlan_macgrp_chg(wlanlist->WlanID,temp,operate);
				wlanlist = wlanlist->next;
			}
		}

		CW_FREE_OBJECT(temp);
		return 0;
	}
	wid_syslog_debug_debug(WID_DEFAULT, "%s: mac "MACSTR" not in maclist of mac-group %d\n", __func__, MAC2STR(mac), groupid);
	return 	MAC_NOT_IN_LIST;
}

int wid_wtp_bind_macgroup(unsigned int WtpID,unsigned int groupid, unsigned char policy)
{
	unsigned char WlanID = 0;
	unsigned char localradio_id = 0;
	WTPlist *wtplist = NULL;
	WTPlist *wtptemp = NULL;
	MAC_list *maclist = NULL;
	int i = 0;
	msgq msg;
	struct msgqlist *elem = NULL;

	
	/* check */
	if ((1 > groupid) || (MAC_GROUP_NUM <= groupid))
	{
		return GROUP_ID_LARGE_THAN_MAX;
	}
	if (NULL == MAC_GROUP[groupid])
	{
		return MAC_GROUP_NOT_EXIST;
	}
	
	if ((1 > WtpID) || (WTP_NUM <= WtpID))
	{
		return WTP_ID_LARGE_THAN_MAX;
	}
	if (NULL == AC_WTP[WtpID])
	{
		return WTP_ID_NOT_EXIST;
	}
	
	if ((AC_WTP[WtpID]->macgroupID == groupid) && (AC_WTP[WtpID]->mac_grp_policy == policy))
	{
		wid_syslog_debug_debug(WID_DEFAULT, "%s, wtp %d already bind macgroup %d policy %s%s\n",
											__func__, WtpID, groupid,
											(1 == policy) ? "white" : "",
											(2 == policy) ? "black" : "");
		return 0;
	}
	else if (AC_WTP[WtpID]->macgroupID != 0)
	{
		return WTP_BIND_MACGRP;
	}
		
	AC_WTP[WtpID]->macgroupID = groupid;
	AC_WTP[WtpID]->mac_grp_policy = policy;
		
	if ((AC_WTP[WtpID] != NULL) && (AC_WTP[WtpID]->WTPStat == WID_RUN))
	{
		CWThreadMutexLock(&(gWTPs[WtpID].WTPThreadMutex));
		if (gWTPs[WtpID].isNotFree && (CW_ENTER_RUN == gWTPs[WtpID].currentState))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WtpID%THREAD_NUM+1;
			msg.mqinfo.WTPID = WtpID;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_BLACK_WHITE_LIST;
			msg.mqinfo.u.WtpInfo.value[0] = WlanID;
			msg.mqinfo.u.WtpInfo.value[1] = localradio_id;
			msg.mqinfo.u.WtpInfo.value[2] = policy;
			msg.mqinfo.u.WtpInfo.value[3] = LEVEL_AP;
			msg.mqinfo.u.WtpInfo.value[4] = OVERWRITE;
			CWThreadMutexLock(&MAC_GROUP[groupid]->macListMutex);
			msg.mqinfo.u.WtpInfo.value[5] = MAC_GROUP[groupid]->count;
			maclist = MAC_GROUP[groupid]->macList;
			for (i = 0; (i < MAC_GROUP[groupid]->count) && (i < GROUP_MAC_COUNT); i++)
			{
				memcpy(msg.mqinfo.u.WtpInfo.macarry[i].mac, maclist->mac, sizeof(maclist->mac));
				maclist = maclist->next;
			}
			CWThreadMutexUnlock(&MAC_GROUP[groupid]->macListMutex);
			
			if (-1 == msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0))
			{
				wid_syslog_info("%s msgsend %s", __func__, strerror(errno));
			}
		}		
		CWThreadMutexUnlock(&(gWTPs[WtpID].WTPThreadMutex));
	}
	else if (NULL != AC_WTP[WtpID])
	{
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WtpID%THREAD_NUM+1;
		msg.mqinfo.WTPID = WtpID;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WTP_S_TYPE;
		msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_BLACK_WHITE_LIST;
		msg.mqinfo.u.WtpInfo.value[0] = WlanID;
		msg.mqinfo.u.WtpInfo.value[1] = localradio_id;
		msg.mqinfo.u.WtpInfo.value[2] = policy;
		msg.mqinfo.u.WtpInfo.value[3] = LEVEL_AP;
		msg.mqinfo.u.WtpInfo.value[4] = OVERWRITE;
		CWThreadMutexLock(&MAC_GROUP[groupid]->macListMutex);
		msg.mqinfo.u.WtpInfo.value[5] = MAC_GROUP[groupid]->count;
		maclist = MAC_GROUP[groupid]->macList;
		for (i = 0; (i < MAC_GROUP[groupid]->count) && (i < GROUP_MAC_COUNT); i++)
		{
			memcpy(msg.mqinfo.u.WtpInfo.macarry[i].mac, maclist->mac, sizeof(maclist->mac));
			maclist = maclist->next;
		}
		CWThreadMutexUnlock(&MAC_GROUP[groupid]->macListMutex);
			
		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if (elem == NULL)
		{
			WID_MALLOC_ERR();
			return MALLOC_ERROR;
		}
		else
		{
			memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
			elem->next = NULL;
			memcpy((char*)&(elem->mqinfo), (char*)&(msg.mqinfo), sizeof(msg.mqinfo));
			WID_INSERT_CONTROL_LIST(WtpID, elem);
			elem = NULL;
		}
	}

	/* add wtp to notice chain */
	if (NULL == MAC_GROUP[groupid]->WTPList)
	{
		wtptemp = (WTPlist *)malloc(sizeof(WTPlist));
		if (NULL == wtptemp)
		{
			wid_syslog_info("%s malloc %s", __func__, strerror(errno));
			return MALLOC_ERROR;
		}
		wtptemp->WTPIndex = WtpID;
		wtptemp->next = NULL;
		MAC_GROUP[groupid]->WTPList = wtptemp;
	}
	else if (MAC_GROUP[groupid]->WTPList->WTPIndex == WtpID)
	{
		return 0;	//bssindex in the head,do nothing
	}
	else
	{
		wtplist = MAC_GROUP[groupid]->WTPList;
		while (NULL != wtplist->next)
		{
			if (wtplist->next->WTPIndex == WtpID)
			{
				return 0;
			}
			wtplist = wtplist->next;
		}

		wtptemp = (WTPlist *)malloc(sizeof(WTPlist));
		if (NULL == wtptemp)
		{
			wid_syslog_info("%s malloc %s", __func__, strerror(errno));
			return MALLOC_ERROR;
		}
		else
		{
			wtptemp->WTPIndex = WtpID;	
			wtptemp->next = NULL;
			wtplist->next = wtptemp;
		}		
	}		

	return 	0;
}

int wid_wtp_unbind_macgroup(unsigned int WtpID)
{
	unsigned char WlanID = 0;
	unsigned char localradio_id = 0;
	unsigned char count = 0;
	WTPlist *wtplist = NULL;
	WTPlist *wtptemp = NULL;
	unsigned int groupid = 0;
	unsigned char policy = 0;
	msgq msg;
	struct msgqlist *elem = NULL;

	/* check */
	if ((1 > WtpID) || (WTP_NUM <= WtpID))
	{
		return WTP_ID_LARGE_THAN_MAX;
	}
	if (NULL == AC_WTP[WtpID])
	{
		return WTP_ID_NOT_EXIST;
	}	

	if (AC_WTP[WtpID]->macgroupID == 0)
	{
		return 0;
	}
	else
	{
		wid_syslog_debug_debug(WID_DEFAULT, "**wtp%d unbind macgroupID %d **\n", WtpID, AC_WTP[WtpID]->macgroupID);
	}
	
	groupid = AC_WTP[WtpID]->macgroupID;
	policy = AC_WTP[WtpID]->mac_grp_policy;		
	AC_WTP[WtpID]->macgroupID = 0;
	AC_WTP[WtpID]->mac_grp_policy = 0;

	if ((NULL != AC_WTP[WtpID]) && (WID_RUN == AC_WTP[WtpID]->WTPStat))
	{
		CWThreadMutexLock(&(gWTPs[WtpID].WTPThreadMutex));
		if (gWTPs[WtpID].isNotFree && (CW_ENTER_RUN == gWTPs[WtpID].currentState))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WtpID%THREAD_NUM+1;
			msg.mqinfo.WTPID = WtpID;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_BLACK_WHITE_LIST;
			msg.mqinfo.u.WtpInfo.value[0] = WlanID;
			msg.mqinfo.u.WtpInfo.value[1] = localradio_id;
			msg.mqinfo.u.WtpInfo.value[2] = policy;
			msg.mqinfo.u.WtpInfo.value[3] = LEVEL_AP;
			msg.mqinfo.u.WtpInfo.value[4] = CANCEL;
			msg.mqinfo.u.WtpInfo.value[5] = count;
			
			if (-1 == msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0))
			{
				wid_syslog_info("%s msgsend %s", __func__, strerror(errno));
			}
		}		
		CWThreadMutexUnlock(&(gWTPs[WtpID].WTPThreadMutex));
	}
	else if (NULL != AC_WTP[WtpID])
	{
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WtpID%THREAD_NUM+1;
		msg.mqinfo.WTPID = WtpID;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WTP_S_TYPE;
		msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_BLACK_WHITE_LIST;
		msg.mqinfo.u.WtpInfo.value[0] = WlanID;
		msg.mqinfo.u.WtpInfo.value[1] = localradio_id;
		msg.mqinfo.u.WtpInfo.value[2] = policy;
		msg.mqinfo.u.WtpInfo.value[3] = LEVEL_AP;
		msg.mqinfo.u.WtpInfo.value[4] = CANCEL;
		msg.mqinfo.u.WtpInfo.value[5] = count;
			
		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if (NULL == elem)
		{
			WID_MALLOC_ERR();
			return MALLOC_ERROR;
		}
		else
		{
			memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
			elem->next = NULL;
			memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
			WID_INSERT_CONTROL_LIST(WtpID, elem);
			elem = NULL;
		}
	}
	
	/* del wtp from notice list */
	if (NULL == MAC_GROUP[groupid]->WTPList)
	{
		return 0;
	}
	wtplist = MAC_GROUP[groupid]->WTPList;
	if (wtplist->WTPIndex == WtpID)
	{
		wtptemp = wtplist->next;
		free(wtplist);
		wtplist = NULL;
		MAC_GROUP[groupid]->WTPList = wtptemp;	
	}
	else
	{
		wtplist = MAC_GROUP[groupid]->WTPList;
		while (NULL != wtplist->next)
		{
			if (wtplist->next->WTPIndex == WtpID)
			{
				wtptemp = wtplist->next;
				wtplist->next = wtplist->next->next;
				free(wtptemp);
				wtptemp = NULL;
				return 0;
			}
			wtplist = wtplist->next;
		}
	}		

	return 	0;
}


int set_wtp_local_survival(unsigned int wtpid, unsigned char state)
{
	unsigned char WlanID = 0;
	unsigned char localradio_id = 0;
	msgq msg;
	struct msgqlist *elem = NULL;	
	
	WID_CHECK_WTP_STANDARD_RET(wtpid, WTP_ID_NOT_EXIST);

	if (NULL == AC_WTP[wtpid])
	{
		return WTP_ID_NOT_EXIST;
	}
	
	AC_WTP[wtpid]->electronic_menu = state;
	
	wid_syslog_debug_debug(WID_DEFAULT, "%s, set local-survival new state %s\n", __func__,
										 (AC_WTP[wtpid]->electronic_menu) ? "enable" : "disable");
		
	if ((AC_WTP[wtpid] != NULL) && (AC_WTP[wtpid]->WTPStat == WID_RUN))
	{
		CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));

		if (gWTPs[wtpid].isNotFree && (CW_ENTER_RUN == gWTPs[wtpid].currentState))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = wtpid%THREAD_NUM+1;
			msg.mqinfo.WTPID = wtpid;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_ELECTRONIC_MENU;
			msg.mqinfo.u.WtpInfo.value[0] = WlanID;
			msg.mqinfo.u.WtpInfo.value[1] = localradio_id;
			msg.mqinfo.u.WtpInfo.value[2] = LEVEL_AP;
			msg.mqinfo.u.WtpInfo.value[3] = state;

			if (-1 == msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0))
			{
				wid_syslog_info("%s msgsend %s", __func__, strerror(errno));
			}
			
			wid_syslog_debug_debug(WID_DEFAULT, "send local-survival state %d msg OK\n",
												AC_WTP[wtpid]->electronic_menu);
				
		}		
		CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));
	}
	else if (NULL != AC_WTP[wtpid])
	{
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = wtpid%THREAD_NUM+1;
		msg.mqinfo.WTPID = wtpid;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WTP_S_TYPE;
		msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_ELECTRONIC_MENU;
		msg.mqinfo.u.WtpInfo.value[0] = WlanID;
		msg.mqinfo.u.WtpInfo.value[1] = localradio_id;
		msg.mqinfo.u.WtpInfo.value[2] = LEVEL_AP;
		msg.mqinfo.u.WtpInfo.value[3] = state;
			
		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if (elem == NULL)
		{
			WID_MALLOC_ERR();
			return MALLOC_ERROR;
		}		
		else
		{
			memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
			elem->next = NULL;
			memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));

			WID_INSERT_CONTROL_LIST(wtpid, elem);		
			elem = NULL;
		
			wid_syslog_debug_debug(WID_DEFAULT, "insert local-survival state %d msg to controllist OK\n",
												AC_WTP[wtpid]->electronic_menu);
		}
	}

	return 0;	
}


void notice_wtp_macgrp_chg(unsigned int WtpID, MAC_list *maclist, unsigned char op)
{
	unsigned char WlanID = 0;
	unsigned char localradio_id = 0;
	unsigned char count = 1;
	unsigned int i = 0;
	msgq msg;
	struct msgqlist *elem = NULL;

	if(NULL == maclist)
	{
		return;
	}

	if(!check_wtpid_func(WtpID) || (NULL == AC_WTP[WtpID]))
	{
		return;	
	}
		
	if ((AC_WTP[WtpID] != NULL)&&(AC_WTP[WtpID]->WTPStat == 5))
	{
		CWThreadMutexLock(&(gWTPs[WtpID].WTPThreadMutex));
		if(gWTPs[WtpID].isNotFree && (CW_ENTER_RUN == gWTPs[WtpID].currentState))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WtpID%THREAD_NUM+1;
			msg.mqinfo.WTPID = WtpID;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_BLACK_WHITE_LIST;
			msg.mqinfo.u.WtpInfo.value[0] = WlanID;
			msg.mqinfo.u.WtpInfo.value[1] = localradio_id;
			msg.mqinfo.u.WtpInfo.value[2] = AC_WTP[WtpID]->mac_grp_policy;
			msg.mqinfo.u.WtpInfo.value[3] = LEVEL_AP;
			msg.mqinfo.u.WtpInfo.value[4] = op;
			msg.mqinfo.u.WtpInfo.value[5] = count;

			for (i = 0; i < count; i++)
			{
				if(maclist) 
				{
					memcpy(msg.mqinfo.u.WtpInfo.macarry[i].mac, maclist->mac, sizeof(maclist->mac));
					maclist = maclist->next;
				}
			}
			
			if (-1 == msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0))
			{
				wid_syslog_info("%s msgsend %s", __func__, strerror(errno));
			}
			wid_syslog_debug_debug(WID_DEFAULT, "%s gWTPs[%d].currentState %s msgsnd ACDBUS_MSGQ\n",
												__func__, WtpID,
												(CW_ENTER_RUN == gWTPs[WtpID].currentState) ? "run":"");
		}		
		CWThreadMutexUnlock(&(gWTPs[WtpID].WTPThreadMutex));
	}
	else if (NULL != AC_WTP[WtpID])
	{
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WtpID%THREAD_NUM+1;
		msg.mqinfo.WTPID = WtpID;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WTP_S_TYPE;
		msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_BLACK_WHITE_LIST;
		msg.mqinfo.u.WtpInfo.value[0] = WlanID;
		msg.mqinfo.u.WtpInfo.value[1] = localradio_id;
		msg.mqinfo.u.WtpInfo.value[2] = AC_WTP[WtpID]->mac_grp_policy;
		msg.mqinfo.u.WtpInfo.value[3] = LEVEL_AP;
		msg.mqinfo.u.WtpInfo.value[4] = op;
		msg.mqinfo.u.WtpInfo.value[5] = count;

		for(i = 0; i < count; i++)
		{
			if(maclist) 
			{
				memcpy(msg.mqinfo.u.WtpInfo.macarry[i].mac,maclist->mac,sizeof(maclist->mac));
				maclist = maclist->next;
			}
		}

		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if (NULL == elem)
		{
			WID_MALLOC_ERR();
			return ;
		}
		else
		{
			memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
			elem->next = NULL;
			memcpy(&(elem->mqinfo), &(msg.mqinfo), sizeof(msg.mqinfo));
			WID_INSERT_CONTROL_LIST(WtpID, elem);
			elem = NULL;
					
			wid_syslog_debug_debug(WID_DEFAULT, "%s wtp %d elem insert control list\n",
												__func__, WtpID);
	
		}		
	}
	return ;	
}

	
int wid_wlan_bind_macgroup(unsigned char WlanID,unsigned int groupid, unsigned char policy)
{
	WLANlist *wlanlist = NULL;
	WLANlist *wlantemp = NULL;

	if((AC_WLAN[WlanID]->macgroupID == groupid) && (AC_WLAN[WlanID]->mac_grp_policy == policy))
	{
		return 0;
	}
	else if(AC_WLAN[WlanID]->macgroupID != 0)
	{
		return WTP_BIND_MACGRP;
	}
		
	AC_WLAN[WlanID]->macgroupID = groupid;
	AC_WLAN[WlanID]->mac_grp_policy = policy;
	
	if(AC_WLAN[WlanID]->Status == 0)
	{
		int m = 0, n = 0;		
		for(m = 0; m < WTP_NUM; m++)
		{
			if(AC_WTP[m] != NULL)
			{
				for(n = 0; n < AC_WTP[m]->RadioCount; n++)
				{					
					if(AC_WLAN[WlanID]->S_WTP_BSS_List[m][n] != 0)
					{	
						unsigned int BSSIndex = AC_WLAN[WlanID]->S_WTP_BSS_List[m][n];
						if((check_bssid_func(BSSIndex))&&(AC_BSS[BSSIndex] != NULL))
						{
							msgq msg;
							int i = 0;
							memset((char*)&msg, 0, sizeof(msg));
							msg.mqid = m%THREAD_NUM+1;
							msg.mqinfo.WTPID = m;
							msg.mqinfo.type = CONTROL_TYPE;
							msg.mqinfo.subtype = WTP_S_TYPE;
							msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_BLACK_WHITE_LIST;
							msg.mqinfo.u.WtpInfo.value[0] = WlanID;
							msg.mqinfo.u.WtpInfo.value[1] = n;
							msg.mqinfo.u.WtpInfo.value[2] = policy;
							msg.mqinfo.u.WtpInfo.value[3] = LEVEL_WLAN;
							msg.mqinfo.u.WtpInfo.value[4] = OVERWRITE;
							CWThreadMutexLock(&MAC_GROUP[groupid]->macListMutex);
							msg.mqinfo.u.WtpInfo.value[5] = MAC_GROUP[groupid]->count;
							MAC_list *maclist = MAC_GROUP[groupid]->macList;
							for(i = 0; i < MAC_GROUP[groupid]->count;i++)
							{
								memcpy(msg.mqinfo.u.WtpInfo.macarry[i].mac,maclist->mac,sizeof(maclist->mac));
								maclist = maclist->next;
							}
							CWThreadMutexUnlock(&MAC_GROUP[groupid]->macListMutex);						
		
							if((AC_WTP[m]->WTPStat == WID_RUN)&&(AC_WTP[m]->CMD->radiowlanid[n][WlanID] == 2))
							{ 
								if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
								{
									wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
								}
								wid_syslog_debug_debug(WID_DEFAULT, "%s wtp %d bss %d msgsnd ACDBUS_MSGQ\n",
												__func__, m, BSSIndex);
							}
							else
							{
								struct msgqlist *elem = NULL;
								elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
								if(elem == NULL)
								{
									WID_MALLOC_ERR();
									return MALLOC_ERROR;
								}
								memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
								elem->next = NULL;
								memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
								WID_INSERT_CONTROL_LIST(m, elem);
								elem = NULL;
								wid_syslog_debug_debug(WID_DEFAULT, "%s wtp %d elem insert control list\n",
																	__func__, m);
							}
						}
					}
				}
			}
		}
	}
	
	if(NULL == MAC_GROUP[groupid]->WLANList)		//instert to notice list
	{
		wlantemp = (WLANlist *)malloc(sizeof(WLANlist));
		wlantemp->WlanID = WlanID;
		wlantemp->next = NULL;
		MAC_GROUP[groupid]->WLANList = wlantemp;
		wid_syslog_debug_debug(WID_DEFAULT, "%s mac-group %d wlanlist null, now wlan %d bind mac-group %d %s\n",
											__func__, groupid, WlanID, groupid,
											(1 == policy) ? "white" : "black");
	}
	else if(MAC_GROUP[groupid]->WLANList->WlanID == WlanID)
	{
		wid_syslog_debug_debug(WID_DEFAULT, "%s wlan %d already bind mac-group %d\n",
											__func__, WlanID, groupid);
		return 0;	//bssindex in the head,do nothing
	}
	else
	{
		wlanlist = MAC_GROUP[groupid]->WLANList;
		while(NULL != wlanlist->next)
		{
			if(wlanlist->next->WlanID == WlanID)
			{
				wid_syslog_debug_debug(WID_DEFAULT, "%s wlan %d already bind mac-group %d\n",
													__func__, WlanID, groupid);
				return 0;
			}
			wlanlist = wlanlist->next;
		}

		wlantemp = (WLANlist *)malloc(sizeof(WLANlist));
		if(NULL == wlantemp)
		{
			wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
			perror("malloc");
			return MALLOC_ERROR;
		}
		else
		{
			wlantemp->WlanID = WlanID;	
			wlantemp->next = NULL;
			wlanlist->next = wlantemp;
			wid_syslog_debug_debug(WID_DEFAULT, "%s wlan %d bind mac-group %d successfully\n",
												__func__, WlanID, groupid);
		}
		
	}	//insert tail		

	return 	0;
}

int wid_wlan_unbind_macgroup(unsigned char WlanID)
{
	WLANlist *wlanlist = NULL;
	WLANlist *wlantemp = NULL;

	unsigned int groupid = AC_WLAN[WlanID]->macgroupID;
	unsigned char policy = AC_WLAN[WlanID]->mac_grp_policy;
	if (AC_WLAN[WlanID]->macgroupID == 0)
	{
		return 0;
	}
	else
	{
		wid_syslog_debug_debug(WID_DEFAULT,"**wlan %d unbind macgroupID %d **\n",
											WlanID,AC_WLAN[WlanID]->macgroupID);
	}
		
	AC_WLAN[WlanID]->macgroupID = 0;
	AC_WLAN[WlanID]->mac_grp_policy = 0;

	if (AC_WLAN[WlanID]->Status == 0)
	{
		int m = 0, n = 0;		
		for (m = 0; m < WTP_NUM; m++)
		{
			if (AC_WTP[m] != NULL)
			{
				for (n = 0; n < AC_WTP[m]->RadioCount; n++)
				{					
					if (AC_WLAN[WlanID]->S_WTP_BSS_List[m][n] != 0)
					{	
						unsigned int BSSIndex = AC_WLAN[WlanID]->S_WTP_BSS_List[m][n];
						if ((check_bssid_func(BSSIndex)) && (AC_BSS[BSSIndex] != NULL))
						{
							msgq msg;
							struct msgqlist *elem = NULL;
							unsigned char count = 0;
							memset((char*)&msg, 0, sizeof(msg));
							msg.mqid = m%THREAD_NUM+1;
							msg.mqinfo.WTPID = m;
							msg.mqinfo.type = CONTROL_TYPE;
							msg.mqinfo.subtype = WTP_S_TYPE;
							msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_BLACK_WHITE_LIST;
							msg.mqinfo.u.WtpInfo.value[0] = WlanID;
							msg.mqinfo.u.WtpInfo.value[1] = n;
							msg.mqinfo.u.WtpInfo.value[2] = policy;
							msg.mqinfo.u.WtpInfo.value[3] = LEVEL_WLAN;
							msg.mqinfo.u.WtpInfo.value[4] = CANCEL;
							msg.mqinfo.u.WtpInfo.value[5] = count;
		
							if ((AC_WTP[m]->WTPStat == WID_RUN) && (AC_WTP[m]->CMD->radiowlanid[n][WlanID] == 2))
							{ 
								if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
								{
									wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
								}
								wid_syslog_debug_debug(WID_DEFAULT,"wlan %d unbind macgroupID %d msgsnd ACDBUS_MSGQ\n", WlanID, groupid);
							}
							else
							{
								elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
								if(NULL == elem)
								{
									WID_MALLOC_ERR();
									return MALLOC_ERROR;
								}
								memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
								elem->next = NULL;
								memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
								WID_INSERT_CONTROL_LIST(m, elem);
								elem = NULL;
								wid_syslog_debug_debug(WID_DEFAULT,"wlan %d unbind macgroupID %d insert CONTROL_LIST\n",
																	WlanID, groupid);
							}
						}
					}
				}
			}
		}
	}	
	
	if(NULL == MAC_GROUP[groupid]->WLANList)		//instert to notice list
	{
		return 0;
	}
	wlanlist = MAC_GROUP[groupid]->WLANList;
	if(wlanlist->WlanID == WlanID)
	{
		wlantemp = wlanlist->next;
		free(wlanlist);
		wlanlist = NULL;
		MAC_GROUP[groupid]->WLANList = wlantemp;
		wid_syslog_debug_debug(WID_DEFAULT,"%s, wlan %d unbind macgroupID %d "
											"delete wlan %d from mac-group %d wlanlist\n",
											__func__, WlanID, groupid, WlanID, groupid);
	}
	else
	{
		wlanlist = MAC_GROUP[groupid]->WLANList;
		while(NULL != wlanlist->next)
		{
			if(wlanlist->next->WlanID == WlanID)
			{
				wlantemp = wlanlist->next;
				wlanlist->next = wlanlist->next->next;
				free(wlantemp);
				wlantemp = NULL;
				wid_syslog_debug_debug(WID_DEFAULT,"%s, wlan %d unbind macgroupID %d "
													"delete wlan %d from mac-group %d wlanlist\n",
													__func__, WlanID, groupid, WlanID, groupid);
				return 0;
			}
			wlanlist = wlanlist->next;
		}		
	}		

	return 	0;
}


int set_wlan_electronic_menu(unsigned char WlanID,unsigned char state)
{
	int m = 0, n = 0;

	AC_WLAN[WlanID]->electronic_menu = state;
	
	if(AC_WLAN[WlanID]->Status == 0)
	{		
		for(m = 0; m < WTP_NUM; m++)
		{
			if(AC_WTP[m] != NULL)
			{
				for(n = 0; n < AC_WTP[m]->RadioCount; n++)
				{					
					if(AC_WLAN[WlanID]->S_WTP_BSS_List[m][n] != 0)
					{	
						unsigned int BSSIndex = AC_WLAN[WlanID]->S_WTP_BSS_List[m][n];
						if((check_bssid_func(BSSIndex))&&(AC_BSS[BSSIndex] != NULL))
						{
							msgq msg;
							memset((char*)&msg, 0, sizeof(msg));
							
							msg.mqid = m%THREAD_NUM+1;
							msg.mqinfo.WTPID = m;
							msg.mqinfo.type = CONTROL_TYPE;
							msg.mqinfo.subtype = WTP_S_TYPE;
							msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_ELECTRONIC_MENU;
							msg.mqinfo.u.WtpInfo.value[0] = WlanID;
							msg.mqinfo.u.WtpInfo.value[1] = n;
							msg.mqinfo.u.WtpInfo.value[2] = LEVEL_WLAN;
							msg.mqinfo.u.WtpInfo.value[3] = state;
		
							if((AC_WTP[m]->WTPStat == WID_RUN)&&(AC_WTP[m]->CMD->radiowlanid[n][WlanID] == 2))
							{ 
								if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
								{
									wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
								}
								wid_syslog_debug_debug(WID_DEFAULT,"%s, set wlan %d electronic menu %s msgsnd ACDBUS_MSGQ\n",
																	__func__, WlanID, (1 == state) ? "enable":"disable");
							}
							else
							{
								struct msgqlist *elem = NULL;
								elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
								if(elem == NULL)
								{
									WID_MALLOC_ERR();
									return MALLOC_ERROR;
								}
								
								memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
								elem->next = NULL;
								memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
								WID_INSERT_CONTROL_LIST(m, elem);
								elem = NULL;
								wid_syslog_debug_debug(WID_DEFAULT,"%s, set wlan %d local-survival %s insert CONTROL_LIST\n",
																	__func__, WlanID, (1 == state) ? "enable":"disable");
							}
						}
					}
				}
			}
		}
	}	
	return 0;
}

void notice_wlan_macgrp_chg(unsigned char WlanID,MAC_list *maclist,unsigned char op)
{

	if((NULL == maclist) || (NULL == AC_WLAN[WlanID]))
	{
		return;
	}
	if(AC_WLAN[WlanID]->Status == 0)
	{
		int m = 0, n = 0;		
		for(m = 0; m < WTP_NUM; m++)
		{
			if(AC_WTP[m] != NULL)
			{
				for(n = 0; n < AC_WTP[m]->RadioCount; n++)
				{					
					if(AC_WLAN[WlanID]->S_WTP_BSS_List[m][n] != 0)
					{	
						unsigned int BSSIndex = AC_WLAN[WlanID]->S_WTP_BSS_List[m][n];
						if((check_bssid_func(BSSIndex))&&(AC_BSS[BSSIndex] != NULL))
						{
							msgq msg;
							int i = 0;
							unsigned char count = 1;
							memset((char*)&msg, 0, sizeof(msg));
							msg.mqid = m%THREAD_NUM+1;
							msg.mqinfo.WTPID = m;
							msg.mqinfo.type = CONTROL_TYPE;
							msg.mqinfo.subtype = WTP_S_TYPE;
							msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_BLACK_WHITE_LIST;
							msg.mqinfo.u.WtpInfo.value[0] = WlanID;
							msg.mqinfo.u.WtpInfo.value[1] = n;
							msg.mqinfo.u.WtpInfo.value[2] = AC_WLAN[WlanID]->mac_grp_policy;
							msg.mqinfo.u.WtpInfo.value[3] = LEVEL_WLAN;
							msg.mqinfo.u.WtpInfo.value[4] = op;
							msg.mqinfo.u.WtpInfo.value[5] = count;
							for(i = 0; i < count; i++)
							{
								if(maclist)
								{
									memcpy(msg.mqinfo.u.WtpInfo.macarry[i].mac,maclist->mac,sizeof(maclist->mac));
									maclist = maclist->next;
								}
							}							
		
							if((AC_WTP[m]->WTPStat == WID_RUN)&&(AC_WTP[m]->CMD->radiowlanid[n][WlanID] == 2))
							{ 
								if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
								{
									wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
								}
								wid_syslog_debug_debug(WID_DEFAULT,"%s, wlan %d msgsnd ACDBUS_MSGQ\n",
																	__func__, WlanID);
							}
							else
							{
								struct msgqlist *elem = NULL;
								elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
								if(elem == NULL)
								{
									WID_MALLOC_ERR();
									return;
								}
								memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
								elem->next = NULL;
								memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
								WID_INSERT_CONTROL_LIST(m, elem);
								elem = NULL;
								wid_syslog_debug_debug(WID_DEFAULT,"%s, wlan %d msgsnd ACDBUS_MSGQ\n",
																	__func__, WlanID);
							}
						}
					}
				}
			}
		}
	}
}

#if 0
int WID_CREATE_NEW_WTP(char *WTPNAME, unsigned int WTPID, char* WTPSN, char* WTPModel,int issn){

	if(gStaticWTPs >= WTP_NUM)
	{
		return WTP_OVER_MAX_NUM;//
	}

	//trap test
	//int tmpvalue = 500;
	//wid_dbus_trap_wtp_code_start(WTPID);
	//wid_dbus_trap_wtp_electrify_register_circle(WTPID, tmpvalue);	
	//wid_dbus_trap_wtp_ap_power_off(WTPID);
	//wid_dbus_trap_wtp_ip_change_alarm(WTPID);
	//wid_dbus_trap_wtp_ap_power_off(WTPID);


	int num, i, j, k,m,ii,jj;
	char RadioType[L_RADIO_NUM];
	char RadioPowerType[L_RADIO_NUM];
	unsigned int RadioExternFlag[L_RADIO_NUM];
	unsigned int gwtpid;
	if(!check_wtpid_func(WTPID))
	{
		wid_syslog_err("%s\n",__func__);
		return 1;
	}
	AC_WTP[WTPID] = (WID_WTP*)malloc(sizeof(WID_WTP));
	memset(AC_WTP[WTPID], 0, sizeof(WID_WTP));
	AC_WTP[WTPID]->WTPNAME = (char*)malloc(strlen(WTPNAME)+1);	
	memset(AC_WTP[WTPID]->WTPNAME,0,strlen(WTPNAME)+1);
	memcpy(AC_WTP[WTPID]->WTPNAME,WTPNAME,strlen(WTPNAME));	
	AC_WTP[WTPID]->WTPIP= (char*)malloc(DEFAULT_LEN);	
	memset(AC_WTP[WTPID]->WTPIP,0,DEFAULT_LEN);

	AC_WTP[WTPID]->WTPID = WTPID;
	AC_WTP[WTPID]->wtp_allowed_max_sta_num=64; //xm
	AC_WTP[WTPID]->wtp_triger_num=1; //xm
	AC_WTP[WTPID]->wtp_flow_triger=0; //xm
	AC_WTP[WTPID]->EchoTimer = gEchoRequestTimer;
	AC_WTP[WTPID]->ap_sta_wapi_report_interval = 10;
	AC_WTP[WTPID]->APGroupID = 0;

	if(issn == 1)
	{
		AC_WTP[WTPID]->WTPMAC = (unsigned char*)malloc(7);	
		memset(AC_WTP[WTPID]->WTPMAC,0,7);
		
		AC_WTP[WTPID]->WTPSN = (char*)malloc(NAS_IDENTIFIER_NAME);
		memset(AC_WTP[WTPID]->WTPSN, 0, NAS_IDENTIFIER_NAME);
		//AC_WTP[WTPID]->WTPSN = (char*)malloc(strlen(WTPSN)+1);
		//memset(AC_WTP[WTPID]->WTPSN, 0, strlen(WTPSN)+1);
		memcpy(AC_WTP[WTPID]->WTPSN, WTPSN, strlen(WTPSN));
	}
	else
	{
		/*default code
		AC_WTP[WTPID]->WTPSN = (char*)malloc(DEFAULT_SN_LENTH+1);
		memset(AC_WTP[WTPID]->WTPSN, 0, DEFAULT_SN_LENTH+1);
		memcpy(AC_WTP[WTPID]->WTPSN, gdefaultsn, DEFAULT_SN_LENTH);
		*/
		AC_WTP[WTPID]->WTPSN = (char*)malloc(NAS_IDENTIFIER_NAME);
		memset(AC_WTP[WTPID]->WTPSN, 0, NAS_IDENTIFIER_NAME);
		memcpy(AC_WTP[WTPID]->WTPSN, gdefaultsn, 20);
		/*used to test ,avoid the point of sn error*/
		AC_WTP[WTPID]->WTPMAC = (unsigned char*)malloc(MAC_LEN+1);	
		memset(AC_WTP[WTPID]->WTPMAC,0,(MAC_LEN+1));
		memcpy(AC_WTP[WTPID]->WTPMAC,(unsigned char *)WTPSN,MAC_LEN);
	}	
	
	AC_WTP[WTPID]->WTPModel = (char*)malloc(strlen(WTPModel)+1);
	memset(AC_WTP[WTPID]->WTPModel, 0, strlen(WTPModel)+1);
	memcpy(AC_WTP[WTPID]->WTPModel, WTPModel, strlen(WTPModel));
	AC_WTP[WTPID]->updateversion = NULL;
	AC_WTP[WTPID]->updatepath = NULL;
	AC_WTP[WTPID]->isipv6addr = 0;
	
	AC_WTP[WTPID]->sendsysstart = 2;	
	AC_WTP[WTPID]->WTPStat = 7;
	AC_WTP[WTPID]->isused = 0;
	AC_WTP[WTPID]->quitreason = WTP_UNUSED;
	AC_WTP[WTPID]->isBinddingWlan = 0;
	//AC_WTP[WTPID]->BindingWlanCount = 0;
	AC_WTP[WTPID]->tunnel_mode = CW_LOCAL_BRIDGING;
	AC_WTP[WTPID]->CTR_ID = 0;
	AC_WTP[WTPID]->DAT_ID = 0;
	AC_WTP[WTPID]->BindingSock= -1;//initialize binding socket
	AC_WTP[WTPID]->BindingSystemIndex= -1;//initialize binding interface system index
	memset(AC_WTP[WTPID]->BindingIFName,0, ETH_IF_NAME_LEN);
	AC_WTP[WTPID]->Wlan_Id = NULL;
	AC_WTP[WTPID]->wtp_login_mode = 0;
	AC_WTP[WTPID]->WFR_Index = WTPID*L_RADIO_NUM;
	AC_WTP[WTPID]->CMD = (WID_CMD*)malloc(sizeof(WID_CMD));
	AC_WTP[WTPID]->CMD->CMD = 0;
	AC_WTP[WTPID]->CMD->setCMD = 0;
	AC_WTP[WTPID]->CMD->wlanCMD = 0;
	AC_WTP[WTPID]->NeighborAPInfos = NULL;
	
	AC_WTP[WTPID]->apcminfo.ap_cpu_info_head = NULL;
	AC_WTP[WTPID]->apcminfo.ap_mem_info_head = NULL;
	AC_WTP[WTPID]->apcminfo.ap_snr_info_head = NULL;
	AC_WTP[WTPID]->apcminfo.ap_cpu_info_length = 0;
	AC_WTP[WTPID]->apcminfo.ap_mem_info_length = 0;
	AC_WTP[WTPID]->apcminfo.ap_snr_info_length = 0;
	
	AC_WTP[WTPID]->rouge_ap_infos = NULL;	
	AC_WTP[WTPID]->wids_device_list = NULL;	
	AC_WTP[WTPID]->rx_echocount = 0;
	AC_WTP[WTPID]->ap_ipadd = 0;
	AC_WTP[WTPID]->ap_gateway = 0;
	AC_WTP[WTPID]->ap_mask_new = 0;
	AC_WTP[WTPID]->ap_dnsfirst = 0;
	AC_WTP[WTPID]->ap_dnssecend = 0;
	AC_WTP[WTPID]->resetflag = 0;
	AC_WTP[WTPID]->ap_mask = 0;
	AC_WTP[WTPID]->sysver = NULL;
	AC_WTP[WTPID]->ver = NULL;
	AC_WTP[WTPID]->codever = NULL;
	AC_WTP[WTPID]->add_time = NULL;
	AC_WTP[WTPID]->imagedata_time = 0;
	AC_WTP[WTPID]->config_update_time = 0;
	AC_WTP[WTPID]->ElectrifyRegisterCircle = 0;
	AC_WTP[WTPID]->updateStat = 0;
	AC_WTP[WTPID]->updatefailcount = 0;
	AC_WTP[WTPID]->updatefailstate = 0;
	AC_WTP[WTPID]->manual_update_time = 0;	
	AC_WTP[WTPID]->location = NULL;
	memset(AC_WTP[WTPID]->wep_flag,0,WTP_WEP_NUM);
	AC_WTP[WTPID]->ControlList = NULL;
	AC_WTP[WTPID]->ControlWait = NULL;
	//AC_WTP[WTPID]->netid = NULL;
	AC_WTP[WTPID]->netid = (char*)malloc(sizeof(char)*12);
	memset(AC_WTP[WTPID]->netid, 0, 12);
	memcpy(AC_WTP[WTPID]->netid, "defaultcode", 11);
	memset(AC_WTP[WTPID]->cpuType,0,WTP_TYPE_DEFAULT_LEN);
	memcpy(AC_WTP[WTPID]->cpuType,"soc",3);
	memset(AC_WTP[WTPID]->memType,0,WTP_TYPE_DEFAULT_LEN);
	memcpy(AC_WTP[WTPID]->memType,"flash",5);
	memset(AC_WTP[WTPID]->flashType,0,WTP_TYPE_DEFAULT_LEN);
	memcpy(AC_WTP[WTPID]->flashType,"flash",5);/*wuwl add.when wtp didn't into run ,display this*/
	for(j = 0;j < L_RADIO_NUM; j++)
	{
		AC_WTP[WTPID]->CMD->radioid[j] = 0;
		for(k = 0;k < WLAN_NUM; k++)
		{
			AC_WTP[WTPID]->CMD->radiowlanid[j][k] = 0;
		}
	}
	AC_WTP[WTPID]->wtp_trap_switch = 1;/*enable*/
	AC_WTP[WTPID]->wtp_trap_lev = 1;
	AC_WTP[WTPID]->wtp_cpu_use_threshold = 10;
	AC_WTP[WTPID]->wtp_mem_use_threshold = 30;
	AC_WTP[WTPID]->wtp_rogue_ap_threshold = 10;
	AC_WTP[WTPID]->wtp_rogue_terminal_threshold = 1;

	AC_WTP[WTPID]->apstatisticsinterval = 10;

	AC_WTP[WTPID]->neighborchannelrssithold = -70;//zhaoruijia,20100825,add
	AC_WTP[WTPID]->samechannelrssithold = -80;//zhaoruijia,20100825,add
    AC_WTP[WTPID]->neighborchannel_trap_flag = 0;
	AC_WTP[WTPID]->samechannel_trap_flag = 0;

	AC_WTP[WTPID]->ntp_interval = 3600;/*zhaoruijia,20100904,transplant ACTIMESYNCHROFAILURE from 1.2omc to 1.3*/
	AC_WTP[WTPID]->ntp_state = 1; /*zhaoruijia,20100904,transplant ACTIMESYNCHROFAILURE from 1.2omc to 1.3*/

	AC_WTP[WTPID]->wid_trap.ignore_percent = 0; // zhangshu add 2010-08-27 
	AC_WTP[WTPID]->wid_trap.ignore_switch = 0;  // zhangshu add 2010-08-27 

    AC_WTP[WTPID]->ntp_trap_flag = 0;/*zhaoruijia,20100904,transplant ACTIMESYNCHROFAILURE from 1.2omc to 1.3*/

	
		/*
		if((AC_WLAN[k] != NULL)&&(AC_WLAN[k]->Status == 0))
		{	
			//changed by weiay 20080617
			if(AC_WTP[WTPID]->BindingSystemIndex != -1)
			{
				printf("***wtp index is %d\n",AC_WTP[WTPID]->BindingSystemIndex);
				if(AC_WLAN[k]->Wlan_Ifi != NULL)
				{
					struct ifi * wlan_ifi = AC_WLAN[k]->Wlan_Ifi;
					while(wlan_ifi != NULL)
					{
						printf("*** wlan index is %d\n",wlan_ifi->ifi_index);
						if(AC_WTP[WTPID]->BindingSystemIndex == wlan_ifi->ifi_index)
						{
							break;
						}
						wlan_ifi = wlan_ifi->ifi_next;
					}
					
					if(wlan_ifi == NULL)
					{
						printf("*** wtp binding interface doesn't match with wlan binding interface **\n");
						return -1;
					}
					else
					{
						AC_WTP[WTPID]->CMD->wlanid[k] = 1;
						AC_WTP[WTPID]->CMD->wlanCMD += 1;
					}
				}
				else
				{
					AC_WTP[WTPID]->CMD->wlanid[k] = 1;
					AC_WTP[WTPID]->CMD->wlanCMD += 1;
				}
			}
			//changedn end
			else
			{
				AC_WTP[WTPID]->CMD->wlanid[k] = 1;
				AC_WTP[WTPID]->CMD->wlanCMD += 1;
			}
		}
	}
	*/
	AC_WTP[WTPID]->CMD->staCMD = -1;
	memset(AC_WTP[WTPID]->CMD->StaInf, 0, 8);
	AC_WTP[WTPID]->CMD->keyCMD = -1;
	AC_WTP[WTPID]->CMD->key.BSSIndex = 0;
	AC_WTP[WTPID]->CMD->key.WTPID = 0;
	AC_WTP[WTPID]->CMD->key.key_idx = 0;
	AC_WTP[WTPID]->CMD->key.key_len = 0;
	AC_WTP[WTPID]->CMD->key.cipher = 0;
	memset(AC_WTP[WTPID]->CMD->key.StaAddr, 0, MAC_LEN);
	memset(AC_WTP[WTPID]->CMD->key.key, 0, DEFAULT_LEN);
	for(i=0;i<L_RADIO_NUM;i++)
	{
		AC_WTP[WTPID]->WTP_Radio[i] = NULL;
	}
	CWConfigVersionInfo *pnode = gConfigVersionInfo;
	num = -1;
	while(pnode != NULL)
	{
		//printf("wtp model:%s \n",WTPModel);
		//printf("pnode->str_ap_model:%s \n",pnode->str_ap_model);
		//printf("pnode->str_ap_code:%s \n",pnode->str_ap_code);
		if((strcmp(pnode->str_ap_model,WTPModel) == 0)||(strcmp(pnode->str_ap_code,WTPModel) == 0))
		{
			num = pnode->radio_num;
			
			AC_WTP[WTPID]->APCode= (char*)malloc(strlen(pnode->str_ap_code)+1);
			memset(AC_WTP[WTPID]->APCode, 0, strlen(pnode->str_ap_code)+1);
			memcpy(AC_WTP[WTPID]->APCode, pnode->str_ap_code, strlen(pnode->str_ap_code));
			//printf("model:%s innercode:%s\n",WTPModel,AC_WTP[WTPID]->APCode);
			//save radio type 
			if((strlen(pnode->str_ap_code) > 5)&&(memcmp(pnode->str_ap_code, "ALTAI", 5) == 0)){
				AC_WTP[WTPID]->sendsysstart = 0;
			}
			for(m=0;((m<num)&&(m<L_RADIO_NUM));m++)
			{
				RadioType[m] = pnode->radio_info[m].radio_type;
				RadioPowerType[m] = pnode->radio_info[m].txpower;
				RadioExternFlag[m] = pnode->radio_info[m].extern_flag;
			}
			break;
		}
		pnode = pnode->next;
	}	
	wid_syslog_debug_debug(WID_DEFAULT,"wtp model:%s radio count is:%d\n",WTPModel,num);
	if(num == -1)
	{
		free(AC_WTP[WTPID]->WTPMAC);
		AC_WTP[WTPID]->WTPMAC = NULL;
		free(AC_WTP[WTPID]->WTPIP);
		AC_WTP[WTPID]->WTPIP = NULL;
		free(AC_WTP[WTPID]->WTPNAME);
		AC_WTP[WTPID]->WTPNAME = NULL;
		free(AC_WTP[WTPID]->WTPSN);
		AC_WTP[WTPID]->WTPSN = NULL;
		free(AC_WTP[WTPID]->WTPModel);
		AC_WTP[WTPID]->WTPModel = NULL;
		free(AC_WTP[WTPID]->netid);
		AC_WTP[WTPID]->netid = NULL;
		free(AC_WTP[WTPID]->CMD);
		AC_WTP[WTPID]->CMD = NULL;
		free(AC_WTP[WTPID]);
		AC_WTP[WTPID] = NULL;
		return 1;
	}

	gwtpid = WTPID*L_RADIO_NUM;
	AC_WTP[WTPID]->RadioCount = num;
  //AC_WTP[WTPID]->channelsendtimes = 1;   /*wuwl add for send channel_cont only one time at the beginning of the wtp access*/
	for(i=0; ((i<num)&&(i<L_RADIO_NUM)); i++){	
		AC_RADIO[gwtpid] = (WID_WTP_RADIO*)malloc(sizeof(WID_WTP_RADIO));
		memset(AC_RADIO[gwtpid], 0, sizeof(WID_WTP_RADIO));
		AC_RADIO[gwtpid]->WTPID = WTPID;
		AC_RADIO[gwtpid]->Radio_G_ID = gwtpid;
		AC_RADIO[gwtpid]->Radio_L_ID = i;
		AC_RADIO[gwtpid]->Radio_Chan = 0;
		AC_RADIO[gwtpid]->ishighpower = RadioPowerType[i];
		if(AC_RADIO[gwtpid]->ishighpower == 1){
			AC_RADIO[gwtpid]->Radio_TXP = 27;
		}
		else{
			AC_RADIO[gwtpid]->Radio_TXP = 20;
		}
		AC_RADIO[gwtpid]->Radio_TXPOF= 0;/*wuwl add */
		AC_RADIO[gwtpid]->channelsendtimes = 1;	 /*wuwl add for send channel_cont only one time at the beginning of the wtp access*/

		if(RadioType[i] == 7){
			AC_RADIO[gwtpid]->Radio_Type = 5;
		}else{
			AC_RADIO[gwtpid]->Radio_Type = RadioType[i];
		}

		AC_RADIO[gwtpid]->Radio_Type_Bank = RadioType[i];

		if((AC_RADIO[gwtpid]->Radio_Type & 0x02) == 0x02)
		{
			AC_RADIO[gwtpid]->Radio_Chan = 149;
		}

		AC_RADIO[gwtpid]->Support_Rate_Count = 0;
		AC_RADIO[gwtpid]->Radio_Rate = NULL;
		//AC_RADIO[gwtpid]->Radio_Rate = 0;// 54m/bps//sz1121 add channel 0,rate 0
		AC_RADIO[gwtpid]->FragThreshold = 2346;
		AC_RADIO[gwtpid]->BeaconPeriod = 100;
		AC_RADIO[gwtpid]->IsShortPreamble = 1;
		AC_RADIO[gwtpid]->DTIMPeriod = 1; //
		AC_RADIO[gwtpid]->ShortRetry = 7; //
		AC_RADIO[gwtpid]->LongRetry = 4; //
		AC_RADIO[gwtpid]->rtsthreshold = 2346;
		AC_RADIO[gwtpid]->AdStat = 2;
		AC_RADIO[gwtpid]->OpStat = 2;
		AC_RADIO[gwtpid]->CMD = 0x0;
		for(ii=0;ii<L_BSS_NUM;ii++){
			AC_RADIO[gwtpid]->BSS[ii] = NULL;
		}
		AC_RADIO[gwtpid]->QOSID = 0;
		AC_RADIO[gwtpid]->QOSstate = 0;
		AC_RADIO[gwtpid]->bandwidth = 108;
		AC_RADIO[gwtpid]->auto_channel = 0;
		AC_RADIO[gwtpid]->auto_channel_cont = 0;
		AC_RADIO[gwtpid]->txpowerautostate = 1;
		AC_RADIO[gwtpid]->wifi_state = 1;
		AC_RADIO[gwtpid]->channelchangetime = 0;
		AC_RADIO[gwtpid]->excommand = NULL;
		AC_RADIO[gwtpid]->diversity = 0;//default is 0
		AC_RADIO[gwtpid]->txantenna = 1;//default is main
		AC_RADIO[gwtpid]->isBinddingWlan = 0;
		AC_RADIO[gwtpid]->BindingWlanCount = 0;
		AC_RADIO[gwtpid]->upcount = 0;
		AC_RADIO[gwtpid]->downcount = 0;
		AC_RADIO[gwtpid]->guardinterval = 1;
		AC_RADIO[gwtpid]->mcs = 0;
		AC_RADIO[gwtpid]->cwmode = 0;
		AC_RADIO[gwtpid]->Wlan_Id = NULL;
		AC_RADIO[gwtpid]->rx_data_deadtime = 10;
		AC_RADIO[gwtpid]->REFlag = RadioExternFlag[i];//zhanglei add for A8
		AC_WTP[WTPID]->WTP_Radio[i] = AC_RADIO[gwtpid];
		memset(AC_RADIO[gwtpid]->br_ifname,0,L_BSS_NUM*IF_NAME_MAX);
			
		/*11n set begin*/
		AC_RADIO[gwtpid]->Ampdu.Able = 1;/*enable*/
		AC_RADIO[gwtpid]->Ampdu.AmpduLimit = 65535;
		AC_RADIO[gwtpid]->MixedGreenfield.Mixed_Greenfield = 1;/*enable*/
		AC_RADIO[gwtpid]->channel_offset =0;
		AC_RADIO[gwtpid]->tx_chainmask_state_value = 3;

		/*a8 chushihua start*/
		if(AC_RADIO[gwtpid]->REFlag == 1){
			AC_RADIO[gwtpid]->sector_state_value = 0 ;
			AC_RADIO[gwtpid]->inter_vap_able = 0;
			AC_RADIO[gwtpid]->intra_vap_able = 0;
			AC_RADIO[gwtpid]->keep_alive_period = 3600;
			AC_RADIO[gwtpid]->keep_alive_idle_time = 3600;
			AC_RADIO[gwtpid]->congestion_avoidance = 0;

		}
	
		for(ii=0;ii<SECTOR_NUM;ii++)
		{	
			//CW_CREATE_OBJECT_ERR(AC_RADIO[gwtpid]->sector[ii],WID_oem_sector,return NULL;);
			AC_RADIO[gwtpid]->sector[ii] = (WID_oem_sector*)malloc(sizeof(WID_oem_sector));
			AC_RADIO[gwtpid]->sector[ii]->state = 0;
			AC_RADIO[gwtpid]->sector[ii]->tx_power = 0;
		}
		for(jj=0;jj<TX_CHANIMASK_NUM;jj++)
		{	
			AC_RADIO[gwtpid]->tx_chainmask[jj] = (WID_oem_tx_chainmask*)malloc(sizeof(WID_oem_tx_chainmask));
			AC_RADIO[gwtpid]->tx_chainmask[jj]->state = 0;
		}
		if((AC_RADIO[gwtpid]->Radio_Type & 0x08) == 0x08)//if mode is 11n,beacon interval set to 400
		{
			AC_RADIO[gwtpid]->BeaconPeriod = 400;
			AC_RADIO[gwtpid]->diversity = 1;// 11 n default is 1
			AC_RADIO[gwtpid]->txantenna = 0;// 11n default is 0
		}
		//set default support rate list 11g&11b/g 12,11b 4
		AC_RADIO[gwtpid]->Support_Rate_Count = 12;

		//memory leak
		//AC_RADIO[gwtpid]->Radio_Rate = (struct Support_Rate_List *)malloc(sizeof(struct Support_Rate_List));
		AC_RADIO[gwtpid]->Radio_Rate = create_support_rate_list(1);//here add 10 first
		
		//printf("/////the list has %d element////\n",AC_RADIO[gwtpid]->Support_Rate_Count);
		
		int rate = 10;
		AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);

		rate = 20;
		AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);

		rate = 55;
		AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);

		rate = 60;
		AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);

		rate = 90;
		AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);

		rate = 110;
		AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);

		rate = 120;
		AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);

		rate = 180;
		AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);

		rate = 240;
		AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);

		rate = 360;
		AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);

		rate = 480;
		AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);

		rate = 540;
		AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);
		/*add 11n rate 1300,3000*/
		if((AC_RADIO[gwtpid]->Radio_Type & 0x08) == 0x08){
			rate = 1300;
			AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);
			
			rate = 3000;
			AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);
		}
		delete_rate_from_list(AC_RADIO[gwtpid]->Radio_Rate,0);
		AC_RADIO[gwtpid]->Support_Rate_Count = length_of_rate_list(AC_RADIO[gwtpid]->Radio_Rate);
		AC_RADIO[gwtpid]->txpowerstep = 1;//zhaoruijia,20100917,add radio txpower step 
		//printf("/////the list has %d element////\n",AC_RADIO[gwtpid]->Support_Rate_Count);
		//display_support_rate_list(AC_RADIO[gwtpid]->Radio_Rate);
		gwtpid++;
	}
	wid_init_wtp_info_in_create(WTPID);
	AC_WTP[WTPID]->wids_statist.floodingcount = 0;
	AC_WTP[WTPID]->wids_statist.sproofcount = 0;
	AC_WTP[WTPID]->wids_statist.weakivcount = 0;
	gStaticWTPs++;
	//only for test no release code //////////////////////////////////
	
	//AC_WTP[WTPID]->NeighborAPInfos = create_ap_info_list(3);
	//AC_WTP[WTPID]->rouge_ap_infos = create_ap_info_list_test(1);
	//display_ap_info_list(AC_WTP[WTPID]->NeighborAPInfos);
	//display_ap_info_list(AC_WTP[WTPID]->rouge_ap_infos);

	//merge_ap_list(AC_WTP[WTPID]->NeighborAPInfos,&(AC_WTP[WTPID]->rouge_ap_infos));

	//char *mac = "222222";
	//struct Neighbor_AP_ELE *papnode = create_mac_elem(mac);
	
	//printf("##############################################\n");
	
	//insert_elem_into_ap_list((AC_WTP[WTPID]->NeighborAPInfos),papnode);
	//delete_elem_from_ap_list(&(AC_WTP[WTPID]->NeighborAPInfos),papnode);
	//destroy_ap_info_list(&(AC_WTP[WTPID]->NeighborAPInfos));
	/*
	if(AC_WTP[WTPID]->NeighborAPInfos == NULL)
	{
		printf("NeighborAPInfos == NULL\n");
	}
	else
	{
		printf("NeighborAPInfos != NULL\n");
	}

	if(AC_WTP[WTPID]->rouge_ap_infos== NULL)
	{
		printf("rouge_ap_infos == NULL\n");
	}
	else
	{
		printf("rouge_ap_infos != NULL\n");
	}
	
	display_ap_info_list(AC_WTP[WTPID]->NeighborAPInfos);
	display_ap_info_list(AC_WTP[WTPID]->rouge_ap_infos);

	*/

	//display_ap_info_list(AC_WTP[WTPID]->NeighborAPInfos);
	//destroy_ap_info_list(AC_WTP[WTPID]->NeighborAPInfos);
	//printf("////////////001//////////\n");
	/*
	
	AC_WTP[WTPID]->NeighborAPInfos = create_ap_info_list(2);
	display_ap_info_list(AC_WTP[WTPID]->NeighborAPInfos);
	destroy_ap_info_list(AC_WTP[WTPID]->NeighborAPInfos);

	printf("////////////002//////////\n");

	AC_WTP[WTPID]->NeighborAPInfos = create_ap_info_list(3);
	display_ap_info_list(AC_WTP[WTPID]->NeighborAPInfos);
	destroy_ap_info_list(AC_WTP[WTPID]->NeighborAPInfos);

	/////////////////////////////////////////////////////
	
	*/


	//AC_WTP[WTPID]->wids_device_list = create_wids_info_list(3);

	
	return 0 ;
	
}
#endif

int WID_CREATE_NEW_WTP
(
	char *WTPNAME, 
	unsigned int WTPID,
	unsigned char* WTPSN, 
 	char* WTPModel,
	int issn,
	int apcodeflag,
	char *code
)
{
	if ((gStaticWTPs >= WTP_NUM) || ((gStaticWTPs > gMaxWTPs)))
	{
		return WTP_OVER_MAX_NUM;//
	}

	//trap test
	//int tmpvalue = 500;
	//wid_dbus_trap_wtp_code_start(WTPID);
	//wid_dbus_trap_wtp_electrify_register_circle(WTPID, tmpvalue);	
	//wid_dbus_trap_wtp_ap_power_off(WTPID);
	//wid_dbus_trap_wtp_ip_change_alarm(WTPID);
	//wid_dbus_trap_wtp_ap_power_off(WTPID);

	int num = 0, i = 0, j = 0, k = 0, m = 0, ii = 0, jj = 0;
	char RadioType[L_RADIO_NUM] = {0};
	char RadioPowerType[L_RADIO_NUM] = {0};
	char RadioChainmask[L_RADIO_NUM] = {0};
	unsigned int RadioExternFlag[L_RADIO_NUM] = {0};
	unsigned int gwtpid = 0;
	
	if (!check_wtpid_func(WTPID))
	{
		wid_syslog_err("%s:%d wtp%d not exist\n", __func__, __LINE__, WTPID);	
		return  WTP_ID_NOT_EXIST;
	}
	
	AC_WTP[WTPID] = (WID_WTP*)malloc(sizeof(WID_WTP));
	memset(AC_WTP[WTPID], 0, sizeof(WID_WTP));
	AC_WTP[WTPID]->WTPNAME = (char*)malloc(strlen(WTPNAME)+1);	
	memset(AC_WTP[WTPID]->WTPNAME, 0, strlen(WTPNAME)+1);
	memcpy(AC_WTP[WTPID]->WTPNAME, WTPNAME, strlen(WTPNAME));	
	AC_WTP[WTPID]->WTPIP = (char*)malloc(DEFAULT_LEN);	
	memset(AC_WTP[WTPID]->WTPIP, 0, DEFAULT_LEN);

	AC_WTP[WTPID]->WTPID = WTPID;
	AC_WTP[WTPID]->wtp_allowed_max_sta_num = gWTP_MAX_STA;
	AC_WTP[WTPID]->wtp_triger_num = 1;
	AC_WTP[WTPID]->dhcp_snooping = gDHCP_SNOOPING;
	AC_WTP[WTPID]->wtp_flow_triger = gWTP_FLOW_TRIGER;
	AC_WTP[WTPID]->EchoTimer = gEchoRequestTimer;
	AC_WTP[WTPID]->ap_sta_wapi_report_interval = gAP_STA_WAPI_REPORT_INTERVAL;
	AC_WTP[WTPID]->ap_sta_wapi_report_switch = gAP_STA_WAPI_REPORT_SWITCH;
	AC_WTP[WTPID]->APGroupID = 0;
	AC_WTP[WTPID]->RSSI = WAW_DEFAULT_RSSI;

	if (issn == 1)
	{
		AC_WTP[WTPID]->WTPMAC = (unsigned char*)malloc(MAC_LEN+1);	
		memset(AC_WTP[WTPID]->WTPMAC, 0, (MAC_LEN+1));
		
		AC_WTP[WTPID]->WTPSN = (char*)malloc(NAS_IDENTIFIER_NAME);
		memset(AC_WTP[WTPID]->WTPSN, 0, NAS_IDENTIFIER_NAME);
		memcpy(AC_WTP[WTPID]->WTPSN, WTPSN, strlen((char *)WTPSN));
	}
	else
	{
		/*default code
		AC_WTP[WTPID]->WTPSN = (char*)malloc(DEFAULT_SN_LENTH+1);
		memset(AC_WTP[WTPID]->WTPSN, 0, DEFAULT_SN_LENTH+1);
		memcpy(AC_WTP[WTPID]->WTPSN, gdefaultsn, DEFAULT_SN_LENTH);
		*/
		AC_WTP[WTPID]->WTPSN = (char*)malloc(NAS_IDENTIFIER_NAME);
		memset(AC_WTP[WTPID]->WTPSN, 0, NAS_IDENTIFIER_NAME);
		memcpy(AC_WTP[WTPID]->WTPSN, gdefaultsn, DEFAULT_SN_LENTH);
		/*used to test ,avoid the point of sn error*/
		AC_WTP[WTPID]->WTPMAC = (unsigned char*)malloc(MAC_LEN+1);	
		memset(AC_WTP[WTPID]->WTPMAC, 0, (MAC_LEN+1));
		memcpy(AC_WTP[WTPID]->WTPMAC, (unsigned char *)WTPSN, MAC_LEN);
	}	
	
	AC_WTP[WTPID]->WTPModel = (char*)malloc(strlen(WTPModel)+1);
	memset(AC_WTP[WTPID]->WTPModel, 0, strlen(WTPModel)+1);
	memcpy(AC_WTP[WTPID]->WTPModel, WTPModel, strlen(WTPModel));
	AC_WTP[WTPID]->updateversion = NULL;
	AC_WTP[WTPID]->updatepath = NULL;
	AC_WTP[WTPID]->isipv6addr = 0;
	
	AC_WTP[WTPID]->sendsysstart = 2;	
	AC_WTP[WTPID]->WTPStat = WID_QUIT;
	AC_WTP[WTPID]->isused = 0;
	AC_WTP[WTPID]->unused_flag = 0;
	AC_WTP[WTPID]->quitreason = WTP_UNUSED;
	AC_WTP[WTPID]->isBinddingWlan = 0;
	//AC_WTP[WTPID]->BindingWlanCount = 0;
	AC_WTP[WTPID]->tunnel_mode = CW_LOCAL_BRIDGING;
	AC_WTP[WTPID]->CTR_ID = 0;
	AC_WTP[WTPID]->DAT_ID = 0;
	AC_WTP[WTPID]->BindingSock= -1;//initialize binding socket
	AC_WTP[WTPID]->BindingSystemIndex= -1;//initialize binding interface system index
	memset(AC_WTP[WTPID]->BindingIFName,0, ETH_IF_NAME_LEN);
	AC_WTP[WTPID]->Wlan_Id = NULL;
	AC_WTP[WTPID]->wtp_login_mode = 0;
	AC_WTP[WTPID]->WFR_Index = WTPID*L_RADIO_NUM;
	AC_WTP[WTPID]->CMD = (WID_CMD*)malloc(sizeof(WID_CMD));
	AC_WTP[WTPID]->CMD->CMD = 0;
	AC_WTP[WTPID]->CMD->setCMD = 0;
	AC_WTP[WTPID]->CMD->wlanCMD = 0;
	AC_WTP[WTPID]->apcminfo.ap_cpu_info_head = NULL;
	AC_WTP[WTPID]->apcminfo.ap_mem_info_head = NULL;
	AC_WTP[WTPID]->apcminfo.ap_snr_info_head = NULL;
	AC_WTP[WTPID]->apcminfo.ap_cpu_info_length = 0;
	AC_WTP[WTPID]->apcminfo.ap_mem_info_length = 0;
	AC_WTP[WTPID]->apcminfo.ap_snr_info_length = 0;
	
	for (i = 0; i < L_RADIO_NUM; i++)
	{
		AC_WTP[WTPID]->NeighborAPInfos[i] = NULL;
	}
	for (i = 0; i < L_RADIO_NUM; i++)
	{
		AC_WTP[WTPID]->rouge_ap_infos[i] = NULL;
	}
	
	AC_WTP[WTPID]->wids_device_list = NULL;	
	AC_WTP[WTPID]->rx_echocount = 0;
	AC_WTP[WTPID]->ap_ipadd = 0;
	AC_WTP[WTPID]->ap_gateway = 0;
	AC_WTP[WTPID]->ap_mask_new = 0;
	AC_WTP[WTPID]->ap_dnsfirst = 0;
	AC_WTP[WTPID]->ap_dnssecend = 0;
	AC_WTP[WTPID]->resetflag = 0;
	AC_WTP[WTPID]->ap_mask = 0;
	AC_WTP[WTPID]->sysver = NULL;
	AC_WTP[WTPID]->ver = NULL;
	AC_WTP[WTPID]->codever = NULL;
	AC_WTP[WTPID]->ApReportVer = NULL;
	AC_WTP[WTPID]->add_time = NULL;
	AC_WTP[WTPID]->imagedata_time = 0;
	AC_WTP[WTPID]->config_update_time = 0;
	AC_WTP[WTPID]->ElectrifyRegisterCircle = 0;
	AC_WTP[WTPID]->updateStat = 0;
	AC_WTP[WTPID]->updatefailcount = 0;
	AC_WTP[WTPID]->updatefailstate = 0;
	AC_WTP[WTPID]->manual_update_time = 0;	
	AC_WTP[WTPID]->location = NULL;
	AC_WTP[WTPID]->option60_param = NULL;
	//memset(AC_WTP[WTPID]->wep_flag,0,WTP_WEP_NUM);
	AC_WTP[WTPID]->ControlList = NULL;
	AC_WTP[WTPID]->ControlWait = NULL;
	AC_WTP[WTPID]->sta_ip_report = gSTAINFOREPORT;
	//AC_WTP[WTPID]->netid = NULL;
	AC_WTP[WTPID]->netid = (char*)malloc(sizeof(char)*12);
	memset(AC_WTP[WTPID]->netid, 0, 12);
	memcpy(AC_WTP[WTPID]->netid, "defaultcode", 11);
	memset(AC_WTP[WTPID]->cpuType, 0, WTP_TYPE_DEFAULT_LEN);
	memcpy(AC_WTP[WTPID]->cpuType, "soc", 3);
	memset(AC_WTP[WTPID]->memType, 0, WTP_TYPE_DEFAULT_LEN);
	memcpy(AC_WTP[WTPID]->memType, "flash", 5);
	memset(AC_WTP[WTPID]->flashType, 0, WTP_TYPE_DEFAULT_LEN);
	memcpy(AC_WTP[WTPID]->flashType, "flash", 5);/*wuwl add.when wtp didn't into run ,display this*/

	for (j = 0; j < L_RADIO_NUM; j++)
	{
		AC_WTP[WTPID]->CMD->radioid[j] = 0;
		for (k = 0; k < WLAN_NUM; k++)
		{
			AC_WTP[WTPID]->CMD->radiowlanid[j][k] = 0;
		}
	}
	AC_WTP[WTPID]->wtp_trap_switch = 1;/*enable*/
	AC_WTP[WTPID]->wtp_seqnum_switch = 1;
	AC_WTP[WTPID]->wtp_trap_lev = 1;
	AC_WTP[WTPID]->wtp_cpu_use_threshold = gWTP_CPU_USE_THRESHOLD;
	AC_WTP[WTPID]->wtp_mem_use_threshold = gWTP_MEM_USE_THRESHOLD;
	AC_WTP[WTPID]->wtp_rogue_ap_threshold = gWTP_ROGUE_AP_THRESHOLD;
	AC_WTP[WTPID]->wtp_rogue_terminal_threshold = gWTP_ROGUE_TERMINAL_THRESHOLD;

	AC_WTP[WTPID]->apstatisticsinterval = apstatisticsinterval;
	AC_WTP[WTPID]->dhcp_snooping = gDHCP_SNOOPING;

	AC_WTP[WTPID]->neighborchannelrssithold = gNEIGHBORCHANNELRSSITHOLD;
	AC_WTP[WTPID]->samechannelrssithold = gSAMECHANNELRSSITHOLD;
    AC_WTP[WTPID]->neighborchannel_trap_flag = 0;
	AC_WTP[WTPID]->channel_device_interference_flag = 0;   /*fengwenchao add 20110221 for wid_dbus_trap_wtp_channel_device_interference*/
	AC_WTP[WTPID]->ap_rogue_threshold_flag = 1;            /*fengwenchao add 20110221 for wid_dbus_trap_ap_rogue_threshold */
	AC_WTP[WTPID]->ac_discovery_danger_ap_flag = 1;        /*fengwenchao add 20110221 for wid_dbus_trap_wtp_ac_discovery_danger_ap*/ 
	AC_WTP[WTPID]->find_wids_attack_flag = 1;              /*fengwenchao add 20110221 for wid_dbus_trap_wtp_find_wids_attack */
	AC_WTP[WTPID]->channel_count_minor_flag = 0;           /*fengwenchao add 20110221 for wid_dbus_trap_wtp_channel_count_minor */
	AC_WTP[WTPID]->samechannel_trap_flag = 0;
	AC_WTP[WTPID]->sta_ip_report = gSTAINFOREPORT;
	AC_WTP[WTPID]->ap_sta_wapi_report_switch = gAP_STA_WAPI_REPORT_SWITCH;

	AC_WTP[WTPID]->ntp_interval = gNTP_INTERVAL;/*zhaoruijia,20100904,transplant ACTIMESYNCHROFAILURE from 1.2omc to 1.3*//*wcl modify for globle variable*/
	AC_WTP[WTPID]->ntp_state = gNTP_STATE; /*zhaoruijia,20100904,transplant ACTIMESYNCHROFAILURE from 1.2omc to 1.3*//*wcl modify for globle variable*/
	AC_WTP[WTPID]->elem_num = 0;
	AC_WTP[WTPID]->wid_trap.ignore_percent = 0;
	AC_WTP[WTPID]->wid_trap.ignore_switch = 0;
	AC_WTP[WTPID]->wid_trap.rogue_terminal_trap_flag = 0;  // fengwenchao add 20111116 for AXSSZFI-558
	/* zhangshu add for init terminal dis info, 2010-10-08 */
	AC_WTP[WTPID]->ter_dis_info.reportpkt = gTER_DIS_INFOREPORTPKT;
	AC_WTP[WTPID]->ter_dis_info.reportswitch= gTER_DIS_INFOREPORTSWITCH;
	AC_WTP[WTPID]->ter_dis_info.sta_trap_count = gTER_DIS_INFOSTA_TRAP_COUNT;

	AC_WTP[WTPID]->ntp_trap_flag = 0;   /*zhaoruijia,20100904,transplant ACTIMESYNCHROFAILURE from 1.2omc to 1.3*/
	AC_WTP[WTPID]->mac_grp_policy = 0;  /* 0:no set mac group type , 1: white 2: black*/
	AC_WTP[WTPID]->macgroupID = 0;      /* no bind macgroup*/
	AC_WTP[WTPID]->electronic_menu = 0; /*disable*/

	/* REQUIREMENTS-536/ENR4-2 for 5G-FIRST */
	AC_WTP[WTPID]->join5g.join5g_switch   = gWTP_JOIN5G_SWITCH;
	AC_WTP[WTPID]->join5g.aging_time      = gWTP_JOIN5G_AGING_TIME;
	AC_WTP[WTPID]->join5g.discard_count   = gWTP_JOIN5G_DISCARD_COUNT;
	AC_WTP[WTPID]->join5g.scan_time       = gWTP_JOIN5G_SCAN_TIME;
	AC_WTP[WTPID]->join5g.sta_count       = gWTP_JOIN5G_STA_COUNT;
	AC_WTP[WTPID]->join5g.signal_strength = gWTP_JOIN5G_SIGNAL_STRENGTH;

	wtp_upgrade_init(&AC_WTP[WTPID]->upgrade);
		/*
		if((AC_WLAN[k] != NULL)&&(AC_WLAN[k]->Status == 0))
		{	
			//changed by weiay 20080617
			if(AC_WTP[WTPID]->BindingSystemIndex != -1)
			{
				printf("***wtp index is %d\n",AC_WTP[WTPID]->BindingSystemIndex);
				if(AC_WLAN[k]->Wlan_Ifi != NULL)
				{
					struct ifi * wlan_ifi = AC_WLAN[k]->Wlan_Ifi;
					while(wlan_ifi != NULL)
					{
						printf("*** wlan index is %d\n",wlan_ifi->ifi_index);
						if(AC_WTP[WTPID]->BindingSystemIndex == wlan_ifi->ifi_index)
						{
							break;
						}
						wlan_ifi = wlan_ifi->ifi_next;
					}
					
					if(wlan_ifi == NULL)
					{
						printf("*** wtp binding interface doesn't match with wlan binding interface **\n");
						return -1;
					}
					else
					{
						AC_WTP[WTPID]->CMD->wlanid[k] = 1;
						AC_WTP[WTPID]->CMD->wlanCMD += 1;
					}
				}
				else
				{
					AC_WTP[WTPID]->CMD->wlanid[k] = 1;
					AC_WTP[WTPID]->CMD->wlanCMD += 1;
				}
			}
			//changedn end
			else
			{
				AC_WTP[WTPID]->CMD->wlanid[k] = 1;
				AC_WTP[WTPID]->CMD->wlanCMD += 1;
			}
		}
	}
	*/
	AC_WTP[WTPID]->CMD->staCMD = -1;
	memset(AC_WTP[WTPID]->CMD->StaInf, 0, 8);
	AC_WTP[WTPID]->CMD->keyCMD = -1;
	AC_WTP[WTPID]->CMD->key.BSSIndex = 0;
	AC_WTP[WTPID]->CMD->key.WTPID = 0;
	AC_WTP[WTPID]->CMD->key.key_idx = 0;
	AC_WTP[WTPID]->CMD->key.key_len = 0;
	AC_WTP[WTPID]->CMD->key.cipher = 0;
	memset(AC_WTP[WTPID]->CMD->key.StaAddr, 0, MAC_LEN);
	memset(AC_WTP[WTPID]->CMD->key.key, 0, DEFAULT_LEN);
	for (i = 0; i < L_RADIO_NUM; i++)
	{
		AC_WTP[WTPID]->WTP_Radio[i] = NULL;
	}
	
	num = -1;
	int n = 0;	
	for (n = 0; n < ((sizeof(SOFT_XMLINFO))/sizeof(SOFT_XMLINFO[0])); n++)
	{
		if (strcasecmp(SOFT_XMLINFO[n].str_ap_model,WTPModel) == 0)
		{
			num = SOFT_XMLINFO[n].radio_num;
			AC_WTP[WTPID]->apifinfo.eth_num = SOFT_XMLINFO[n].eth_num;
			AC_WTP[WTPID]->apcodeflag = 0;

			if (code != NULL)
			{
				CW_FREE_OBJECT(AC_WTP[WTPID]->APCode);
                AC_WTP[WTPID]->APCode = (char*)malloc(strlen(code)+1);
                memset(AC_WTP[WTPID]->APCode, 0, strlen(code)+1);
                memcpy(AC_WTP[WTPID]->APCode, code, strlen(code));
			        
			}
			//printf("model:%s innercode:%s\n",WTPModel,AC_WTP[WTPID]->APCode);
			//save radio type 
			/*
			if((pnode->str_ap_code != NULL)&&(strlen(pnode->str_ap_code) > 5)&&(memcmp(pnode->str_ap_code, "ALTAI", 5) == 0)){
				AC_WTP[WTPID]->sendsysstart = 0;
			}
			*/
			for (m = 0; ((m < num) && (m < L_RADIO_NUM)); m++)
			{
				RadioType[m] = SOFT_XMLINFO[n].radio_info[m].radio_type;
				RadioPowerType[m] = SOFT_XMLINFO[n].radio_info[m].txpower;
				RadioExternFlag[m] = SOFT_XMLINFO[n].radio_info[m].extern_flag;
				RadioChainmask[m] = SOFT_XMLINFO[n].radio_info[m].chainmask_num;
			}
			break;
		}
	}	
	wid_syslog_debug(WAI_FUNC_LINE_FMT"create "WAI_AFI0_FMT"model '%s' name '%s' sn '%s' with %u radios\n", \
				WAI_FUNC_LINE_LITERAL, WTPID, WTPModel, WTPNAME, WTPSN, num);
	if (num == -1)
	{
		CW_FREE_OBJECT(AC_WTP[WTPID]->WTPMAC);
		CW_FREE_OBJECT(AC_WTP[WTPID]->WTPIP);
		CW_FREE_OBJECT(AC_WTP[WTPID]->WTPNAME);
		CW_FREE_OBJECT(AC_WTP[WTPID]->WTPSN);
		CW_FREE_OBJECT(AC_WTP[WTPID]->WTPModel);
		CW_FREE_OBJECT(AC_WTP[WTPID]->netid);
		CW_FREE_OBJECT(AC_WTP[WTPID]->CMD);
		CW_FREE_OBJECT(AC_WTP[WTPID]);
		return 1;
	}

	gwtpid = WTPID*L_RADIO_NUM;
	AC_WTP[WTPID]->RadioCount = num;
  //AC_WTP[WTPID]->channelsendtimes = 1;   /*wuwl add for send channel_cont only one time at the beginning of the wtp access*/
	for (i = 0; ((i < num) && (i < L_RADIO_NUM)); i++)
	{	
		AC_RADIO[gwtpid] = (WID_WTP_RADIO*)malloc(sizeof(WID_WTP_RADIO));
		memset(AC_RADIO[gwtpid], 0, sizeof(WID_WTP_RADIO));
		AC_RADIO[gwtpid]->WTPID = WTPID;
		AC_RADIO[gwtpid]->Radio_G_ID = gwtpid;
		AC_RADIO[gwtpid]->Radio_L_ID = i;
		AC_RADIO[gwtpid]->Radio_Chan = 0;
		AC_RADIO[gwtpid]->ishighpower = RadioPowerType[i];
		AC_RADIO[gwtpid]->Radio_country_code = gCOUNTRYCODE; /*wcl add for OSDEVTDPB-31*/
		if (AC_RADIO[gwtpid]->ishighpower == 1)
		{
			AC_RADIO[gwtpid]->Radio_TXP = 27;
		}
		else
		{
			AC_RADIO[gwtpid]->Radio_TXP = 20;
		}
		AC_RADIO[gwtpid]->Radio_TXPOF = 0;
		AC_RADIO[gwtpid]->channelsendtimes = 1;	 /*wuwl add for send channel_cont only one time at the beginning of the wtp access*/
		memcpy(AC_RADIO[gwtpid]->Radio_MAC, AC_WTP[WTPID]->WTPMAC, MAC_LEN);
		if (i == 1)
		{
			AC_RADIO[gwtpid]->Radio_MAC[5] = (AC_RADIO[gwtpid]->Radio_MAC[5]&0xf0)|0x08;
		}
		
		if (7 == RadioType[i])
		{
			AC_RADIO[gwtpid]->Radio_Type = Radio_11bg;
		}
		else if (10 == RadioType[i])
		{
			AC_RADIO[gwtpid]->Radio_Type = Radio_11a_11an;
		}
		else if (12 == RadioType[i])
		{
			AC_RADIO[gwtpid]->Radio_Type = Radio_11g_11gn;
		}
		else if (15 == RadioType[i])
		{
			AC_RADIO[gwtpid]->Radio_Type = Radio_11a_11an;
		}
		else if ((26 == RadioType[i]) || (31 == RadioType[i]))
		{
			AC_RADIO[gwtpid]->Radio_Type = Radio_11a_11an_11ac;
		}
		else
		{
			AC_RADIO[gwtpid]->Radio_Type = RadioType[i];
		}

		if (10 == RadioType[i])
		{
			AC_RADIO[gwtpid]->Radio_Type_Bank = 26;
		}
		else if (12 == RadioType[i])
		{
			AC_RADIO[gwtpid]->Radio_Type_Bank = 44;
		}
		else if (26 == RadioType[i])
		{
			AC_RADIO[gwtpid]->Radio_Type_Bank = 90;
		}
		else if (31 == RadioType[i])
		{
			AC_RADIO[gwtpid]->Radio_Type_Bank = 127;
		}
		else
		{
			AC_RADIO[gwtpid]->Radio_Type_Bank = RadioType[i];
		}

		if (WAI_RADIO5G_TYPE(AC_RADIO[gwtpid]->Radio_Type))
		{
			AC_RADIO[gwtpid]->Radio_Chan = WAI_RADIO5G_CH_DEFAULT(AC_RADIO[gwtpid]->Radio_country_code);
		}
		else 
		{
			AC_RADIO[gwtpid]->Radio_Chan = WAI_RADIO2G_CH_DEFAULT(AC_RADIO[gwtpid]->Radio_country_code);	
		}

		AC_RADIO[gwtpid]->Support_Rate_Count = 0;
		AC_RADIO[gwtpid]->txpowerstep = 1;//zhaoruijia,20100917,add radio txpower step 
		AC_RADIO[gwtpid]->Radio_Rate = NULL;
		//AC_RADIO[gwtpid]->Radio_Rate = 0;// 54m/bps//sz1121 add channel 0,rate 0
		AC_RADIO[gwtpid]->FragThreshold = 2346;
		AC_RADIO[gwtpid]->BeaconPeriod = 100;
		AC_RADIO[gwtpid]->IsShortPreamble = 1;
		AC_RADIO[gwtpid]->DTIMPeriod = 1; 
		AC_RADIO[gwtpid]->ShortRetry = 7; 
		AC_RADIO[gwtpid]->LongRetry = 4; 
		AC_RADIO[gwtpid]->rtsthreshold = 2347;//zhangshu modify for rts initial
		AC_RADIO[gwtpid]->AdStat = 2;
		AC_RADIO[gwtpid]->OpStat = 2;
		AC_RADIO[gwtpid]->CMD = 0x0;
		for (ii = 0; ii < L_BSS_NUM; ii++)
		{
			AC_RADIO[gwtpid]->BSS[ii] = NULL;
		}
		AC_RADIO[gwtpid]->QOSID = 0;
		AC_RADIO[gwtpid]->QOSstate = 0;
		AC_RADIO[gwtpid]->bandwidth = gBANDWIDTH;
		AC_RADIO[gwtpid]->auto_channel = 0;
		AC_RADIO[gwtpid]->auto_channel_cont = 0;
		AC_RADIO[gwtpid]->txpowerautostate = 1;
		AC_RADIO[gwtpid]->wifi_state = 1;
		AC_RADIO[gwtpid]->radio_countermeasures_flag = 0;
		AC_RADIO[gwtpid]->channelchangetime = 0;
		AC_RADIO[gwtpid]->excommand = NULL;
		AC_RADIO[gwtpid]->diversity = 0;//default is 0
		AC_RADIO[gwtpid]->txantenna = 1;//default is main
		AC_RADIO[gwtpid]->isBinddingWlan = 0;
		AC_RADIO[gwtpid]->BindingWlanCount = 0;
		AC_RADIO[gwtpid]->upcount = 0;
		AC_RADIO[gwtpid]->downcount = 0;
		AC_RADIO[gwtpid]->guardinterval = 1;
		//AC_RADIO[gwtpid]->mcs = 0;   fengwenchao modify 20110411
		AC_RADIO[gwtpid]->cwmode = 0;
		AC_RADIO[gwtpid]->Wlan_Id = NULL;
		AC_RADIO[gwtpid]->REFlag = RadioExternFlag[i];//zhanglei add for A8
		AC_WTP[WTPID]->WTP_Radio[i] = AC_RADIO[gwtpid];
		memset(AC_RADIO[gwtpid]->br_ifname, 0, WLAN_NUM*IF_NAME_MAX);
		/*wcl add for RDIR-33*/
		AC_RADIO[gwtpid]->ack.Op = ACK_timeout;
		AC_RADIO[gwtpid]->ack.Type = RADIO;
		AC_RADIO[gwtpid]->ack.state = 0;
		AC_RADIO[gwtpid]->ack.distance = 0;
		/*wcl add end*/
		memset(AC_RADIO[gwtpid]->wep_flag, 0, WTP_WEP_NUM);	//fengwenchao change
		/*11n set begin*/
		AC_RADIO[gwtpid]->Ampdu.Op = Ampdu_op;
		AC_RADIO[gwtpid]->Ampdu.Type = RADIO;
		AC_RADIO[gwtpid]->Ampdu.Able = 1;/*enable*/
		AC_RADIO[gwtpid]->Ampdu.AmpduLimit = 65535;
		AC_RADIO[gwtpid]->Ampdu.subframe= 32;
		/* zhangshu add for amsdu init, 2010-10-09 */
		AC_RADIO[gwtpid]->Amsdu.Op = Amsdu_op;
		AC_RADIO[gwtpid]->Amsdu.Type = RADIO;
		AC_RADIO[gwtpid]->Amsdu.Able = 0;/*disable*/
		AC_RADIO[gwtpid]->Amsdu.AmsduLimit = 4000;
		AC_RADIO[gwtpid]->Amsdu.subframe = 32;
		AC_RADIO[gwtpid]->MixedGreenfield.Mixed_Greenfield = 0;
		memset(AC_RADIO[gwtpid]->MixedGreenfield.Wlan_Mixed, 0, WLAN_NUM);
		AC_RADIO[gwtpid]->channel_offset =0;
		AC_RADIO[gwtpid]->radio_disable_flag = 0;/*fengwenchao add 20110920 for radio disable config save*/
		AC_RADIO[gwtpid]->chainmask_num = RadioChainmask[i];//zhangshu add for default chainmask number
		memset(AC_RADIO[gwtpid]->mcs_list,0,L_BSS_NUM);  //fengwenchao add 20120314 for requirements-407
		AC_RADIO[gwtpid]->mcs_count = 1;
		if (0 == AC_RADIO[gwtpid]->chainmask_num)  //use for no chainmask xml configuration
		{
		    AC_RADIO[gwtpid]->chainmask_num = 1;
		}
		if (2 == AC_RADIO[gwtpid]->chainmask_num)
		{
		    AC_RADIO[gwtpid]->tx_chainmask_state_value = 3;
		    AC_RADIO[gwtpid]->rx_chainmask_state_value = 3; 
		}
		else if (3 == AC_RADIO[gwtpid]->chainmask_num)
		{
		    AC_RADIO[gwtpid]->tx_chainmask_state_value = 7;
		    AC_RADIO[gwtpid]->rx_chainmask_state_value = 7; 
		}
		else
		{
		    AC_RADIO[gwtpid]->tx_chainmask_state_value = 1;
		    AC_RADIO[gwtpid]->rx_chainmask_state_value = 1; 
		}

		for (jj = 0; jj < TX_CHANIMASK_NUM; jj++)
		{	
			AC_RADIO[gwtpid]->tx_chainmask[jj] = (WID_oem_tx_chainmask*)malloc(sizeof(WID_oem_tx_chainmask));
			AC_RADIO[gwtpid]->tx_chainmask[jj]->state = 0;
		}
		if ((AC_RADIO[gwtpid]->Radio_Type & 0x08) == 0x08)//if mode is 11n,beacon interval set to 400
		{
			AC_RADIO[gwtpid]->BeaconPeriod = 400;
			AC_RADIO[gwtpid]->diversity = 1;// 11 n default is 1
			AC_RADIO[gwtpid]->txantenna = 0;// 11n default is 0
		}

		AC_RADIO[gwtpid]->Radio_Rate = create_support_rate_list(1);//here add 10 first
		int rate = 0;
		if ((AC_RADIO[gwtpid]->Radio_Type&IEEE80211_11B) > 0)
		{
			AC_RADIO[gwtpid]->Support_Rate_Count = 4;
			
			rate = 10;
			AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);
			
			rate = 20;
			AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);
			
			rate = 55;
			AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);

			rate = 110;
			AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);

			AC_RADIO[gwtpid]->Radio_Rate = delete_rate_from_list(AC_RADIO[gwtpid]->Radio_Rate, 0);
			AC_RADIO[gwtpid]->Support_Rate_Count = length_of_rate_list(AC_RADIO[gwtpid]->Radio_Rate);
		}
		if ((AC_RADIO[gwtpid]->Radio_Type&IEEE80211_11A) > 0)
		{
			AC_RADIO[gwtpid]->Support_Rate_Count = 8;
			
			rate = 60;
			AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);
	
			rate = 90;
			AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);
	
			rate = 120;
			AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);
	
			rate = 180;
			AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);
	
			rate = 240;
			AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);
	
			rate = 360;
			AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);
	
			rate = 480;
			AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);
	
			rate = 540;
			AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);

			AC_RADIO[gwtpid]->Radio_Rate = delete_rate_from_list(AC_RADIO[gwtpid]->Radio_Rate, 0);
			delsame_rate_from_list(AC_RADIO[gwtpid]->Radio_Rate);
			AC_RADIO[gwtpid]->Support_Rate_Count = length_of_rate_list(AC_RADIO[gwtpid]->Radio_Rate);
		}
		if ((AC_RADIO[gwtpid]->Radio_Type&IEEE80211_11G) > 0)
		{
			AC_RADIO[gwtpid]->Support_Rate_Count = 8;

			rate = 60;
			AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);

			rate = 90;
			AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);

			rate = 120;
			AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);

			rate = 180;
			AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);

			rate = 240;
			AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);

			rate = 360;
			AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);

			rate = 480;
			AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);

			rate = 540;
			AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);

			AC_RADIO[gwtpid]->Radio_Rate = delete_rate_from_list(AC_RADIO[gwtpid]->Radio_Rate, 0);
			delsame_rate_from_list(AC_RADIO[gwtpid]->Radio_Rate);
			AC_RADIO[gwtpid]->Support_Rate_Count = length_of_rate_list(AC_RADIO[gwtpid]->Radio_Rate);
		}
		if (((AC_RADIO[gwtpid]->Radio_Type&IEEE80211_11N) > 0) || ((AC_RADIO[gwtpid]->Radio_Type&IEEE80211_11AC) > 0))
		{
			/*fengwenchao add 20120314 forrequirements-407*/
			int j = 0;
			if (AC_RADIO[gwtpid]->chainmask_num == 1)
			{
				for (j = 0; j < 8; j++)
				{
					AC_RADIO[gwtpid]->mcs_list[j] = j;
				}
				AC_RADIO[gwtpid]->mcs_count = 8;

				rate = 722;
				AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);

				AC_RADIO[gwtpid]->Radio_Rate = delete_rate_from_list(AC_RADIO[gwtpid]->Radio_Rate, 0);
				delsame_rate_from_list(AC_RADIO[gwtpid]->Radio_Rate);
				AC_RADIO[gwtpid]->Support_Rate_Count = length_of_rate_list(AC_RADIO[gwtpid]->Radio_Rate);
			}
			else if (AC_RADIO[gwtpid]->chainmask_num == 2)
			{
				for (j = 0; j < 16; j++)
				{
					AC_RADIO[gwtpid]->mcs_list[j] = j;
				}
				AC_RADIO[gwtpid]->mcs_count = 16;
				
				rate = 1444;
				AC_RADIO[gwtpid]->Radio_Rate = insert_rate_into_list(AC_RADIO[gwtpid]->Radio_Rate,rate);

				AC_RADIO[gwtpid]->Radio_Rate = delete_rate_from_list(AC_RADIO[gwtpid]->Radio_Rate, 0);
				delsame_rate_from_list(AC_RADIO[gwtpid]->Radio_Rate);
				AC_RADIO[gwtpid]->Support_Rate_Count = length_of_rate_list(AC_RADIO[gwtpid]->Radio_Rate);	
			}
			else if (AC_RADIO[gwtpid]->chainmask_num == 3)
			{
				for (j = 0; j < 24; j++)
				{
					AC_RADIO[gwtpid]->mcs_list[j] = j;
				}
				AC_RADIO[gwtpid]->mcs_count = 24;
			}
			/*fengwenchao add end*/
			
			WID_ADD_RADIO_APPLY_QOS(gwtpid,QOS_NUM-1,1);
		}

		/*a8 chushihua start*/
		if (AC_RADIO[gwtpid]->REFlag == 1)
		{
			AC_RADIO[gwtpid]->sector_state_value = 0 ;
			AC_RADIO[gwtpid]->inter_vap_able = 0;
			AC_RADIO[gwtpid]->intra_vap_able = 0;
			AC_RADIO[gwtpid]->keep_alive_period = 3600;
			AC_RADIO[gwtpid]->keep_alive_idle_time = 3600;
			AC_RADIO[gwtpid]->congestion_avoidance = 0;
		}
	
		for (ii = 0; ii < SECTOR_NUM; ii++)
		{	
			//CW_CREATE_OBJECT_ERR(AC_RADIO[gwtpid]->sector[ii],WID_oem_sector,return NULL;);
			AC_RADIO[gwtpid]->sector[ii] = (WID_oem_sector*)malloc(sizeof(WID_oem_sector));
			AC_RADIO[gwtpid]->sector[ii]->state = 0;
			AC_RADIO[gwtpid]->sector[ii]->tx_power = 0;
		}

		AC_RADIO[gwtpid]->StartService.times = -1;
		AC_RADIO[gwtpid]->StopService.times = -1;
	
		AC_RADIO[gwtpid]->spec_analysis.enalbe = 0;
		AC_RADIO[gwtpid]->spec_analysis.scan_cycle = SA_DEFAULT_CYCLE;
		AC_RADIO[gwtpid]->spec_analysis.scan_time = SA_DEFAULT_TIME;
		AC_RADIO[gwtpid]->spec_analysis.report_interval = SA_DEFAULT_REPORT_INTERVAL;
		
		gwtpid++;
	}
	wid_init_wtp_info_in_create(WTPID);
	AC_WTP[WTPID]->wids_statist.floodingcount = 0;
	AC_WTP[WTPID]->wids_statist.sproofcount = 0;
	AC_WTP[WTPID]->wids_statist.weakivcount = 0;
	gStaticWTPs++;
	
	return 0 ;
}


int WID_DELETE_WTP(unsigned int WTPID)
{
	WID_CHECK_WTP_STANDARD_RET(WTPID, WTP_ID_NOT_EXIST);
	
	if (AC_WTP[WTPID]->isused == 1)
	{
		syslog(LOG_ERR, "*** error this WTP is used and active, you can not delete this ***\n");
		syslog(LOG_ERR, "*** if you want to delete please unused it first ***\n");
		return WTP_ID_BE_USED;
	}
	int num = AC_WTP[WTPID]->RadioCount;
	int i = 0, j = 0, k = 0, ii = 0;
	int bssindex = 0;
	unsigned char wlanid = 0;
	int ebr_id = 0;
	unsigned int RID = AC_WTP[WTPID]->WFR_Index;
	char macAddr[MAC_LEN] = {0};
	
	for (i = 0; i < num; i++)
	{
		for (k = 0; k < L_BSS_NUM; k++)
		{
			if (AC_RADIO[RID]->BSS[k] != NULL)
			{
				wlanid = AC_RADIO[RID]->BSS[k]->WlanID;
				/*fengwenchao add 20111221 for ISSUES-850*/
				#if 0
				if((AC_RADIO[RID])&&(!strncasecmp(AC_RADIO[RID]->br_ifname[wlanid],"ebr",3)))
				{
					char ebrname[ETH_IF_NAME_LEN];
					memset(ebrname,0,ETH_IF_NAME_LEN);
					memcpy(ebrname,AC_RADIO[RID]->br_ifname[wlanid],strlen(AC_RADIO[RID]->br_ifname[wlanid]));
					 ret = Check_Interface_Exist(ebrname,&quitreason);
					 if(ret == 0)
					 	return RADIO_IN_EBR;
				}
				#endif
				if (check_whether_in_ebr(vrrid,WTPID,i,wlanid,&ebr_id))
				{
					wid_syslog_debug_debug(WID_DBUS,"<error> %s  check interface in ebr\n",__func__);
					return RADIO_IN_EBR;
				}
				/*fengwenchao add end*/
			}
		}
		RID++;
	}
	memset(macAddr, 0, MAC_LEN);
	if (AC_WTP[WTPID] != NULL)
	{
		memcpy(macAddr,AC_WTP[WTPID]->WTPMAC,MAC_LEN);
	}
	else
	{
		wid_syslog_warning("%s,%d,AC_WTP[%d] is %p.\n",__func__,__LINE__,WTPID,AC_WTP[WTPID]);
	}
	RID = AC_WTP[WTPID]->WFR_Index;
	for (i = 0; ((i < num)&&(AC_RADIO[RID] != NULL)); i++)
	{
		wid_syslog_debug_debug(WID_DBUS,"%s,%d.\n",__func__,__LINE__);

		//free bss 20080806
		for (k = 0; k < L_BSS_NUM; k++)
		{
			if (AC_RADIO[RID]->BSS[k] != NULL)
			{
				wlanid = AC_RADIO[RID]->BSS[k]->WlanID;
				if (AC_RADIO[RID]->BSS[k]->BSS_IF_POLICY == BSS_INTERFACE)
				{
					//should added delete l3 interface
					Delete_BSS_L3_Interface(AC_RADIO[RID]->BSS[k]->BSSIndex);
				}
				if (AC_RADIO[RID]->BSS[k]->BSS_IF_POLICY == WLAN_INTERFACE)
				{
					//remove interface from wlan br
					Del_BSS_L3_Interface_BR(AC_RADIO[RID]->BSS[k]->BSSIndex);
					//should added delete l3 interface
					Delete_BSS_L3_Interface(AC_RADIO[RID]->BSS[k]->BSSIndex);
				}
				bssindex = AC_RADIO[RID]->BSS[k]->BSSIndex;
				//weichao add 
				if (AC_BSS[bssindex]->acl_conf != NULL)
				{	
					if (AC_BSS[bssindex]->acl_conf->accept_mac != NULL)
					{
						free_maclist(AC_BSS[bssindex]->acl_conf,AC_BSS[bssindex]->acl_conf->accept_mac);
						AC_BSS[bssindex]->acl_conf->accept_mac = NULL;
					}
					if (AC_BSS[bssindex]->acl_conf->deny_mac != NULL)
					{
						free_maclist(AC_BSS[bssindex]->acl_conf,AC_BSS[bssindex]->acl_conf->deny_mac);
						AC_BSS[bssindex]->acl_conf->deny_mac = NULL;
					}
					CW_FREE_OBJECT(AC_BSS[bssindex]->acl_conf);
				}
				wlanid = AC_RADIO[RID]->BSS[k]->WlanID;
				if ((AC_WLAN[wlanid]) && (AC_WLAN[wlanid]->S_WTP_BSS_List[WTPID][i] == bssindex))
				{
				    AC_WLAN[wlanid]->S_WTP_BSS_List[WTPID][i] = 0;
                }
				AC_RADIO[RID]->BSS[k]->WlanID = 0;
				AC_RADIO[RID]->BSS[k]->Radio_G_ID = 0;
				AC_RADIO[RID]->BSS[k]->Radio_L_ID = 0;
				AC_RADIO[RID]->BSS[k]->State = 0;
				AC_RADIO[RID]->BSS[k]->BSSIndex = 0;
				memset(AC_RADIO[RID]->BSS[k]->BSSID, 0, MAC_LEN);
				CW_FREE_OBJECT(AC_RADIO[RID]->BSS[k]->BSSID);
				CW_FREE_OBJECT(AC_RADIO[RID]->BSS[k]);
				AC_WTP[WTPID]->WTP_Radio[i]->BSS[k] = NULL;
				AC_BSS[bssindex] = NULL;
			}

		}
		//added end 20080806
		
		if (AC_WTP[WTPID]->WTP_Radio[i]->Support_Rate_Count != 0)
		{
			AC_WTP[WTPID]->WTP_Radio[i]->Support_Rate_Count = 0;
			destroy_support_rate_list(AC_WTP[WTPID]->WTP_Radio[i]->Radio_Rate);

		}
		AC_WTP[WTPID]->WTP_Radio[i] = NULL;
		
		struct wlanid *wlan_id = AC_RADIO[RID]->Wlan_Id;
		struct wlanid *wlan_id_next = NULL;
		
		while (wlan_id != NULL)
		{			
			wlan_id_next = wlan_id->next;
		
			CW_FREE_OBJECT(wlan_id);
		
			wlan_id = wlan_id_next;
		}
		for (j = 0; j < SECTOR_NUM; j++)
		{	
			CW_FREE_OBJECT(AC_RADIO[RID]->sector[j]);
		}
		for (ii = 0; ii < TX_CHANIMASK_NUM; ii++)
		{	
			CW_FREE_OBJECT(AC_RADIO[RID]->tx_chainmask[ii]);
		}
		
		CW_FREE_OBJECT(AC_RADIO[RID]);
		
		RID++;
	}
	CW_FREE_OBJECT(AC_WTP[WTPID]->WTPIP);
	CW_FREE_OBJECT(AC_WTP[WTPID]->WTPMAC);
	CW_FREE_OBJECT(AC_WTP[WTPID]->CMD);
	CW_FREE_OBJECT(AC_WTP[WTPID]->WTPSN);
	CW_FREE_OBJECT(AC_WTP[WTPID]->WTPNAME);
	CW_FREE_OBJECT(AC_WTP[WTPID]->WTPModel);
	CW_FREE_OBJECT(AC_WTP[WTPID]->APCode);
	CW_FREE_OBJECT(AC_WTP[WTPID]->add_time);
	CW_FREE_OBJECT(AC_WTP[WTPID]->quit_time);
	CW_FREE_OBJECT(AC_WTP[WTPID]->location);
	CW_FREE_OBJECT(AC_WTP[WTPID]->netid);
	CW_FREE_OBJECT(AC_WTP[WTPID]->option60_param);
//	CW_FREE_OBJECT(AC_WTP[WTPID]->sysver);
//	CW_FREE_OBJECT(AC_WTP[WTPID]->ver);
//	CW_FREE_OBJECT(AC_WTP[WTPID]->codever);
	AC_WTP[WTPID]->sysver = NULL;
	AC_WTP[WTPID]->ver = NULL;
	AC_WTP[WTPID]->codever = NULL;

	if (AC_WTP[WTPID]->apcminfo.ap_cpu_info_head != NULL)
	{	
		struct ap_cpu_info *p = AC_WTP[WTPID]->apcminfo.ap_cpu_info_head;
		struct ap_cpu_info *tmp = NULL;
		
		while (p != NULL)
		{
			tmp = p;
			p = p->next;
			tmp->next = NULL;
			CW_FREE_OBJECT(tmp);
			AC_WTP[WTPID]->apcminfo.ap_cpu_info_length--;
		}
	}
	
	if (AC_WTP[WTPID]->apcminfo.ap_mem_info_head != NULL)
	{	
		struct ap_cpu_info *p = AC_WTP[WTPID]->apcminfo.ap_mem_info_head;
		struct ap_cpu_info *tmp = NULL;
		
		while (p != NULL)
		{
			tmp = p;
			p = p->next;
			tmp->next = NULL;
			CW_FREE_OBJECT(tmp);
			AC_WTP[WTPID]->apcminfo.ap_mem_info_length--;
		}
	}
	if (AC_WTP[WTPID]->apcminfo.ap_snr_info_head != NULL)
	{	
		struct ap_snr_info * p = AC_WTP[WTPID]->apcminfo.ap_snr_info_head;
		struct ap_snr_info * tmp = NULL;
		
		while (p != NULL)
		{
			tmp = p;
			p = p->next;
			tmp->next = NULL;
			CW_FREE_OBJECT(tmp);
			AC_WTP[WTPID]->apcminfo.ap_snr_info_length--;
			printf("ap_snr_info_length:%d",AC_WTP[WTPID]->apcminfo.ap_snr_info_length);
		}
	}
	/*fengwenchao add 20111118 for GM-3*/
	if (AC_WTP[WTPID]->heart_time.heart_time_value_head != NULL)
	{
		struct heart_time_value_head *p = AC_WTP[WTPID]->heart_time.heart_time_value_head;
		struct heart_time_value_head *tmp = NULL;
		
		while (p != NULL)
		{
			tmp = p;
			p = p->next;
			tmp->next = NULL;
			CW_FREE_OBJECT(tmp);
			AC_WTP[WTPID]->heart_time.heart_time_value_length--;
			printf("heart_time_value_length:%d",AC_WTP[WTPID]->heart_time.heart_time_value_length);
		}
	}
	/*fengwenchao add end*/
	CWThreadMutexLock(&(gWTPs[WTPID].RRMThreadMutex));
	for (i = 0; ((AC_WTP[WTPID])&&(i < num)&&(i < L_RADIO_NUM)); i++)
	{
		if ((AC_WTP[WTPID])&&((AC_WTP[WTPID]->NeighborAPInfos[i]) != NULL))
		{
			destroy_ap_info_list(&(AC_WTP[WTPID]->NeighborAPInfos[i]));
		}
		if ((AC_WTP[WTPID])&&((AC_WTP[WTPID]->rouge_ap_infos[i]) != NULL))
		{
			destroy_ap_info_list(&(AC_WTP[WTPID]->rouge_ap_infos[i]));
		}
	}
	CWThreadMutexUnlock(&(gWTPs[WTPID].RRMThreadMutex)); 

	//added by weiay 20080630
	/*
	struct wlanid *wlan_id = NULL;
	while(wlan_id != NULL)
	{
		AC_WTP[WTPID]->Wlan_Id = wlan_id->next;
		free(wlan_id);
		wlan_id = NULL;
		wlan_id = AC_WTP[WTPID]->Wlan_Id;
	}
	*/
	//added end
	if (AC_WTP[WTPID]->APGroupID != 0)
	{
		del_ap_group_member(AC_WTP[WTPID]->APGroupID,WTPID);
	}
	CW_FREE_OBJECT(AC_WTP[WTPID]);

	gStaticWTPs--;
	
	struct wtp_con_info *con_info = NULL;
	con_info = malloc(sizeof(struct wtp_con_info));
	memset(con_info, 0, sizeof(struct wtp_con_info));
	memcpy(con_info->wtpmac, macAddr, MAC_LEN);
	wid_syslog_info("%s:%d wtp%d con_info->wtpmac:"MACSTR".\n",__func__,__LINE__,WTPID,MAC2STR(con_info->wtpmac));
	con_info->wtpindex = WTPID;
	con_info->wtpindex2 = WTPID;
	wid_del_conflict_wtpinfo(con_info);
	CW_FREE_OBJECT(con_info);
	
	return 0;
}


int WID_SUSPEND_WTP(unsigned int WTPID)
{
	char i = 0, result = 0;
	msgq msg;
	
	if (gWTPs[WTPID].isNotFree)
	{ 	
		gWTPs[WTPID].isRequestClose = CW_TRUE;
		syslog_wtp_log(WTPID, 0, "WTP UNUSED", 0);
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WTPID%THREAD_NUM + 1;
		msg.mqinfo.WTPID = WTPID;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WTP_S_TYPE;
		msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_REBOOT;
		if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
		{
			wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
		}
	}
	else
	{
		for (i = 0; i < BATCH_UPGRADE_AP_NUM; i++)
		{
			if (gConfigVersionUpdateInfo[i] != NULL)
			{
				result = 1;
				break;
			}
		}
		if ((result != 0) && (find_in_wtp_list(WTPID) == CW_TRUE))
		{
			CWTimerCancel(&(gWTPs[WTPID].updateTimer),0);
			delete_wtp_list(WTPID);
		}
		
		if ((AC_WTP[WTPID] != NULL) && (AC_WTP[WTPID]->isused == 1) && (AC_WTP[WTPID]->unused_flag == 1))
		{
			AC_WTP[WTPID]->isused = 0;
			AC_WTP[WTPID]->unused_flag = 0;
		}
	}
	CWThreadMutexLock(&(gWTPs[WTPID].WTPThreadControllistMutex));
	WID_CLEAN_CONTROL_LIST(WTPID);
	CWThreadMutexUnlock(&(gWTPs[WTPID].WTPThreadControllistMutex));
	
	WID_CLEAN_WTP_STA_LIST(WTPID);

	return 0;
}

int WID_DISABLE_WLAN(unsigned char WlanID)
{
	int j = 0, m = 0;
	int Radioid = 0;
	
    WID_CHECK_WLAN_EXIST_RET(WlanID,WLAN_ID_NOT_EXIST);
    
	if(AC_WLAN[WlanID]->Status == 1)
	{
	    return 0;
	}
	
	wid_syslog_debug_debug(WID_DEFAULT,"%s:%d wlan%d status %s need disable\n",__func__,__LINE__,WlanID,(AC_WLAN[WlanID]->Status)?"disable":"enable");
	
	AC_WLAN[WlanID]->Status = 1;
#if NOSOFTAC
	AsdWsm_WLANOp(WlanID, WID_MODIFY, 0);
#endif	
	for (m = 1; m < WTP_NUM; m++)
	{
		if (AC_WTP[m] != NULL)
		{
			if (0 == CONFIG_WLAN_CHECK_APPLY_WTP(m, WlanID))
			{
				wid_syslog_debug_debug(WID_DEFAULT,"%s:%d wtp%d binding wlan%d match success\n",__func__,__LINE__,m,WlanID);
				WID_DISABLE_WLAN_APPLY_WTP(m, WlanID);
			}
			else
			{   		
				for(j = 0; j < AC_WTP[m]->RadioCount; j++)
				{
					Radioid = m*L_RADIO_NUM+j;
					WID_DISABLE_WLAN_APPLY_RADIO(Radioid, WlanID);
				}
			}
		}
	}
	return 0;
}

int issued_wlan_enable(unsigned int wtpid,unsigned char l_radioid, unsigned char wlanid, unsigned char op_level)
{    
	msgq msg;
	struct msgqlist *elem = NULL;
	
	memset((char*)&msg, 0, sizeof(msg));
	msg.mqid = wtpid%THREAD_NUM+1;
	msg.mqinfo.WTPID = wtpid;
	msg.mqinfo.type = CONTROL_TYPE;
	msg.mqinfo.subtype = WLAN_S_TYPE;
	msg.mqinfo.u.WlanInfo.Wlan_Op = WLAN_ADD;
	msg.mqinfo.u.WlanInfo.LEVEL = op_level;
	msg.mqinfo.u.WlanInfo.WLANID = wlanid;
	msg.mqinfo.u.WlanInfo.Radio_L_ID = l_radioid;
	msg.mqinfo.u.WlanInfo.HideESSid = AC_WLAN[wlanid]->HideESSid;
	memset(msg.mqinfo.u.WlanInfo.WlanKey, 0, DEFAULT_LEN);
	memcpy(msg.mqinfo.u.WlanInfo.WlanKey, AC_WLAN[wlanid]->WlanKey, DEFAULT_LEN);
	msg.mqinfo.u.WlanInfo.KeyLen = AC_WLAN[wlanid]->KeyLen;
	msg.mqinfo.u.WlanInfo.wpa_group_rekey = AC_WLAN[wlanid]->wpa_group_rekey;
	msg.mqinfo.u.WlanInfo.SecurityType = AC_WLAN[wlanid]->SecurityType;
	msg.mqinfo.u.WlanInfo.SecurityIndex = AC_WLAN[wlanid]->SecurityIndex;
	msg.mqinfo.u.WlanInfo.asic_hex = AC_WLAN[wlanid]->asic_hex;						/* 0 asic; 1 hex*/
	msg.mqinfo.u.WlanInfo.Roaming_Policy = AC_WLAN[wlanid]->Roaming_Policy;         /*Roaming (1 enable /0 disable)*/
	msg.mqinfo.u.WlanInfo.wlan_send_traffic_limit = AC_WLAN[wlanid]->wlan_send_traffic_limit;
	msg.mqinfo.u.WlanInfo.wlan_traffic_limit = AC_WLAN[wlanid]->wlan_traffic_limit;
	memset(msg.mqinfo.u.WlanInfo.WlanEssid, 0, ESSID_LENGTH);
	memcpy(msg.mqinfo.u.WlanInfo.WlanEssid, AC_WLAN[wlanid]->ESSID, ESSID_LENGTH);
	if (op_level)
	{
		msg.mqinfo.u.WlanInfo.bssindex = AC_WLAN[wlanid]->S_WTP_BSS_List[wtpid][l_radioid];
		unsigned int bssindex = AC_WLAN[wlanid]->S_WTP_BSS_List[wtpid][l_radioid];
		if ((0 != bssindex) && (check_bssid_func(bssindex)))
		{
			if (AC_BSS[bssindex]->aliasSetFlag)
			{
				memset(msg.mqinfo.u.WlanInfo.WlanEssid, 0, ESSID_LENGTH);
				memcpy(msg.mqinfo.u.WlanInfo.WlanEssid, AC_BSS[bssindex]->aliasESSID, ESSID_LENGTH);
			}
			if (AC_BSS[bssindex]->KeyLen)
			{
				memset(msg.mqinfo.u.WlanInfo.WlanKey, 0, DEFAULT_LEN);
				memcpy(msg.mqinfo.u.WlanInfo.WlanKey, AC_BSS[bssindex]->WlanKey, DEFAULT_LEN);
				msg.mqinfo.u.WlanInfo.KeyLen = AC_BSS[bssindex]->KeyLen;
			}
		}
	}
	
	unsigned char ssidbuffer[DEFAULT_LEN] = {0};
	int len = strlen((char *)msg.mqinfo.u.WlanInfo.WlanEssid);
	wid_hex_dump_essid(msg.mqinfo.u.WlanInfo.WlanEssid, len, ssidbuffer);
	
	wid_syslog_debug_debug(WID_DEFAULT, WAI_FUNC_LINE_FMT"wtp%d radio%d wlan%d %s essid %s%s level(%d)%s\n",
							WAI_FUNC_LINE_LITERAL, wtpid, l_radioid, wlanid, WAI_WLAN_OP_STR(WLAN_ADD), ssidbuffer,
							msg.mqinfo.u.WlanInfo.WlanEssid, op_level, (0 == op_level)? "LEVEL_AP" : "LEVEL_RADIO");    
	
	if ((AC_WTP[wtpid] != NULL) && (AC_WTP[wtpid]->WTPStat == WID_RUN))
	{   
		if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
		{
			wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
		}
	}
	else
	{
		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if (elem == NULL)
		{
			wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
			return 0;
		}
		memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
		elem->next = NULL;
		memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
		WID_INSERT_CONTROL_LIST(wtpid, elem);
	}
	
	return 0;
}

int issued_wlan_disable(unsigned int wtpid,unsigned char l_radioid, unsigned char wlanid, unsigned char op_level)
{    
    msgq msg;
    struct msgqlist *elem = NULL;
        
    memset((char*)&msg, 0, sizeof(msg));
    msg.mqid = wtpid%THREAD_NUM+1;
    msg.mqinfo.WTPID = wtpid;
    msg.mqinfo.type = CONTROL_TYPE;
    msg.mqinfo.subtype = WLAN_S_TYPE;
    msg.mqinfo.u.WlanInfo.Wlan_Op = WLAN_DEL;    
    msg.mqinfo.u.WlanInfo.LEVEL = op_level;
    msg.mqinfo.u.WlanInfo.WLANID = wlanid;
    msg.mqinfo.u.WlanInfo.Radio_L_ID = l_radioid;
	if (op_level)
	{
		msg.mqinfo.u.WlanInfo.bssindex = AC_WLAN[wlanid]->S_WTP_BSS_List[wtpid][l_radioid];
	}
	
	wid_syslog_debug_debug(WID_DEFAULT, WAI_FUNC_LINE_FMT"wtp%d radio%d wlan%d op(%d)%s level(%d)%s\n",
							WAI_FUNC_LINE_LITERAL, wtpid, l_radioid, wlanid, WLAN_DEL,
							WAI_WLAN_OP_STR(WLAN_DEL), op_level, (0 == op_level)? "LEVEL_AP" : "LEVEL_RADIO");    
	
	if ((AC_WTP[wtpid] != NULL) && (AC_WTP[wtpid]->WTPStat == WID_RUN))
	{
		if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
		{
			wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
		}
	}
	else
	{
		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if (elem == NULL)
		{
			wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
			return 0;
		}
		memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
		elem->next = NULL;
		memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
		WID_INSERT_CONTROL_LIST(wtpid, elem);
	}

    return 0;
}

int issued_wlan_taffic_limit(unsigned int wtpid,unsigned char l_radioid, unsigned char wlanid, unsigned char op_level)
{    
	msgq msg;
	struct msgqlist *elem = NULL;
	
	memset((char*)&msg, 0, sizeof(msg));
	msg.mqid = wtpid%THREAD_NUM+1;
	msg.mqinfo.WTPID = wtpid;
	msg.mqinfo.type = CONTROL_TYPE;
	msg.mqinfo.subtype = WTP_S_TYPE;
	msg.mqinfo.u.WtpInfo.Wtp_Op = WLAN_TRAFFIC_LIMIT;
	msg.mqinfo.u.WtpInfo.c1 = op_level;
	msg.mqinfo.u.WtpInfo.wlanid = wlanid;
	msg.mqinfo.u.WtpInfo.radioid = l_radioid;
	msg.mqinfo.u.WtpInfo.i1 = AC_WLAN[wlanid]->wlan_send_traffic_limit;
	msg.mqinfo.u.WtpInfo.i2 = AC_WLAN[wlanid]->wlan_traffic_limit;
	
	unsigned char ssidbuffer[DEFAULT_LEN] = {0};
	int len = strlen((char *)AC_WLAN[wlanid]->ESSID);
	wid_hex_dump_essid(AC_WLAN[wlanid]->ESSID, len, ssidbuffer);
	
	wid_syslog_debug_debug(WID_DEFAULT, WAI_FUNC_LINE_FMT"wtp%d radio%d wlan%d essid %s send_traffic_limit %d traffic_limit %d level(%d)%s\n",
							WAI_FUNC_LINE_LITERAL, wtpid, l_radioid, wlanid, (AC_WLAN[wlanid]->chinaEssid) ? ssidbuffer : AC_WLAN[wlanid]->ESSID,
							AC_WLAN[wlanid]->wlan_send_traffic_limit, AC_WLAN[wlanid]->wlan_traffic_limit,
							op_level, (0 == op_level)? "LEVEL_AP" : "LEVEL_RADIO");    
	
	if ((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPStat == WID_RUN))
	{
		if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
		{
			wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
		}
	}
	else
	{
		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if (elem == NULL)
		{
			wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
			return 0;
		}
		memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
		elem->next = NULL;
		memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
		WID_INSERT_CONTROL_LIST(wtpid, elem);
	}
	
	return 0;
}

//weichao add 2011.11.03
int WLAN_FLOW_CHECK(unsigned char WlanID)
{
	msgq msg;
	struct msgqlist *elem = NULL;

	int m = 0, m1 = 0;	
	for (m = 0; m < WTP_NUM; m++)
	{
		if (AC_WTP[m] != NULL)
		{
			for (m1 = 0; m1 < AC_WTP[m]->RadioCount; m1++)
			{
				wid_syslog_debug_debug(WID_DEFAULT,"%s:%d wtp%d radio%d wlan%d bssindex %d\n",__func__,__LINE__,m,m1,WlanID,AC_WLAN[WlanID]->S_WTP_BSS_List[m][m1]);	
				if ((AC_WLAN[WlanID]->SecurityType == IEEE8021X)
					|| (AC_WLAN[WlanID]->SecurityType == WPA_E)
					|| (AC_WLAN[WlanID]->SecurityType == WPA2_E)
					|| (AC_WLAN[WlanID]->SecurityType == MD5))
				{    
					if (AC_WLAN[WlanID]->S_WTP_BSS_List[m][m1] != 0)
					{
					    unsigned int BSSIndex = AC_WLAN[WlanID]->S_WTP_BSS_List[m][m1];
						if ((check_bssid_func(BSSIndex)) && (AC_BSS[BSSIndex] != NULL) && (AC_WTP[m] != NULL))
						{
							msg.mqid = m%THREAD_NUM+1;
							msg.mqinfo.WTPID = m;
							msg.mqinfo.type = CONTROL_TYPE;
							msg.mqinfo.subtype = WTP_S_TYPE;
							msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_FLOW_CHECK;
							msg.mqinfo.u.WlanInfo.WLANID = WlanID;
							msg.mqinfo.u.WlanInfo.Radio_L_ID = m1;
							msg.mqinfo.u.WlanInfo.flow_check = AC_WLAN[WlanID]->flow_check;
							msg.mqinfo.u.WlanInfo.no_flow_time = AC_WLAN[WlanID]->no_flow_time;
							msg.mqinfo.u.WlanInfo.limit_flow = AC_WLAN[WlanID]->limit_flow;
							
							if (AC_WTP[m]->WTPStat == WID_RUN)
							{	
								if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
								{
									wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
								}
							}
							else
							{
								elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
								if (elem == NULL)
								{
									wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
									return 0;
								}
								
								memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
								elem->next = NULL;
								memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
								
								WID_INSERT_CONTROL_LIST(m, elem);
							}
						}
					}
				}
			}
		}
	}
	return 0; 
}

int WID_wds_disable(unsigned char WlanID,unsigned char wds_mesh)
{
	WID_CHECK_WLAN_EXIST_RET(WlanID, WLAN_ID_NOT_EXIST);
	
	if(AC_WLAN[WlanID]->Status == 1)
	{
		return WLAN_BE_DISABLE;
	}
	

	if(AC_WLAN[WlanID]->WDSStat== 1)
	{
		AC_WLAN[WlanID]->WDSStat= 0;
		if((wds_mesh&(0x02)) !=0)
			AC_WLAN[WlanID]->wds_mesh = 1;
		else
			AC_WLAN[WlanID]->wds_mesh = 0;
	}
	else
	{
		return 0;
	}
	
	int m = 0, m1 = 0;	
	for(m = 0; m < WTP_NUM; m++)
	{
		if(AC_WTP[m] != NULL)
		{
			for(m1 = 0; m1 < AC_WTP[m]->RadioCount; m1++)
			{				
				if(AC_WLAN[WlanID]->S_WTP_BSS_List[m][m1] != 0)
				{	
					unsigned int BSSIndex = AC_WLAN[WlanID]->S_WTP_BSS_List[m][m1];
					if((check_bssid_func(BSSIndex))&&(AC_BSS[BSSIndex] != NULL)&&(AC_BSS[BSSIndex]->WDSStat == WDS_SOME)){
						continue;
					}
					if((AC_BSS[BSSIndex] != NULL)&&(AC_WTP[m] != NULL))
					{
						wid_set_bss_wds(m, m1, WlanID, WLAN_WDS_DISABLE);
						AC_BSS[BSSIndex]->WDSStat = DISABLE;
					}				
				}
			}
		}
	}

	return 0;
}


int WID_wds_enable(unsigned char WlanID,unsigned char wds_mesh)
{
	WID_CHECK_WLAN_EXIST_RET(WlanID, WLAN_ID_NOT_EXIST);
	
	if(AC_WLAN[WlanID]->Status == 1)
	{
		return WLAN_BE_DISABLE;
	}		
	
	if(AC_WLAN[WlanID]->WDSStat== 0)
	{
		AC_WLAN[WlanID]->WDSStat= 1;
		if((wds_mesh&(0x02)) !=0)
			AC_WLAN[WlanID]->wds_mesh = 1;
		else
			AC_WLAN[WlanID]->wds_mesh = 0;
	}
	else
	{
		return 0;
	}
	
	int m = 0, n = 0;
	for(m = 0; m < WTP_NUM; m++)
	{
		if((AC_WTP[m]!=NULL))
		{
			for(n = 0; n < AC_WTP[m]->RadioCount; n++)
			{				
				if(AC_WLAN[WlanID]->S_WTP_BSS_List[m][n] != 0)
				{					
					unsigned int BSSIndex = AC_WLAN[WlanID]->S_WTP_BSS_List[m][n];
					if((check_bssid_func(BSSIndex))
						&&(AC_BSS[BSSIndex] != NULL)
					    &&(AC_BSS[BSSIndex]->WDSStat == WDS_SOME))
					{
						continue;
					}
					if((AC_BSS[BSSIndex] != NULL)&&(AC_WTP[m] != NULL))
					{											
						wid_set_bss_wds(m, n, WlanID, WLAN_WDS_ENABLE);
						AC_BSS[BSSIndex]->WDSStat = WDS_ANY;
					}
				}			
			}
		}
	}
	
	AC_WLAN[WlanID]->WDSStat = 1;

	return 0;
}



unsigned int wid_enable_wlan_load_config(wlan_t WlanID)
{
	unsigned int IGNORE_UBSV bssindex = 0;
	unsigned int wtpid = 0, l_radioid = 0;

	WID_CHECK_WLAN_EXIST_RET(WlanID, WLAN_ID_NOT_EXIST);
	
	if (NULL == AC_WLAN[WlanID]->Wlan_Ifi)
	{
		return INTERFACE_NOT_BE_BINDED;
	}


	if(AC_WLAN[WlanID]->Status == 0)
	{
		return 0;
	}

	for (wtpid = 0; wtpid < WTP_NUM; wtpid++)
	{
		if((NULL == AC_WTP[wtpid]) || (1 != AC_WTP[wtpid]->isused))
		{
			continue;
		}
		
		for(l_radioid = 0; l_radioid < AC_WTP[wtpid]->RadioCount; l_radioid++)
		{
			/*			
			if((AC_WTP[wtpid]->WTP_Radio[l_radio_id]->isBinddingWlan == 1)&&(AC_WTP[wtpid]->CMD->radiowlanid[l_radio_id][WlanID]==0))
			*/
			if (1 != AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan)
				
			{
				continue;
			}

			struct ifi *wlan_ifi = AC_WLAN[WlanID]->Wlan_Ifi;
			while (wlan_ifi != NULL)
			{
				if(AC_WTP[wtpid]->BindingSystemIndex == wlan_ifi->ifi_index)
				{
					break;
				}
				wlan_ifi = wlan_ifi->ifi_next;
			}
			
			if(wlan_ifi == NULL)
			{
				continue;
			}

			/*
			if(AC_WTP[wtpid]->WTP_Radio[l_radio_id]->isBinddingWlan == 1)
			*/
			if (1 != AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan)
			{
				continue;
			}
			
			struct wlanid *wlan_id = AC_WTP[wtpid]->WTP_Radio[l_radioid]->Wlan_Id;
			while (wlan_id != NULL)
			{	
				if (wlan_id->wlanid == WlanID)
				{
					break;
				}
				wlan_id = wlan_id->next;
			}

			if (NULL == wlan_id)
			{
				continue;
			}
			
			if (wlan_id != NULL)
			{
				bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[wtpid][l_radioid];
			}

			/*
			if((check_bssid_func(AC_WLAN[WlanID]->S_WTP_BSS_List[wtpid][l_radio_id]))
				&&(AC_BSS[(AC_WLAN[WlanID]->S_WTP_BSS_List[wtpid][n])]->WDSStat == WDS_ANY))
			{} else {}
			*/

			/*
			if((check_bssid_func(bssindex))&&(AC_BSS[bssindex]!=NULL)
				&& (AC_BSS[bssindex]->wsm_sta_info_reportswitch == 1))
			{}
			*/

			/*
			sprintf(ath_str,"ath.%d-%d",n,WlanID);
			sprintf(command,"ifconfig %s down;iwpriv %s inact %u;ifconfig %s up",ath_str,ath_str,AC_WLAN[WlanID]->ap_max_inactivity,ath_str);
			*/
			
			/*
			int type = 1;//manual
			int flag = 1;//enable
			if(gtrapflag>=4)
			{
				wid_dbus_trap_ap_ath_error(wtpid,n,WlanID,type,flag);
			}
			*/
				
			/*
			send eap switch & mac to ap ,zhangshu add 2010-10-22
			if((AC_WLAN[WlanID]->eap_mac_switch==1)
				&&(AC_WLAN[WlanID]->wlan_if_policy==NO_INTERFACE)
				&&(AC_BSS[bssindex]!=NULL)&&(AC_BSS[bssindex]->BSS_IF_POLICY==NO_INTERFACE))
			else
			*/

			/* wlan tunnel switch func for REQUIREMENTS-264
				sprintf(apcmd,"echo 3 > /proc/sys/net/ath.%d-%d/vap_splitmac",n,WlanID);
				wid_radio_set_extension_command(m,apcmd);
			*/

			/*
			if(AC_BSS[bssindex]->traffic_limit_able == 1)
			if(AC_BSS[bssindex]->limit_sta_rssi != 0)
			if(AC_BSS[bssindex]->multi_user_optimize_switch == 1)
			*/
			
			/*
			wid_radio_set_mixed_puren_switch(AC_WTP[m]->WTP_Radio[n]->Radio_G_ID);
			*/
			
			/*
			setWtpUniMutiBroCastIsolation(wtpid,l_radioid,WlanID,pcy);
			*/
				
			/*
			setWtpNoRespToStaProReq(m,l_radioid,WlanID,AC_BSS[(AC_WLAN[WlanID]->S_WTP_BSS_List[wtpid][n])]->noResToStaProReqSW);
			*/

			/*
			setWtpUniMutiBroCastRate(wtpid,l_radioid,WlanID,AC_BSS[(AC_WLAN[WlanID]->S_WTP_BSS_List[wtpid][n])]->muti_rate);
			*/

			/*
			if ((0 != AC_WLAN[WlanID]->aclgrp_id) 
				&& (NULL != STA_ACL_GROUP[AC_WLAN[WlanID]->aclgrp_id]))
			*/

			/*
			WID_RADIO_WLAN_PACKET_POWER(wtpid, l_radioid, WlanID, AC_BSS[(AC_WLAN[WlanID]->S_WTP_BSS_List[wtpid][n])]->packet_power);
			*/

			if (0 != memcmp(QOS_AP_11E_TO_1P_DEFAULT, AC_WLAN[WlanID]->qos_ap_11e_to_1p, MAX_QOS_11E_VAL+1))
			{
				set_ap_bss_qos_map_default(wtpid, l_radioid, QOS_MAP_11E_TO_1P, WlanID);
			}
			if (0 != memcmp(QOS_AP_11E_TO_DSCP_DEFAULT, AC_WLAN[WlanID]->qos_ap_11e_to_dscp, MAX_QOS_11E_VAL+1))
			{
				set_ap_bss_qos_map_default(wtpid, l_radioid, QOS_MAP_11E_TO_DSCP, WlanID);
			}
			if (0 != memcmp(QOS_AP_DSCP_TO_11E_DEFAULT, AC_WLAN[WlanID]->qos_ap_dscp_to_11e, MAX_QOS_DSCP_VAL+1))
			{
				set_ap_bss_qos_map_default(wtpid, l_radioid, QOS_MAP_DSCP_TO_11E, WlanID);
			}
			if (0 != memcmp(QOS_AP_1P_TO_11E_DEFAULT, AC_WLAN[WlanID]->qos_ap_1p_to_11e, MAX_QOS_1P_VAL+1))
			{
				set_ap_bss_qos_map_default(wtpid, l_radioid, QOS_MAP_1P_TO_11E, WlanID);
			}
			if (0 != AC_WLAN[WlanID]->qos_ap_11e_to_1p_switch)
			{
				set_ap_bss_qos_map_switch(wtpid, l_radioid, WlanID, QOS_MAP_11E_TO_1P, AC_WLAN[WlanID]->qos_ap_11e_to_1p_switch);
			}
			if (0 != AC_WLAN[WlanID]->qos_ap_11e_to_dscp_switch)
			{
				set_ap_bss_qos_map_switch(wtpid, l_radioid, WlanID, QOS_MAP_11E_TO_DSCP, AC_WLAN[WlanID]->qos_ap_11e_to_dscp_switch);
			}
			if (0 != AC_WLAN[WlanID]->balance_switch)
			{											
				wid_bss_balance_switch(wtpid, l_radioid, WlanID);										
			}
		}
	}

	return 0;
}


int WID_ENABLE_WLAN(unsigned char WlanID)
{
	unsigned int groupid = 0;		
	unsigned char policy = 0;
	WTPQUITREASON quitreason = WTP_INIT;
	msgq msg;
	struct msgqlist *elem = NULL;
	unsigned int bssindex = 0;	
	//char buf[DEFAULT_LEN] = {0};
	//struct wds_bssid *wds = NULL;
	//unsigned char pcy = 0;
	//msgq msg2;
	//struct msgqlist *elem2 = NULL;
	unsigned int bind_wlan = 0;
	//msgq msg4 ;
	//struct msgqlist *elem4 = NULL; 
	//char *command = NULL;
	//char *ath_str = NULL;
	unsigned char IGNORE_UBSV aclgroupid = 0;
	
	if (AC_WLAN[WlanID]->Wlan_Ifi == NULL)
	{
		wid_syslog_warning("<warning>%s-%d wlan%d INTERFACE_NOT_BE_BINDED\n",__func__,__LINE__,WlanID);
		//return INTERFACE_NOT_BE_BINDED;
	}
	
	if (AC_WLAN[WlanID]->Status == 0)
	{
		return 0;
	}
	
	if (AC_WLAN[WlanID]->wlan_if_policy != NO_INTERFACE)
	{
		int ret = -1;
		int i = 0, j = 0;
		char ifiname[ETH_IF_NAME_LEN-1];
		memset(ifiname, 0, ETH_IF_NAME_LEN-1);
		
		if (AC_WLAN[WlanID]->wlan_if_policy == WLAN_INTERFACE)
		{
			//snprintf(ifiname,ETH_IF_NAME_LEN,"WLAN%d",WlanID);
			if(local)
			{
				snprintf(ifiname,ETH_IF_NAME_LEN-1,"wlanl%d-%d-%d",slotid,vrrid,WlanID);
			}
			else
			{
				snprintf(ifiname,ETH_IF_NAME_LEN-1,"wlan%d-%d-%d",slotid,vrrid,WlanID);				
			}
			
			ret = Check_Interface_Config(ifiname,&quitreason);
			if (ret != 0)
			{
				return L3_INTERFACE_ERROR;
			}
		}
		else if (AC_WLAN[WlanID]->wlan_if_policy == BSS_INTERFACE)
		{
			for (i = 0; i < WTP_NUM; i++)
			{
				if ((AC_WTP[i] != NULL) && (AC_WTP[i]->isused == 1))
				{
					for (j = 0; j < AC_WTP[i]->RadioCount; j++)
					{
						if (AC_WLAN[WlanID]->S_WTP_BSS_List[i][j] != 0)
						{
							int bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[i][j];
							int wtpid = (bssindex/L_BSS_NUM)/L_RADIO_NUM;
							int radioid = j;
						
							memset(ifiname,0,ETH_IF_NAME_LEN-1);
							//snprintf(ifiname,ETH_IF_NAME_LEN,"BSS%d",AC_WLAN[WlanID]->S_WTP_BSS_List[i][j]);
							//snprintf(ifiname,ETH_IF_NAME_LEN,"radio%d-%d-%d.%d",vrrid,wtpid,radioid,WlanID);
							if (local)
                            {
								snprintf(ifiname,ETH_IF_NAME_LEN - 1,"r%d-%d-%d.%d",vrrid,wtpid,radioid,WlanID);
                            }
							else
                            {     
								snprintf(ifiname,ETH_IF_NAME_LEN - 1,"r%d-%d-%d-%d.%d",slotid,vrrid,wtpid,radioid,WlanID);
                            }
                            
							ret = Check_Interface_Config(ifiname,&quitreason);
							if (ret != 0)
							{
								return L3_INTERFACE_ERROR;
							}
						}
					}
				}
			}
		}
		else
		{
			wid_syslog_debug_debug(WID_DEFAULT, WAI_FUNC_LINE_FMT"can not present but i am not sure\n", WAI_FUNC_LINE_LITERAL);
		}
	}
	else//local mode to put wlan-vlan to bss
	{
		int i = 0, j = 0;
		for (i = 0; i < WTP_NUM; i++)
		{
			/*if((AC_WTP[i]!=NULL)&&(AC_WTP[i]->isused == 1))*/
			if (AC_WTP[i] != NULL)
			{
				for (j = 0; j < AC_WTP[i]->RadioCount; j++)
				{
					if (AC_WLAN[WlanID]->S_WTP_BSS_List[i][j] != 0)
					{
						int bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[i][j];
						if ((check_bssid_func(bssindex)) && (AC_BSS[bssindex]))
						{
							AC_BSS[bssindex]->wlan_vlanid = AC_WLAN[WlanID]->vlanid;
						}
					}
				}
			}
		}
		//printf("put wlan vlan to the bss\n");
	}
	//check wep wlan 
	if ((AC_WLAN[WlanID]->EncryptionType == WEP) && (AC_WLAN[WlanID]->SecurityType != IEEE8021X))
	{
		int i = 0, j = 0, i1 = 0;

		wid_syslog_debug_debug(WID_DEFAULT,"%s: wlan%d EncryptionType %d\n",__func__,WlanID,AC_WLAN[WlanID]->EncryptionType);
		
		for (i = 0; i < WTP_NUM; i++)
		{			
			if ((AC_WTP[i] != NULL) && (AC_WTP[i]->isused == 1))
			{
				for (j = 0; j < AC_WTP[i]->RadioCount; j++)//zhanglei change L_RADIO_NUM to AC_WTP[i]->RadioCount
				{
					if (AC_WLAN[WlanID]->S_WTP_BSS_List[i][j] != 0)
					{
						int bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[i][j];
						
						if ((check_bssid_func(bssindex))/*&&(AC_BSS[bssindex]->keyindex == 0)*/)//wlan is wep but bss is not,so put wep keyindex to the bss
						{	
							//
							for (i1 = 0; i1 < WTP_WEP_NUM; i1++)
							{	
								if (AC_RADIO[AC_BSS[bssindex]->Radio_G_ID]->wep_flag[i1] != 0)
								{
									if ((AC_WLAN[WlanID]->SecurityIndex == AC_BSS[AC_RADIO[AC_BSS[bssindex]->Radio_G_ID]->wep_flag[i1]]->keyindex)
									    && (bssindex != AC_RADIO[AC_BSS[bssindex]->Radio_G_ID]->wep_flag[i1]))
									{
										return SECURITYINDEX_IS_SAME;
									}	
								}
								if (AC_RADIO[AC_BSS[bssindex]->Radio_G_ID]->wep_flag[i1] == bssindex)
								{
									AC_RADIO[AC_BSS[bssindex]->Radio_G_ID]->wep_flag[i1] = 0;
									AC_BSS[bssindex]->keyindex = 0;	
								}
							}
							
							i1 = AC_WLAN[WlanID]->SecurityIndex-1;
							if (i1 < WTP_WEP_NUM)
							{
								if (AC_RADIO[AC_BSS[bssindex]->Radio_G_ID]->wep_flag[i1] == 0)
								{
									AC_RADIO[AC_BSS[bssindex]->Radio_G_ID]->wep_flag[i1] = bssindex;
									AC_BSS[bssindex]->keyindex = AC_WLAN[WlanID]->SecurityIndex;
									break;
								}
								if (i1 == WTP_WEP_NUM-1)//no room to put wep wlan
								{
									//not process , when add wlan just to avoid add this bss
								}
							}
							//
						}
						//fengwenchao change end
					}
				}
			}
		}
	}
	else//wlan is not wep
	{
		int i = 0, j = 0, i1 = 0;
		for (i = 0; i < WTP_NUM; i++)
		{
			if ((AC_WTP[i] != NULL) && (AC_WTP[i]->isused == 1))
			{
				for (j = 0; j < AC_WTP[i]->RadioCount; j++)//zhanglei change L_RADIO_NUM to AC_WTP[i]->RadioCount
				{
					if (AC_WLAN[WlanID]->S_WTP_BSS_List[i][j] != 0)
					{
						int bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[i][j];

						if ((check_bssid_func(bssindex)) && (AC_BSS[bssindex]->keyindex != 0))//wlan is none but bss is wep,so remove the bss key index
						{
							for (i1 = 0; i1 < WTP_WEP_NUM; i1++)
							{
								if (AC_RADIO[AC_BSS[bssindex]->Radio_G_ID]->wep_flag[i1] == bssindex)
								{
									AC_RADIO[AC_BSS[bssindex]->Radio_G_ID]->wep_flag[i1] = 0;
									AC_BSS[bssindex]->keyindex = 0;
									break;
								}
							}
						}
					}
				}
			}
		}
	}
	
	int m = 0, n = 0;
	wid_syslog_debug_debug(WID_DEFAULT, WAI_FUNC_LINE_FMT"create wlan%d %s\n", WAI_FUNC_LINE_LITERAL, WlanID, AC_WLAN[WlanID]->ESSID);
	
	for (m = 0; m < WTP_NUM; m++)
	{
		if ((AC_WTP[m] != NULL) && (AC_WTP[m]->isused == 1))
		{
			wid_syslog_debug_debug(WID_DEFAULT, WAI_FUNC_LINE_FMT"wtp%d binding index is %d\n",WAI_FUNC_LINE_LITERAL,m,AC_WTP[m]->BindingSystemIndex);
            
#ifdef _CheckBindingIf_
			if (AC_WLAN[WlanID]->Wlan_Ifi != NULL)//default Wlan_Ifi equal NULL
			{
				struct ifi *wlan_ifi = AC_WLAN[WlanID]->Wlan_Ifi;
				while (wlan_ifi != NULL)
				{
					wid_syslog_debug_debug(WID_DEFAULT,WAI_FUNC_LINE_FMT"wlan%d index is %d\n",WAI_FUNC_LINE_LITERAL,WlanID,wlan_ifi->ifi_index);
					if (AC_WTP[m]->BindingSystemIndex == wlan_ifi->ifi_index)
					{
						break;
					}
					wlan_ifi = wlan_ifi->ifi_next;
				}
				
				if (wlan_ifi == NULL)
				{
					wid_syslog_debug_debug(WID_DEFAULT,"%s: wtp%d binding interface doesn't match with wlan%d binding interface\n",__func__,m,WlanID);
					continue;
				}
				else
#else
			{
#endif
				{
					//AC_WTP[m]->CMD->wlanCMD += 1;
					//AC_WTP[m]->CMD->wlanid[WlanID] = 1;
					
					int apbind = 0;
					int ret = 0;
					ret = CONFIG_WLAN_CHECK_APPLY_WTP(m, WlanID);
					if (ret == 0)
					{
						apbind = 1;
						issued_wlan_enable(m, 0, WlanID, LEVEL_AP);
					}
					
					for (n = 0; n < AC_WTP[m]->RadioCount; n++)
					{
						if ((AC_WTP[m]->WTP_Radio[n]->isBinddingWlan == 1)
							&& (AC_WTP[m]->CMD->radiowlanid[n][WlanID] == 0))
						{
							if (AC_WTP[m]->WTP_Radio[n]->isBinddingWlan == 1)
							{
								struct wlanid *wlan_id = AC_WTP[m]->WTP_Radio[n]->Wlan_Id;
								while (wlan_id != NULL)
								{
									if (wlan_id->wlanid == WlanID)
									{
										break;
									}
									wlan_id = wlan_id->next;
								}
								if (wlan_id == NULL)
                                {
                                    continue;
                                }

                                bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[m][n];
                                
								WID_WTP_SSID_KEY_CONFLICT(AC_WTP[m]->WTP_Radio[n]->Radio_G_ID,WlanID);
								if ((AC_WLAN[WlanID]->EncryptionType == WEP) && (AC_WLAN[WlanID]->SecurityType != IEEE8021X))   /*fengwenchao modify 20110309 802.1x*/
								{
									if ((check_bssid_func(bssindex)) && (AC_BSS[bssindex]->keyindex == 0))
									{
										wid_syslog_debug_debug(WID_DEFAULT,"wlan is wep ,but no room to put bss %d to the wep bss,so not add this bss\n",bssindex);
										break;
									}
								}
								if (apbind)
								{
									if (AC_BSS[bssindex] != NULL)
                            		{
                            			AC_BSS[bssindex]->keyindex = AC_WLAN[WlanID]->SecurityIndex;
                            		}
                            	}	
                        		else
                        		{
                                    issued_wlan_enable(m, n, WlanID, LEVEL_RADIO);
                        		}
								
								//wei chao add flow check 2011.11.03								
								/*if((AC_WLAN[WlanID]->SecurityType == IEEE8021X)
									||(AC_WLAN[WlanID]->SecurityType == WPA_E)
									||(AC_WLAN[WlanID]->SecurityType == WPA2_E)
									||(AC_WLAN[WlanID]->SecurityType == MD5))
								{
									msgq msg3;
									struct msgqlist *elem3 = NULL;
									msg3.mqid = m%THREAD_NUM+1;
									msg3.mqinfo.WTPID = m;
									msg3.mqinfo.type = CONTROL_TYPE;
									msg3.mqinfo.subtype = WTP_S_TYPE;
									msg3.mqinfo.u.WtpInfo.Wtp_Op = WTP_FLOW_CHECK;
									msg3.mqinfo.u.WlanInfo.WLANID = WlanID;
									msg3.mqinfo.u.WlanInfo.Radio_L_ID = n;
									msg3.mqinfo.u.WlanInfo.flow_check = AC_WLAN[WlanID]->flow_check;
									msg3.mqinfo.u.WlanInfo.no_flow_time = AC_WLAN[WlanID]->no_flow_time;
									msg3.mqinfo.u.WlanInfo.limit_flow = AC_WLAN[WlanID]->limit_flow;
									if(AC_WTP[m]->WTPStat == WID_RUN)
									{	
										if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg3, sizeof(msg.mqinfo), 0) == -1)
										{
											wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
										}
									}
									else
									{
										elem3 = (struct msgqlist*)malloc(sizeof(struct msgqlist));
										if(elem3 == NULL)
										{			
											wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
											return 0;
										}
								
										memset((char*)&(elem3->mqinfo), 0, sizeof(msgqdetail));
										elem3->next = NULL;
										memcpy((char*)&(elem3->mqinfo),(char*)&(msg3.mqinfo),sizeof(msg3.mqinfo));
										WID_INSERT_CONTROL_LIST(m, elem3);
									}
								}*/
								//weichao add 
								/*command = (char *)malloc(sizeof(char)*100);
								if(NULL == command)
								{							
									wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
									return 0;
								}
								memset(command,0,100);
								ath_str = (char *)malloc(sizeof(char)*20);
								if(NULL == ath_str)
								{
									wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
									CW_FREE_OBJECT(command);
									return 0;
								}
								memset(ath_str,0,20);
								memset(&msg4,0,sizeof(msg4));
								msg4.mqid = m%THREAD_NUM +1;
								msg4.mqinfo.WTPID = m;
								msg4.mqinfo.type = CONTROL_TYPE;
								msg4.mqinfo.subtype = WTP_S_TYPE;
								msg4.mqinfo.u.WtpInfo.Wtp_Op = WTP_EXTEND_CMD;
						
								sprintf(ath_str,"ath.%d-%d",n,WlanID);
								sprintf(command,"ifconfig %s down;iwpriv %s inact %u;ifconfig %s up",ath_str,ath_str,AC_WLAN[WlanID]->ap_max_inactivity,ath_str);
								memcpy(msg4.mqinfo.u.WtpInfo.value, command, strlen(command));
								wid_syslog_debug_debug(WID_DEFAULT,"the command is : %s\n",command);
							
								if(AC_WTP[m]->WTPStat == WID_RUN)
								{	
									if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg4, sizeof(msg4.mqinfo), 0) == -1)
									{
										wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
										perror("msgsnd");
									}
								}
								else
								{
									elem4 = (struct msgqlist*)malloc(sizeof(struct msgqlist));
									if(elem4 == NULL)
									{
										wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
										CW_FREE_OBJECT(command);
										CW_FREE_OBJECT(ath_str);
										return 0;
									}
									memset((char*)&(elem4->mqinfo), 0, sizeof(msgqdetail));
									elem4->next = NULL;
									memcpy((char*)&(elem4->mqinfo),(char*)&(msg4.mqinfo),sizeof(msg4.mqinfo));
									WID_INSERT_CONTROL_LIST(m, elem4);
								}
								
								CW_FREE_OBJECT(command);
								CW_FREE_OBJECT(ath_str);*/

								//add wds state info
							
								/*if((check_bssid_func(AC_WLAN[WlanID]->S_WTP_BSS_List[m][n]))
									&&(AC_BSS[(AC_WLAN[WlanID]->S_WTP_BSS_List[m][n])]->WDSStat == WDS_ANY))
								{
									msg2.mqid = m%THREAD_NUM +1;
									msg2.mqinfo.WTPID = m;
									msg2.mqinfo.type = CONTROL_TYPE;
									msg2.mqinfo.subtype = WDS_S_TYPE;
									msg2.mqinfo.u.WlanInfo.Wlan_Op = WLAN_WDS_ENABLE;
									msg2.mqinfo.u.WlanInfo.WLANID = WlanID;
									msg2.mqinfo.u.WlanInfo.Radio_L_ID = n;
								
									elem2 = (struct msgqlist*)malloc(sizeof(struct msgqlist));
									if(elem2 == NULL)
									{
										wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
										perror("malloc");
										return 0;
									}
									memset((char*)&(elem2->mqinfo), 0, sizeof(msgqdetail));
									elem2->next = NULL;
									memcpy((char*)&(elem2->mqinfo),(char*)&(msg2.mqinfo),sizeof(msg2.mqinfo));
									WID_INSERT_CONTROL_LIST(m, elem2);
								}
								else
								{
									bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[m][n];
									if((check_bssid_func(bssindex))&&(AC_BSS[bssindex] != NULL)
										&& (AC_BSS[bssindex]->WDSStat == WDS_SOME))
									{
										wds = AC_BSS[bssindex]->wds_bss_list;
										while(wds != NULL)
										{
											memset(buf,0,DEFAULT_LEN);
											sprintf(buf,"/usr/sbin/wds_add ath.%d-%d %02X:%02X:%02X:%02X:%02X:%02X\n",
													AC_BSS[bssindex]->Radio_L_ID,WlanID,wds->BSSID[0],wds->BSSID[1],
													wds->BSSID[2],wds->BSSID[3],wds->BSSID[4],wds->BSSID[5]);
//											printf("/usr/sbin/wds_add ath.%d-%d %02X:%02X:%02X:%02X:%02X:%02X\n",AC_BSS[bssindex]->Radio_L_ID,WlanID,wds->BSSID[0],wds->BSSID[1],wds->BSSID[2],wds->BSSID[3],wds->BSSID[4],wds->BSSID[5]);
											wid_radio_set_extension_command(m,buf);
											wds = wds->next;
										}
									}
								}*/
								if (gtrapflag >= 4)
								{
								#if NOSOFTAC
									int type = 1;//manual
									int flag = 1;//enable
									wid_dbus_trap_ap_ath_error(m,n,WlanID,type,flag);
								#endif
								}

							    /* send eap switch & mac to ap ,zhangshu add 2010-10-22 */
                            	/*char apcmd[WID_SYSTEM_CMD_LENTH];
                            	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);
                                bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[m][n];
                            	if((AC_WLAN[WlanID]->eap_mac_switch == 1)
									&&(AC_WLAN[WlanID]->wlan_if_policy == NO_INTERFACE)
									&&(AC_BSS[bssindex] != NULL)
									&&(AC_BSS[bssindex]->BSS_IF_POLICY == NO_INTERFACE))
                            	{
                        		    sprintf(apcmd,"set_eap_mac ath.%d-%d %s",n,WlanID,AC_WLAN[WlanID]->eap_mac);
                        		}
                        		else
                        		{
                        		    sprintf(apcmd,"set_eap_mac ath.%d-%d 0",n,WlanID);
                        		}
                            	wid_syslog_debug_debug(WID_DEFAULT,"Enable Wlan: set eap mac cmd %s\n",apcmd);
                            	wid_radio_set_extension_command(m,apcmd);*/
                            	/* end */

							    /* wlan tunnel switch func for REQUIREMENTS-264 */
                            	/*memset(apcmd,0,WID_SYSTEM_CMD_LENTH);

                            	if(AC_WLAN[WlanID]->wlan_tunnel_switch == 1)
                            	{
									//sprintf(apcmd,"echo 3 > /proc/sys/net/ath.%d-%d/vap_splitmac",n,WlanID);
									sprintf(apcmd,TUNNEL_SWITCH_CMD";"AP_OPEN_IPFORWARD";"AP_SPFAST_DOWM";"AP_SPFAST_UP,n,WlanID);
									wid_radio_set_extension_command(m,apcmd);
                        		}*/
                            	/* end */
                            	/*
                            	if((check_bssid_func(AC_WLAN[WlanID]->S_WTP_BSS_List[m][n]))
									&&(AC_BSS[(AC_WLAN[WlanID]->S_WTP_BSS_List[m][n])] != NULL))
                            	{
                            		bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[m][n];
                            		wid_syslog_debug_debug(WID_DEFAULT,"!@#$ AC_BSS[%d]->traffic_limit_able = %d\n",
															bssindex,AC_BSS[bssindex]->traffic_limit_able);
                            		if(AC_BSS[bssindex]->traffic_limit_able == 1)
									{
                            		    WID_Save_Traffic_Limit(bssindex, m);
                            		}
                            		AC_BSS[bssindex]->upcount++;//book add, 2011-1-25
                            	}*/
								/*fengwenchao add 20120220 for autelan-2841
                                if((AC_WTP[m]->WTP_Radio[n]->MixedGreenfield.Mixed_Greenfield != 0)
                                    &&((AC_WTP[m]->WTP_Radio[n]->Radio_Type != 10)&&(AC_WTP[m]->WTP_Radio[n]->Radio_Type !=12))) //fengwenchao modify 20120716 for autelan-3057
                                {
                                	wid_radio_set_mixed_puren_switch(AC_WTP[m]->WTP_Radio[n]->Radio_G_ID);
                                }
                                fengwenchao add end*/
								/*if(((AC_WTP[m]->WTP_Radio[n]->Radio_Type&IEEE80211_11N) == IEEE80211_11N)
									&&(AC_WTP[m]->WTP_Radio[n]->Radio_Type != 10)
									&& (AC_WTP[m]->WTP_Radio[n]->Radio_Type != 12))
								{
									unsigned int r = 0;
									for(r = 1; r < WLAN_NUM; r++)
									{
										if(AC_WTP[m]->WTP_Radio[n]->MixedGreenfield.Wlan_Mixed[r] != 0)
										{
											wid_radio_set_mixed_puren_switch(AC_WTP[m]->WTP_Radio[n]->Radio_G_ID, r);
										}
									}				   					
			    				}*/
								/*if((check_bssid_func(AC_WLAN[WlanID]->S_WTP_BSS_List[m][n]))
									&&((AC_BSS[(AC_WLAN[WlanID]->S_WTP_BSS_List[m][n])]->unicast_sw == 1)\
										||(AC_BSS[(AC_WLAN[WlanID]->S_WTP_BSS_List[m][n])]->muti_bro_cast_sw == 1)
										||(AC_BSS[(AC_WLAN[WlanID]->S_WTP_BSS_List[m][n])]->muti_rate != 10)))
								{
									bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[m][n];
									if((1 == AC_BSS[bssindex]->muti_bro_cast_sw)&&(1 == AC_BSS[bssindex]->unicast_sw))
									{
										pcy = 3;
									}
									else if(1 == AC_BSS[bssindex]->muti_bro_cast_sw)
									{
										pcy = 2;
									}
									else if(1 == AC_BSS[bssindex]->unicast_sw)
									{
										pcy = 1;
									}
									else
									{
										pcy = 0;
									}
									if(AC_BSS[bssindex]->wifi_sw == 1)
									{
										pcy = pcy|0x4;
									}
									else
									{
										pcy = pcy&~0x4;
									}
									setWtpUniMutiBroCastIsolation(m,n,WlanID,pcy);
									wid_syslog_debug_debug(WID_DBUS,"%s, %d, radio %d-%d wlan:%d bssindex %d.config save.\n",
															__func__,__LINE__,m,n,WlanID,(AC_WLAN[WlanID]->S_WTP_BSS_List[m][n]));
								}*/
								if ((check_bssid_func(AC_WLAN[WlanID]->S_WTP_BSS_List[m][n]))
									&& (AC_BSS[(AC_WLAN[WlanID]->S_WTP_BSS_List[m][n])]->noResToStaProReqSW == 1))
								{
									setWtpNoRespToStaProReq(m,n,WlanID,AC_BSS[(AC_WLAN[WlanID]->S_WTP_BSS_List[m][n])]->noResToStaProReqSW);
									wid_syslog_debug_debug(WID_DBUS,"%s,%d, radio%d-%d wlan %d bssindex %d.config save.\n",
															__func__,__LINE__,m,n,WlanID,(AC_WLAN[WlanID]->S_WTP_BSS_List[m][n]));
								}
								/*fengwenchao add 20120522 for autelan-2969*/
								if ((check_bssid_func(AC_WLAN[WlanID]->S_WTP_BSS_List[m][n]))
									&& (AC_BSS[(AC_WLAN[WlanID]->S_WTP_BSS_List[m][n])]->muti_rate != 10))
								{
									setWtpUniMutiBroCastRate(m,n,WlanID,AC_BSS[(AC_WLAN[WlanID]->S_WTP_BSS_List[m][n])]->muti_rate);
									wid_syslog_debug_debug(WID_DBUS,"%s,%d, radio%d-%d wlan %d bssindex %d.config save.\n",
															__func__,__LINE__,m,n,WlanID,(AC_WLAN[WlanID]->S_WTP_BSS_List[m][n]));
								}
								/*fengwenchao add end*/
								if (check_bssid_func(bssindex) && AC_BSS[bssindex]->multi_user_optimize_switch == 1)
								{		
									char wlanid =AC_BSS[bssindex]->WlanID;
									int radioid = AC_BSS[bssindex]->Radio_G_ID;
									muti_user_optimize_switch(wlanid,radioid,1);
								}
									
								if (0 != AC_WLAN[WlanID]->electronic_menu)
								{									
									elem = NULL;								
									memset((char*)&msg, 0, sizeof(msg));
									msg.mqid = m%THREAD_NUM+1;
									msg.mqinfo.WTPID = m;
									msg.mqinfo.type = CONTROL_TYPE;
									msg.mqinfo.subtype = WTP_S_TYPE;
									msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_ELECTRONIC_MENU;
									msg.mqinfo.u.WtpInfo.value[0] = WlanID;
									msg.mqinfo.u.WtpInfo.value[1] = n;
									msg.mqinfo.u.WtpInfo.value[2] = LEVEL_WLAN;
									msg.mqinfo.u.WtpInfo.value[3] = AC_WLAN[WlanID]->electronic_menu;
										
									if (WID_RUN == AC_WTP[m]->WTPStat)
									{	
										if (-1 == msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0))
										{
											wid_syslog_info("%s msgsend %s", __func__, strerror(errno));
										}
									}
									else
									{
										elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
										if (NULL == elem)
										{
											wid_syslog_info("%s malloc %s", __func__, strerror(errno));
											return 0;
										}
										memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
										elem->next = NULL;
										memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
										WID_INSERT_CONTROL_LIST(m, elem);									
									}
									wid_syslog_debug_debug(WID_DEFAULT, "%s wlan%d local-survival switch %d\n",
															__func__, WlanID, AC_WLAN[WlanID]->electronic_menu);
								}
								if (0 != AC_WLAN[WlanID]->macgroupID)
								{
									int i = 0;
									groupid = AC_WLAN[WlanID]->macgroupID;		
									policy = AC_WLAN[WlanID]->mac_grp_policy;									
									elem = NULL;								
									memset((char*)&msg, 0, sizeof(msg));
									msg.mqid = m%THREAD_NUM+1;
									msg.mqinfo.WTPID = m;
									msg.mqinfo.type = CONTROL_TYPE;
									msg.mqinfo.subtype = WTP_S_TYPE;
									msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_BLACK_WHITE_LIST;
									msg.mqinfo.u.WtpInfo.value[0] = WlanID;
									msg.mqinfo.u.WtpInfo.value[1] = n;
									msg.mqinfo.u.WtpInfo.value[2] = policy;
									msg.mqinfo.u.WtpInfo.value[3] = LEVEL_WLAN;
									msg.mqinfo.u.WtpInfo.value[4] = OVERWRITE;
									CWThreadMutexLock(&MAC_GROUP[groupid]->macListMutex);
									msg.mqinfo.u.WtpInfo.value[5] = MAC_GROUP[groupid]->count;
									MAC_list *maclist = MAC_GROUP[groupid]->macList;
									for (i = 0; (i < MAC_GROUP[groupid]->count) && (i < GROUP_MAC_COUNT); i++)
									{
										memcpy(msg.mqinfo.u.WtpInfo.macarry[i].mac, maclist->mac, sizeof(maclist->mac));
										maclist = maclist->next;
									}
									CWThreadMutexUnlock(&MAC_GROUP[groupid]->macListMutex);
										
									if (WID_RUN == AC_WTP[m]->WTPStat)
									{	
										if (-1 == msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0))
										{
											wid_syslog_info("%s msgsend %s", __func__, strerror(errno));
										}
									}
									else
									{
										elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
										if(NULL == elem)
										{
											wid_syslog_info("%s malloc %s", __func__, strerror(errno));
											return 0;
										}
										memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
										elem->next = NULL;
										memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
										WID_INSERT_CONTROL_LIST(m, elem);									
									}
									wid_syslog_debug_debug(WID_DEFAULT, "%s AC_WLAN[%d]->macgroupID %d\n",
															__func__, WlanID, AC_WLAN[WlanID]->macgroupID);
								}
								
								/*acl-group*/
								if ((0 != AC_WLAN[WlanID]->aclgrp_id) 
									&& (NULL != STA_ACL_GROUP[AC_WLAN[WlanID]->aclgrp_id]))
								{
									aclgroupid = AC_WLAN[WlanID]->aclgrp_id;
									memset((char*)&msg, 0, sizeof(msg));
									msg.mqid = m%THREAD_NUM+1;
									msg.mqinfo.WTPID = m;
									msg.mqinfo.type = CONTROL_TYPE;
									msg.mqinfo.subtype = WTP_S_TYPE;
									msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_ACL_LIST;
									msg.mqinfo.u.WtpInfo.value[0] = WlanID;
									msg.mqinfo.u.WtpInfo.value[1] = n;
									msg.mqinfo.u.WtpInfo.value[2] = OVERWRITE;
									msg.mqinfo.u.WtpInfo.value[3] = LEVEL_WLAN;
									msg.mqinfo.u.WtpInfo.value[4] = AC_WLAN[WlanID]->aclgrp_id;
			
									if(AC_WTP[m]->WTPStat == WID_RUN)
									{ 
										if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
										{
											wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
										}
									}
									else
									{
										elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
										if (NULL == elem)
										{
											WID_MALLOC_ERR();			
											return 0;
										}			
										memset(elem, 0, sizeof(struct msgqlist));
										
										elem->mqinfo.WTPID = m;
										elem->mqinfo.type = CONTROL_TYPE;
										elem->mqinfo.subtype = WTP_S_TYPE;
										elem->mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_ACL_LIST;
										elem->mqinfo.u.WtpInfo.value[0] = WlanID;
										elem->mqinfo.u.WtpInfo.value[1] = n;
										elem->mqinfo.u.WtpInfo.value[2] = OVERWRITE;
										elem->mqinfo.u.WtpInfo.value[3] = LEVEL_WLAN;
										elem->mqinfo.u.WtpInfo.value[4] = AC_WLAN[WlanID]->aclgrp_id;
								
										WID_INSERT_CONTROL_LIST(m, elem);
									}
								}
								
								if (check_bssid_func(bssindex) && AC_BSS[bssindex]->multi_user_optimize_switch == 1)
								{
									char wlanid =AC_BSS[bssindex]->WlanID;
									int radioid = AC_BSS[bssindex]->Radio_G_ID;
									muti_user_optimize_switch(wlanid,radioid,1);
								}
								if ((check_bssid_func(AC_WLAN[WlanID]->S_WTP_BSS_List[m][n]))
									&& (AC_BSS[(AC_WLAN[WlanID]->S_WTP_BSS_List[m][n])]->packet_power != 0))
								{
									WID_RADIO_WLAN_PACKET_POWER(m, n, WlanID, AC_BSS[(AC_WLAN[WlanID]->S_WTP_BSS_List[m][n])]->packet_power);
								}
    						}
    						
                            //wid_syslog_debug_debug("AC_WTP[%d]->CMD->wlanid[%d]:%d wlanCMD:%d\n",m,WlanID, AC_WTP[m]->CMD->wlanid[WlanID],AC_WTP[m]->CMD->wlanCMD);
    					}
    					
						for (bind_wlan = 0; bind_wlan < 8; bind_wlan++)
		    			{
							if (AC_WTP[m]->WTP_Radio[n]->cpe_intf[bind_wlan].vlan_count != 0)
		    				{
		    					wid_radio_set_cpe_channel(m,n,bind_wlan);
		    				}
		    			}
    				}
    			}

#if _CheckBindingIf_
			} //just for sourceinsight parse
#else
			}
#endif
    	}
    }
	wid_enable_wlan_load_config(WlanID);
		
	AC_WLAN[WlanID]->CMD = 0;	
	AC_WLAN[WlanID]->Status = 0;
#if NOSOFTAC
	AsdWsm_WLANOp(WlanID, WID_MODIFY, 0);
#endif
	return 0;
}


int WID_USED_WTP(unsigned int WtpID)
{
	int i = 0;
	unsigned int groupid = 0;		
	unsigned char policy = 0;
	WTPQUITREASON quitreason = WTP_INIT;	
	msgq msg;
	struct msgqlist *elem = NULL;	
	msgq msg2;
	struct msgqlist *elem2 = NULL;
	msgq msg4 ;
	struct msgqlist *elem4 = NULL;
	char *command = NULL;
	char *ath_str  = NULL;
	unsigned int bssindex = 0;	
	char buf[DEFAULT_LEN] = {0};
	struct wds_bssid *wds = NULL;
	unsigned char IGNORE_UBSV aclgroupid = 0;
	
	if ((AC_WTP[WtpID] != NULL) && (AC_WTP[WtpID]->isused == 0))
	{
		//AC_WTP[WtpID]->isused = 1;
		//AC_WTP[WtpID]->quitreason = WTP_NORMAL;
	}
	else
	{
		return 0;
	}
	if (AC_WTP[WtpID]->BindingSystemIndex == -1)
	{
		//return INTERFACE_NOT_BE_BINDED;
	}
	
	int j = 0, ret = 0, k = 0;
	unsigned char pcy = 0;
	char ifiname[ETH_IF_NAME_LEN] = {0};
	int check1 = 0, check2 = 0;
	
	CWThreadMutexLock(&(gWTPs[WtpID].WTPThreadControllistMutex));
	WID_CLEAN_CONTROL_LIST(WtpID);
	CWThreadMutexUnlock(&(gWTPs[WtpID].WTPThreadControllistMutex));
	
	for (j = 0; j < AC_WTP[WtpID]->RadioCount; j++)
	{
		for (k = 0; k < L_BSS_NUM; k++)
		{
			if (AC_WTP[WtpID]->WTP_Radio[j]->BSS[k] != NULL)
			{
				if (AC_WTP[WtpID]->WTP_Radio[j]->BSS[k]->BSS_IF_POLICY == NO_INTERFACE)
				{
					check1++;
				}
				else
				{
					check2++;
				}
				//if((check1 != 0)&&(check2 != 0))
					//return IF_POLICY_CONFLICT;
				if (AC_WTP[WtpID]->WTP_Radio[j]->BSS[k]->BSS_IF_POLICY == BSS_INTERFACE)
				{
					//assemble radio1-0.1
					memset(ifiname,0,ETH_IF_NAME_LEN);
					if (local)
						snprintf(ifiname,ETH_IF_NAME_LEN,"r%d-%d-%d.%d",vrrid,WtpID,j,AC_WTP[WtpID]->WTP_Radio[j]->BSS[k]->WlanID);
					else
						snprintf(ifiname,ETH_IF_NAME_LEN,"r%d-%d-%d-%d.%d",slotid,vrrid,WtpID,j,AC_WTP[WtpID]->WTP_Radio[j]->BSS[k]->WlanID);
					//memset(ifiname,0,ETH_IF_NAME_LEN);
					//snprintf(ifiname,ETH_IF_NAME_LEN,"BSS%d",AC_WTP[WtpID]->WTP_Radio[j]->BSS[k]->BSSIndex);
					ret = Check_Interface_Config(ifiname,&quitreason);
					
					if (ret != 0)
					{
						return L3_INTERFACE_ERROR;
					}
				}
				if (AC_WTP[WtpID]->WTP_Radio[j]->BSS[k]->BSS_IF_POLICY == WLAN_INTERFACE)
				{
					memset(ifiname,0,ETH_IF_NAME_LEN-1);
					if(local)
						snprintf(ifiname,ETH_IF_NAME_LEN-1,"wlanl%d-%d-%d",slotid,vrrid,AC_WTP[WtpID]->WTP_Radio[j]->BSS[k]->WlanID);
					else
						snprintf(ifiname,ETH_IF_NAME_LEN-1,"wlan%d-%d-%d",slotid,vrrid,AC_WTP[WtpID]->WTP_Radio[j]->BSS[k]->WlanID);
						
					ret = Check_Interface_Config(ifiname,&quitreason);
					
					if (ret != 0)
					{
						return L3_INTERFACE_ERROR;
					}
				}
			}
		}
		if (AC_WTP[WtpID]->WTP_Radio[j] != NULL)
		{
			if (AC_WTP[WtpID]->WTP_Radio[j]->auto_channel != 0)
			{
				memset(buf,0,DEFAULT_LEN);
				sprintf(buf,"echo 1 > /proc/sys/dev/wifi%d/nonoverlapping",j);
				wid_radio_set_extension_command(WtpID,buf);
			}

			if (AC_WTP[WtpID]->WTP_Radio[j]->REFlag == 1)
			{
				wid_wtp_radio_extern_command_check(WtpID,j);
			}
		}		
	}
	
	if (check1 != 0)
	{
		AC_WTP[WtpID]->tunnel_mode = CW_LOCAL_BRIDGING;
	}
	else if (check2 != 0)
	{
		AC_WTP[WtpID]->tunnel_mode = CW_802_DOT_11_TUNNEL;
	}

	AC_WTP[WtpID]->isused = 1;
	AC_WTP[WtpID]->quitreason = WTP_NORMAL;

	k = 0;
	int m = 0;
	AC_WTP[WtpID]->CMD->wlanCMD = 0;
	for (k = 0; k < WLAN_NUM; k++)
	{
		if ((AC_WLAN[k] == NULL) || (AC_WLAN[k]->Status == 1))
		{
			continue;
		}
#ifdef _CheckBindingIf_
		if (AC_WLAN[k]->Wlan_Ifi != NULL)
		{
			struct ifi *wlan_ifi = AC_WLAN[k]->Wlan_Ifi;
			while (wlan_ifi != NULL)
			{
				if (AC_WTP[WtpID]->BindingSystemIndex == wlan_ifi->ifi_index)
				{
					break;
				}
				wlan_ifi = wlan_ifi->ifi_next;
			}
			
			if (wlan_ifi == NULL)
			{
				continue;
			}
			else
#else
		{
#endif
			{
			    int wtp_bind_wlan = 0;
			    ret = CONFIG_WLAN_CHECK_APPLY_WTP(WtpID,k);
                if (ret == 0)
                {
                    wtp_bind_wlan = 1;
                    issued_wlan_enable(WtpID, 0, k, LEVEL_AP);
                }

        		for (m = 0; m < AC_WTP[WtpID]->RadioCount; m++)
        		{	
        			AC_WTP[WtpID]->CMD->radiowlanid[m][k] = 0;

					if (AC_WTP[WtpID]->WTP_Radio[m]->isBinddingWlan == 1)
					{
						struct wlanid *wlan_id = AC_WTP[WtpID]->WTP_Radio[m]->Wlan_Id;
						while (wlan_id != NULL)
						{	
							if (wlan_id->wlanid == k)
							{
								break;
							}
							wlan_id = wlan_id->next;
						}
						if (wlan_id != NULL)
						{
							if (0 == wtp_bind_wlan)
							{
								issued_wlan_enable(WtpID, m, k, LEVEL_RADIO);
							}
#if 0
							/*xm add 09.5.13*/
							if((AC_WLAN[wlan_id->wlanid] != NULL)&&(AC_WLAN[wlan_id->wlanid]->balance_switch == 1))
							{
								char *command=NULL;
								command = (char *)malloc(sizeof(char)*50);
								memset(command,0,50);
								strncpy(command,"echo 1 > /proc/sys/dev/wifi0/traffic_balance",44);
								set_balance_probe_extension_command(WtpID,command);
								free(command);
								command = NULL;
							}
#endif
							//add wds state
							if ((check_bssid_func(AC_WLAN[k]->S_WTP_BSS_List[WtpID][m]))
								&& (AC_BSS[(AC_WLAN[k]->S_WTP_BSS_List[WtpID][m])]->WDSStat == WDS_ANY))
							{
								msg2.mqid = WtpID%THREAD_NUM +1;
								msg2.mqinfo.WTPID = WtpID;
								msg2.mqinfo.type = CONTROL_TYPE;
								msg2.mqinfo.subtype = WDS_S_TYPE;
								msg2.mqinfo.u.WlanInfo.Wlan_Op = WLAN_WDS_ENABLE;
								msg2.mqinfo.u.WlanInfo.WLANID = k;
								msg2.mqinfo.u.WlanInfo.Radio_L_ID = m;
								
								elem2 = (struct msgqlist*)malloc(sizeof(struct msgqlist));
								if (elem2 == NULL)
								{
									return 0;
								}
								memset((char*)&(elem2->mqinfo), 0, sizeof(msgqdetail));
								elem2->next = NULL;
								memcpy((char*)&(elem2->mqinfo),(char*)&(msg2.mqinfo),sizeof(msg2.mqinfo));
								WID_INSERT_CONTROL_LIST(WtpID, elem2);
							}

							//added end	
							else
							{
								bssindex = AC_WLAN[k]->S_WTP_BSS_List[WtpID][m];
								if((check_bssid_func(bssindex))
									&& (AC_BSS[bssindex] != NULL) 
									&& (AC_BSS[bssindex]->WDSStat == WDS_SOME))
								{
									wds = AC_BSS[bssindex]->wds_bss_list;
									while(wds != NULL)
									{
										memset(buf,0,DEFAULT_LEN);
										sprintf(buf,"/usr/sbin/wds_add ath.%d-%d %02X:%02X:%02X:%02X:%02X:%02X\n",
												AC_BSS[bssindex]->Radio_L_ID,k,MAC2STR(wds->BSSID));
										wid_radio_set_extension_command(WtpID,buf);
										wds = wds->next;
									}
								}
							}
							//add local bss wlan l2 isolation
							if((check_bssid_func(AC_WLAN[k]->S_WTP_BSS_List[WtpID][m]))
								&&(AC_BSS[(AC_WLAN[k]->S_WTP_BSS_List[WtpID][m])]->ath_l2_isolation == 1))
							{
								bssindex = AC_WLAN[k]->S_WTP_BSS_List[WtpID][m];
								memset(buf,0,DEFAULT_LEN);
								sprintf(buf,"iwpriv ath.%d-%d ap_bridge 0\n",AC_BSS[bssindex]->Radio_L_ID,AC_BSS[bssindex]->WlanID);
								wid_radio_set_extension_command(WtpID,buf);
							}
							/*traffic limit*/
							if((check_bssid_func(AC_WLAN[k]->S_WTP_BSS_List[WtpID][m]))
								&&(AC_BSS[(AC_WLAN[k]->S_WTP_BSS_List[WtpID][m])]->traffic_limit_able == 1))
							{
//								unsigned int value = 0;
								bssindex = AC_WLAN[k]->S_WTP_BSS_List[WtpID][m];
								WID_Save_Traffic_Limit(bssindex, WtpID);
							#if 0
								if(AC_BSS[bssindex]->traffic_limit != 0)
								{
									value = AC_BSS[bssindex]->traffic_limit;
									memset(buf,0,DEFAULT_LEN);
									sprintf(buf,"autelan traffic_limit ath.%d-%d set_vap_flag 1;autelan traffic_limit ath.%d-%d set_vap %d",AC_BSS[bssindex]->Radio_L_ID
																																					,AC_BSS[bssindex]->WlanID
																																					,AC_BSS[bssindex]->Radio_L_ID
																																					,AC_BSS[bssindex]->WlanID
																																					,value);
									wid_syslog_debug_debug(WID_DEFAULT,"wid_set_bss_traffic_limit_value buf %s\n",buf);
									wid_radio_set_extension_command(WtpID,buf);
								}
			
								if(AC_BSS[bssindex]->average_rate != 0)
								{
									value = AC_BSS[bssindex]->average_rate;
									memset(buf,0,DEFAULT_LEN);
									sprintf(buf,"autelan traffic_limit ath.%d-%d set_every_node_flag 1;autelan traffic_limit ath.%d-%d set_every_node %d",AC_BSS[bssindex]->Radio_L_ID
																																					,AC_BSS[bssindex]->WlanID
																																					,AC_BSS[bssindex]->Radio_L_ID
																																					,AC_BSS[bssindex]->WlanID
																																					,value);
									wid_syslog_debug_debug(WID_DEFAULT,"wid_set_bss_traffic_limit_average_value buf %s\n",buf);
									wid_radio_set_extension_command(WtpID,buf);
								}

								if(AC_BSS[bssindex]->send_traffic_limit != 0)
								{
									value = AC_BSS[bssindex]->send_traffic_limit;
									memset(buf,0,DEFAULT_LEN);
									sprintf(buf,"autelan traffic_limit ath.%d-%d set_vap_flag 1;autelan traffic_limit ath.%d-%d set_vap_send %d",AC_BSS[bssindex]->Radio_L_ID
																																					,AC_BSS[bssindex]->WlanID
																																					,AC_BSS[bssindex]->Radio_L_ID
																																					,AC_BSS[bssindex]->WlanID
																																					,value);
									wid_syslog_debug_debug(WID_DEFAULT,"wid_set_bss_traffic_limit_send_value buf %s\n",buf);
									wid_radio_set_extension_command(WtpID,buf);
								}
			
								if(AC_BSS[bssindex]->send_average_rate != 0)
								{
									value = AC_BSS[bssindex]->send_average_rate;
									memset(buf,0,DEFAULT_LEN);
									sprintf(buf,"autelan traffic_limit ath.%d-%d set_every_node_flag 1;autelan traffic_limit ath.%d-%d set_every_node_send %d",AC_BSS[bssindex]->Radio_L_ID
																																					,AC_BSS[bssindex]->WlanID
																																					,AC_BSS[bssindex]->Radio_L_ID
																																					,AC_BSS[bssindex]->WlanID
																																					,value);
									wid_syslog_debug_debug(WID_DEFAULT,"wid_set_bss_traffic_limit_average_send_value buf %s\n",buf);
									wid_radio_set_extension_command(WtpID,buf);
								}
							#endif
							}

							/*ip mac binding*/
							if((check_bssid_func(AC_WLAN[k]->S_WTP_BSS_List[WtpID][m]))
								&&(AC_BSS[(AC_WLAN[k]->S_WTP_BSS_List[WtpID][m])]->ip_mac_binding == 1)) //fengwenchao add "check_bssid_func" for onlinebug-288,20120517
							{
								memset(buf,0,DEFAULT_LEN);
								bssindex = AC_WLAN[k]->S_WTP_BSS_List[WtpID][m]; //fengwenchao add 20120517 for autelan-2970
								sprintf(buf,"/usr/sbin/set_ip_enable ath.%d-%d %d",
										AC_BSS[bssindex]->Radio_L_ID,AC_BSS[bssindex]->WlanID,1);
								
								wid_radio_set_extension_command(WtpID,buf);
							}
							if((check_bssid_func(AC_WLAN[k]->S_WTP_BSS_List[WtpID][m]))
								&&((AC_BSS[(AC_WLAN[k]->S_WTP_BSS_List[WtpID][m])]->unicast_sw == 1)
									||(AC_BSS[(AC_WLAN[k]->S_WTP_BSS_List[WtpID][m])]->muti_bro_cast_sw == 1)
									||(AC_BSS[(AC_WLAN[k]->S_WTP_BSS_List[WtpID][m])]->muti_rate != 10)))
							{

								if((1 == AC_BSS[bssindex]->muti_bro_cast_sw)&&(1 == AC_BSS[bssindex]->unicast_sw))
								{
									pcy = 3;
								}
								else if(1 == AC_BSS[bssindex]->muti_bro_cast_sw)
								{
									pcy = 2;
								}
								else if(1 == AC_BSS[bssindex]->unicast_sw)
								{
									pcy = 1;
								}
								else
								{
									pcy = 0;
								}
								if(AC_BSS[bssindex]->wifi_sw == 1)
								{
									pcy = pcy|0x4;
								}
								else
								{
									pcy = pcy&~0x4;
								}
								ret = setWtpUniMutiBroCastIsolation(WtpID,m,k,pcy);
							}
							if((check_bssid_func(AC_WLAN[k]->S_WTP_BSS_List[WtpID][m]))
								&&(AC_BSS[(AC_WLAN[k]->S_WTP_BSS_List[WtpID][m])]->noResToStaProReqSW == 1))
							{
								ret = setWtpNoRespToStaProReq(WtpID,m,k,AC_BSS[(AC_WLAN[k]->S_WTP_BSS_List[WtpID][m])]->noResToStaProReqSW);
							}
							/*fengwenchao add 20120522 for autelan-2969*/
							if((check_bssid_func(AC_WLAN[k]->S_WTP_BSS_List[WtpID][m]))
								&&(AC_BSS[(AC_WLAN[k]->S_WTP_BSS_List[WtpID][m])]->muti_rate != 10))
							{
								setWtpUniMutiBroCastRate(WtpID,m,k,AC_BSS[(AC_WLAN[k]->S_WTP_BSS_List[WtpID][m])]->muti_rate);
							}
							/*fengwenchao add end*/		
							
							if((AC_WLAN[k]->SecurityType == IEEE8021X)
								||(AC_WLAN[k]->SecurityType == WPA_E)
								||(AC_WLAN[k]->SecurityType == WPA2_E)
								||(AC_WLAN[k]->SecurityType == MD5))
							{
								msgq msg3;
								struct msgqlist *elem3 = NULL;
								
								msg3.mqid = WtpID%THREAD_NUM +1;
								msg3.mqinfo.WTPID = WtpID;			
								msg3.mqinfo.type = CONTROL_TYPE;
								msg3.mqinfo.subtype = WTP_S_TYPE;
								msg3.mqinfo.u.WtpInfo.Wtp_Op = WTP_FLOW_CHECK;
								msg3.mqinfo.u.WlanInfo.WLANID = k;
								msg3.mqinfo.u.WlanInfo.Radio_L_ID = m;
								msg3.mqinfo.u.WlanInfo.flow_check = AC_WLAN[k]->flow_check;
								msg3.mqinfo.u.WlanInfo.no_flow_time = AC_WLAN[k]->no_flow_time;
								msg3.mqinfo.u.WlanInfo.limit_flow = AC_WLAN[k]->limit_flow;
								 
								elem3 = (struct msgqlist*)malloc(sizeof(struct msgqlist));
								if(elem3 == NULL)
								{			
									wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
									return 0;
								}
								
								memset((char*)&(elem3->mqinfo), 0, sizeof(msgqdetail));
								elem3->next = NULL;
								memcpy((char*)&(elem3->mqinfo),(char*)&(msg3.mqinfo),sizeof(msg3.mqinfo));
								WID_INSERT_CONTROL_LIST(WtpID, elem3);
							}
							
							if(AC_WLAN[k]->Status == 0)
							{
								command = (char *)malloc(sizeof(char)*100);
								if(NULL == command)
								{							
									wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
									return 0;
								}
								ath_str = (char *)malloc(sizeof(char)*20);
								if(NULL == ath_str)
								{
									wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
		                            CW_FREE_OBJECT(command);
									return 0;
								}
								memset(command,0,100);
								memset(ath_str,0,20);
								memset(&msg4,0,sizeof(msg4));
								msg4.mqid = WtpID%THREAD_NUM +1;
								msg4.mqinfo.WTPID = WtpID;			
								msg4.mqinfo.type = CONTROL_TYPE;
								msg4.mqinfo.subtype = WTP_S_TYPE;
								msg4.mqinfo.u.WtpInfo.Wtp_Op = WTP_EXTEND_CMD;
								
								sprintf(ath_str,"ath.%d-%d",m,k);
								sprintf(command,"ifconfig %s down;iwpriv %s inact %u;ifconfig %s up",ath_str,ath_str,AC_WLAN[k]->ap_max_inactivity,ath_str);
								memcpy(msg4.mqinfo.u.WtpInfo.value, command, strlen(command));
							
								elem4 = (struct msgqlist*)malloc(sizeof(struct msgqlist));
								if(elem4 == NULL)
								{			
									wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
		                            CW_FREE_OBJECT(command);
		    						CW_FREE_OBJECT(ath_str);
									return 0;
								}
						
								memset((char*)&(elem4->mqinfo), 0, sizeof(msgqdetail));
								elem4->next = NULL;
								memcpy((char*)&(elem4->mqinfo),(char*)&(msg4.mqinfo),sizeof(msg4.mqinfo));
								WID_INSERT_CONTROL_LIST(WtpID, elem4);
								CW_FREE_OBJECT(command);
								CW_FREE_OBJECT(ath_str);
							}
							/* send eap switch & mac to ap,zhangshu add 2010-10-22 */
                        	char apcmd[WID_SYSTEM_CMD_LENTH];
                        	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);
                            bssindex = AC_WLAN[k]->S_WTP_BSS_List[WtpID][m];
                        	if((AC_WLAN[k]->eap_mac_switch == 1)
								&&(AC_WLAN[k]->wlan_if_policy == NO_INTERFACE)
								&&(AC_BSS[bssindex] != NULL)
								&&(AC_BSS[bssindex]->BSS_IF_POLICY == NO_INTERFACE))
                        	{
                        	    sprintf(apcmd,"set_eap_mac ath.%d-%d %s",m,k,AC_WLAN[k]->eap_mac);
                        	}
                        	else
                        	{
                        	    sprintf(apcmd,"set_eap_mac ath.%d-%d 0",m,k);
                        	}
							
							/* wlan tunnel switch func for REQUIREMENTS-264 */
							memset(apcmd, 0, WID_SYSTEM_CMD_LENTH);
							if ((AC_WLAN[k] != NULL)
								&& (AC_WLAN[k]->wlan_tunnel_switch == 1))
							{
								//sprintf(apcmd, "echo 3 > /proc/sys/net/ath.%d-%d/vap_splitmac",m, k);
								sprintf(apcmd,TUNNEL_SWITCH_CMD";"AP_OPEN_IPFORWARD";"AP_SPFAST_DOWM";"AP_SPFAST_UP,m, k);
								wid_radio_set_extension_command(WtpID, apcmd);
							}
							
							if ((AC_WLAN[k] != NULL)
								&&(check_bssid_func(AC_WLAN[k]->S_WTP_BSS_List[WtpID][m]))
								&&(0 != AC_WLAN[k]->balance_switch))
							{											
								wid_bss_balance_switch(WtpID, m, k);										
							}
                        	
							if((AC_BSS[bssindex])&&(AC_BSS[bssindex]->multi_user_optimize_switch == 1))
							{
								char wlanid =AC_BSS[bssindex]->WlanID;
								int radioid = AC_BSS[bssindex]->Radio_G_ID;
								muti_user_optimize_switch(wlanid,radioid,1);
								
							}
                        	wid_radio_set_extension_command(WtpID,apcmd);
                        	/* end */
							int bssindex = AC_WLAN[k]->S_WTP_BSS_List[WtpID][m];
							if((AC_BSS[bssindex])
								&&(AC_BSS[bssindex]->BSS_IF_POLICY != NO_INTERFACE)
								&&(AC_BSS[bssindex]->BSS_TUNNEL_POLICY != CW_802_DOT_11_TUNNEL))
							{
								msgq msg;
								struct msgqlist *elem = NULL;
								memset((char*)&msg, 0, sizeof(msg));
								msg.mqid = WtpID%THREAD_NUM+1;
								msg.mqinfo.WTPID = WtpID;
								msg.mqinfo.type = CONTROL_TYPE;
								msg.mqinfo.subtype = WLAN_S_TYPE;
								msg.mqinfo.u.WlanInfo.Wlan_Op = WLAN_CHANGE_TUNNEL;
								msg.mqinfo.u.WlanInfo.WLANID = k;
								msg.mqinfo.u.WlanInfo.Radio_L_ID = m;
								msg.mqinfo.u.WlanInfo.bssindex = AC_WLAN[k]->S_WTP_BSS_List[WtpID][m];
								
								if((AC_WTP[WtpID]->WTPStat == WID_RUN))
								{ 
									if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
									{
										wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
									}
								}
								else
								{
									elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
									if(NULL == elem)
									{
										wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
										return 0;
									}
									memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
									elem->next = NULL;
									memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
									WID_INSERT_CONTROL_LIST(WtpID, elem);
								}
							}
							
							if ((0 != AC_WLAN[k]->aclgrp_id) && (NULL != STA_ACL_GROUP[AC_WLAN[k]->aclgrp_id]))
							{
								aclgroupid = AC_WLAN[k]->aclgrp_id;
								memset((char*)&msg, 0, sizeof(msg));
								msg.mqid = WtpID%THREAD_NUM+1;
								msg.mqinfo.WTPID = WtpID;
								msg.mqinfo.type = CONTROL_TYPE;
								msg.mqinfo.subtype = WTP_S_TYPE;
								msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_ACL_LIST;
								msg.mqinfo.u.WtpInfo.value[0] = k;
								msg.mqinfo.u.WtpInfo.value[1] = m;
								msg.mqinfo.u.WtpInfo.value[2] = OVERWRITE;
								msg.mqinfo.u.WtpInfo.value[3] = LEVEL_WLAN;
								msg.mqinfo.u.WtpInfo.value[4] = AC_WLAN[k]->aclgrp_id;
								/*
								msg.mqinfo.u.WtpInfo.value3 = STA_ACL_GROUP[aclgroupid]->rule_cnt;
								rulelist = STA_ACL_GROUP[aclgroupid]->rule_list;
								for (i = 0; i < STA_ACL_GROUP[aclgroupid]->rule_cnt; i++)
								{
									msg.mqinfo.u.WtpInfo.value[i] = rulelist->rule_id;
									rulelist = rulelist->next;
								}
								*/
								if(AC_WTP[WtpID]->WTPStat == WID_RUN)
								{ 
									if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
									{
										wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
									}
								}
								else
								{
									elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
									if(NULL == elem)
										{
										WID_MALLOC_ERR();			
										return 0;
									}			
									memset(elem, 0, sizeof(struct msgqlist));
									elem->mqinfo.WTPID = WtpID;
									elem->mqinfo.type = CONTROL_TYPE;
									elem->mqinfo.subtype = WTP_S_TYPE;
									elem->mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_ACL_LIST;
									elem->mqinfo.u.WtpInfo.value[0] = k;
									elem->mqinfo.u.WtpInfo.value[1] = m;
									elem->mqinfo.u.WtpInfo.value[2] = OVERWRITE;
									elem->mqinfo.u.WtpInfo.value[3] = LEVEL_WLAN;
									elem->mqinfo.u.WtpInfo.value[4] = AC_WLAN[k]->aclgrp_id;
							
									WID_INSERT_CONTROL_LIST(WtpID, elem);
								}
							}
													
							if (0 != AC_WLAN[k]->electronic_menu)
							{									
								elem = NULL;								
								memset((char*)&msg, 0, sizeof(msg));
								msg.mqid = WtpID%THREAD_NUM+1;
								msg.mqinfo.WTPID = WtpID;
								msg.mqinfo.type = CONTROL_TYPE;
								msg.mqinfo.subtype = WTP_S_TYPE;
								msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_ELECTRONIC_MENU;
								msg.mqinfo.u.WtpInfo.value[0] = k;
								msg.mqinfo.u.WtpInfo.value[1] = m;
								msg.mqinfo.u.WtpInfo.value[2] = LEVEL_WLAN;
								msg.mqinfo.u.WtpInfo.value[3] = AC_WLAN[k]->electronic_menu;
							
								if (WID_RUN == AC_WTP[WtpID]->WTPStat)
								{	
									if (-1 == msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0))
									{
										wid_syslog_info("%s msgsend %s", __func__, strerror(errno));
									}
								}
								else
								{
									elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
									if (NULL == elem)
									{
										wid_syslog_info("%s malloc %s", __func__, strerror(errno));
										return 0;
									}
									memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
									elem->next = NULL;
									memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
									WID_INSERT_CONTROL_LIST(WtpID, elem);									
								}
								wid_syslog_debug_debug(WID_DEFAULT, "%s wlan%d local-survival switch %d\n",
														__func__, k, AC_WLAN[k]->electronic_menu);
							}
							
							if(0 != AC_WLAN[k]->macgroupID)
							{									
								groupid = AC_WLAN[k]->macgroupID;		
								policy = AC_WLAN[k]->mac_grp_policy;									
								elem = NULL;								
								memset((char*)&msg, 0, sizeof(msg));
								msg.mqid = WtpID%THREAD_NUM+1;
								msg.mqinfo.WTPID = WtpID;
								msg.mqinfo.type = CONTROL_TYPE;
								msg.mqinfo.subtype = WTP_S_TYPE;
								msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_BLACK_WHITE_LIST;
								msg.mqinfo.u.WtpInfo.value[0] = k;
								msg.mqinfo.u.WtpInfo.value[1] = m;
								msg.mqinfo.u.WtpInfo.value[2] = policy;
								msg.mqinfo.u.WtpInfo.value[3] = LEVEL_WLAN;
								msg.mqinfo.u.WtpInfo.value[4] = OVERWRITE;
								CWThreadMutexLock(&MAC_GROUP[groupid]->macListMutex);
								msg.mqinfo.u.WtpInfo.value[5] = MAC_GROUP[groupid]->count;
								MAC_list *maclist = MAC_GROUP[groupid]->macList;
								for (i = 0; (i < MAC_GROUP[groupid]->count) && (i < GROUP_MAC_COUNT); i++)
								{
									memcpy(msg.mqinfo.u.WtpInfo.macarry[i].mac, maclist->mac, sizeof(maclist->mac));
									maclist = maclist->next;
								}
								CWThreadMutexUnlock(&MAC_GROUP[groupid]->macListMutex);
							
								if (WID_RUN == AC_WTP[WtpID]->WTPStat)
								{	
									if (-1 == msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0))
									{
										wid_syslog_info("%s msgsend %s", __func__, strerror(errno));
									}
								}
								else
								{
									elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
									if(NULL == elem)
									{
										wid_syslog_info("%s malloc %s", __func__, strerror(errno));
										return 0;
									}
									memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
									elem->next = NULL;
									memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
									WID_INSERT_CONTROL_LIST(WtpID, elem);									
								}
							}
							if((check_bssid_func(AC_WLAN[k]->S_WTP_BSS_List[WtpID][m]))
								&&(AC_BSS[(AC_WLAN[k]->S_WTP_BSS_List[WtpID][m])]->packet_power != 0))
							{							
								WID_RADIO_WLAN_PACKET_POWER(WtpID, m, k, AC_BSS[(AC_WLAN[k]->S_WTP_BSS_List[WtpID][m])]->packet_power);
							}
						}
						else
						{
							continue;
						}
					}
				}
			}
		}
	}

	if(AC_WTP[WtpID]->ntp_state != 1)
	{
		wid_set_wtp_ntp(WtpID);
	}
	
	WID_CONFIG_SAVE(WtpID);
	
	return 0;
}

//zhangshu add for save traffic limit, 2011-1-7
void WID_Save_Traffic_Limit(unsigned int bssindex, unsigned int WtpID)
{
    char buf[DEFAULT_LEN];
    unsigned int value = 0;
    int flag = 0;
    
	if(AC_BSS[bssindex]->traffic_limit != 0)
	{
		value = AC_BSS[bssindex]->traffic_limit;
		memset(buf,0,DEFAULT_LEN);
		sprintf(buf,"autelan traffic_limit ath.%d-%d set_vap_flag 1;autelan traffic_limit ath.%d-%d set_vap %d",AC_BSS[bssindex]->Radio_L_ID
																														,AC_BSS[bssindex]->WlanID
																														,AC_BSS[bssindex]->Radio_L_ID
																														,AC_BSS[bssindex]->WlanID
																														,value);
		wid_syslog_debug_debug(WID_DEFAULT,"wid_set_bss_traffic_limit_value buf %s\n",buf);
		wid_radio_set_extension_command(WtpID,buf);
		flag = 1;
	}

	if(AC_BSS[bssindex]->average_rate != 0)
	{
		value = AC_BSS[bssindex]->average_rate;
		memset(buf,0,DEFAULT_LEN);
		sprintf(buf,"autelan traffic_limit ath.%d-%d set_every_node_flag 1;autelan traffic_limit ath.%d-%d set_every_node %d",AC_BSS[bssindex]->Radio_L_ID
																														,AC_BSS[bssindex]->WlanID
																														,AC_BSS[bssindex]->Radio_L_ID
																														,AC_BSS[bssindex]->WlanID
																														,value);
		wid_syslog_debug_debug(WID_DEFAULT,"wid_set_bss_traffic_limit_average_value buf %s\n",buf);
		wid_radio_set_extension_command(WtpID,buf);
		flag = 1;
	}

	if(AC_BSS[bssindex]->send_traffic_limit != 0)
	{
		value = AC_BSS[bssindex]->send_traffic_limit;
		memset(buf,0,DEFAULT_LEN);
		sprintf(buf,"autelan traffic_limit ath.%d-%d set_vap_flag 1;autelan traffic_limit ath.%d-%d set_vap_send %d",AC_BSS[bssindex]->Radio_L_ID
																														,AC_BSS[bssindex]->WlanID
																														,AC_BSS[bssindex]->Radio_L_ID
																														,AC_BSS[bssindex]->WlanID
																														,value);
		wid_syslog_debug_debug(WID_DEFAULT,"wid_set_bss_traffic_limit_send_value buf %s\n",buf);
		wid_radio_set_extension_command(WtpID,buf);
		flag = 1;
	}

	if(AC_BSS[bssindex]->send_average_rate != 0)
	{
		value = AC_BSS[bssindex]->send_average_rate;
		memset(buf,0,DEFAULT_LEN);
		sprintf(buf,"autelan traffic_limit ath.%d-%d set_every_node_flag 1;autelan traffic_limit ath.%d-%d set_every_node_send %d",AC_BSS[bssindex]->Radio_L_ID
																														,AC_BSS[bssindex]->WlanID
																														,AC_BSS[bssindex]->Radio_L_ID
																														,AC_BSS[bssindex]->WlanID
																														,value);
		wid_syslog_debug_debug(WID_DEFAULT,"wid_set_bss_traffic_limit_average_send_value buf %s\n",buf);
		wid_radio_set_extension_command(WtpID,buf);
		flag = 1;
	}
	if(flag != 0){
	    AC_BSS[bssindex]->traffic_limit_able = 1;
	}

    return; 
}
//fengwenchao add 20110126 for XJDEV-32  from 2.0
int wid_set_ap_eth_if_mtu(unsigned int wtpid,unsigned char eth_index)
{
//	int ret = 0;
	msgq msg;
	struct msgqlist *elem = NULL;

	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPStat == WID_RUN))
	{
		CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));
		if(gWTPs[wtpid].isNotFree && (gWTPs[wtpid].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = wtpid%THREAD_NUM+1;
			msg.mqinfo.WTPID = wtpid;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_IF_ETH_MTU;
			msg.mqinfo.u.WtpInfo.value1 = eth_index;

			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_info("%s msgsend %s",__func__,strerror(errno));
				perror("msgsnd");
			}
		}
		CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));
	}
	else if((AC_WTP[wtpid] != NULL))
	{
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = wtpid%THREAD_NUM+1;
		msg.mqinfo.WTPID = wtpid;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WTP_S_TYPE;
		msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_IF_ETH_MTU;
		msg.mqinfo.u.WtpInfo.value1 = eth_index;

		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if(elem == NULL)
		{
			wid_syslog_info("%s malloc %s",__func__,strerror(errno));
			perror("malloc");
			return 0;
		}
		memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
		elem->next = NULL;
		memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
		WID_INSERT_CONTROL_LIST(wtpid, elem);
	}
	wid_syslog_debug_debug(WID_DEFAULT," wtpid %d,wid_set_ap_eth_if_mtu\n",wtpid);
	return 0;
}
//fengwenchao add end

int WID_UNUSED_WTP(unsigned int WtpID)
{
	int IGNORE_UBSV tmp = 0;
	int i = 0;
	
	WID_CHECK_WTP_STANDARD_RET(WtpID, WTP_ID_NOT_EXIST);
	
	if ((AC_WTP[WtpID] != NULL) && (AC_WTP[WtpID]->isused == 1))
	{
		AC_WTP[WtpID]->unused_flag = 1;
		wid_trap_remote_restart(WtpID);
		tmp = WID_SUSPEND_WTP(WtpID);
		//AC_WTP[WtpID]->isused = 0;
		AC_WTP[WtpID]->quitreason = WTP_UNUSED;
		//AC_WTP[WtpID]->channelsendtimes = 1;
		for (i = 0; ((i < AC_WTP[WtpID]->RadioCount) && (i < L_RADIO_NUM)); i++)
		{
			if(AC_WTP[WtpID]->WTP_Radio[i]->auto_channel_cont == 0)
			{
				AC_WTP[WtpID]->WTP_Radio[i]->channelsendtimes = 1;
			}
		}
	}
	else
	{
		//printf("*** this wtp before state is unused ***\n");
	}
		
	return 0;
}

void WID_WTP_SSID_KEY_CONFLICT(unsigned int RadioID,unsigned char WlanID)
{
//	unsigned int WtpID = RadioID/L_RADIO_NUM;
//	unsigned char localradio_id = RadioID%L_RADIO_NUM;
	struct wlanid *wlan_id_next = NULL;

	wlan_id_next = AC_RADIO[RadioID]->Wlan_Id;
	while(wlan_id_next != NULL)
	{	
		if(wlan_id_next->wlanid == WlanID){
			wlan_id_next = wlan_id_next->next;
			continue;
		}else{
			if(((AC_WLAN[wlan_id_next->wlanid])&&(AC_WLAN[wlan_id_next->wlanid]->SecurityID == AC_WLAN[WlanID]->SecurityID)
				&&(AC_WLAN[WlanID]->KeyLen))
				|| ((AC_WLAN[wlan_id_next->wlanid])&&(AC_WLAN[WlanID]->KeyLen) && (AC_WLAN[wlan_id_next->wlanid]->KeyLen == AC_WLAN[WlanID]->KeyLen)
				&& (strncmp(AC_WLAN[wlan_id_next->wlanid]->WlanKey,AC_WLAN[WlanID]->WlanKey,AC_WLAN[WlanID]->KeyLen)==0)))
				{
					#if NOSOFTAC
					wid_dbug_trap_ssid_key_conflict(WtpID, (unsigned char)localradio_id, wlan_id_next->wlanid, WlanID);
					#endif
				}
				break;
		}
	}

	return ;
}


int Check_Interface_Config(char * ifname,WTPQUITREASON *quitreason)
{
	int sockfd;
	struct ifreq	ifr;
	
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	
	strncpy(ifr.ifr_name,ifname, sizeof(ifr.ifr_name));	
	
	if(ioctl(sockfd, SIOCGIFINDEX, &ifr) == -1) //bind to a interface
	{
		*quitreason = IF_NOINDEX;
		wid_syslog_err(WAI_FUNC_LINE_FMT"interface %s get gindex error(%d) %s\n",  \
				WAI_FUNC_LINE_LITERAL, ifname, errno, strerror(errno));
		close(sockfd);
		return APPLY_IF_FAIL;
	 }
	
	close(sockfd);
	return 0;
	
}
/*fengwenchao copy from 1318 for AXSSZFI-839*/
int Get_Interface_binding_Info(char * ifname, struct ifi_info *ifi)
{
	int sockfd;
	struct ifreq	ifr;
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	memset(&ifr,0,sizeof(struct ifreq));
	strncpy(ifr.ifr_name,ifname, sizeof(ifr.ifr_name));			
	
	if(ioctl(sockfd, SIOCGIFUDFFLAGS, (char *)&ifr) == -1)
	{
		wid_syslog_err(WAI_FUNC_LINE_FMT" interface %s get udf flags error(%d) %s\n",  \
				WAI_FUNC_LINE_LITERAL, ifname, errno, strerror(errno));
	}
	else
	{
		wid_syslog_debug(WAI_FUNC_LINE_FMT"interface %s get udf flags %#x\n",  \
				WAI_FUNC_LINE_LITERAL, ifname, ifr.ifr_flags);
		ifi->ifi_bflags = ifr.ifr_flags;
	}

	close(sockfd);
	return WID_DBUS_SUCCESS;
}

int Set_Interface_binding_Info(char * ifname,char flag)/*add flag--1,clear flag--0*/
{
	int sockfd = -1;
	struct ifreq	ifr;
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	
	if(sockfd < 0)
	{
		return WID_DBUS_ERROR;
	}
	memset(&ifr, 0, sizeof(struct ifreq));
	strncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));			

	if(ioctl(sockfd, SIOCGIFUDFFLAGS, &ifr) == -1)
	{
		wid_syslog_err(WAI_FUNC_LINE_FMT" interface %s get udf flags error(%d) %s\n",  \
				WAI_FUNC_LINE_LITERAL, ifname, errno, strerror(errno));
	}
	else
	{
		wid_syslog_debug(WAI_FUNC_LINE_FMT"interface %s get udf flags %#x\n",  \
				WAI_FUNC_LINE_LITERAL, ifname, ifr.ifr_flags);
	}
	if(flag == 0)
	{
		ifr.ifr_flags &= ~(IFF_BINDING_FLAG);
	}
	else
	{
		ifr.ifr_flags |= IFF_BINDING_FLAG;
	}

	if(ioctl(sockfd, SIOCSIFUDFFLAGS, (char *)&ifr) == -1)
	{
		wid_syslog_err(WAI_FUNC_LINE_FMT" interface %s set new udf flags %#x error(%d) %s\n",  \
				WAI_FUNC_LINE_LITERAL, ifname, ifr.ifr_flags, errno, strerror(errno));
	}
	else
	{
		wid_syslog_debug(WAI_FUNC_LINE_FMT"interface %s set new udf flags %#x\n",  \
				WAI_FUNC_LINE_LITERAL, ifname, ifr.ifr_flags);
	}
	close(sockfd);
	return WID_DBUS_SUCCESS;
}
/*fengwenchao copy end*/
int Get_Interface_Info(char * ifname, struct ifi_info *ifi)
{
	int sockfd = -1;
	struct ifreq ifr, ifrcopy;
	struct sockaddr_in	*sinptr = NULL;
	struct sockaddr_in6	*sin6ptr = NULL;

	if(NULL == ifname || NULL == ifi)
	{
		return INTERFACE_NOT_EXIST;
	}

	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (0 > sockfd)
	{
		return APPLY_IF_FAIL;
	}
	strncpy(ifr.ifr_name,ifname, sizeof(ifr.ifr_name));
	if (ioctl(sockfd, SIOCGIFINDEX, &ifr) == -1)//bind to a interface 
	{
		wid_syslog_err(WAI_FUNC_LINE_FMT""WAI_GENERAL_FMT"get interface %s gindex error(%d) %s\n", \
						WAI_FUNC_LINE_LITERAL, ifname, errno, strerror(errno));
		close(sockfd);
		return APPLY_IF_FAIL;
	}
	ifi->ifi_index = ifr.ifr_ifindex;
	if (ioctl(sockfd, SIOCGIFFLAGS, &ifr) == -1)
	{ 
		wid_syslog_err(WAI_FUNC_LINE_FMT""WAI_GENERAL_FMT"get interface %s flags error(%d) %s\n", \
						WAI_FUNC_LINE_LITERAL, ifname, errno, strerror(errno));
		close(sockfd);
		return APPLY_IF_FAIL;
	}
	if(ifr.ifr_flags & IFF_UP)
	{
		ifi->ifi_flags = ifr.ifr_flags;
	}
	else
	{
		wid_syslog_info(WAI_FUNC_LINE_FMT""WAI_GENERAL_FMT"get interface %s flags %#x found down\n", \
						WAI_FUNC_LINE_LITERAL, ifname, ifr.ifr_flags);
		return APPLY_IF_FAIL;
	}
	
#if NOSOFTAC
	Get_Interface_binding_Info(ifname,ifi);//fengwenchao copy from 1318 for AXSSZFI-839
#endif
	if(ioctl(sockfd, SIOCGIFADDR, &ifr) == -1)
	{
		wid_syslog_info(WAI_FUNC_LINE_FMT""WAI_GENERAL_FMT"get interface %s address error(%d) %s\n", \
						WAI_FUNC_LINE_LITERAL, ifname, errno, strerror(errno));
		close(sockfd);
		ifi->addr_num = 0;
		return WID_DBUS_SUCCESS;
	}

	wid_syslog_debug(WAI_FUNC_LINE_FMT""WAI_GENERAL_FMT"interface %s get address %s\n", \
				WAI_FUNC_LINE_LITERAL, ifname, inet_ntoa(((struct sockaddr_in*)(&ifr.ifr_addr))->sin_addr));

	ifi->addr_num = ipaddr_list(ifi->ifi_index, ifi->addr, IFI_ADDR_NUM);
	
	int i = 0;
	for(i = 0; i < ifi->addr_num; i++)
	{
        ifi->addr[i] = htonl(ifi->addr[i]);
	}
	switch (ifr.ifr_addr.sa_family)
	{
		case AF_INET:
			sinptr = (struct sockaddr_in *) &ifr.ifr_addr;
			ifi->ifi_addr = (struct sockaddr*)calloc(1, sizeof(struct sockaddr_in));
			if(NULL == ifi->ifi_addr)
			{
				close(sockfd);
				return APPLY_IF_FAIL;
			}
			memcpy(ifi->ifi_addr, sinptr, sizeof(struct sockaddr_in));
	
#ifdef	SIOCGIFBRDADDR
			ifrcopy = ifr;
			if (ifi->ifi_flags & IFF_BROADCAST)
			{
				ioctl(sockfd, SIOCGIFBRDADDR, &ifrcopy);
				sinptr = (struct sockaddr_in *) &ifrcopy.ifr_broadaddr;
				ifi->ifi_brdaddr = (struct sockaddr*)calloc(1, sizeof(struct sockaddr_in));
				if(NULL == ifi->ifi_brdaddr)
				{
				    close(sockfd);
				    return APPLY_IF_FAIL;
				}
				memcpy(ifi->ifi_brdaddr, sinptr, sizeof(struct sockaddr_in));				
				wid_syslog_debug(WAI_FUNC_LINE_FMT""WAI_GENERAL_FMT"interface %s get bcast address %s\n", \
							WAI_FUNC_LINE_LITERAL, ifname, inet_ntoa(((struct sockaddr_in*)(ifi->ifi_brdaddr))->sin_addr));
			}
#endif
			
			break;
			
		case AF_INET6:
			sin6ptr = (struct sockaddr_in6 *) &ifr.ifr_addr;
			ifi->ifi_addr = (struct sockaddr*)calloc(1, sizeof(struct sockaddr_in6));
			if(NULL == ifi->ifi_addr)
			{
			    close(sockfd);
			    return APPLY_IF_FAIL;
			}
			memcpy(ifi->ifi_addr, sin6ptr, sizeof(struct sockaddr_in6));

			break;

        default:
			break;
	}
	close(sockfd);
	return WID_DBUS_SUCCESS;
}

int Get_Ipaddr_Info(struct ifi_info *ifi)
{
	int ret = 0;
	int sockfd = -1;
	struct ifreq ifr, ifrcopy;
	struct sockaddr_in	*sinptr = NULL;
	struct sockaddr_in6	*sin6ptr = NULL;
	
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (0 >= sockfd)
	{
		return -1;
	}

	ret = ipaddr_list_v2(ifi,ifi->addr, IFI_IF_NUM);
	if(ret != 0)
	{
		close(sockfd);
		return ret;
	}
	strncpy(ifr.ifr_name,ifi->ifi_name, sizeof(ifr.ifr_name));	
	wid_syslog_debug_debug(WID_DEFAULT,"%s:%d ip:%d.%d.%d.%d.,ifname=%s.",__func__,__LINE__,(ifi->addr[0])&0xFF,(ifi->addr[0])&0xFF,(ifi->addr[0])&0xFF,(ifi->addr[0])&0xFF,ifr.ifr_name);
	if (ioctl(sockfd, SIOCGIFINDEX, &ifr) == -1)    //bind to a interface 
	{
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d wtp quit reason is SIOCGIFINDEX error",__func__,__LINE__);
		close(sockfd);
		return APPLY_IF_FAIL;
    }
	ifi->ifi_index = ifr.ifr_ifindex;
	if (ioctl(sockfd, SIOCGIFFLAGS, &ifr) == -1)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d wtp quit reason is SIOCGIFFLAGS error",__func__,__LINE__);
		close(sockfd);
		return APPLY_IF_FAIL;
	}
	if(ifr.ifr_flags & IFF_UP)
	{
		ifi->ifi_flags = ifr.ifr_flags;
	}
	else
	{
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d wtp quit reason is IF_DOWN error",__func__,__LINE__);
	}
	if(ioctl(sockfd, SIOCGIFADDR, &ifr) == -1)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d wtp quit reason is SIOCGIFADDR error",__func__,__LINE__);
		close(sockfd);
		ifi->addr_num = 0;
		return WID_DBUS_SUCCESS;
	}
	wid_syslog_debug_debug(WID_DEFAULT,"%s:%d addr %s",__func__,__LINE__,inet_ntoa(((struct sockaddr_in*)(&ifr.ifr_addr))->sin_addr));
	
	switch (ifr.ifr_addr.sa_family)
	{
		case AF_INET:
			wid_syslog_debug_debug(WID_DEFAULT,"%s,%d.",__func__,__LINE__);
			sinptr = (struct sockaddr_in *) &ifr.ifr_addr;
			ifi->ifi_addr = (struct sockaddr*)calloc(1, sizeof(struct sockaddr_in));
			memcpy(ifi->ifi_addr, sinptr, sizeof(struct sockaddr_in));
	
#ifdef	SIOCGIFBRDADDR
			wid_syslog_debug_debug(WID_DEFAULT,"%s,%d.",__func__,__LINE__);
			ifrcopy = ifr;
			if (ifi->ifi_flags & IFF_BROADCAST)
			{
				ioctl(sockfd, SIOCGIFBRDADDR, &ifrcopy);
				sinptr = (struct sockaddr_in *) &ifrcopy.ifr_broadaddr;
				ifi->ifi_brdaddr = (struct sockaddr*)calloc(1, sizeof(struct sockaddr_in));
				memcpy(ifi->ifi_brdaddr, sinptr, sizeof(struct sockaddr_in));				
				wid_syslog_debug_debug(WID_DEFAULT,"%s:%d addr %s",__func__,__LINE__,inet_ntoa(((struct sockaddr_in*)(ifi->ifi_brdaddr))->sin_addr));
			}
#endif
	
			break;
		case AF_INET6:
			sin6ptr = (struct sockaddr_in6 *) &ifr.ifr_addr;
			ifi->ifi_addr = (struct sockaddr*)calloc(1, sizeof(struct sockaddr_in6));
			memcpy(ifi->ifi_addr, sin6ptr, sizeof(struct sockaddr_in6));

			break;

		default:
			wid_syslog_debug_debug(WID_DEFAULT,"%s,%d.",__func__,__LINE__);
			break;
	}
	wid_syslog_debug_debug(WID_DEFAULT,"%s,%d.",__func__,__LINE__);
	close(sockfd);
	return WID_DBUS_SUCCESS;
}

int Delete_Bind_Interface_For_WID(struct ifi_info *ifi)
{
	struct CWMultiHomedInterface *tmp = gACSocket.interfaces;
	struct CWMultiHomedInterface *tmp_next = gACSocket.interfaces;
	if((gACSocket.count == 0)||(tmp == NULL))
		return 0;
	int i = 0;
	int m = 0;
	int n = 0;
	if(ifi)
		n = strlen(ifi->ifi_name);
	int gIndex = 0;
	while(tmp_next != NULL)
	{		
		m = strlen(tmp_next->ifname);
		if((m == n) && (strncmp(tmp_next->ifname, ifi->ifi_name, strlen(ifi->ifi_name)) == 0))
		{
			for(i = 0; i < ifi->addr_num; i++)
			{
				//if((memcmp(&(((struct sockaddr_in *)&(tmp_next->addr))->sin_addr.s_addr),&(ifi->addr[i]),sizeof(int))==0))
				if(((struct sockaddr_in *)&(tmp_next->addr))->sin_addr.s_addr == ifi->addr[i])
				{
					tmp = tmp_next->if_next;
					tmp_next->if_next = NULL;
					gIndex = tmp_next->gIf_Index;
					
					if((gIndex < gMaxInterfacesCount)&& (gIndex >= 0))
					{	gInterfaces[gIndex].WTPCount = 0;
						gInterfaces[gIndex].enable = 0; 
					}
					else
					{
						wid_syslog_err("%s:%d gIndex %d is not legal\n",__func__,__LINE__,gIndex);
					}
										
					wid_syslog_notice("%s:%d delete %d (%d, %s) index %d sock %d\n",__func__,__LINE__,tmp_next->gIf_Index, tmp_next->systemIndex, tmp_next->ifname,ifi->ifi_index,tmp_next->sock);
					close(tmp_next->sock);
					free(tmp_next);
					tmp_next = tmp;
					
					WIDWsm_VRRPIFOp((unsigned char*)ifi->ifi_name,ifi->addr[i],VRRP_UNREG_IF);
					gACSocket.interfaces = tmp;
					if(gACSocket.count > 0)
					{
						gACSocket.count--;
					}
					break;
				}				
			}
			if(i < ifi->addr_num)
			{
				tmp = gACSocket.interfaces;
				tmp_next = tmp;
				continue;
			}
		}
				
		break;
	}
	if(gACSocket.interfaces == NULL)
	{
		return 0;
	}
	tmp = gACSocket.interfaces;
	tmp_next = tmp->if_next;
	while(tmp_next != NULL)
	{
		m = strlen(tmp_next->ifname);
		if((m == n) && (strncmp(tmp_next->ifname, ifi->ifi_name, strlen(ifi->ifi_name)) == 0))
		{
			for(i = 0; i < ifi->addr_num; i++)
			{
				//if((memcmp(&(((struct sockaddr_in *)&(tmp_next->addr))->sin_addr).s_addr,&(ifi->addr[i]),sizeof(int))==0))
				if(((struct sockaddr_in *)&(tmp_next->addr))->sin_addr.s_addr == ifi->addr[i])
				{
					tmp->if_next = tmp_next->if_next;
					tmp_next->if_next = NULL;
					gIndex = tmp_next->gIf_Index;
					
					if((gIndex < gMaxInterfacesCount)&& (gIndex >= 0))
					{	gInterfaces[gIndex].WTPCount = 0;
						gInterfaces[gIndex].enable = 0; 
					}
					else
					{
						wid_syslog_err("%s:%d gIndex %d is not legal\n",__func__,__LINE__,gIndex);
					}
										
					wid_syslog_notice("%s:%d delete %d (%d, %s) index %d sock %d\n",__func__,__LINE__,tmp_next->gIf_Index, tmp_next->systemIndex, tmp_next->ifname,ifi->ifi_index,tmp_next->sock);
					close(tmp_next->sock);
					CW_FREE_OBJECT(tmp_next);
					tmp_next = tmp->if_next;						
					WIDWsm_VRRPIFOp((unsigned char*)ifi->ifi_name,ifi->addr[i],VRRP_UNREG_IF);
					if(gACSocket.count > 0)
					{
						gACSocket.count--;
					}
					break;
				}
			}
			if(i < ifi->addr_num)
			{
				continue;
			}
		}
		tmp = tmp_next;
		tmp_next = tmp->if_next;
	}
	return 0;
}

void Check_Current_Interface_and_delete(char * ifname, struct ifi_info *ifi){
	struct CWMultiHomedInterface *tmp = gACSocket.interfaces;
	struct CWMultiHomedInterface *tmp_next = gACSocket.interfaces;
	int i = 0;
	int m = 0;
	int n = strlen(ifname);
	int gIndex = 0;
	while(tmp_next != NULL){		
		m = strlen(tmp_next->ifname);
		if((m == n)&&(strncmp(tmp_next->ifname,ifname, strlen(ifname)) == 0)){
			if((tmp_next->systemIndex != ifi->ifi_index)){
				tmp = tmp_next->if_next;
				tmp_next->if_next = NULL;
				gIndex = tmp_next->gIf_Index;				
				//printf("delete %d (%d, %s)", tmp_next->gIf_Index, tmp_next->systemIndex, tmp_next->ifname,ifi->ifi_index);
				//fengwenchao modify begin 20110524
				if((gIndex < gMaxInterfacesCount)&& (gIndex >= 0))
				{	gInterfaces[gIndex].WTPCount = 0;
					gInterfaces[gIndex].enable = 0; 
				}
				else
				{
					wid_syslog_err("gIndex	%d is not legal \n",gIndex);
				}
				//fengwenchao modify end
				close(tmp_next->sock);
				CW_FREE_OBJECT(tmp_next);
				tmp_next = tmp;
				gACSocket.interfaces = tmp;
				if(gACSocket.count > 0)
					gACSocket.count--;
				wid_syslog_debug_debug(WID_DEFAULT,"%s,111gACSocket.count--,count=%d\n",__func__,gACSocket.count);
				Check_WLAN_WTP_IF_Index(ifi,ifname);	
				continue;
			}else{
				for(i=0;i<ifi->addr_num;i++){
					//if((memcmp(&(((struct sockaddr_in *)&(tmp_next->addr))->sin_addr).s_addr,&(ifi->addr[i]),sizeof(int))==0))
					if(((struct sockaddr_in *)&(tmp_next->addr))->sin_addr.s_addr == ifi->addr[i])
					{
						ifi->check_addr[i] += 1;
						if(ifi->check_addr[i] == 2)
							ifi->addr[i] = 0;
						break;
					}				
				}
				/*if((memcmp(&((struct sockaddr_in *)&(tmp_next->addr))->sin_addr,&((struct sockaddr_in *)&(ifi->ifi_brdaddr))->sin_addr,sizeof(struct in_addr))==0)){
					ifi->check_brdaddr += 1;
					break;
				}	*/
				if(i == ifi->addr_num){			
					tmp = tmp_next->if_next;
					tmp_next->if_next = NULL;
					gIndex = tmp_next->gIf_Index;
					//fengwenchao modify begin 20110524
					if((gIndex < gMaxInterfacesCount)&& (gIndex >= 0))
					{	gInterfaces[gIndex].WTPCount = 0;
						gInterfaces[gIndex].enable = 0; 
					}
					else
					{
						wid_syslog_err("gIndex	%d is not legal \n",gIndex);
					}
					//fengwenchao modify end
					//printf("delete %d (%d, %s)", tmp_next->gIf_Index, tmp_next->systemIndex, tmp_next->ifname,ifi->ifi_index);
					close(tmp_next->sock);
					CW_FREE_OBJECT(tmp_next);
					tmp_next = tmp;
					gACSocket.interfaces = tmp;
					if(gACSocket.count > 0)
						gACSocket.count--;
					wid_syslog_debug_debug(WID_DEFAULT,"%s,222gACSocket.count--,count=%d\n",__func__,gACSocket.count);
					continue;
				}else{
					break;
				}
			}
				
		}
		break;
	}
	if(gACSocket.interfaces == NULL)
		return;
	tmp = gACSocket.interfaces;
	tmp_next = tmp->if_next;
	while(tmp_next != NULL){
		m = strlen(tmp_next->ifname);
		if((m == n)&&(strncmp(tmp_next->ifname,ifname, strlen(ifname)) == 0)){
			if((tmp_next->systemIndex != ifi->ifi_index)){
				tmp->if_next = tmp_next->if_next;
				tmp_next->if_next = NULL;
				gIndex = tmp_next->gIf_Index;
				//fengwenchao modify begin 20110524
				if((gIndex < gMaxInterfacesCount)&& (gIndex >= 0))
				{	gInterfaces[gIndex].WTPCount = 0;
					gInterfaces[gIndex].enable = 0; 
				}
				else
				{
					wid_syslog_err("gIndex	%d is not legal \n",gIndex);
				}
				//fengwenchao modify end
				close(tmp_next->sock);
				CW_FREE_OBJECT(tmp_next);
				tmp_next = tmp->if_next;				
				if(gACSocket.count > 0)
					gACSocket.count --;
				wid_syslog_debug_debug(WID_DEFAULT,"%s,333gACSocket.count--,count=%d\n",__func__,gACSocket.count);
				Check_WLAN_WTP_IF_Index(ifi,ifname);	
				continue;
			}else{
				for(i=0;i<ifi->addr_num;i++){
					//if((memcmp(&(((struct sockaddr_in *)&(tmp_next->addr))->sin_addr).s_addr,&(ifi->addr[i]),sizeof(struct in_addr))==0))
					if(((struct sockaddr_in *)&(tmp_next->addr))->sin_addr.s_addr == ifi->addr[i])
					{
						ifi->check_addr[i] += 1;
						if(ifi->check_addr[i] == 2)
							ifi->addr[i] = 0;
						break;
					}
				}
				/*if((memcmp(&((struct sockaddr_in *)&(tmp_next->addr))->sin_addr,&((struct sockaddr_in *)&(ifi->ifi_brdaddr))->sin_addr,sizeof(struct in_addr))==0)){
					ifi->check_brdaddr += 1;
					tmp = tmp_next;
					tmp_next = tmp->if_next;
					continue;
				}*/
				if(i == ifi->addr_num){			
					tmp->if_next = tmp_next->if_next;
					tmp_next->if_next = NULL;
					gIndex = tmp_next->gIf_Index;
					//fengwenchao modify begin 20110524
					if((gIndex < gMaxInterfacesCount)&& (gIndex >= 0))
					{	gInterfaces[gIndex].WTPCount = 0;
						gInterfaces[gIndex].enable = 0; 
					}
					else
					{
						wid_syslog_err("gIndex	%d is not legal \n",gIndex);
					}
					//fengwenchao modify end
					close(tmp_next->sock);
					CW_FREE_OBJECT(tmp_next);
					tmp_next = tmp->if_next;
					if(gACSocket.count > 0)
						gACSocket.count --;
					wid_syslog_debug_debug(WID_DEFAULT,"%s,444gACSocket.count--,count=%d\n",__func__,gACSocket.count);
					continue;
				}else{
					tmp = tmp_next;
					tmp_next = tmp->if_next;
					continue;
				}
			}
				
		}
		tmp = tmp_next;
		tmp_next = tmp->if_next;
	}
	return;
}
int Delete_listenning_IF(char * ifname){
	struct CWMultiHomedInterface *tmp = gACSocket.interfaces;
	struct CWMultiHomedInterface *tmp_next = gACSocket.interfaces;
//	int i = 0;
	unsigned int  ip =0;
	int gIndex = 0;
	struct ifi *tmp2 = WID_IF;
	struct ifi *tmp3 = WID_IF;
	if(ifname == NULL){
		wid_syslog_debug_debug(WID_DEFAULT,"%s,ifname=%p\n",__func__,ifname);
		return -1;
	}
	if((gACSocket.count == 0)||(tmp == NULL))
		return 0;
	int m = strlen(tmp2->ifi_name);
	int n = strlen(ifname);
	wid_syslog_debug_debug(WID_DEFAULT,"%s,00delete interface from WID_IF,ifname=%s,m=%d,n=%d\n",__func__,ifname,m,n);
	if((m == n)&&(tmp2->lic_flag == DOWN_LINK_IF_TYPE)&&(memcmp(tmp2->ifi_name,ifname,m)==0)){
		WID_IF = tmp2->ifi_next;
		tmp2->ifi_next = NULL;
		free(tmp2);
		tmp2 = NULL;
		wid_syslog_debug_debug(WID_DEFAULT,"%s,11delete interface from WID_IF,ifname=%s\n",__func__,ifname);
	}else{
		tmp2 = tmp3->ifi_next;
		while(tmp2 != NULL){
			int m = strlen(tmp2->ifi_name);
			wid_syslog_debug_debug(WID_DEFAULT,"%s,22delete interface from WID_IF,tmp2->ifi_name=%s,m=%d,n=%d\n",__func__,tmp2->ifi_name,m,n);
			if((m == n)&&(tmp2->lic_flag == DOWN_LINK_IF_TYPE)&&(memcmp(tmp2->ifi_name,ifname,m)==0)){
				tmp3->ifi_next = tmp2->ifi_next;
				tmp2->ifi_next = NULL;
				free(tmp2);
				tmp2 = NULL;	
				wid_syslog_debug_debug(WID_DEFAULT,"%s,33delete interface from WID_IF,ifname=%s\n",__func__,ifname);
				break;
			}
			tmp3 = tmp2;
			tmp2 = tmp2->ifi_next;
		}
	}
	if((tmp == NULL)||(tmp_next == NULL)){
		return -1;
	}
	m = strlen(tmp->ifname);
	n = strlen(ifname);
	while(tmp != NULL){
		tmp_next = tmp->if_next;
		if((m == n)&&(strncmp(tmp->ifname,ifname,IFI_NAME) == 0)){		
			if(tmp->lic_flag == (DOWN_LINK_IF_TYPE|DOWN_LINK_IP_TYPE)){
				Set_Interface_binding_Info(ifname,0);
				tmp->lic_flag = DOWN_LINK_IP_TYPE;
				wid_syslog_debug_debug(WID_DEFAULT,"%s modify\n",__func__);
				break;
			}
			else if(tmp->lic_flag == DOWN_LINK_IF_TYPE){
				gACSocket.interfaces = tmp_next;
				tmp->if_next = NULL;
				gIndex = tmp->gIf_Index;
				if((gIndex < gMaxInterfacesCount)&& (gIndex >= 0))
				{	gInterfaces[gIndex].WTPCount = 0;
					gInterfaces[gIndex].enable = 0; 
				}
				close(tmp->sock);
				Set_Interface_binding_Info(ifname,0);			
				ip = ((struct sockaddr_in *)&(tmp->addr))->sin_addr.s_addr;
				WIDWsm_VRRPIFOp((unsigned char*)(tmp->ifname),ip,VRRP_UNREG_IF);
				free(tmp);
				tmp = NULL;
				if(gACSocket.count > 0)
					gACSocket.count--;
				wid_syslog_debug_debug(WID_DEFAULT,"%s,000gACSocket.count--,count=%d\n",__func__,gACSocket.count);
				tmp = tmp_next;
				continue;
			}
		}
		break;
	}
	while(tmp_next != NULL){		
		m = strlen(tmp_next->ifname);
		if((m == n)&&(strncmp(tmp_next->ifname,ifname,IFI_NAME) == 0)){				
			if(tmp_next->lic_flag == (DOWN_LINK_IF_TYPE|DOWN_LINK_IP_TYPE)){
				Set_Interface_binding_Info(ifname,0);
				tmp_next->lic_flag = DOWN_LINK_IP_TYPE;
				wid_syslog_debug_debug(WID_DEFAULT,"%s modify2222\n",__func__);
				break;
			}
			else if(tmp_next->lic_flag == DOWN_LINK_IF_TYPE){
				tmp->if_next = tmp_next->if_next;
				tmp_next->if_next = NULL;
				gIndex = tmp_next->gIf_Index;				
				if((gIndex >= 0)&&(gIndex < gMaxInterfacesCount)){    //fengwenchao change gIndex > 0  to  gIndex >= 0  20110525
					gInterfaces[gIndex].WTPCount = 0;
					gInterfaces[gIndex].enable = 0;
				}
				close(tmp_next->sock);
				Set_Interface_binding_Info(ifname,0);
				ip = ((struct sockaddr_in *)&(tmp_next->addr))->sin_addr.s_addr;
				WIDWsm_VRRPIFOp((unsigned char*)(tmp_next->ifname),ip,VRRP_UNREG_IF);
				free(tmp_next);
				tmp_next = NULL;
				tmp_next = tmp->if_next;
				if(gACSocket.count > 0)
					gACSocket.count--;
				wid_syslog_debug_debug(WID_DEFAULT,"%s,222gACSocket.count--,count=%d\n",__func__,gACSocket.count);
			}
			continue;
		}
		tmp = tmp_next;
		tmp_next = tmp->if_next;
	}
	return 0;
}
int Delete_listenning_IP(unsigned int ipaddr,LISTEN_FLAG flag){
	struct CWMultiHomedInterface *tmp = gACSocket.interfaces;
	struct CWMultiHomedInterface *tmp_next = gACSocket.interfaces;
	int gIndex = 0;
	struct ifi *tmp2 = WID_IF;
	struct ifi *tmp3 = WID_IF;
	char find = 0;
	if((gACSocket.count == 0)||(tmp == NULL))
		return 0;
	wid_syslog_debug_debug(WID_DEFAULT,"%s,delete ip from WID_IF,ip=%d.%d.%d.%d.\n",__func__,(ipaddr>>24)&0xFF,(ipaddr>>16)&0xFF,(ipaddr>>8)&0xFF,(ipaddr)&0xFF);
	//if((m == n)&&(memcmp(tmp2->ifi_name,ifname,m)==0))
	if((tmp2->addr == ipaddr)&&(tmp2->lic_flag == flag)){
		WID_IF = tmp2->ifi_next;
		tmp2->ifi_next = NULL;
		free(tmp2);
		tmp2 = NULL;
		wid_syslog_debug_debug(WID_DEFAULT,"1,%s,ip=%d.%d.%d.%d.\n",__func__,(ipaddr>>24)&0xFF,(ipaddr>>16)&0xFF,(ipaddr>>8)&0xFF,(ipaddr)&0xFF);
	}else{
		tmp2 = tmp3->ifi_next;
		while(tmp2 != NULL){
			//int m = strlen(tmp2->ifi_name);
			wid_syslog_debug_debug(WID_DEFAULT,"2,%s,ip=%d.%d.%d.%d.\n",__func__,(ipaddr>>24)&0xFF,(ipaddr>>16)&0xFF,(ipaddr>>8)&0xFF,(ipaddr)&0xFF);
			//if((m == n)&&(memcmp(tmp2->ifi_name,ifname,m)==0))
			if((tmp2->addr == ipaddr)&&(tmp2->lic_flag == flag)){
				tmp3->ifi_next = tmp2->ifi_next;
				tmp2->ifi_next = NULL;
				free(tmp2);
				tmp2 = NULL;	
				wid_syslog_debug_debug(WID_DEFAULT,"3,%s,ip=%d.%d.%d.%d.\n",__func__,(ipaddr>>24)&0xFF,(ipaddr>>16)&0xFF,(ipaddr>>8)&0xFF,(ipaddr)&0xFF);
				break;
			}
			tmp3 = tmp2;
			tmp2 = tmp2->ifi_next;
		}
	}
	if((tmp == NULL)||(tmp_next == NULL)){
		return -1;
	}
	tmp_next = tmp->if_next;
	//if((m == n)&&(strncmp(tmp->ifname,ifname,IFI_NAME) == 0))
	wid_syslog_debug_debug(WID_DEFAULT,"%s,tmp->lic_flag=%d,flag=%d.\n",__func__,tmp->lic_flag,flag);
	if((((struct sockaddr_in *)&(tmp->addr))->sin_addr.s_addr == ipaddr)){
		if(tmp->lic_flag == (DOWN_LINK_IF_TYPE|DOWN_LINK_IP_TYPE)){
			tmp->lic_flag = DOWN_LINK_IF_TYPE;
		}
		else if(tmp->lic_flag == flag){
			gACSocket.interfaces = tmp_next;
			tmp->if_next = NULL;
			close(tmp->sock);
			if(flag != LIC_TYPE)
				WIDWsm_VRRPIFOp((unsigned char*)(tmp->ifname),ipaddr,VRRP_UNREG_IF);
			free(tmp);
			tmp = NULL;
			if(gACSocket.count > 0)
				gACSocket.count--;
			wid_syslog_debug_debug(WID_DEFAULT,"%s,000gACSocket.count--,count=%d\n",__func__,gACSocket.count);
			find  = 1;
		}	
	}/*else*/
	if(find == 0){
		wid_syslog_debug_debug(WID_DEFAULT,"22%s,tmp_next->lic_flag=%d,flag=%d.\n",__func__,tmp_next->lic_flag,flag);
		while(tmp_next != NULL){	
			wid_syslog_debug_debug(WID_DEFAULT,"33%s,tmp_next->lic_flag=%d,flag=%d.\n",__func__,tmp_next->lic_flag,flag);
			//m = strlen(tmp_next->ifname);
			//if((m == n)&&(strncmp(tmp_next->ifname,ifname,IFI_NAME) == 0))
			if((((struct sockaddr_in *)&(tmp_next->addr))->sin_addr.s_addr == ipaddr)){
				if(tmp_next->lic_flag == (DOWN_LINK_IF_TYPE|DOWN_LINK_IP_TYPE)){
					tmp_next->lic_flag = DOWN_LINK_IF_TYPE;
				}
				else if(tmp_next->lic_flag == flag){
					tmp->if_next = tmp_next->if_next;
					tmp_next->if_next = NULL;
					gIndex = tmp_next->gIf_Index;				
					if((gIndex >= 0)&&(gIndex < gMaxInterfacesCount)){    //fengwenchao change gIndex > 0  to  gIndex >= 0  20110525
						gInterfaces[gIndex].WTPCount = 0;
						gInterfaces[gIndex].enable = 0;
					}
					close(tmp_next->sock);
					if(flag != LIC_TYPE)
						WIDWsm_VRRPIFOp((unsigned char*)(tmp_next->ifname),ipaddr,VRRP_UNREG_IF);
					free(tmp_next);
					tmp_next = NULL;
					tmp_next = tmp->if_next;
					if(gACSocket.count > 0)
						gACSocket.count--;
					wid_syslog_debug_debug(WID_DEFAULT,"%s,222gACSocket.count--,count=%d\n",__func__,gACSocket.count);
						break;
				}
			}
			tmp = tmp_next;
			tmp_next = tmp->if_next;
		}
	}
	return 0;
}

void Check_Current_Interface(char * ifname, struct CWMultiHomedInterface **p,struct CWMultiHomedInterface **pbr){
	struct CWMultiHomedInterface *tmp = gACSocket.interfaces;
	if(ifname == NULL){
		wid_syslog_debug_debug(WID_DEFAULT,"%s,ifname=%p\n",__func__,ifname);
		return;
	}
	while(tmp != NULL){
		//printf("tmp->ifname %s\n",tmp->ifname);
		int m = strlen(tmp->ifname);
		int n = strlen(ifname);
		//printf("##### m:%d n:%d####\n",m,n);
		if((m == n)&&(strncmp(tmp->ifname,ifname, strlen(ifname)) == 0)){
			if(tmp->kind == CW_PRIMARY)
				*p = tmp;
			else if(tmp->kind == CW_BROADCAST_OR_ALIAS)
				*pbr = tmp;
		}
		tmp = tmp->if_next;
	}
	return;
}

int Modify_Interface(struct CWMultiHomedInterface *p, struct CWMultiHomedInterface *pbr,  struct ifi_info *ifi, int port)
{
	int i = 0;
	int yes = 1;
	CWSocket sock = -1;
	if((sock = socket(ifi->ifi_addr->sa_family, SOCK_DGRAM, 0)) < 0)
	{
		CWNetworkRaiseSystemError(CW_ERROR_CREATING);
	}
	
	// reuse address
	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
	
	// bind address
	sock_set_port_cw(ifi->ifi_addr, htons(port));
	
	if(bind(sock, (struct sockaddr*) ifi->ifi_addr, CWNetworkGetAddressSize((CWNetworkLev4Address*)ifi->ifi_addr)) < 0)
	{
		close(sock);
		CWUseSockNtop(ifi->ifi_addr,wid_syslog_debug_debug(WID_DEFAULT,"failed %s\n", str);
		);
		//CWNetworkRaiseSystemError(CW_ERROR_CREATING);
	}

	CWUseSockNtop(ifi->ifi_addr,
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d bound %s (%d, %s)\n", __func__, __LINE__, str, ifi->ifi_index, ifi->ifi_name);
	);
	
	// store socket inside multihomed socket
	wid_syslog_debug_debug(WID_DEFAULT,"%s:%d p->sock %d\n", __func__, __LINE__, p->sock);
	close(p->sock);
	p->sock = sock;
	wid_syslog_debug_debug(WID_DEFAULT,"%s:%d p->sock %d\n", __func__, __LINE__, p->sock);
	p->systemIndex = ifi->ifi_index;
	
	// the next field is useful only if we are an IPv6 server. In this case, p->addr contains the IPv6
	// address of the interface and p->addrIPv4 contains the equivalent IPv4 address. On the other side,
	// if we are an IPv4 server p->addr contains the IPv4 address of the interface and p->addrIPv4 is
	// garbage.
	p->addrIPv4.ss_family = AF_UNSPEC;
	CW_COPY_NET_ADDR_PTR(&(p->addr), ifi->ifi_addr);	
	i = p->gIf_Index;
	if((i < gMaxInterfacesCount)&&(i >= 0)&&(gInterfaces[i].enable == 1)){	//fengwenchao modify 20110525	
		CW_COPY_NET_ADDR_PTR(&(gInterfaces[i].addr), ((CWNetworkLev4Address*)&(p->addr)));
	}
/*	if (ifi->ifi_flags & IFF_BROADCAST) { // try to bind broadcast address
		if((sock = socket(ifi->ifi_addr->sa_family, SOCK_DGRAM, 0)) < 0) {
			CWNetworkRaiseSystemError(CW_ERROR_CREATING);
		}
		
		// reuse address
		setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
		
	
		sock_set_port_cw(ifi->ifi_brdaddr, htons(port));
		
		if (bind(sock, (struct sockaddr*) ifi->ifi_brdaddr, CWNetworkGetAddressSize((CWNetworkLev4Address*)ifi->ifi_brdaddr)) < 0) {
			close(sock);
			if (errno == EADDRINUSE) {
				CWUseSockNtop(ifi->ifi_brdaddr,
				wid_syslog_debug_debug("EADDRINUSE: %s", str);
				);
			} else {
				CWUseSockNtop(ifi->ifi_brdaddr,
				wid_syslog_debug_debug("failed %s", str);
				);
				//CWDeleteList(&interfaceList, CWNetworkDeleteMHInterface);
				//CWNetworkRaiseSystemError(CW_ERROR_CREATING);
			}
		}
	
		CWUseSockNtop(ifi->ifi_brdaddr,
			wid_syslog_debug_debug("bound %s (%d, %s)", str, ifi->ifi_index, ifi->ifi_name);
		);
		
		// store socket inside multihomed socket
		if(pbr == NULL){
			CW_CREATE_OBJECT_ERR(pbr, struct CWMultiHomedInterface, return CWErrorRaise(CW_ERROR_OUT_OF_MEMORY, NULL););
			struct CWMultiHomedInterface* inf = gACSocket.interfaces;
			while(inf->if_next != NULL)
				inf = inf->if_next;
			inf->if_next = pbr;

		}
		
		wid_syslog_debug_debug("pbr->sock %d\n",pbr->sock);
		close(pbr->sock);
		pbr->sock = sock;		
		wid_syslog_debug_debug("pbr->sock %d\n",pbr->sock);
		pbr->kind = CW_BROADCAST_OR_ALIAS;
		pbr->systemIndex = ifi->ifi_index;
		CW_COPY_NET_ADDR_PTR(&(pbr->addr), ifi->ifi_brdaddr);
		
		// the next field is useful only if we are an IPv6 server. In this case, p->addr contains the IPv6
		// address of the interface and p->addrIPv4 contains the equivalent IPv4 address. On the other side,
		// if we are an IPv4 server p->addr contains the IPv4 address of the interface and p->addrIPv4 is
		// garbage.
		pbr->addrIPv4.ss_family = AF_UNSPEC;
		
	}
	*/
	return 0;
}


int Match_And_Modify_Interface(struct CWMultiHomedInterface *p,struct CWMultiHomedInterface *pbr, struct ifi_info *ifi)
{
	if((p->systemIndex != ifi->ifi_index)
	    ||(sock_cmp_addr((struct sockaddr*)(&p->addr), (struct sockaddr*)(ifi->ifi_addr), sizeof(CWNetworkLev4Address))))
    {
		Modify_Interface(p,pbr,ifi,CW_CONTROL_PORT);
	//	Modify_Interface(p,pbr,ifi,CW_CONTROL_PORT_AU);
	}
	return 0;
}

int Bind_BroadAddr_For_WID(struct ifi_info *ifi, int port)
{
	int yes = 1;
	CWSocket sock = -1;
	struct CWMultiHomedInterface *p = NULL;

	if (ifi->ifi_flags & IFF_BROADCAST)		// try to bind broadcast address
	{
		if((sock = socket(ifi->ifi_addr->sa_family, SOCK_DGRAM, 0)) < 0)
		{
			CWNetworkRaiseSystemError(CW_ERROR_CREATING);
		}
		
		// reuse address
		setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
	
		//sock_set_port_cw(ifi->ifi_brdaddr, htons(CW_CONTROL_PORT));
		sock_set_port_cw(ifi->ifi_brdaddr, htons(port));//zhanglei change
		if (bind(sock, (struct sockaddr*) ifi->ifi_brdaddr, CWNetworkGetAddressSize((CWNetworkLev4Address*)ifi->ifi_brdaddr)) < 0)
		{
			close(sock);
			if (errno == EADDRINUSE)
			{
				CWUseSockNtop(ifi->ifi_brdaddr,
					wid_syslog_debug_debug(WID_DEFAULT,"%s:%d EADDRINUSE: %s\n", __func__, __LINE__, str);
				);
			}
			else
			{
	
				CWUseSockNtop(ifi->ifi_brdaddr,
					wid_syslog_debug_debug(WID_DEFAULT,"%s:%d failed %s\n", __func__, __LINE__, str);
				);
				//CWDeleteList(&interfaceList, CWNetworkDeleteMHInterface);
				//CWNetworkRaiseSystemError(CW_ERROR_CREATING);
			}
		}
		
		CWUseSockNtop(ifi->ifi_brdaddr,
			wid_syslog_debug_debug(WID_DEFAULT,"%s:%d bound %s (%d, %s)\n", __func__, __LINE__, str, ifi->ifi_index, ifi->ifi_name);
		);
		
		// store socket inside multihomed socket
		
		CW_CREATE_OBJECT_ERR(p, struct CWMultiHomedInterface, {close(sock);return CWErrorRaise(CW_ERROR_OUT_OF_MEMORY, NULL);});
		memset(p->ifname, 0, IFI_NAME);
		strncpy(p->ifname, ifi->ifi_name, IFI_NAME);
		p->sock = sock; 		
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d pbr->sock %d\n", __func__, __LINE__, p->sock);
		p->kind = CW_BROADCAST_OR_ALIAS;
		p->systemIndex = ifi->ifi_index;
		p->systemIndexbinding = ifi->ifi_index_binding;
		CW_COPY_NET_ADDR_PTR(&(p->addr), ifi->ifi_brdaddr);
		
		// the next field is useful only if we are an IPv6 server. In this case, p->addr contains the IPv6
		// address of the interface and p->addrIPv4 contains the equivalent IPv4 address. On the other side,
		// if we are an IPv4 server p->addr contains the IPv4 address of the interface and p->addrIPv4 is
		// garbage.
		p->addrIPv4.ss_family = AF_UNSPEC;
		struct CWMultiHomedInterface* inf = gACSocket.interfaces;
		if(gACSocket.interfaces == NULL)
		{
			gACSocket.interfaces = p;
		}
		else
		{
			while(inf->if_next != NULL)
			{
				inf = inf->if_next;
			}	
			inf->if_next = p;
			p->if_next = NULL;
		}
		gACSocket.count++; // we add a socket to the multihomed socket		
	}
	
	return 0;
}

int Check_Listenning_If(char* ifname,struct ifi_info *ifi,char flag)
{
	int m = 0, n = 0/*,ret=0*/;
	struct CWMultiHomedInterface /*  *p=NULL,*/*p_next = NULL;
	p_next = gListenningIF.interfaces;
	wid_syslog_debug_debug(WID_DEFAULT,"%s:%d gListenningIF.count=%d gListenningIF.interfaces=%p p_next=%p.\n",
	                        __func__,__LINE__,gListenningIF.count,gListenningIF.interfaces,p_next);

	if(gListenningIF.count <= 0)
	{
	    return 0;
	}
	
	while(p_next != NULL)
	{
		if(ifname)
		{
		    m = strlen(ifname);
		}
		if(p_next->ifname)
		{
		    n = strlen(p_next->ifname);
		}
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d gListenningIF.count=%d m=%d,n=%d,ifname=%s,p_next->ifname=%s.\n",
                            		        __func__,__LINE__,gListenningIF.count,m,n,ifname,p_next->ifname);

		if((m == n) && (strcmp(ifname,p_next->ifname) == 0))
		{
			wid_syslog_debug_debug(WID_DEFAULT,"%s:%d m=%d,n=%d,ifname=%s,p_next->ifname=%s\n",__func__,__LINE__,m,n,ifname,p_next->ifname);
			if(flag == 1)
			{
				((struct sockaddr_in *)&(p_next->addr))->sin_addr.s_addr = ((struct sockaddr_in *) ifi->ifi_addr)->sin_addr.s_addr;
			}
			//ptr = p_next;
			return IF_HAS_BEEN_LISTENNING;
			//break;
		}
		p_next = p_next->if_next;
	}
	wid_syslog_debug_debug(WID_DEFAULT,"%s:%d p_next=%p.\n",__func__,__LINE__,p_next);
	return 0 ;
}

int Check_Listenning_Ip(char *ifname,unsigned int addr,LISTEN_FLAG flag,char nl_flag)
{
	int m = 0, n = 0/*,ret=0*/;
	struct CWMultiHomedInterface /*  *p=NULL,*/*p_next = NULL;
	p_next = gListenningIF.interfaces;
	char tmp_if[IFI_NAME];
	memset(tmp_if, 0, IFI_NAME);
	
	wid_syslog_debug_debug(WID_DEFAULT,"%s:%d gListenningIF.count=%d, gListenningIF.interfaces=%p\n", __func__, __LINE__, gListenningIF.count, gListenningIF.interfaces);
	
	if(gListenningIF.count <= 0)
	{
	    return 0;
	}
	wid_syslog_debug_debug(WID_DEFAULT,"%s:%d p_next=%p.\n", __func__, __LINE__, p_next);
	
	while(p_next != NULL)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d gListenningIF.count=%d.\n", __func__, __LINE__, gListenningIF.count);
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d m=%d,n=%d,ifname=%s,p_next->ifname=%s\n",__func__, __LINE__,m,n,ifname,p_next->ifname);
		if((((struct sockaddr_in *)&(p_next->addr))->sin_addr.s_addr == addr)&&(flag == p_next->lic_flag))
		{
			if(memcmp(p_next->ifname,tmp_if,IFI_NAME) != 0)
			{
				wid_syslog_debug_debug(WID_DEFAULT,"%s:%d p_next->ifname=%s,is NULL.\n",__func__, __LINE__,p_next->ifname);
			}
			else
			{
				memset(p_next->ifname,0,IFI_NAME);
				memcpy(p_next->ifname,ifname,IFI_NAME);
			}
			if(nl_flag == 1)
			{
				memset(p_next->ifname,0,IFI_NAME);
				memcpy(p_next->ifname,ifname,IFI_NAME);
			}
			wid_syslog_debug_debug(WID_DEFAULT,"%s:%d m=%d,n=%d,ifname=%s,p_next->ifname=%s,nl_flag=%d.\n",__func__, __LINE__,m,n,ifname,p_next->ifname,nl_flag);
			//ptr = p_next;
			return IF_HAS_BEEN_LISTENNING;
			//break;
		}
		p_next = p_next->if_next;
	}
	
	wid_syslog_debug_debug(WID_DEFAULT,"%s:%d p_next=%p.\n",__func__, __LINE__,p_next);
	
	return 0 ;
}

int Add_Listenning_IF(char *ifname)
{
	struct CWMultiHomedInterface *ptr = NULL;
	struct CWMultiHomedInterface *inf2 = gListenningIF.interfaces;
	
	CW_CREATE_OBJECT_ERR(ptr, struct CWMultiHomedInterface, return CWErrorRaise(CW_ERROR_OUT_OF_MEMORY, NULL););
	if(ptr == NULL)
	{
		wid_syslog_err(WAI_FUNC_LINE_FMT"interface %s begin listen memory alloc error(%d) %s\n",\
					WAI_FUNC_LINE_LITERAL, ifname, errno, strerror(errno));
		perror("malloc");
		return 0;
	}
	
	memset(ptr, 0, sizeof(struct CWMultiHomedInterface));
	memset(ptr->ifname,0,IFI_NAME);
	memcpy(ptr->ifname,ifname,strlen(ifname));
	
	ptr->if_next = NULL;
	ptr->lic_flag = DOWN_LINK_IF_TYPE;

	if(gListenningIF.interfaces == NULL)
	{
		gListenningIF.interfaces = ptr;
		ptr->if_next = NULL;
		gListenningIF.count ++;
	}
	else
	{
		int ret = 0;
		if(ret == 0)
		{
			while(inf2->if_next != NULL)
			{
				inf2 = inf2->if_next;				
			}
			inf2->if_next = ptr;
			ptr->if_next = NULL;
			gListenningIF.count ++;
		}
		else
		{
			CW_FREE_OBJECT(ptr);
		}
	}
	
	wid_syslog_info(WAI_FUNC_LINE_FMT"interface %s add to listen list got count %u\n",\
				WAI_FUNC_LINE_LITERAL, ifname, gListenningIF.count);
	return 0;
}

int Add_Listenning_IP(char *ifname,unsigned int addr,LISTEN_FLAG flag)
{
	struct CWMultiHomedInterface *ptr = NULL;
	struct CWMultiHomedInterface *inf2 = gListenningIF.interfaces;
	
	CW_CREATE_OBJECT_ERR(ptr, struct CWMultiHomedInterface, return CWErrorRaise(CW_ERROR_OUT_OF_MEMORY, NULL););
	if(ptr == NULL)
	{
		wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
		perror("malloc");
		return 0;
	}
	
	memset(ptr,0,sizeof(struct CWMultiHomedInterface));
	memset(ptr->ifname,0,IFI_NAME);
	memcpy(ptr->ifname,ifname,strlen(ifname));
	
	ptr->lic_flag = flag;
	((struct sockaddr_in *)&(ptr->addr))->sin_addr.s_addr = addr;
	ptr->if_next = NULL;
	
	wid_syslog_debug_debug(WID_DEFAULT,"%s,gListenningIF.count=%d,gListenningIF.interfaces=%p.\n",__func__,gListenningIF.count,gListenningIF.interfaces);

	if(gListenningIF.interfaces == NULL)
	{
		gListenningIF.interfaces = ptr;
		ptr->if_next = NULL;
		gListenningIF.count ++;
		wid_syslog_debug_debug(WID_DEFAULT,"%s,11gListenningIF.count ++,count=%d\n",__func__,gListenningIF.count);
	}
	else
	{
		int ret = 0;
		ret = Check_Listenning_Ip(ptr->ifname,addr,flag,0);
		if(ret == 0)
		{
			while(inf2->if_next != NULL)
			{
				inf2 = inf2->if_next;				
			}
			inf2->if_next = ptr;
			ptr->if_next = NULL;
			gListenningIF.count ++;
			wid_syslog_debug_debug(WID_DEFAULT,"%s,22gListenningIF.count ++,count=%d\n",__func__,gListenningIF.count);
		}
		else
		{
			CW_FREE_OBJECT(ptr);
		}
	}
	return 0;
}

int check_bind_sock_info(struct ifi_info *ifi,LISTEN_FLAG lic_flag)
{
	struct CWMultiHomedInterface *tmp = gACSocket.interfaces;
	struct CWMultiHomedInterface *tmp_next = gACSocket.interfaces;
	
	unsigned int ipaddr = ((struct sockaddr_in *)(ifi->ifi_addr))->sin_addr.s_addr;
	if(tmp == NULL)
		return 0;

	if((((struct sockaddr_in *)&(tmp->addr))->sin_addr.s_addr == ipaddr)&&(tmp->lic_flag == lic_flag)){
		tmp->lic_flag |= lic_flag;
		return 1;
	}
	else{
		while(tmp_next != NULL){	
			if((((struct sockaddr_in *)&(tmp_next->addr))->sin_addr.s_addr == ipaddr)&&(tmp_next->lic_flag == lic_flag)){
				tmp_next->lic_flag |= lic_flag;
				return 1;
			}
			tmp = tmp_next;
			tmp_next = tmp->if_next;
		}
	}
	return 0;
}



int Bind_Interface_For_WID(struct ifi_info *ifi, int port,LISTEN_FLAG lic_flag)
{
	int yes = 1;
	CWSocket sock;
	int i = 0;
	struct CWMultiHomedInterface *p = NULL;

	if((lic_flag != LIC_TYPE)&&(check_bind_sock_info(ifi,lic_flag) == 1))
	{
		return 1;
	}
	
	if((sock = socket(ifi->ifi_addr->sa_family, SOCK_DGRAM, 0)) < 0)
	{
		CWNetworkRaiseSystemError(CW_ERROR_CREATING);
	}
	
	// reuse address
	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
	
	// bind address
	//sock_set_port_cw(ifi->ifi_addr, htons(CW_CONTROL_PORT));
	sock_set_port_cw(ifi->ifi_addr, htons(port));//zhanglei change
	if(bind(sock, (struct sockaddr*) ifi->ifi_addr, CWNetworkGetAddressSize((CWNetworkLev4Address*)ifi->ifi_addr)) < 0)
	{
		CWUseSockNtop(ifi->ifi_addr,
				wid_syslog_err(WAI_FUNC_LINE_FMT""WAI_GENERAL_FMT"bind sock %u address %s error(%d) %s\n", \
							WAI_FUNC_LINE_LITERAL, sock, str, errno, strerror(errno)););
		close(sock);
	}

	CWUseSockNtop(ifi->ifi_addr,
		wid_syslog_notice(WAI_FUNC_LINE_FMT""WAI_GENERAL_FMT"bind sock %d to %s index %#x %s\n", \
					WAI_FUNC_LINE_LITERAL, sock,ifi->ifi_name, ifi->ifi_index,str););
		
	// store socket inside multihomed socket
	
	CW_CREATE_OBJECT_ERR(p, struct CWMultiHomedInterface, {close(sock);return CWErrorRaise(CW_ERROR_OUT_OF_MEMORY, NULL);});
	memset(p->ifname, 0, IFI_NAME);
	strncpy(p->ifname, ifi->ifi_name, IFI_NAME);
	p->sock = sock;
	p->ipv6Flag = 0;
	p->lic_flag = lic_flag;
	if(strncmp(ifi->ifi_name, "lo", 2))  // don't consider loopback an interface
	{
		p->kind = CW_PRIMARY;
	}
	else
	{
		p->kind = CW_BROADCAST_OR_ALIAS; // should be BROADCAST_OR_ALIAS_OR_MULTICAST_OR_LOOPBACK ;-)
#ifdef CW_DEBUGGING
		if(!strncmp(ifi->ifi_name, "lo", 2))
		{
			p->kind = CW_PRIMARY;
		}
#endif
	}
	p->systemIndex = ifi->ifi_index;
	
	p->systemIndexbinding = ifi->ifi_index_binding;
	// the next field is useful only if we are an IPv6 server. In this case, p->addr contains the IPv6
	// address of the interface and p->addrIPv4 contains the equivalent IPv4 address. On the other side,
	// if we are an IPv4 server p->addr contains the IPv4 address of the interface and p->addrIPv4 is
	// garbage.
	p->addrIPv4.ss_family = AF_UNSPEC;
	CW_COPY_NET_ADDR_PTR(&(p->addr), ifi->ifi_addr);
	if(p->kind == CW_PRIMARY)
	{
		for(i = 0; i < gMaxInterfacesCount; i++)
		{
			if(gInterfaces[i].enable == 0)
			{
				CW_COPY_NET_ADDR_PTR(&(gInterfaces[i].addr), ((CWNetworkLev4Address*)&(p->addr)) );
				CW_COPY_NET_ADDR_PTR(&(gInterfaces[i].addrIPv4), ((struct sockaddr_in*)&(p->addr)) );
				gInterfaces[i].enable = 1;
				gInterfaces[i].WTPCount = 0;
				p->gIf_Index = i;
				break;
			}
		}
	}	
	struct CWMultiHomedInterface* inf = gACSocket.interfaces;
	if(gACSocket.interfaces == NULL)
	{
		gACSocket.interfaces = p;
		p->if_next = NULL;
	}
	else
	{
		while(inf->if_next != NULL)
		{
		    inf = inf->if_next;
		}
		inf->if_next = p;			
		p->if_next = NULL;
	}
	gACSocket.count++; // we add a socket to the multihomed socket
		
	return 0;
}

void Check_WLAN_WTP_IF_Index(struct ifi_info *ifi, char *ifname)
{
	int i = 0, j = 0;
	
	for(i = 1;i < WTP_NUM; i++)
	{
		if((AC_WTP[i] != NULL)
		    && (strlen(AC_WTP[i]->BindingIFName) == strlen(ifname))
		    && (strncmp(AC_WTP[i]->BindingIFName,ifname,IFI_NAME) == 0)
		    && (AC_WTP[i]->BindingSystemIndex != ifi->ifi_index))
	    {
			AC_WTP[i]->BindingSystemIndex = ifi->ifi_index;
		}
	}
	for(j = 1; j < WLAN_NUM; j++)
	{
		if(AC_WLAN[j] != NULL)
		{
			struct ifi *wif = AC_WLAN[j]->Wlan_Ifi;
			while(wif != NULL)
			{
				if((strlen(wif->ifi_name) == strlen(ifname))
				    && (strncmp(wif->ifi_name,ifname,IFI_NAME) == 0)
				    && (wif->ifi_index != ifi->ifi_index))
			    {
					wif->ifi_index = ifi->ifi_index;
					break;
				}
				wif = wif->ifi_next;
			}
		}
	}
}

unsigned int is_local_board_interface(const char *ifname)
{
	/*********************hanhui upgrade***************
#define SIOCGIFPRIVFLAGS 0x89b0
	***************************************************/
#define SIOCGIFPRIVFLAGS 0x89b1
	/**************************end*********************/

	#define IFF_RPA 0x20
	int sock = -1;
	struct ifreq tmp;

	if (NULL == ifname) {
		return -1;
	}
	memset(&tmp, 0, sizeof(tmp));
	strcpy(tmp.ifr_name, ifname);

	sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	if (sock < 0) {
		return -1;
	}

	if (ioctl(sock, SIOCGIFPRIVFLAGS , &tmp) < 0) {
		close(sock);
		return -1;
	}
	close(sock);
	
	return ((tmp.ifr_flags & IFF_RPA) != IFF_RPA);	
}

int Check_And_Bind_Interface_For_WID(char *ifname)
{
	int ret = 0;
	int retv6 = 0;
	int i = 0;
	unsigned int IGNORE_UBSV ip = 0;
	struct ifi_info *ifi_tmp = NULL;
	struct ifi *tmp = NULL;
	struct ifi *tmp2 = NULL;
	if(!ifname)
	{
		wid_syslog_err(WAI_FUNC_LINE_FMT""WAI_GENERAL_FMT"interface name nil when check and bind\n",WAI_FUNC_LINE_LITERAL);
		return PARAM_NULL_POINTER;
	}
	ifi_tmp = (struct ifi_info*)calloc(1, sizeof(struct ifi_info));
	if(!ifi_tmp)
	{
		wid_syslog_err(WAI_FUNC_LINE_FMT""WAI_GENERAL_FMT"calloc error when check and bind interface %s\n", \
					WAI_FUNC_LINE_LITERAL, ifname);
		return MALLOC_ERROR;
	}
	memset(ifi_tmp->ifi_name, 0, sizeof(ifi_tmp->ifi_name));
	strncpy(ifi_tmp->ifi_name, ifname, sizeof(ifi_tmp->ifi_name));
	//struct CWMultiHomedInterface *p = NULL,*pbr = NULL;	
#if NOSOFTAC	
	if(!is_local_board_interface(ifname))
	{
		CW_FREE_OBJECT(ifi_tmp);
		return WID_INTERFACE_NOT_BE_LOCAL_BOARD;	
	}
#endif
	ret = Get_Interface_Info(ifname, ifi_tmp);
	if(ret != 0)
	{		
		Delete_Interface(ifname, ifi_tmp->ifi_index);

		CW_FREE_OBJECT(ifi_tmp->ifi_addr);
		CW_FREE_OBJECT(ifi_tmp->ifi_brdaddr);
		CW_FREE_OBJECT(ifi_tmp);
		
		return ret;		
	}
	if(WID_IF == NULL)
	{
		if(0 == isNoCheck)
		{
			if((ifi_tmp->ifi_bflags&IFF_BINDING_FLAG) == IFF_BINDING_FLAG)
			{
				CW_FREE_OBJECT(ifi_tmp->ifi_addr);
				CW_FREE_OBJECT(ifi_tmp->ifi_brdaddr);
			   	CW_FREE_OBJECT(ifi_tmp);
		   
		   		wid_syslog_err(WAI_FUNC_LINE_FMT""WAI_GENERAL_FMT"new list interface %s check flag %#x found already binded\n", \
							WAI_FUNC_LINE_LITERAL, ifname, ifi_tmp->ifi_bflags);
			   	return IF_BINDING_FLAG;
		   	}
			wid_syslog_err(WAI_FUNC_LINE_FMT""WAI_GENERAL_FMT"new list interface %s check flag %#x found no binding\n", \
						WAI_FUNC_LINE_LITERAL, ifname, ifi_tmp->ifi_bflags);
		}
		else
		{
			wid_syslog_err(WAI_FUNC_LINE_FMT""WAI_GENERAL_FMT"new list interface %s skip flag check for loading config phase\n", \
						WAI_FUNC_LINE_LITERAL, ifname);
		}

		tmp = (struct ifi*)malloc(sizeof(struct ifi));
		memset(tmp, 0, sizeof(struct ifi));
		memcpy(tmp->ifi_name, ifi_tmp->ifi_name, IFI_NAME);
		tmp->lic_flag = DOWN_LINK_IF_TYPE;
		WID_IF = tmp;
#if NOSOFTAC
		Set_Interface_binding_Info(ifi_tmp->ifi_name,1);//fengwenchao copy from 1318 for AXSSZFI-839
#endif 
		Add_Listenning_IF(ifname);
		//printf("1111111tmp->ifname %s",tmp->ifi_name);
	}
	else
	{
		tmp = WID_IF;
		while(tmp != NULL)
		{
			if((tmp->lic_flag == DOWN_LINK_IF_TYPE)&&(memcmp(tmp->ifi_name,ifi_tmp->ifi_name,IFI_NAME)==0))
			{
				CW_FREE_OBJECT(ifi_tmp->ifi_addr);
				CW_FREE_OBJECT(ifi_tmp->ifi_brdaddr);
				CW_FREE_OBJECT(ifi_tmp);
				wid_syslog_debug(WAI_FUNC_LINE_FMT""WAI_GENERAL_FMT"interface %s has already been in bind iface list\n", \
								WAI_FUNC_LINE_LITERAL, ifname);
				return 0;
			}
			tmp = tmp->ifi_next;
		}
		/*fengwenchao copy from 1318 for AXSSZFI-839*/
		
		if(0 == isNoCheck)
		{
			if((ifi_tmp->ifi_bflags&IFF_BINDING_FLAG)==IFF_BINDING_FLAG)
			{				
				CW_FREE_OBJECT(ifi_tmp->ifi_addr);
				CW_FREE_OBJECT(ifi_tmp->ifi_brdaddr);
				CW_FREE_OBJECT(ifi_tmp);
			
				wid_syslog_err(WAI_FUNC_LINE_FMT""WAI_GENERAL_FMT"interface %s check flag %#x found already binded\n", \
						WAI_FUNC_LINE_LITERAL, ifname, ifi_tmp->ifi_bflags);
				return IF_BINDING_FLAG;
			}
			wid_syslog_err(WAI_FUNC_LINE_FMT""WAI_GENERAL_FMT"interface %s check flag %#x found no binding\n", \
						WAI_FUNC_LINE_LITERAL, ifname, ifi_tmp->ifi_bflags);
		}
		else
		{
			wid_syslog_err(WAI_FUNC_LINE_FMT""WAI_GENERAL_FMT"interface %s skip flag check for loading config phase\n", \
						WAI_FUNC_LINE_LITERAL, ifname);
		}
		/*fengwenchao copy end*/
		tmp = (struct ifi*)malloc(sizeof(struct ifi));
		memset(tmp, 0, sizeof(struct ifi));
		memcpy(tmp->ifi_name, ifi_tmp->ifi_name, IFI_NAME);
		tmp2 = WID_IF;
		tmp->lic_flag = DOWN_LINK_IF_TYPE;
		WID_IF = tmp;
		WID_IF->ifi_next = tmp2;
#if NOSOFTAC
		Set_Interface_binding_Info(ifi_tmp->ifi_name,1);//fengwenchao copy from 1318 for AXSSZFI-839
#endif
		Add_Listenning_IF(ifname);
		//printf("222222222tmp->ifname %s",tmp->ifi_name);
	}
/*	printf("ifi->addr_num %d\n",ifi->addr_num);
	Check_Current_Interface_and_delete(ifname,ifi);
	printf("ifi->addr_num %d\n",ifi->addr_num);
	if(ifi->check_brdaddr < 2)
	{
		ret = Bind_BroadAddr_For_WID(ifi,CW_CONTROL_PORT);		
		ret = Bind_BroadAddr_For_WID(ifi,CW_CONTROL_PORT_AU);
	}*/
	for(i = 0; i < ifi_tmp->addr_num; i++)
	{		
		if(ifi_tmp->addr[i] == 0)
		{
			continue;
		}
		memcpy(&((struct sockaddr_in *) ifi_tmp->ifi_addr)->sin_addr, &(ifi_tmp->addr[i]), sizeof(struct in_addr));
	    
		ret = Bind_Interface_For_WID(ifi_tmp,CW_CONTROL_PORT,DOWN_LINK_IF_TYPE);
		if(ret == 1)
		{
			ret = 0;
			continue;
		}
		//ret = Bind_Interface_For_WID(ifi_tmp,CW_CONTROL_PORT_AU);
		ip = ((struct sockaddr_in *)(ifi_tmp->ifi_addr))->sin_addr.s_addr;
#if NOSOFTAC
		WIDWsm_VRRPIFOp((unsigned char*)ifi_tmp->ifi_name,ip,VRRP_REG_IF);
#endif
		if(gNetworkPreferredFamily == CW_IPv6)
		{
			///retv6 = ipv6_bind_interface_for_wid(ifi_tmp,CW_CONTROL_PORT);
			//retv6 = ipv6_bind_interface_for_wid(ifi_tmp,CW_CONTROL_PORT_AU);
		}
		Check_WLAN_WTP_IF_Index(ifi_tmp, ifname);
	}
	
	gInterfacesCount = CWNetworkCountInterfaceAddresses(&gACSocket);
	gInterfacesCountIpv4 = CWNetworkCountInterfaceAddressesIpv4(&gACSocket);
	gInterfacesCountIpv6 = CWNetworkCountInterfaceAddressesIpv6(&gACSocket);
	//printf("gInterfacesCount %d\n",gInterfacesCount);

	CW_FREE_OBJECT(ifi_tmp->ifi_addr);
	CW_FREE_OBJECT(ifi_tmp->ifi_brdaddr);
	CW_FREE_OBJECT(ifi_tmp);

	if((ret == 0) && (retv6 == BINDING_IPV6_ADDRE_RROR))
	{
		return retv6;
	}
	return ret;
}

int Check_And_Bind_Ipaddr_For_WID(unsigned int ipaddr,LISTEN_FLAG flag)
{
	int ret = 0;
	int retv6 = 0;
	int i = 0;
	unsigned int ip = 0;
	char ifname[IFI_NAME];
	memset(ifname, 0, IFI_NAME);
	struct ifi *tmp = NULL;
	struct ifi *tmp2 = NULL;
	
	struct ifi_info *ifi_tmp = (struct ifi_info*)calloc(1, sizeof(struct ifi_info));
	memset(ifi_tmp, 0, sizeof(struct ifi_info));
	memset(ifi_tmp->ifi_name,0,sizeof(ifi_tmp->ifi_name));
	ifi_tmp->addr[0] = ipaddr;
	ifi_tmp->addr_num = 1;
	
	ret = Get_Ipaddr_Info(ifi_tmp);
	wid_syslog_debug_debug(WID_DEFAULT,"%s:%d ipaddr %u ret %d.\n", __func__, __LINE__, ipaddr, ret);
	
	strncpy(ifname,ifi_tmp->ifi_name,sizeof(ifi_tmp->ifi_name));
	if(ret != NO_IF_HAS_THIS_IP)
	{
		if(!is_local_board_interface(ifname))
		{
			CW_FREE_OBJECT(ifi_tmp->ifi_addr);
			CW_FREE_OBJECT(ifi_tmp->ifi_brdaddr);			
			CW_FREE_OBJECT(ifi_tmp);
			return WID_INTERFACE_NOT_BE_LOCAL_BOARD;	
		}
		//struct listen_if_info *pnode = NULL;
		if(ret != 0)
		{
			Delete_Interface(ifname, ifi_tmp->ifi_index);
			CW_FREE_OBJECT(ifi_tmp->ifi_addr);
			CW_FREE_OBJECT(ifi_tmp->ifi_brdaddr);
			CW_FREE_OBJECT(ifi_tmp);
			return ret;		
		}	
	}
	else
	{
		ifi_tmp->addr_num = 0;
	}
	wid_syslog_debug_debug(WID_DEFAULT,"%s,%d.",__func__,__LINE__);
	
	if(WID_IF == NULL)
	{
		tmp = (struct ifi*)malloc(sizeof(struct ifi));
		memset(tmp,0,sizeof(struct ifi));
		memset(tmp->ifi_name,0,IFI_NAME);
		memcpy(tmp->ifi_name,ifi_tmp->ifi_name,IFI_NAME);
		tmp->ifi_next = NULL;
		tmp->addr = ifi_tmp->addr[0];
		tmp->lic_flag = flag;
		WID_IF = tmp;
		
		wid_syslog_debug_debug(WID_DEFAULT,"%s,%d.",__func__,__LINE__);
		Add_Listenning_IP(ifname,tmp->addr,flag);
		//printf("1111111tmp->ifname %s",tmp->ifi_name);
	}
	else
	{
		tmp = WID_IF;
		while(tmp != NULL)
		{
			//if(memcmp(tmp->ifi_name,ifi_tmp->ifi_name,IFI_NAME)==0)
			if((tmp->addr == ifi_tmp->addr[0])&&(tmp->lic_flag == flag))
			{
				CW_FREE_OBJECT(ifi_tmp->ifi_addr);
				CW_FREE_OBJECT(ifi_tmp->ifi_brdaddr);
				CW_FREE_OBJECT(ifi_tmp);
				wid_syslog_debug_debug(WID_DEFAULT,"interface has been in WID_IF\n");
				return 0;
			}
			tmp = tmp->ifi_next;
		}
		tmp = (struct ifi*)malloc(sizeof(struct ifi));
		memset(tmp,0,sizeof(struct ifi));
		memset(tmp->ifi_name,0,IFI_NAME);
		memcpy(tmp->ifi_name,ifi_tmp->ifi_name,IFI_NAME);
		tmp->addr = ifi_tmp->addr[0];
		tmp->lic_flag = flag;
		tmp->ifi_next = NULL;
		tmp2 = WID_IF;
		WID_IF = tmp;
		WID_IF->ifi_next = tmp2;		
		
		wid_syslog_debug_debug(WID_DEFAULT,"%s,%d.",__func__,__LINE__);
		Add_Listenning_IP(ifname,tmp->addr,flag);
	}
	wid_syslog_debug_debug(WID_DEFAULT,"%s,%d ifi_tmp->addr_num %d.",__func__,__LINE__, ifi_tmp->addr_num);
		
	for(i = 0; i < ifi_tmp->addr_num; i++)
	{		
		if(ifi_tmp->addr[i] == 0)
			continue;
		memcpy(&((struct sockaddr_in *) ifi_tmp->ifi_addr)->sin_addr,&(ifi_tmp->addr[i]),sizeof(struct in_addr));
		//if(Lic_ip.lic_active_ac_ip == ((struct sockaddr_in *) ifi_tmp->ifi_addr)->sin_addr.s_addr)
		if(flag == LIC_TYPE)
		{
			ret = Bind_Interface_For_WID(ifi_tmp,WID_LIC_AC_PORT,LIC_TYPE);	 
			wid_syslog_debug_debug(WID_DBUS,"%s:%d WID_LIC_AC_PORT %d.\n",__func__,__LINE__,WID_LIC_AC_PORT);
		}
		else
		{
			wid_syslog_debug_debug(WID_DBUS,"%s:%d CW_CONTROL_PORT %d.\n",__func__,__LINE__, CW_CONTROL_PORT);
			
			ret = Bind_Interface_For_WID(ifi_tmp,CW_CONTROL_PORT,DOWN_LINK_IP_TYPE);		
			if(ret == 1)
			{
				ret = 0;
				continue;
			}			//ret = Bind_Interface_For_WID(ifi_tmp,CW_CONTROL_PORT_AU);
			ip = ((struct sockaddr_in *)(ifi_tmp->ifi_addr))->sin_addr.s_addr;
			WIDWsm_VRRPIFOp((unsigned char*)ifi_tmp->ifi_name,ip,VRRP_REG_IF);
			
			if(gNetworkPreferredFamily == CW_IPv6)
			{
				///retv6 = ipv6_bind_interface_for_wid(ifi_tmp,CW_CONTROL_PORT);
				//retv6 = ipv6_bind_interface_for_wid(ifi_tmp,CW_CONTROL_PORT_AU);
			}
			Check_WLAN_WTP_IF_Index(ifi_tmp,ifname);
		}
	}
	
	gInterfacesCount = CWNetworkCountInterfaceAddresses(&gACSocket);
    gInterfacesCountIpv4 = CWNetworkCountInterfaceAddressesIpv4(&gACSocket);
	gInterfacesCountIpv6 = CWNetworkCountInterfaceAddressesIpv6(&gACSocket);
	//printf("gInterfacesCount %d\n",gInterfacesCount);

	CW_FREE_OBJECT(ifi_tmp->ifi_addr);
	CW_FREE_OBJECT(ifi_tmp->ifi_brdaddr);
	CW_FREE_OBJECT(ifi_tmp);
	if((ret == 0)&&(retv6 == BINDING_IPV6_ADDRE_RROR))
	{
		return retv6;
	}
	return ret;
}


//added end
int WID_ADD_IF_APPLY_WLAN(unsigned char WlanID, char * ifname)
{
	int ret = 0;
	int sockfd = -1;
	struct ifreq ifr;
	struct ifi *wif = NULL;
	struct ifi *wifnext = NULL;
	
	if(AC_WLAN[WlanID]->Status == 0)
	{
		return WLAN_BE_ENABLE;
	}

	ret = Check_And_Bind_Interface_For_WID(ifname);
	if(ret != 0)
	{
		return ret;
	}
	
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);	
	if(sockfd < 0)
	{
		return WID_DBUS_ERROR;
	}

	strncpy(ifr.ifr_name,ifname, sizeof(ifr.ifr_name));
	
	if (ioctl(sockfd, SIOCGIFINDEX, &ifr) == -1)//bind to a interface
	{
		close(sockfd);
		return APPLY_IF_FAIL;
	}
	close(sockfd);
	wif = (struct ifi*)malloc(sizeof(struct ifi));
	memset(wif->ifi_name,0,ETH_IF_NAME_LEN);
	memcpy(wif->ifi_name,ifname,strlen(ifname));
	wif->ifi_index = ifr.ifr_ifindex;
	wif->nas_id_len = 0;
	memset(wif->nas_id,0,NAS_IDENTIFIER_NAME);
	wif->ifi_next = NULL;
	
	if(AC_WLAN[WlanID]->Wlan_Ifi == NULL)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d wlan%d binding ifname:%s sysindex:%d\n",__func__,__LINE__,WlanID,ifname,wif->ifi_index);
		AC_WLAN[WlanID]->Wlan_Ifi = wif ;
		AC_WLAN[WlanID]->Wlan_Ifi->ifi_next = NULL;
	}
	else
	{
		wifnext = AC_WLAN[WlanID]->Wlan_Ifi;
		while(wifnext != NULL)
		{	
			if(wifnext->ifi_index == wif->ifi_index)
			{				
				CW_FREE_OBJECT(wif);
				return 0;
			}
			wifnext = wifnext->ifi_next;
		}
		
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d wlan%d binding ifname:%s sysindex:%d\n",__func__,__LINE__,WlanID,ifname,wif->ifi_index);
		wifnext = AC_WLAN[WlanID]->Wlan_Ifi;
		while(wifnext->ifi_next != NULL)
		{	
			wifnext = wifnext->ifi_next;
		}
		
		wifnext->ifi_next= wif;
	}
	AC_WLAN[WlanID]->ifcount++;

	return 0;
}


int WID_ADD_IF_APPLY_WLAN_ipv6(unsigned char WlanID, char * ifname)
{
	if(AC_WLAN[WlanID]->Status == 0)
	{
		return WLAN_BE_ENABLE;
	}	
	
	struct ifreq	ifr;
	struct ifi *wif = NULL;
	struct ifi *wifnext = NULL;	
	struct ifi * tmp = NULL;
	struct ifi * tmp2 = NULL;
	int i = 0;
	int ret = 0;
	int isystemindex = 0;
	struct ifi_info *ifi_tmp = (struct ifi_info*)calloc(1, sizeof(struct ifi_info));
	memset(ifi_tmp->ifi_name,0,sizeof(ifi_tmp->ifi_name));
	strncpy(ifi_tmp->ifi_name,ifname,sizeof(ifi_tmp->ifi_name));

	struct tag_ipv6_addr_list *ipv6list = (struct tag_ipv6_addr_list *)malloc(sizeof(struct tag_ipv6_addr_list));
	if(ipv6list == NULL)
	{
		CW_FREE_OBJECT(ifi_tmp);
		return BINDING_IPV6_ADDRE_RROR;
	}
	ipv6list->ifindex = 0;
	ipv6list->ipv6list = NULL;
	ipv6list->ipv6num = 0;
	
	ret = get_if_addr_ipv6_list(ifname, ipv6list);
	if(ret != 0)
	{
		if(istryreadipv6addr == 0)
		{
			for(i=0;i<READ_IFNET_INFO_COUNT;i++)
			{
				struct timeval tval;
				tval.tv_sec = 0;
				tval.tv_usec = 100000;
				select(0,NULL,NULL,NULL,&tval); 
				
				ret = get_if_addr_ipv6_list(ifname, ipv6list);
				wid_syslog_debug_debug(WID_DEFAULT,"get ipv6 retry count %d",i);

				if(ret == 0)
				{	
					istryreadipv6addr = 1;
					break;
				}
				istryreadipv6addr = 1;
			}
		}
		if(ret != 0)
		{
			CW_FREE_OBJECT(ifi_tmp);
			free_ipv6_addr_list(ipv6list);
			ret = BINDING_IPV6_ADDRE_RROR;
			return ret;
		}
	}
	struct tag_ipv6_addr *ipv6addr = ipv6list->ipv6list;
		
	ifi_tmp->ifi_addr6 = (struct sockaddr*)calloc(1, sizeof(struct sockaddr_in6));
	isystemindex = ipv6list->ifindex;
	//display_ipv6_addr_list(ipv6list);
	//free_ipv6_addr_list(ipv6list);
	//display_ipv6_addr_list(ipv6list);	
	
	if(WID_IF_V6 == NULL)
	{
		for(i = 0; i < ipv6list->ipv6num; i++)
		{
			inet_pton(AF_INET6, (char*)ipv6addr->ipv6addr, &(((struct sockaddr_in6*)ifi_tmp->ifi_addr6)->sin6_addr));
			ret = ipv6_bind_interface_for_wid(ifi_tmp,CW_CONTROL_PORT);
			//ret = ipv6_bind_interface_for_wid(ifi_tmp,CW_CONTROL_PORT_AU);
			WIDWsm_VRRPIFOp_IPv6(ifi_tmp,VRRP_REG_IF);
			ipv6addr = ipv6addr->next;
		}	

		if(ret == 0)
		{
		   	tmp = (struct ifi*)malloc(sizeof(struct ifi));
			memset(tmp,0,sizeof(struct ifi));
			memcpy(tmp->ifi_name,ifname,strlen(ifname));
			
			tmp->ifi_index = isystemindex;
			printf("tmp->ifi_index = %d\n",tmp->ifi_index);
			tmp->isipv6addr = 1;
			WID_IF_V6 = tmp;
		}
		else
		{
			free(ifi_tmp->ifi_addr6);
			ifi_tmp->ifi_addr6 = NULL;
			free(ifi_tmp);
			ifi_tmp = NULL;
			free_ipv6_addr_list(ipv6list);
			return ret;
		}		
	}
	else
	{
		tmp = WID_IF_V6;
		while(tmp != NULL)
		{
			if((strlen(ifname) == strlen(tmp->ifi_name))&&(strcmp(tmp->ifi_name,ifname)==0))
			{
				isystemindex = tmp->ifi_index;
				break;
			}
			tmp = tmp->ifi_next;
		}

		if(tmp == NULL)
		{
			for(i = 0; i < ipv6list->ipv6num; i++)
			{
				inet_pton(AF_INET6, (char*)ipv6addr->ipv6addr, &(((struct sockaddr_in6*)ifi_tmp->ifi_addr6)->sin6_addr));
				ret = ipv6_bind_interface_for_wid(ifi_tmp,CW_CONTROL_PORT);
			//	ret = ipv6_bind_interface_for_wid(ifi_tmp,CW_CONTROL_PORT_AU);
				WIDWsm_VRRPIFOp_IPv6(ifi_tmp,VRRP_REG_IF);
				ipv6addr = ipv6addr->next;
			}	

			if (ret == 0)
			{
				tmp = (struct ifi*)malloc(sizeof(struct ifi));
				memset(tmp, 0, sizeof(struct ifi));
				memcpy(tmp->ifi_name, ifname, strlen(ifname));
				tmp->ifi_index = isystemindex;
				tmp->isipv6addr = 1;
				tmp2 = WID_IF_V6;
				WID_IF_V6 = tmp;
				WID_IF_V6->ifi_next = tmp2;	
			}
			else
			{
				CW_FREE_OBJECT(ifi_tmp->ifi_addr6);
				CW_FREE_OBJECT(ifi_tmp);
				free_ipv6_addr_list(ipv6list);
				return ret;
			}
		}
	}
		
	gInterfacesCount = CWNetworkCountInterfaceAddresses(&gACSocket);
	gInterfacesCountIpv4 = CWNetworkCountInterfaceAddressesIpv4(&gACSocket);
	gInterfacesCountIpv6 = CWNetworkCountInterfaceAddressesIpv6(&gACSocket);
	CW_FREE_OBJECT(ifi_tmp->ifi_addr6);
	CW_FREE_OBJECT(ifi_tmp);
	free_ipv6_addr_list(ipv6list);

	if(ret != 0)
	return ret;

	ifr.ifr_ifindex = isystemindex;

	wif = (struct ifi*)malloc(sizeof(struct ifi));
	memset(wif->ifi_name,0,ETH_IF_NAME_LEN);
	memcpy(wif->ifi_name,ifname,strlen(ifname));
	wif->ifi_index = ifr.ifr_ifindex;
	printf("wif->ifi_index = %d\n",wif->ifi_index);
	wif->nas_id_len = 0;//zhanglei add
	memset(wif->nas_id,0,NAS_IDENTIFIER_NAME);//zhanglei add
	wif->ifi_next = NULL;
	wif->isipv6addr = 1;
	
	if(AC_WLAN[WlanID]->Wlan_Ifi == NULL)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d wlan%d binding ifname:%s sysindex:%d**\n",__func__,__LINE__,WlanID,ifname,wif->ifi_index);
		AC_WLAN[WlanID]->Wlan_Ifi = wif ;
		AC_WLAN[WlanID]->Wlan_Ifi->ifi_next = NULL;
	}
	else
	{
		wifnext = AC_WLAN[WlanID]->Wlan_Ifi;
		while(wifnext != NULL)
		{	
			if(wifnext->ifi_index == wif->ifi_index)
			{
				//printf("warnning you have binding this wlan eth ,please do not binding this again");
				CW_FREE_OBJECT(wif);
				return 0;
			}
			wifnext = wifnext->ifi_next;
		}
		
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d wlan%d binding ifname :%s sysindex:%d**\n",__func__,__LINE__,WlanID,ifname,wif->ifi_index);
		wifnext = AC_WLAN[WlanID]->Wlan_Ifi;
		while(wifnext->ifi_next!= NULL)
		{	
			wifnext = wifnext->ifi_next;
		}
		
		wifnext->ifi_next= wif;
		//wifnext->ifi_next = NULL;
	}
	AC_WLAN[WlanID]->ifcount++;

	//add wlan to the auto ap login if list
	if((g_auto_ap_login.ifnum != 0)||(g_auto_ap_login.auto_ap_if != NULL))
	{
		int i = 0;
		int result = 0;
		wid_auto_ap_if *iflist = NULL;
		iflist = g_auto_ap_login.auto_ap_if;
		while(iflist != NULL)
		{
			if(iflist->ifindex == ifr.ifr_ifindex)
			{
				if(iflist->wlannum >= L_BSS_NUM)
				{
					//printf("interface %s has already binded to %d wlan\n",ifname,L_BSS_NUM);
					break;
				}
				else
				{
					for(i=0;i<L_BSS_NUM;i++)
					{
						if(iflist->wlanid[i] == WlanID)
						{
							//printf("wlan %d has already in the list\n",WlanID);
							result = 1;
							break;
						}
					}
					if(result != 1)
					{
						for(i=0;i<L_BSS_NUM;i++)
						{
							if(iflist->wlanid[i] == 0)
							{
								iflist->wlanid[i] = WlanID;
								iflist->wlannum++;
								result = 1;
								//printf("add wlan %d at i %d\n",WlanID,i);
								break;
							}
						}
					}
				}
			}
			iflist = iflist->ifnext;		
		}
		if(result == 0)
		{
			//printf("interface %s is not in the auto ap login list\n",ifname);
		}
	}
	
	return 0;	
}

int WID_DELETE_IF_APPLY_WLAN(unsigned char WlanID, char *ifname)
{
    if(NULL == ifname)
    {
        return INTERFACE_NOT_EXIST;
    }
    
	struct ifi *wif = NULL;
	struct ifi *wifnext = NULL;
	
	struct ifi *wlan_ifi = AC_WLAN[WlanID]->Wlan_Ifi;
	//printf("**!!!!!!!!!!!! list start !!!!!!!!!!!!!!!***\n");
	while(wlan_ifi != NULL)
	{
		//printf("**!!!!!!!!!!!! list start !!!!!!!!!!!!!!!***\n");
		//printf("**index is:%d name is:%s ***\n",wlan_ifi->ifi_index,wlan_ifi->ifi_name);
		wlan_ifi = wlan_ifi->ifi_next;
		//printf("**!!!!!!!!!!!! list end !!!!!!!!!!!!!!!***\n");
		
	}
	//printf("**!!!!!!!!!!!! list end !!!!!!!!!!!!!!!***\n");
	//added end
	wifnext = AC_WLAN[WlanID]->Wlan_Ifi;
	
	if(AC_WLAN[WlanID]->Wlan_Ifi == NULL)
	{
		return WLAN_NOT_BINDING_IF;
	}
	//else if(wifnext->ifi_index == systemIndex)
	else if(strcmp(wifnext->ifi_name,ifname) == 0)
	{
		AC_WLAN[WlanID]->Wlan_Ifi = wifnext->ifi_next;
		free(wifnext);
		wifnext = NULL;		
		AC_WLAN[WlanID]->ifcount--;
		//delete wtp binding relationship
		wid_check_wtp_apply_wlan(WlanID,ifname);
		
		return 0;
	}
	else
	{
		while(wifnext->ifi_next != NULL)
		{				
			//if(wifnext->ifi_next->ifi_index == systemIndex)
			if(strcmp(wifnext->ifi_next->ifi_name,ifname) == 0)
			{
				wif = wifnext->ifi_next;
				wifnext->ifi_next = wifnext->ifi_next->ifi_next;
				free(wif);
				wif = NULL;				
				AC_WLAN[WlanID]->ifcount--;
				//delete wtp binding relationship
				wid_check_wtp_apply_wlan(WlanID,ifname);
				return 0;
			}
			wifnext = wifnext->ifi_next;
		}
	}
	
	return WLAN_NOT_BINDING_IF;
}

int WID_WLAN_HIDE_ESSID(unsigned char WlanID, unsigned char Hideessid)
{
	WID_CHECK_WLAN_EXIST_RET(WlanID, WLAN_ID_NOT_EXIST);
	
	if (AC_WLAN[WlanID]->Status == 0)
	{
		return WLAN_BE_ENABLE;
	}

	AC_WLAN[WlanID]->HideESSid = Hideessid;

	return 0;
}

int WID_WLAN_L3IF_POLICY(unsigned char WlanID, unsigned char wlanPolicy)
{
	int ret = -1;
	int i = 0;
	wid_syslog_debug_debug(WID_DEFAULT,"%s:%d wlan%d wlanpolicy current:%d past:%d\n",__func__,__LINE__,WlanID,wlanPolicy,AC_WLAN[WlanID]->wlan_if_policy);
	
	WID_CHECK_WLAN_EXIST_RET(WlanID, WLAN_ID_NOT_EXIST);
	
	if (AC_WLAN[WlanID]->Status == 0)
	{
		return WLAN_BE_ENABLE;
	}
	//check wlan vlan policy state
	if ((wlanPolicy != 0) && (AC_WLAN[WlanID]->vlanid != 0))
	{
		return WLAN_BINDING_VLAN;
	}
	
	if (AC_WLAN[WlanID]->wlan_if_policy == wlanPolicy)
	{
		return 0;
	}
	else if ((AC_WLAN[WlanID]->wlan_if_policy == NO_INTERFACE) && (wlanPolicy == WLAN_INTERFACE))
	{		
		ret = Create_Wlan_L3_Interface(WlanID);
		if (ret < 0)
		{
			return WLAN_CREATE_L3_INTERFACE_FAIL;
		}
		//search all AC_BSS to keep bss policy the same with wlan policy
		for (i = 0; i < BSS_NUM; i++)
		{
			if (AC_BSS[i] != NULL)
			{
				if (AC_BSS[i]->WlanID == WlanID)
				{
					if (AC_BSS[i]->BSS_IF_POLICY == AC_WLAN[WlanID]->wlan_if_policy)
					{
						AC_BSS[i]->BSS_IF_POLICY = wlanPolicy;
					}
				}
			}
		}
/*		for(i=0; i<WTP_NUM; i++)
		{
			if(AC_WTP[i] != NULL)
				for(j=0; j<AC_WTP[i]->RadioCount; j++)//zhanglei change L_RADIO_NUM to AC_WTP[i]->RadioCount
				{
					if((AC_WLAN[WlanID]->S_WTP_BSS_List[i][j] != 0)&&(AC_BSS[AC_WLAN[WlanID]->S_WTP_BSS_List[i][j]] != NULL))
					{						
						AC_BSS[AC_WLAN[WlanID]->S_WTP_BSS_List[i][j]]->BSS_IF_POLICY = wlanPolicy;
					}else if(AC_BSS[AC_WLAN[WlanID]->S_WTP_BSS_List[i][j]] == NULL)
						AC_WLAN[WlanID]->S_WTP_BSS_List[i][j] = 0;
				}
		}*/
		
	/*	for(i=0;i<WTP_NUM;i++)
			if(AC_WTP[i] != NULL){
				for(j=0;j<AC_WTP[i]->RadioCount;j++){
					if(AC_WLAN[WlanID]->S_WTP_BSS_List[i][j] != 0){
						WID_DELETE_WLAN_APPLY_WTP(i,WlanID);
						break;
					}
				}
			}*///now allow split&local modes both work , so close this
		
	}
	else if ((AC_WLAN[WlanID]->wlan_if_policy == NO_INTERFACE) && (wlanPolicy == BSS_INTERFACE))
	{	
		/*for(i=0; i<WTP_NUM; i++)
		{
			if(AC_WTP[i] != NULL)
				for(j=0; j<AC_WTP[i]->RadioCount; j++)//zhanglei change L_RADIO_NUM to AC_WTP[i]->RadioCount
				{
					if((AC_WLAN[WlanID]->S_WTP_BSS_List[i][j] != 0)&&(AC_BSS[AC_WLAN[WlanID]->S_WTP_BSS_List[i][j]] != NULL))
					{
						ret = Create_BSS_L3_Interface(AC_WLAN[WlanID]->S_WTP_BSS_List[i][j]);
						
						if(ret < 0)
						{
							return WLAN_CREATE_L3_INTERFACE_FAIL;
						}
						
						AC_BSS[AC_WLAN[WlanID]->S_WTP_BSS_List[i][j]]->BSS_IF_POLICY = wlanPolicy;
					}else if(AC_BSS[AC_WLAN[WlanID]->S_WTP_BSS_List[i][j]] == NULL)
						AC_WLAN[WlanID]->S_WTP_BSS_List[i][j] = 0;
				}
		}*/		
	/*	for(i=0;i<WTP_NUM;i++)
			if(AC_WTP[i] != NULL){
				for(j=0;j<AC_WTP[i]->RadioCount;j++){
					if(AC_WLAN[WlanID]->S_WTP_BSS_List[i][j] != 0){
						WID_DELETE_WLAN_APPLY_WTP(i,WlanID);
						break;
					}
				}
			}*/
	}
	else if ((AC_WLAN[WlanID]->wlan_if_policy == WLAN_INTERFACE) && (wlanPolicy == NO_INTERFACE))
	{
		wid_syslog_debug_debug(WID_DEFAULT,"way test 0001 ");
		ret = Delete_Wlan_L3_Interface(WlanID);	
		if (ret < 0)
		{
			return WLAN_DELETE_L3_INTERFACE_FAIL;
		}
		//search all AC_BSS to keep bss policy the same with wlan policy
		for (i = 0; i < BSS_NUM; i++)
		{
			if (AC_BSS[i] != NULL)
			{
				if (AC_BSS[i]->WlanID == WlanID)
				{
					if (AC_BSS[i]->BSS_IF_POLICY == AC_WLAN[WlanID]->wlan_if_policy)
					{
						AC_BSS[i]->BSS_IF_POLICY = wlanPolicy;
					}
				}
			}
		}
		/*for(i=0; i<WTP_NUM; i++)
		{
			if(AC_WTP[i] != NULL)
				for(j=0; j<AC_WTP[i]->RadioCount; j++)//zhanglei change L_RADIO_NUM to AC_WTP[i]->RadioCount
				{
					if((AC_WLAN[WlanID]->S_WTP_BSS_List[i][j] != 0)&&(AC_BSS[AC_WLAN[WlanID]->S_WTP_BSS_List[i][j]] != NULL))
					{						
						AC_BSS[AC_WLAN[WlanID]->S_WTP_BSS_List[i][j]]->BSS_IF_POLICY = wlanPolicy;
					}else if(AC_BSS[AC_WLAN[WlanID]->S_WTP_BSS_List[i][j]] == NULL)
						AC_WLAN[WlanID]->S_WTP_BSS_List[i][j] = 0;
				}
		}*/		
/*		for(i=0;i<WTP_NUM;i++)
			if(AC_WTP[i] != NULL){
				for(j=0;j<AC_WTP[i]->RadioCount;j++){
					if(AC_WLAN[WlanID]->S_WTP_BSS_List[i][j] != 0){
						WID_DELETE_WLAN_APPLY_WTP(i,WlanID);
						break;
					}
				}
			}*/
	}
	else if ((AC_WLAN[WlanID]->wlan_if_policy == WLAN_INTERFACE) && (wlanPolicy == BSS_INTERFACE))
	{
		ret = Delete_Wlan_L3_Interface(WlanID);
		AC_WLAN[WlanID]->wlan_if_policy = NO_INTERFACE;

	/*	for(i=0; i<WTP_NUM; i++)
		{
			if(AC_WTP[i] != NULL)//zhanglei change L_RADIO_NUM to AC_WTP[i]->RadioCount
				for(j=0; j<AC_WTP[i]->RadioCount; j++)
				{
					if(AC_WLAN[WlanID]->S_WTP_BSS_List[i][j] != 0)
					{
						ret = Create_BSS_L3_Interface(AC_WLAN[WlanID]->S_WTP_BSS_List[i][j]);
						
						if(ret < 0)
						{
							return WLAN_CREATE_L3_INTERFACE_FAIL;
						}
						
						AC_BSS[AC_WLAN[WlanID]->S_WTP_BSS_List[i][j]]->BSS_IF_POLICY = wlanPolicy;
					}
				}
		}*/
		
/*		for(i=0;i<WTP_NUM;i++)
			if(AC_WTP[i] != NULL){
				for(j=0;j<AC_WTP[i]->RadioCount;j++){
					if(AC_WLAN[WlanID]->S_WTP_BSS_List[i][j] != 0){
						WID_DELETE_WLAN_APPLY_WTP(i,WlanID);
						break;
					}
				}
			}*/
		
	}
	else if ((AC_WLAN[WlanID]->wlan_if_policy == BSS_INTERFACE) && (wlanPolicy == NO_INTERFACE))
	{
	/*	for(i=0; i<WTP_NUM; i++)
		{
			if(AC_WTP[i] != NULL)//zhanglei change L_RADIO_NUM to AC_WTP[i]->RadioCount
				for(j=0; j<AC_WTP[i]->RadioCount; j++)
				{
					
					if(AC_WLAN[WlanID]->S_WTP_BSS_List[i][j] != 0)
					{
						
						//ret = Delete_BSS_L3_Interface(AC_WLAN[WlanID]->S_WTP_BSS_List[i][j]);
						//AC_BSS[AC_WLAN[WlanID]->S_WTP_BSS_List[i][j]]->BSS_IF_POLICY = wlanPolicy;		
						WID_DELETE_WLAN_APPLY_WTP(i,WlanID);
					}
				}
		}*/
		
	}
	else if ((AC_WLAN[WlanID]->wlan_if_policy == BSS_INTERFACE) && (wlanPolicy == WLAN_INTERFACE))
	{
	/*	for(i=0; i<WTP_NUM; i++)
		{			
			if(AC_WTP[i] != NULL)
				for(j=0; j<AC_WTP[i]->RadioCount; j++)//zhanglei change L_RADIO_NUM to AC_WTP[i]->RadioCount
				{
					if(AC_WLAN[WlanID]->S_WTP_BSS_List[i][j] != 0)
					{
						//ret = Delete_BSS_L3_Interface(AC_WLAN[WlanID]->S_WTP_BSS_List[i][j]);
						//AC_BSS[AC_WLAN[WlanID]->S_WTP_BSS_List[i][j]]->BSS_IF_POLICY = wlanPolicy;		
						WID_DELETE_WLAN_APPLY_WTP(i,WlanID);
					}
				}
		}*/

		AC_WLAN[WlanID]->wlan_if_policy = NO_INTERFACE;

		ret = Create_Wlan_L3_Interface(WlanID);
		if (ret < 0)
		{
			return WLAN_CREATE_L3_INTERFACE_FAIL;
		}
	}

	wid_syslog_debug_debug(WID_DEFAULT,"%s:%d wlan%d l3 interface policy is:%d\n",__func__,__LINE__,WlanID,wlanPolicy);
	
	//through ioctl create l3 interface
	
	AC_WLAN[WlanID]->wlan_if_policy = wlanPolicy;	

	return 0;
}

int WID_WLAN_L3IF_POLICY_BR(unsigned char WlanID, unsigned char wlanPolicy)
{
	wid_syslog_debug_debug(WID_DEFAULT,"WID_WLAN_L3IF_POLICY_BR policy current:%d past:%d \n",wlanPolicy,AC_WLAN[WlanID]->wlan_if_policy);
	int ret = -1;
	int i=0;
	int j=0;
	int reason = 0;
	if(AC_WLAN[WlanID]->wlan_if_policy == wlanPolicy)
	{
		return 0;
	}
	if(AC_WLAN[WlanID]->Status == 0)
	{
		return WLAN_BE_ENABLE;
	}
	if((wlanPolicy == WLAN_INTERFACE))
	{		
		wid_syslog_debug_debug(WID_DEFAULT,"from no to wlan\n");
		ret = Create_Wlan_L3_BR_Interface(WlanID);
		if(ret < 0)
		{
			return WLAN_CREATE_BR_FAIL;
		}
		if(AC_WLAN[WlanID]->wlan_if_policy == NO_INTERFACE)
			set_wlan_tunnel_mode(WlanID, 1);
		//search all AC_BSS to keep bss policy the same with wlan policy
		for(i=0; i<WTP_NUM; i++)
		{
			//if((AC_WTP[i]!=NULL)&&(AC_WTP[i]->isused == 1))
			if(AC_WTP[i]!=NULL)
			{
				for(j=0; j<AC_WTP[i]->RadioCount; j++)
				{
					if(AC_WLAN[WlanID]->S_WTP_BSS_List[i][j] != 0)
					{
						int bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[i][j];
						if(!check_bssid_func(bssindex)){
							wid_syslog_err("\n");
							//return ;							
						}else{						
							if(AC_BSS[bssindex]->BSS_IF_POLICY == NO_INTERFACE)
							{
								ret = Create_BSS_L3_Interface(bssindex);
								if(ret < 0)
								{
									return BSS_CREATE_L3_INTERFACE_FAIL;
								}
								AC_BSS[bssindex]->BSS_IF_POLICY = BSS_INTERFACE;
								ret = ADD_BSS_L3_Interface_BR(bssindex);
								if(ret < 0)
								{
									return BSS_L3_INTERFACE_ADD_BR_FAIL;
								}
								AC_BSS[bssindex]->BSS_IF_POLICY = WLAN_INTERFACE;
								AC_BSS[bssindex]->BSS_TUNNEL_POLICY = CW_802_DOT_11_TUNNEL;
							}
							else if(AC_BSS[bssindex]->BSS_IF_POLICY == BSS_INTERFACE)
							{
								wid_syslog_debug_debug(WID_DEFAULT,"bssindex %d already bss l3 interface\n",bssindex);
								ret = ADD_BSS_L3_Interface_BR(bssindex);
								if(ret < 0)
								{
									return BSS_L3_INTERFACE_ADD_BR_FAIL;
								}
								if(WID_ADD_RADIO_IF_FAIL == ret){

								}else{
									AC_BSS[bssindex]->BSS_IF_POLICY = WLAN_INTERFACE;
									AC_BSS[bssindex]->BSS_TUNNEL_POLICY = CW_802_DOT_11_TUNNEL;
								}
							}
							else
							{
							}
						}
					}
				}
			}
		}
		char brcmd[WID_SYSTEM_CMD_LENTH];
		memset(brcmd,0,WID_SYSTEM_CMD_LENTH);
		if(local)
			sprintf(brcmd,"ifconfig wlanl%d-%d-%d up\n",slotid,vrrid,WlanID);	
		else
			sprintf(brcmd,"ifconfig wlan%d-%d-%d up\n",slotid,vrrid,WlanID);	
			
//		printf("system cmd: %s\n",brcmd);
		ret = system(brcmd);
		
		reason = WEXITSTATUS(ret);
		if(reason != 0)
		{
			wid_syslog_debug_debug(WID_DEFAULT,"system cmd error,error code %d\n",reason);
			return SYSTEM_CMD_ERROR;
		}
		if(ret != 0)
		{
			wid_syslog_debug_debug(WID_DEFAULT,"system cmd error\n");
			return SYSTEM_CMD_ERROR;
		}
	}
	else if((AC_WLAN[WlanID]->wlan_if_policy == WLAN_INTERFACE)&&(wlanPolicy == NO_INTERFACE))
	{
		wid_syslog_debug_debug(WID_DEFAULT,"from wlan to no");
		
		if(AC_WLAN[WlanID]->wlan_if_policy == WLAN_INTERFACE)
			set_wlan_tunnel_mode(WlanID, 0);
		ret = Delete_Wlan_L3_BR_Interface(WlanID);	
		if(ret < 0)
		{
			return WLAN_DELETE_BR_FAIL;
		}
		AC_WLAN[WlanID]->isolation_policy = 1;
		AC_WLAN[WlanID]->multicast_isolation_policy = 1;
		AC_WLAN[WlanID]->sameportswitch = 0;
	}
	
	wid_syslog_debug_debug(WID_DEFAULT,"*** wlan l3 interface policy is:%d***\n",wlanPolicy);
	
	//through ioctl create l3 interface
	
	AC_WLAN[WlanID]->wlan_if_policy = wlanPolicy;	
	if(AC_WLAN[WlanID]->wlan_if_policy != NO_INTERFACE){
		if(AC_WLAN[WlanID]->WLAN_TUNNEL_POLICY != g_WLAN_TUNNEL_POLICY){
			char nodeFlag = 2;
			ret = WID_RADIO_WLAN_TUNNEL_MODE(WlanID,g_WLAN_TUNNEL_POLICY,nodeFlag);
		}
	}else if(wlanPolicy == NO_INTERFACE){
		char nodeFlag = 2;
		ret = WID_RADIO_WLAN_TUNNEL_MODE(WlanID,CW_802_DOT_11_TUNNEL,nodeFlag);
	}
	return 0;
}

//bss l3 interface area
int WID_BSS_L3IF_POLICY(unsigned int WlanID,unsigned int wtpID,unsigned int radioID,unsigned char BSSID,unsigned char bssPolicy)
{
	//parse interface radio1-0.1&no interface radio1-0.1
//	printf("%d %d %d %d %d\n",WlanID,wtpID,radioID,BSSID,bssPolicy);
	unsigned int BSSindex = ((wtpID*L_RADIO_NUM+radioID)*L_BSS_NUM)+BSSID;
	int ret = -1;
	int ebr_id = 0;
	char ifiname[ETH_IF_NAME_LEN-1];
	if(AC_BSS[BSSindex] == NULL)
	{
		return BSS_NOT_EXIST;
	}
	WTPQUITREASON quitreason = WTP_INIT;
	
//	printf("BSS current:%d past:%d \n",bssPolicy,AC_BSS[BSSindex]->BSS_IF_POLICY);
//	printf("BSS current:%d past:%d \n",bssPolicy,AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY);
	wid_syslog_debug_debug(WID_DEFAULT,"BSS current:%d past:%d \n",bssPolicy,AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY);

	if(AC_BSS[BSSindex]->BSS_IF_POLICY == bssPolicy)
	{
		return 0;
	}
	else
	{
		if(AC_BSS[BSSindex]->State != 0)
		{
			return BSS_BE_ENABLE;
		}
	}

	if((AC_WLAN[WlanID]->wlan_if_policy == 0) || (AC_WLAN[WlanID]->wlan_if_policy == BSS_INTERFACE))//no_interface,bss interface can be no_interface or bss_interface
	{	//printf("state 0 \n");
		if(bssPolicy == 1)//no wlan_interface now
		{
			return IF_POLICY_CONFLICT;
		}
		//if(AC_BSS[BSSindex]->BSS_IF_POLICY == bssPolicy)//current & past is the same,no use to change
		if(AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY == bssPolicy)//current & past is the same,no use to change
		{
			return 0;
		}
		//no_interface to bss_interface
		if((AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY == NO_INTERFACE)&&(bssPolicy == BSS_INTERFACE))
		{
//			printf("state 0 f 0 t b\n");
			ret = Create_BSS_L3_Interface(BSSindex);

			if(ret < 0)
			{
				return BSS_CREATE_L3_INTERFACE_FAIL;
			}
		}
		//bss_interface to no_interface
		else if((AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY == BSS_INTERFACE)&&(bssPolicy == NO_INTERFACE))
		{	//printf("state 0 f b t 0\n");
			if(check_whether_in_ebr(vrrid,wtpID,radioID,WlanID,&ebr_id))
			{
				return RADIO_IN_EBR;
			}
			ret = Delete_BSS_L3_Interface(BSSindex);	

			if(ret < 0)
			{
				return BSS_DELETE_L3_INTERFACE_FAIL;
			}
		}
		//wlan_interface to bss_interface //use interface radio1-0.1
		else if((AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY == WLAN_INTERFACE)&&(bssPolicy == BSS_INTERFACE))
		{//	printf("state 0 f w t b\n");
			//whether to delete the wlan l3 interface???
			/*ret = Delete_Wlan_L3_Interface(WlanID);	
		
			if(ret < 0)
			{
				return WLAN_DELETE_L3_INTERFACE_FAIL;
			}*/
			ret = Create_BSS_L3_Interface(BSSindex);	
			
			if(ret < 0)
			{
				return BSS_CREATE_L3_INTERFACE_FAIL;
			}
		}
		//bss_interface to wlan_interface //use no interface radio1-0.1
		else if((AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY == BSS_INTERFACE)&&(bssPolicy == WLAN_INTERFACE))
		{	//printf("state 0 f b t w\n");
			//first check wlan interface
			memset(ifiname,0,ETH_IF_NAME_LEN-1);
		//	printf("wlan%d\n",AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->WlanID);
			if(local)
				snprintf(ifiname,ETH_IF_NAME_LEN-1,"wlanl%d-%d-%d",slotid,vrrid,AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->WlanID);
			else
				snprintf(ifiname,ETH_IF_NAME_LEN-1,"wlan%d-%d-%d",slotid,vrrid,AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->WlanID);
				
			ret = Check_Interface_Config(ifiname,&quitreason);
			
			if(ret != 0)
			{
				return L3_INTERFACE_ERROR;
			}

			else
			{
				
			
				//delete bss l3 interface
				ret = Delete_BSS_L3_Interface(BSSindex);	
			
				if(ret < 0)
				{
					return BSS_DELETE_L3_INTERFACE_FAIL;
				}
				

			}
		}
		//maybe not happen forever
		else
		{
			return UNKNOWN_ERROR;
		}
		
	}
	
	if(AC_WLAN[WlanID]->wlan_if_policy == 1)//wlan_interface,bss interface can be no_interface or bss_interface or wlan_interface
	{
	//	printf("state 1\n");
		//if(AC_BSS[BSSindex]->BSS_IF_POLICY == bssPolicy)//current & past is the same,no use to change
		if(AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY == bssPolicy)//current & past is the same,no use to change
		{
			return 0;
		}
		//no_interface to bss_interface
		if((AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY == NO_INTERFACE)&&(bssPolicy == BSS_INTERFACE))
		{
	//		printf("state 0 f 0 t b\n");
			ret = Create_BSS_L3_Interface(BSSindex);

			if(ret < 0)
			{
				return BSS_CREATE_L3_INTERFACE_FAIL;
			}
		}
		
		//bss_interface to no_interface
		else if((AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY == BSS_INTERFACE)&&(bssPolicy == NO_INTERFACE))
		{//	printf("state 0 f b t 0\n");
			if(check_whether_in_ebr(vrrid,wtpID,radioID,WlanID,&ebr_id))
			{
				return RADIO_IN_EBR;
			}	
			ret = Delete_BSS_L3_Interface(BSSindex);	

			if(ret < 0)
			{
				return BSS_DELETE_L3_INTERFACE_FAIL;
			}
			/*bss to no , no return to the policy of wlan
			if(AC_WLAN[WlanID]->wlan_if_policy == WLAN_INTERFACE)
			{
				AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY = WLAN_INTERFACE;	

				return 0;
			}*/
		}
		//wlan_interface to bss_interface //use interface radio1-0.1//remove bss if from wlan br
		else if((AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY == WLAN_INTERFACE)&&(bssPolicy == BSS_INTERFACE))
		{//	printf("state 0 f w t b\n");
			// remove bss if from wlan br
			ret = Del_BSS_L3_Interface_BR(BSSindex);
			if(ret < 0)
			{
				wid_syslog_debug_debug(WID_DEFAULT,"remove bss interface from wlan br failed, bssindex %d\n",AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSSIndex);
				return BSS_L3_INTERFACE_DEL_BR_FAIL;
			}
			
		}
		
		//from wlan to no
		else if ((AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY == WLAN_INTERFACE) && (bssPolicy == NO_INTERFACE))
		{
			// remove bss if from wlan br
			ret = Del_BSS_L3_Interface_BR(BSSindex);
			if(ret < 0)
			{
				wid_syslog_debug_debug(WID_DEFAULT,"remove bss interface from wlan br failed, bssindex %d\n",AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSSIndex);
				return BSS_L3_INTERFACE_DEL_BR_FAIL;
			}
			AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY = BSS_INTERFACE;
			
			//deletele bss interface
			ret = Delete_BSS_L3_Interface(BSSindex);
			if(ret < 0)
			{
				wid_syslog_debug_debug(WID_DEFAULT,"delete bss interface failed, bssindex %d\n",AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSSIndex);
				return BSS_DELETE_L3_INTERFACE_FAIL;
			}
			AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY = NO_INTERFACE;
			
		}
		//bss_interface to wlan_interface //use no interface radio1-0.1
		else if((AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY == BSS_INTERFACE)&&(bssPolicy == WLAN_INTERFACE))
		{//	printf("state 0 f b t w\n");
			//first check wlan interface
			memset(ifiname,0,ETH_IF_NAME_LEN-1);
		//	printf("wlan%d\n",AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->WlanID);
			if(local)
				snprintf(ifiname,ETH_IF_NAME_LEN-1,"wlanl%d-%d-%d",slotid,vrrid,AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->WlanID);
			else
				snprintf(ifiname,ETH_IF_NAME_LEN-1,"wlan%d-%d-%d",slotid,vrrid,AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->WlanID);
				
			ret = Check_Interface_Config(ifiname,&quitreason);
			
			if(ret != 0)
			{
				return L3_INTERFACE_ERROR;
			}

			else
			{
				
			
				//delete bss l3 interface
				ret = Delete_BSS_L3_Interface(BSSindex);	
			
				if(ret < 0)
				{
					return BSS_DELETE_L3_INTERFACE_FAIL;
				}
				

			}
		}
		//maybe not happen forever
		else
		{
			return UNKNOWN_ERROR;
		}
		
	}
	
//	printf("*** BSS l3 interface policy is:%d***\n",bssPolicy);
	wid_syslog_debug_debug(WID_DEFAULT,"*** BSS l3 interface policy is:%d***\n",bssPolicy);
	
	
	AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY = bssPolicy;	

	return 0;
}
int WID_RADIO_BSS_L3IF_POLICY(unsigned char WlanID,unsigned int wtpID,unsigned char radioID,unsigned char BSSID,unsigned char bssPolicy)
{
//	printf("%d %d %d %d %d\n",WlanID,wtpID,radioID,BSSID,bssPolicy);
	unsigned int BSSindex = ((wtpID*L_RADIO_NUM+radioID)*L_BSS_NUM)+BSSID;
	int ret = -1;
	char ifiname[ETH_IF_NAME_LEN-1];
	if(AC_BSS[BSSindex] == NULL)
	{
		return BSS_NOT_EXIST;
	}
	WTPQUITREASON quitreason = WTP_INIT;
	
//	printf("BSS current:%d past:%d \n",bssPolicy,AC_BSS[BSSindex]->BSS_IF_POLICY);
//	printf("BSS current:%d past:%d \n",bssPolicy,AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY);
	wid_syslog_debug_debug(WID_DEFAULT,"BSS current:%d past:%d \n",bssPolicy,AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY);
	
	if(AC_BSS[BSSindex]->State != 0)
	{
		return BSS_BE_ENABLE;
	}
	/*
	if(AC_WLAN[WlanID]->wlan_if_policy == 0)//no_interface,bss interface can be no_interface or bss_interface
	{	printf("state 0 \n");
		if(bssPolicy == 1)//no wlan_interface now
		{
			return IF_POLICY_CONFLICT;
		}
		//if(AC_BSS[BSSindex]->BSS_IF_POLICY == bssPolicy)//current & past is the same,no use to change
		if(AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY == bssPolicy)//current & past is the same,no use to change
		{
			return 0;
		}
		//no_interface to bss_interface
		if((AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY == NO_INTERFACE)&&(bssPolicy == BSS_INTERFACE))
		{
			printf("state 0 f 0 t b\n");
			ret = Create_BSS_L3_Interface(BSSindex);

			if(ret < 0)
			{
				return BSS_CREATE_L3_INTERFACE_FAIL;
			}
		}
		//bss_interface to no_interface
		else if((AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY == BSS_INTERFACE)&&(bssPolicy == NO_INTERFACE))
		{	printf("state 0 f b t 0\n");
			ret = Delete_BSS_L3_Interface(BSSindex);	

			if(ret < 0)
			{
				return BSS_DELETE_L3_INTERFACE_FAIL;
			}
		}
		//maybe not happen forever
		else
		{
			return UNKNOWN_ERROR;
		}
		
	}*/
	if(AC_WLAN[WlanID]->wlan_if_policy == 0)//no_interface,bss interface can be no_interface or bss_interface
	{
		return IF_POLICY_CONFLICT;
	}
	//only use when wlan is WLAN_INTERFACE
	if(AC_WLAN[WlanID]->wlan_if_policy == 1)//wlan_interface,bss interface can be no_interface or bss_interface or wlan_interface
	{
//		printf("state 1\n");
		//if(AC_BSS[BSSindex]->BSS_IF_POLICY == bssPolicy)//current & past is the same,no use to change
		if(AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY == bssPolicy)//current & past is the same,no use to change
		{
			return 0;
		}
		//no_interface to bss_interface //use interface radio1-0.1
		if((AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY == NO_INTERFACE)&&(bssPolicy == BSS_INTERFACE))
		{
//			printf("state 0 f 0 t b\n");
			ret = Create_BSS_L3_Interface(BSSindex);

			if(ret < 0)
			{
				return BSS_CREATE_L3_INTERFACE_FAIL;
			}
		}
		//no_interface to wlan_interface
		else if((AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY == NO_INTERFACE)&&(bssPolicy == WLAN_INTERFACE))
		{
//			printf("state 0 f 0 t w\n");
			//assemble wlan1
			memset(ifiname,0,ETH_IF_NAME_LEN-1);
//			printf("wlan%d\n",AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->WlanID);
			if(local)
				snprintf(ifiname,ETH_IF_NAME_LEN-1,"wlanl%d-%d-%d",slotid,vrrid,AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->WlanID);
			else
				snprintf(ifiname,ETH_IF_NAME_LEN-1,"wlan%d-%d-%d",slotid,vrrid,AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->WlanID);
				
			ret = Check_Interface_Config(ifiname,&quitreason);
			
			if(ret != 0)
			{
				return L3_INTERFACE_ERROR;
			}

			else
			{
				
			}
		}
		//bss_interface to no_interface
		else if((AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY == BSS_INTERFACE)&&(bssPolicy == NO_INTERFACE))
		{	//printf("state 0 f b t 0\n");
			//first check wlan interface
			memset(ifiname,0,ETH_IF_NAME_LEN-1);
		//	printf("radio%d-%d.%d\n",wtpID,radioID,WlanID);
			if(local)
				snprintf(ifiname,ETH_IF_NAME_LEN,"r%d-%d-%d.%d",vrrid,wtpID,radioID,WlanID);
			else
				snprintf(ifiname,ETH_IF_NAME_LEN,"r%d-%d-%d-%d.%d",slotid,vrrid,wtpID,radioID,WlanID);
				
			ret = Check_Interface_Config(ifiname,&quitreason);
			
			if(ret == 0)
			{
				return BSS_IF_NEED_DELETE;
			}



		
			ret = Delete_BSS_L3_Interface(BSSindex);	

			if(ret < 0)
			{
				return BSS_DELETE_L3_INTERFACE_FAIL;
			}
		}
		//wlan_interface to no_interface
		else if((AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY == WLAN_INTERFACE)&&(bssPolicy == NO_INTERFACE))
		{
			//whether to delete the wlan l3 interface???
			//ret = Delete_Wlan_L3_Interface(WlanID);	
			printf("state 0 f w t 0\n");
			
		}
		//wlan_interface to bss_interface //use interface radio1-0.1
		else if((AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY == WLAN_INTERFACE)&&(bssPolicy == BSS_INTERFACE))
		{	//printf("state 0 f w t b\n");
			//whether to delete the wlan l3 interface???
			/*ret = Delete_Wlan_L3_Interface(WlanID);	
		
			if(ret < 0)
			{
				return WLAN_DELETE_L3_INTERFACE_FAIL;
			}*/
			ret = Create_BSS_L3_Interface(BSSindex);	
			
			if(ret < 0)
			{
				return BSS_CREATE_L3_INTERFACE_FAIL;
			}
		}
		//bss_interface to wlan_interface //use no interface radio1-0.1
		else if((AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY == BSS_INTERFACE)&&(bssPolicy == WLAN_INTERFACE))
		{	//printf("state 0 f b t w\n");
			return UNKNOWN_ERROR;
			//first check wlan interface
			/*
			memset(ifiname,0,ETH_IF_NAME_LEN);
			printf("wlan%d\n",AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->WlanID);
			snprintf(ifiname,ETH_IF_NAME_LEN,"wlan%d",AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->WlanID);
			ret = Check_Interface_Config(ifiname,&quitreason);
			
			if(ret != 0)
			{
				return L3_INTERFACE_ERROR;
			}

			else
			{
				
			
				//delete bss l3 interface
				ret = Delete_BSS_L3_Interface(BSSindex);	
			
				if(ret < 0)
				{
					return BSS_DELETE_L3_INTERFACE_FAIL;
				}
				

			}*/
		}
		//maybe not happen forever
		else
		{
			return UNKNOWN_ERROR;
		}
		
	}
	
	printf("*** BSS l3 interface policy is:%d***\n",bssPolicy);
	wid_syslog_debug_debug(WID_DEFAULT,"*** BSS l3 interface policy is:%d***\n",bssPolicy);
	
	
	AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY = bssPolicy;	

	return 0;
}
int WID_RADIO_BSS_L3IF_POLICY_BR(unsigned char WlanID,unsigned int wtpID,unsigned char radioID,unsigned char BSSID,unsigned char bssPolicy)
{
//	printf("WlanID %d wtpID %d radioID %d BSSID %d bssPolicy %d\n",WlanID,wtpID,radioID,BSSID,bssPolicy);
	unsigned int BSSindex = ((wtpID*L_RADIO_NUM+radioID)*L_BSS_NUM)+BSSID;
	int ret = -1;
	char ifname[ETH_IF_NAME_LEN];
	
	if(AC_BSS[BSSindex] == NULL)
	{
		return BSS_NOT_EXIST;
	}
//	printf("BSS current:%d past:%d \n",bssPolicy,AC_BSS[BSSindex]->BSS_IF_POLICY);
	
	if(bssPolicy == AC_BSS[BSSindex]->BSS_IF_POLICY)
	{
		return WID_DBUS_SUCCESS;
	}
	WTPQUITREASON quitreason = WTP_INIT;
	
//	printf("BSS current:%d past:%d \n",bssPolicy,AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY);
	wid_syslog_debug_debug(WID_DEFAULT,"BSS current:%d past:%d \n",bssPolicy,AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY);
	
	if(AC_BSS[BSSindex]->State != 0)
	{
		return BSS_BE_ENABLE;
	}
	//from no to wlan
	if ((AC_BSS[BSSindex]->BSS_IF_POLICY == NO_INTERFACE) && (bssPolicy == WLAN_INTERFACE))
	{
		
		//check br
		memset(ifname,0,ETH_IF_NAME_LEN);
		if(local)
			sprintf(ifname,"wlanl%d-%d-%d",slotid,vrrid,WlanID);
		else
			sprintf(ifname,"wlan%d-%d-%d",slotid,vrrid,WlanID);			
		ret = Check_Interface_Config(ifname,&quitreason);
		if(ret != 0)
		{
			
			wid_syslog_debug_debug(WID_DEFAULT,"br not exist,need to be created, bssindex %d wlanid %d\n",AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSSIndex,WlanID);
			return WLAN_CREATE_BR_FAIL;//no br , so return error
		}
		
		//create bss interface
		ret = Create_BSS_L3_Interface(BSSindex);
		if(ret < 0)
		{
			return BSS_CREATE_L3_INTERFACE_FAIL;
		}
		AC_BSS[BSSindex]->BSS_IF_POLICY = BSS_INTERFACE;
		// add bss if to wlan br
		ret = ADD_BSS_L3_Interface_BR(BSSindex);
		if(ret < 0)
		{
			wid_syslog_debug_debug(WID_DEFAULT,"add bss interface to wlan br failed, bssindex %d wlanid %d\n",AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSSIndex,WlanID);
	
			return BSS_L3_INTERFACE_ADD_BR_FAIL;
		}
		AC_BSS[BSSindex]->BSS_IF_POLICY = WLAN_INTERFACE;
		AC_BSS[BSSindex]->BSS_TUNNEL_POLICY = CW_802_DOT_11_TUNNEL;
	}

	
	//from wlan to no
	else if ((AC_BSS[BSSindex]->BSS_IF_POLICY == WLAN_INTERFACE) && (bssPolicy == NO_INTERFACE))
	{
		// remove bss if from wlan br
		ret = Del_BSS_L3_Interface_BR(BSSindex);
		if(ret < 0)
		{
			wid_syslog_debug_debug(WID_DEFAULT,"remove bss interface from wlan br failed, bssindex %d\n",AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSSIndex);
			return BSS_L3_INTERFACE_DEL_BR_FAIL;
		}
		AC_BSS[BSSindex]->BSS_IF_POLICY = BSS_INTERFACE;
		
		//deletele bss interface
		ret = Delete_BSS_L3_Interface(BSSindex);
		if(ret < 0)
		{
			wid_syslog_debug_debug(WID_DEFAULT,"delete bss interface failed, bssindex %d\n",AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSSIndex);
			return BSS_DELETE_L3_INTERFACE_FAIL;
		}
		AC_BSS[BSSindex]->BSS_IF_POLICY = NO_INTERFACE;
		
	}

	//from wlan to bss
	else if ((AC_BSS[BSSindex]->BSS_IF_POLICY == WLAN_INTERFACE) && (bssPolicy == BSS_INTERFACE))
	{
		// remove bss if from wlan br
		ret = Del_BSS_L3_Interface_BR(BSSindex);
		if(ret < 0)
		{	
			wid_syslog_debug_debug(WID_DEFAULT,"remove bss interface from wlan br failed, bssindex %d\n",AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSSIndex);
			return BSS_L3_INTERFACE_DEL_BR_FAIL;
		}
		AC_BSS[BSSindex]->BSS_IF_POLICY = BSS_INTERFACE;
		
	}

	//from bss to wlan
	else if ((AC_BSS[BSSindex]->BSS_IF_POLICY == BSS_INTERFACE) && (bssPolicy == WLAN_INTERFACE))
	{
		// check br
		memset(ifname,0,ETH_IF_NAME_LEN);
		if(local)
			sprintf(ifname,"wlanl%d-%d-%d",slotid,vrrid,WlanID);
		else
			sprintf(ifname,"wlan%d-%d-%d",slotid,vrrid,WlanID);			
		ret = Check_Interface_Config(ifname,&quitreason);
		if(ret != 0)
		{
			
			wid_syslog_debug_debug(WID_DEFAULT,"br not exist,need to be created, bssindex %d wlanid %d\n",AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSSIndex,WlanID);
			return WLAN_CREATE_BR_FAIL;//no br , so return error
		}
		// add bss if to wlan br
		ret = ADD_BSS_L3_Interface_BR(BSSindex);
		if(ret < 0)
		{	
			wid_syslog_debug_debug(WID_DEFAULT,"add bss interface to wlan br failed, bssindex %d\n",AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSSIndex);
			return BSS_L3_INTERFACE_ADD_BR_FAIL;
		}
		AC_BSS[BSSindex]->BSS_IF_POLICY = WLAN_INTERFACE;
		AC_BSS[BSSindex]->BSS_TUNNEL_POLICY = CW_802_DOT_11_TUNNEL;
		
	}

	//from bss to no
	else if ((AC_BSS[BSSindex]->BSS_IF_POLICY == BSS_INTERFACE) && (bssPolicy == NO_INTERFACE))
	{
		//deletele bss interface
		ret = Delete_BSS_L3_Interface(BSSindex);
		if(ret < 0)
		{
			wid_syslog_debug_debug(WID_DEFAULT,"delete bss interface failed, bssindex %d\n",AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSSIndex);
			return BSS_DELETE_L3_INTERFACE_FAIL;
		}
		AC_BSS[BSSindex]->BSS_IF_POLICY = NO_INTERFACE;
		
	}

	//from no to bss
	else if ((AC_BSS[BSSindex]->BSS_IF_POLICY == NO_INTERFACE) && (bssPolicy == BSS_INTERFACE))
	{
		//create bss interface
		ret = Create_BSS_L3_Interface(BSSindex);
		if(ret < 0)
		{
			return BSS_CREATE_L3_INTERFACE_FAIL;
		}
		AC_BSS[BSSindex]->BSS_IF_POLICY = BSS_INTERFACE;
		
	}
	
	else
	{
		return UNKNOWN_ERROR;
	}
	
	
//	printf("*** BSS l3 interface policy is:%d***0--wlan br 1--bss\n",bssPolicy);
	wid_syslog_debug_debug(WID_DEFAULT,"*** BSS l3 interface policy is:%d***\n",bssPolicy);
	
	
	return 0;
	
}

int WID_RADIO_BSS_FORWARD_MODE(unsigned char WlanID,unsigned int wtpID,unsigned char radioID,unsigned char BSSID,unsigned char bssPolicy)
{
//	printf("0999 WlanID %d wtpID %d radioID %d BSSID %d bssPolicy %d\n",WlanID,wtpID,radioID,BSSID,bssPolicy);
	unsigned int BSSindex = ((wtpID*L_RADIO_NUM+radioID)*L_BSS_NUM)+BSSID;
	int ret = -1;
	char ifname[ETH_IF_NAME_LEN];
	
	if(AC_BSS[BSSindex] == NULL)
	{
		return BSS_NOT_EXIST;
	}
//	printf("BSS current:%d past:%d \n",bssPolicy,AC_BSS[BSSindex]->BSS_IF_POLICY);
	
	if(bssPolicy == AC_BSS[BSSindex]->BSS_IF_POLICY)
	{
		return WID_DBUS_SUCCESS;
	}
	
	WTPQUITREASON quitreason = WTP_INIT;
	
//	printf("BSS current:%d past:%d \n",bssPolicy,AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY);
	wid_syslog_debug_debug(WID_DEFAULT,"BSS current:%d past:%d \n",bssPolicy,AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSS_IF_POLICY);
	
	if(AC_BSS[BSSindex]->State != 0)
	{
		return BSS_BE_ENABLE;
	}

	
	if((AC_BSS[BSSindex]->BSS_IF_POLICY == BSS_INTERFACE) && (bssPolicy == WLAN_INTERFACE))
	{
		memset(ifname,0,ETH_IF_NAME_LEN);
		if(local)
			sprintf(ifname,"wlanl%d-%d-%d",slotid,vrrid,WlanID);
		else
			sprintf(ifname,"wlan%d-%d-%d",slotid,vrrid,WlanID);
			
		ret = Check_Interface_Config(ifname,&quitreason);
		if(ret != 0)
		{
			
			wid_syslog_debug_debug(WID_DEFAULT,"br not exist,need to be created, bssindex %d wlanid %d\n",AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSSIndex,WlanID);
			return WLAN_CREATE_BR_FAIL;//no br , so return error
		}
		// add bss if to wlan br
		ret = ADD_BSS_L3_Interface_BR(BSSindex);
		if(ret < 0)
		{	
			wid_syslog_debug_debug(WID_DEFAULT,"add bss interface to wlan br failed, bssindex %d\n",AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSSIndex);
			return BSS_L3_INTERFACE_ADD_BR_FAIL;
		}
		AC_BSS[BSSindex]->BSS_IF_POLICY = WLAN_INTERFACE;
		AC_BSS[BSSindex]->BSS_TUNNEL_POLICY = CW_802_DOT_11_TUNNEL;
	}
	else if((AC_BSS[BSSindex]->BSS_IF_POLICY == WLAN_INTERFACE) && (bssPolicy == BSS_INTERFACE))
	{
		// remove bss if from wlan br
		ret = Del_BSS_L3_Interface_BR(BSSindex);
		if(ret < 0)
		{	
			wid_syslog_debug_debug(WID_DEFAULT,"remove bss interface from wlan br failed, bssindex %d\n",AC_WTP[wtpID]->WTP_Radio[radioID]->BSS[BSSID]->BSSIndex);
			return BSS_L3_INTERFACE_DEL_BR_FAIL;
		}
		AC_BSS[BSSindex]->BSS_IF_POLICY = BSS_INTERFACE;
	}
	else
	{
		//printf("code should not here\n");
		wid_syslog_debug_debug(WID_DEFAULT,"code should not here\n");
	}

	return 0;

}

int WID_RADIO_BSS_TUNNEL_MODE(unsigned char WlanID,unsigned int wtpID,unsigned char radioID,unsigned char BSSID,unsigned char bssPolicy,char nodeFlag)
{
//	printf("WlanID %d wtpID %d radioID %d BSSID %d bssPolicy %d\n",WlanID,wtpID,radioID,BSSID,bssPolicy);
	unsigned int BSSindex = ((wtpID*L_RADIO_NUM+radioID)*L_BSS_NUM)+BSSID;
	
	if(AC_BSS[BSSindex] == NULL)
	{
		return BSS_NOT_EXIST;
	}
	
//	printf("BSS current:%d past:%d \n",bssPolicy,AC_BSS[BSSindex]->BSS_TUNNEL_POLICY);

	
	if(bssPolicy == AC_BSS[BSSindex]->BSS_TUNNEL_POLICY)
	{
		return WID_DBUS_SUCCESS;
	}
	if(0 == nodeFlag){//interface node radio or wlan
		if(AC_BSS[BSSindex]->State != 0)
		{
			return BSS_BE_ENABLE;
		}
	}else{//config wlan or radio node
		if(AC_BSS[BSSindex]->BSS_IF_POLICY == NO_INTERFACE){
			return BSS_IF_NEED_CREATE;
		}
	}

	if((AC_BSS[BSSindex]->BSS_IF_POLICY == WLAN_INTERFACE) && (bssPolicy == CW_802_IPIP_TUNNEL))
	{
		return NO_SURPPORT_IPIP;
	}
	
	if(AC_BSS[BSSindex]->BSS_TUNNEL_POLICY != bssPolicy){
		msgq msg;
		struct msgqlist *elem;
		memset((char*)&msg, 0, sizeof(msg));
		wid_syslog_debug_debug(WID_DEFAULT,"%s: wtp%d binding wlan%d match success\n",__func__,wtpID,WlanID);
		msg.mqid = wtpID%THREAD_NUM+1;
		msg.mqinfo.WTPID = wtpID;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WLAN_S_TYPE;
		msg.mqinfo.u.WlanInfo.Wlan_Op = WLAN_CHANGE_TUNNEL;
		msg.mqinfo.u.WlanInfo.WLANID = WlanID;
		msg.mqinfo.u.WlanInfo.Radio_L_ID = radioID;
		
		msg.mqinfo.u.WlanInfo.bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[wtpID][radioID];
		
		if((AC_WTP[wtpID]->WTPStat == 5)){ 
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
				perror("msgsnd");
			}
		}
		else{
			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if(elem == NULL){
				wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
				perror("malloc");
				return 0;
			}
			memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
			elem->next = NULL;
			memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
			WID_INSERT_CONTROL_LIST(wtpID, elem);
		}
	}
	AC_BSS[BSSindex]->BSS_TUNNEL_POLICY = bssPolicy;


	return WID_DBUS_SUCCESS;

}

int WID_RADIO_WLAN_TUNNEL_MODE(unsigned char WlanID,unsigned char Policy,char nodeFlag)
{
	wid_syslog_debug_debug(WID_DBUS,"WID_RADIO_WLAN_TUNNEL_MODE wlan:%d policy:%d \n",WlanID,Policy);
	int i = 0;
	int j = 0;
	if(0 == nodeFlag)//interface wlan node
	{
		if((AC_WLAN[WlanID])&&(AC_WLAN[WlanID]->Status == 0))
		{
			return WLAN_BE_ENABLE;
		}
	}else{// config wlan node

	}
	if(Policy != CW_802_DOT_11_TUNNEL)
	{
		if((AC_WLAN[WlanID]->wlan_if_policy != WLAN_INTERFACE)
		    &&(AC_WLAN[WlanID]->wlan_if_policy != BSS_INTERFACE))
	    {
			wid_syslog_err("%s WlanID %d not interface\n",__func__,WlanID);
			return INTERFACE_NOT_L3_IF;
		}
	}else{}
	for(i = 0; i < WTP_NUM; i++)
	{
		if(AC_WTP[i] != NULL)
		{
			for(j = 0; j < AC_WTP[i]->RadioCount; j++)
			{
				if(AC_WLAN[WlanID]->S_WTP_BSS_List[i][j] != 0)
				{
					int bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[i][j];
					if(!check_bssid_func(bssindex))
					{
						wid_syslog_err("\n");
					}
					else
					{						
						if(AC_BSS[bssindex]->BSS_IF_POLICY != NO_INTERFACE)
						{
							AC_BSS[bssindex]->BSS_TUNNEL_POLICY = Policy;
							msgq msg;
							struct msgqlist *elem = NULL;
							memset((char*)&msg, 0, sizeof(msg));
							wid_syslog_debug_debug(WID_DEFAULT,"%s: wtp%d binding wlan%d match success\n",__func__,i,WlanID);
							msg.mqid = i%THREAD_NUM+1;
							msg.mqinfo.WTPID = i;
							msg.mqinfo.type = CONTROL_TYPE;
							msg.mqinfo.subtype = WLAN_S_TYPE;
							msg.mqinfo.u.WlanInfo.Wlan_Op = WLAN_CHANGE_TUNNEL;
							msg.mqinfo.u.WlanInfo.WLANID = WlanID;
							msg.mqinfo.u.WlanInfo.Radio_L_ID = j;
							
							msg.mqinfo.u.WlanInfo.bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[i][j];
							
							if((AC_WTP[i]->WTPStat == WID_RUN))
							{ 
								if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
								{
									wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
									perror("msgsnd");
								}
							}
							else
							{
								elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
								if(elem == NULL)
								{
									wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
									perror("malloc");
									return 0;
								}
								memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
								elem->next = NULL;
								memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
								WID_INSERT_CONTROL_LIST(i, elem);
							}
						}
						else if(AC_BSS[bssindex]->BSS_IF_POLICY == NO_INTERFACE)
						{
							AC_BSS[bssindex]->BSS_TUNNEL_POLICY = CW_802_DOT_11_TUNNEL;//in this branch,bss must have been disable,so need't notice ap.
						}
					}
				}
			}
		}
	}
	AC_WLAN[WlanID]->WLAN_TUNNEL_POLICY = Policy;
	wid_syslog_debug_debug(WID_DBUS,"WID_RADIO_WLAN_TUNNEL_MODE wlan:%d WLAN_TUNNEL_POLICY:%d \n",WlanID,AC_WLAN[WlanID]->WLAN_TUNNEL_POLICY );
	return 0;
}

int WID_RADIO_SET_TYPE(unsigned int RadioID, unsigned int RadioType){
	AC_RADIO[RadioID]->Radio_Type = RadioType;
	return 0;
}

int WID_RADIO_SET_TXP(unsigned int RadioID, unsigned short RadioTxp,CWBool flag)
{
	if(AC_RADIO[RadioID]->ishighpower == 1)//high power hardware
	{
		if((RadioTxp > 27)&&(RadioTxp != 100))
		{
			return TXPOWER_OVER_TW_THREE;
		}
	}
	else
	{
		if((RadioTxp > 20)&&(RadioTxp != 100))
		{
			return TXPOWER_OVER_TW;
		}
	}	

	msgq msg;
	if((gWTPs[AC_RADIO[RadioID]->WTPID].currentState == CW_ENTER_RUN)&&(AC_RADIO[RadioID]->AdStat == 2))
	{
		return RADIO_IS_DISABLE;
	}
	
	if((AC_RADIO[RadioID]->Radio_TXP == RadioTxp)&&(!flag))
	{
		return 0;
	}
	if(!flag)
	{
		if((RadioTxp != 0)&&(RadioTxp != 100))
		{
			AC_RADIO[RadioID]->txpowerautostate = 1;
		}
		else if(RadioTxp == 100)
		{
			AC_RADIO[RadioID]->txpowerautostate = 0;
		}
	}
	int WTPIndex = AC_RADIO[RadioID]->WTPID;
	CWThreadMutexLock(&(gWTPs[WTPIndex].RRMThreadMutex));
	
	if(!flag)
	{
		AC_RADIO[RadioID]->Radio_TXP = RadioTxp;
		if(AC_RADIO[RadioID]->Radio_TXP != 100)
		{
			if(AC_RADIO[RadioID]->ishighpower == 1)
			{
				AC_RADIO[RadioID]->Radio_TXPOF = (27-AC_RADIO[RadioID]->Radio_TXP)/AC_RADIO[RadioID]->txpowerstep;
			}
			else
			{	
				AC_RADIO[RadioID]->Radio_TXPOF = (20-AC_RADIO[RadioID]->Radio_TXP)/AC_RADIO[RadioID]->txpowerstep;
			}
		}
	}
	else 
	{
		AC_RADIO[RadioID]->Radio_TXPOF = RadioTxp;//return WTP_NOT_IN_RUN_STATE;
	}
	CWThreadMutexUnlock(&(gWTPs[WTPIndex].RRMThreadMutex));
	
	if(AC_WTP[AC_RADIO[RadioID]->WTPID]->WTPStat == WID_RUN)
	{
		AC_RADIO[RadioID]->CMD |= 0x1;
		AC_WTP[WTPIndex]->CMD->radioid[AC_RADIO[RadioID]->Radio_L_ID] += 1;
		AC_WTP[WTPIndex]->CMD->setCMD = 1;	
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{			
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			if(flag == CW_FALSE)
			{
				msg.mqinfo.u.RadioInfo.Radio_Op = Radio_TXP;
			}
			else
			{
				msg.mqinfo.u.RadioInfo.Radio_Op = Radio_TXPOF;
			}
			msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
			msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
				perror("msgsnd");
			}
		}
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}
    
	return 0;
}

int WID_RADIO_CHANNEL_OFFSET_CWMODE_CHECK(unsigned int RadioID, unsigned int check_channel,unsigned int max_chanenl,unsigned int min_channel)
{
	int ret2 = CHANNEL_CWMODE_SUCCESS;
	if((AC_RADIO[RadioID]->cwmode == 1)||(AC_RADIO[RadioID]->cwmode == 2)||(AC_RADIO[RadioID]->cwmode == 4))
    {
		if(AC_RADIO[RadioID]->channel_offset == 1)
		{				
			if(check_channel > max_chanenl)
			{
				ret2 = CHANNEL_CWMODE_HT40;
			}	
		}
		else if(AC_RADIO[RadioID]->channel_offset == -1)
		{
			if(check_channel < min_channel)
			{
				ret2 = CHANNEL_CWMODE_HT40;
			}	
		}
		else
		{
			ret2 = CHANNEL_CWMODE_SUCCESS;
		}

	}/*else if(AC_RADIO[RadioID]->cwmode == 0){    //fengwenchao comment 20110422
		if(AC_RADIO[RadioID]->channel_offset == 1)
		{				
			if(check_channel > max_chanenl+4){
				ret2 = CHANNEL_CWMODE_HT20;
			}	
		}else if(AC_RADIO[RadioID]->channel_offset == -1){
			if(check_channel < min_channel-4){
				ret2 = CHANNEL_CWMODE_HT20;
			}	
		}else{
			ret2 = CHANNEL_CWMODE_SUCCESS;
		}
	}*/  
	
	return ret2;
}
int WID_RADIO_SET_CHAN(unsigned int RadioID, unsigned char RadioChan)
{
	msgq msg;
	unsigned char IGNORE_UBSV chan_past = 0;
	unsigned char IGNORE_UBSV chan_curr = 0;

	if((gWTPs[AC_RADIO[RadioID]->WTPID].currentState == CW_ENTER_RUN)&&(AC_RADIO[RadioID]->AdStat == 2))
	{
		return RADIO_IS_DISABLE;
	}

	if((((AC_RADIO[RadioID]->Radio_Type & Radio_11a) == 2) || ((AC_RADIO[RadioID]->Radio_Type & Radio_11ac) == 0x40))
	    && (RadioChan <= 14) && (RadioChan != 0))
	{
	 	return WTP_NO_SURPORT_CHANNEL;
	}
		
	if((AC_RADIO[RadioID]->Radio_Chan == RadioChan) && (RadioChan != 0))
	{
/*		if(RadioChan == 0){
			AC_RADIO[RadioID]->auto_channel_cont = 0;			
		}
		else  */
		AC_RADIO[RadioID]->auto_channel_cont = 1;
		return 0;
	}

	chan_past = AC_RADIO[RadioID]->Radio_Chan;
	chan_curr = RadioChan;
	AC_RADIO[RadioID]->channelchangetime++;
	int WTPIndex = AC_RADIO[RadioID]->WTPID;
	CWThreadMutexLock(&(gWTPs[WTPIndex].RRMThreadMutex));
	AC_RADIO[RadioID]->Radio_Chan = RadioChan;	
	CWThreadMutexUnlock(&(gWTPs[WTPIndex].RRMThreadMutex));
	
	wid_syslog_debug_debug(WID_DEFAULT,"%s:%d radio%u-%u chan_past= %u chan_curr= %u\n",__func__,__LINE__,WTPIndex,RadioID%L_RADIO_NUM,chan_past,RadioChan);
	
	if(AC_WTP[AC_RADIO[RadioID]->WTPID]->WTPStat == WID_RUN)
	{
    	AC_RADIO[RadioID]->CMD |= 0x2;	
    	AC_WTP[WTPIndex]->CMD->radioid[AC_RADIO[RadioID]->Radio_L_ID] += 1;
    	AC_WTP[WTPIndex]->CMD->setCMD = 1;	
#if NOSOFTAC
    	AsdWsm_WTP_Channelchange_Op(WTPIndex,AC_RADIO[RadioID]->Radio_L_ID,CHANNEL_CHANGE_INFO);
#endif
    	CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_Channel;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
			msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}
		
	if(gtrapflag >= 4)
	{
#if NOSOFTAC
		wid_dbus_trap_wtp_channel_change(chan_past,chan_curr,RadioID);	
#endif
	}
	
	if(RadioChan == 0)
	{
		AC_RADIO[RadioID]->auto_channel_cont = 0;			
	}
	else
	{
		AC_RADIO[RadioID]->auto_channel_cont = 1;
	}
	
	return 0;
}

/*wcl add for OSDEVTDPB-31*/
int WID_RADIO_SET_COUNTRYCODE(unsigned int RadioID)
{
	msgq msg;
	if((gWTPs[AC_RADIO[RadioID]->WTPID].currentState == CW_ENTER_RUN)&&(AC_RADIO[RadioID]->AdStat == 2))
	{
		return RADIO_IS_DISABLE;
	}
	
	if(AC_WTP[AC_RADIO[RadioID]->WTPID]->WTPStat == WID_RUN)
	{
		AC_RADIO[RadioID]->CMD |= 0x10;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->radioid[AC_RADIO[RadioID]->Radio_L_ID] += 1;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->setCMD = 1;	
		int WTPIndex = AC_RADIO[RadioID]->WTPID;
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_Countrycode;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
			msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{					
					wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
				perror("msgsnd");
			}
		}
		
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}

	return COUNTRY_CODE_SUCCESS;
}

/*end*/
/*wcl add for OSDEVTDPB-31*/

int WID_SET_COUNTRY_CODE_CHECK_CHAN(unsigned int RadioID)
{
	int max_channel;
	int min_channel;
	int change_channel = 0;
	if(AC_RADIO[RadioID] != NULL)
	{
		switch(AC_RADIO[RadioID]->Radio_country_code)
		{
			case COUNTRY_CHINA_CN : 	
									if ((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11A)||(AC_RADIO[RadioID]->Radio_Type == 10))
									{
										max_channel = 159;
										min_channel = 7;
										if((AC_RADIO[RadioID]->Radio_Chan == 149)||(AC_RADIO[RadioID]->Radio_Chan == 153)||(AC_RADIO[RadioID]->Radio_Chan == 157)\
											||(AC_RADIO[RadioID]->Radio_Chan == 161)||(AC_RADIO[RadioID]->Radio_Chan == 165)){
											if(AC_RADIO[RadioID]->channel_offset == 1){
													if(AC_RADIO[RadioID]->Radio_Chan <= max_channel){

													}else{
														change_channel = 157;
														WID_RADIO_SET_CHAN(RadioID,change_channel);
														AC_RADIO[RadioID]->Radio_Chan = 157;
													}
												}else if(AC_RADIO[RadioID]->channel_offset == -1){
													if(AC_RADIO[RadioID]->Radio_Chan >= min_channel){
																				
													}else{
														change_channel =149;
														WID_RADIO_SET_CHAN(RadioID,change_channel);
														AC_RADIO[RadioID]->Radio_Chan = 149;
													}

												}
												
										}else{
											if(AC_RADIO[RadioID]->channel_offset == 1){
												change_channel = 157;
												WID_RADIO_SET_CHAN(RadioID,change_channel);
												AC_RADIO[RadioID]->Radio_Chan = 157;
											}else if(AC_RADIO[RadioID]->channel_offset == -1){
												change_channel = 149;
												WID_RADIO_SET_CHAN(RadioID,change_channel);
												AC_RADIO[RadioID]->Radio_Chan = 149;
											}else{
												change_channel = 153;
												wid_syslog_debug_debug(WID_DBUS,"**********before set channel********");
												WID_RADIO_SET_CHAN(RadioID,change_channel);
												wid_syslog_debug_debug(WID_DBUS,"**********after set channel********");
												AC_RADIO[RadioID]->Radio_Chan = 153;

											}
										}
										
									}else{
										max_channel = 9;
										min_channel = 5;
										if(AC_RADIO[RadioID]->channel_offset == 1){
											if(AC_RADIO[RadioID]->Radio_Chan <= max_channel){

													}else{
														change_channel = 8;														
														WID_RADIO_SET_CHAN(RadioID,change_channel);
														AC_RADIO[RadioID]->Radio_Chan = 8;
													}
										}else if(AC_RADIO[RadioID]->channel_offset == -1){
											if(AC_RADIO[RadioID]->Radio_Chan >= min_channel){

													}else{
														change_channel = 8;
														WID_RADIO_SET_CHAN(RadioID,change_channel);
														AC_RADIO[RadioID]->Radio_Chan = 8;
													}
										
										}
									}
									break;
									
			case COUNTRY_EUROPE_EU : 
									if ((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11A)||(AC_RADIO[RadioID]->Radio_Type == 10))
										{
											max_channel = 134;
											min_channel = 7;
										if((AC_RADIO[RadioID]->Radio_Chan == 36)||(AC_RADIO[RadioID]->Radio_Chan == 40)||(AC_RADIO[RadioID]->Radio_Chan == 44)\
											||(AC_RADIO[RadioID]->Radio_Chan == 48)||(AC_RADIO[RadioID]->Radio_Chan == 52)||(AC_RADIO[RadioID]->Radio_Chan == 56)\
											||(AC_RADIO[RadioID]->Radio_Chan == 60)||(AC_RADIO[RadioID]->Radio_Chan == 64)||(AC_RADIO[RadioID]->Radio_Chan == 100)\
											||(AC_RADIO[RadioID]->Radio_Chan == 104)||(AC_RADIO[RadioID]->Radio_Chan == 108)||(AC_RADIO[RadioID]->Radio_Chan == 112)\
											||(AC_RADIO[RadioID]->Radio_Chan == 116)||(AC_RADIO[RadioID]->Radio_Chan == 120)||(AC_RADIO[RadioID]->Radio_Chan == 124)\
											||(AC_RADIO[RadioID]->Radio_Chan == 128)||(AC_RADIO[RadioID]->Radio_Chan == 132)||(AC_RADIO[RadioID]->Radio_Chan == 136)\
											||(AC_RADIO[RadioID]->Radio_Chan == 140)) 
										{
											if(AC_RADIO[RadioID]->channel_offset == 1){
													if(AC_RADIO[RadioID]->Radio_Chan <= max_channel){

													}else{
														change_channel = 128;
														WID_RADIO_SET_CHAN(RadioID,change_channel);
														AC_RADIO[RadioID]->Radio_Chan = 128;
													}
												}else if(AC_RADIO[RadioID]->channel_offset == -1){
													if(AC_RADIO[RadioID]->Radio_Chan >= min_channel){
																				
													}else{
														change_channel = 36;
														WID_RADIO_SET_CHAN(RadioID,change_channel);
														AC_RADIO[RadioID]->Radio_Chan = 36;
													}

												}
												
											}else{
												if(AC_RADIO[RadioID]->channel_offset == 1){
													change_channel = 128;
													
													WID_RADIO_SET_CHAN(RadioID,change_channel);
													AC_RADIO[RadioID]->Radio_Chan = 128;
												}else if(AC_RADIO[RadioID]->channel_offset == -1){
													AC_RADIO[RadioID]->Radio_Chan = 36;
													WID_RADIO_SET_CHAN(RadioID,AC_RADIO[RadioID]->Radio_Chan);
												}else{
													change_channel = 108;
													WID_RADIO_SET_CHAN(RadioID,change_channel);
													AC_RADIO[RadioID]->Radio_Chan = 108;

											}
										}
									}else{
										max_channel = 9;
										min_channel = 5;
										if(AC_RADIO[RadioID]->channel_offset == 1){
											if(AC_RADIO[RadioID]->Radio_Chan <= max_channel){

													}else{
														change_channel = 8;
														WID_RADIO_SET_CHAN(RadioID,change_channel);
														AC_RADIO[RadioID]->Radio_Chan = 8;
													}
										}else if(AC_RADIO[RadioID]->channel_offset == -1){
											if(AC_RADIO[RadioID]->Radio_Chan >= min_channel){

													}else{
														change_channel = 8;
														WID_RADIO_SET_CHAN(RadioID,change_channel);
														AC_RADIO[RadioID]->Radio_Chan = 8;
													}
										
										}
									}	
									break;
																	
			case COUNTRY_USA_US : 
									if ((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11A)||(AC_RADIO[RadioID]->Radio_Type == 10)){
										max_channel = 159;
										min_channel = 7;
										if((AC_RADIO[RadioID]->Radio_Chan == 36)||(AC_RADIO[RadioID]->Radio_Chan == 40)||(AC_RADIO[RadioID]->Radio_Chan == 44)\
											||(AC_RADIO[RadioID]->Radio_Chan == 48)||(AC_RADIO[RadioID]->Radio_Chan == 52)||(AC_RADIO[RadioID]->Radio_Chan == 56)\
											||(AC_RADIO[RadioID]->Radio_Chan == 60)||(AC_RADIO[RadioID]->Radio_Chan == 64)||(AC_RADIO[RadioID]->Radio_Chan == 100)\
											||(AC_RADIO[RadioID]->Radio_Chan == 104)||(AC_RADIO[RadioID]->Radio_Chan == 108)||(AC_RADIO[RadioID]->Radio_Chan == 112)\
											||(AC_RADIO[RadioID]->Radio_Chan == 116)||(AC_RADIO[RadioID]->Radio_Chan == 120)||(AC_RADIO[RadioID]->Radio_Chan == 124)\
											||(AC_RADIO[RadioID]->Radio_Chan == 128)||(AC_RADIO[RadioID]->Radio_Chan == 132)||(AC_RADIO[RadioID]->Radio_Chan == 136)\
											||(AC_RADIO[RadioID]->Radio_Chan == 140)||(AC_RADIO[RadioID]->Radio_Chan == 149)||(AC_RADIO[RadioID]->Radio_Chan == 153)\
											||(AC_RADIO[RadioID]->Radio_Chan == 157)||(AC_RADIO[RadioID]->Radio_Chan == 161)||(AC_RADIO[RadioID]->Radio_Chan == 165)) 
									{
										if(AC_RADIO[RadioID]->channel_offset == 1){
													if(AC_RADIO[RadioID]->Radio_Chan <= max_channel){

													}else{
														change_channel = 157;
														
														WID_RADIO_SET_CHAN(RadioID,change_channel);
														AC_RADIO[RadioID]->Radio_Chan = 157;
													}
												}else if(AC_RADIO[RadioID]->channel_offset == -1){
													if(AC_RADIO[RadioID]->Radio_Chan >= min_channel){
																				
													}else{
														change_channel = 36;
														WID_RADIO_SET_CHAN(RadioID,change_channel);
														AC_RADIO[RadioID]->Radio_Chan = 36;
													}

												}
												
											}else{
												if(AC_RADIO[RadioID]->channel_offset == 1){
													change_channel = 157;
													WID_RADIO_SET_CHAN(RadioID,change_channel);
													AC_RADIO[RadioID]->Radio_Chan = 157;
												}else if(AC_RADIO[RadioID]->channel_offset == -1){
													change_channel = 36;
													WID_RADIO_SET_CHAN(RadioID,change_channel);
													AC_RADIO[RadioID]->Radio_Chan = 36;
													
												}else{
													change_channel = 108;
													WID_RADIO_SET_CHAN(RadioID,change_channel);
													AC_RADIO[RadioID]->Radio_Chan = 108;

											}

											}
									}else{
										max_channel = 7;
										min_channel = 5;
										if(AC_RADIO[RadioID]->channel_offset == 1){
											if(AC_RADIO[RadioID]->Radio_Chan <= max_channel){

													}else{
														change_channel = 6;
														WID_RADIO_SET_CHAN(RadioID,change_channel);
														AC_RADIO[RadioID]->Radio_Chan = 6;
													}
										}else if(AC_RADIO[RadioID]->channel_offset == -1){
											if(AC_RADIO[RadioID]->Radio_Chan >= min_channel){

													}else{
														change_channel = 6;
														WID_RADIO_SET_CHAN(RadioID,change_channel);
														AC_RADIO[RadioID]->Radio_Chan = 6;
													}
										
										}else if(AC_RADIO[RadioID]->Radio_Chan > 11){
												change_channel = 11;
												WID_RADIO_SET_CHAN(RadioID,change_channel);
												AC_RADIO[RadioID]->Radio_Chan = 11;
										}
										
									}
									break;
																	
			case COUNTRY_JAPAN_JP : 
									if ((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11A)||(AC_RADIO[RadioID]->Radio_Type == 10)){
										max_channel = 40;
										min_channel = 7;
										if((AC_RADIO[RadioID]->Radio_Chan == 36)||(AC_RADIO[RadioID]->Radio_Chan == 40)||(AC_RADIO[RadioID]->Radio_Chan == 44)\
											||(AC_RADIO[RadioID]->Radio_Chan == 48)||(AC_RADIO[RadioID]->Radio_Chan == 52)||(AC_RADIO[RadioID]->Radio_Chan == 56)\
											||(AC_RADIO[RadioID]->Radio_Chan == 60)||(AC_RADIO[RadioID]->Radio_Chan == 64)||(AC_RADIO[RadioID]->Radio_Chan == 100)\
											||(AC_RADIO[RadioID]->Radio_Chan == 104)||(AC_RADIO[RadioID]->Radio_Chan == 108)||(AC_RADIO[RadioID]->Radio_Chan == 112)\
											||(AC_RADIO[RadioID]->Radio_Chan == 116)||(AC_RADIO[RadioID]->Radio_Chan == 120)||(AC_RADIO[RadioID]->Radio_Chan == 124)\
											||(AC_RADIO[RadioID]->Radio_Chan == 128)||(AC_RADIO[RadioID]->Radio_Chan == 132)||(AC_RADIO[RadioID]->Radio_Chan == 136)\
											||(AC_RADIO[RadioID]->Radio_Chan == 140)||(AC_RADIO[RadioID]->Radio_Chan == 184)||(AC_RADIO[RadioID]->Radio_Chan == 188)\
											||(AC_RADIO[RadioID]->Radio_Chan == 192)||(AC_RADIO[RadioID]->Radio_Chan == 196))
									{
										if(AC_RADIO[RadioID]->channel_offset == 1){
													if(AC_RADIO[RadioID]->Radio_Chan <= max_channel){

													}else{
														change_channel = 36;
														WID_RADIO_SET_CHAN(RadioID,change_channel);
														AC_RADIO[RadioID]->Radio_Chan = 36;
													}
												}else if(AC_RADIO[RadioID]->channel_offset == -1){
													if(AC_RADIO[RadioID]->Radio_Chan >= min_channel){
																				
													}else{
														change_channel = 36;
														WID_RADIO_SET_CHAN(RadioID,change_channel);
														AC_RADIO[RadioID]->Radio_Chan = 36;
													}

												}
												
											}else{
												if(AC_RADIO[RadioID]->channel_offset == 1){
													change_channel = 36;
													WID_RADIO_SET_CHAN(RadioID,change_channel);
													AC_RADIO[RadioID]->Radio_Chan = 36;
												}else if(AC_RADIO[RadioID]->channel_offset == -1){
													change_channel = 36;
													WID_RADIO_SET_CHAN(RadioID,change_channel);
													AC_RADIO[RadioID]->Radio_Chan = 36;
												}else{
													change_channel = 108;
													WID_RADIO_SET_CHAN(RadioID,change_channel);
													AC_RADIO[RadioID]->Radio_Chan = 108;

												}
											}
									}else{
										max_channel = 10;
										min_channel = 5;
										if(AC_RADIO[RadioID]->channel_offset == 1){
											if(AC_RADIO[RadioID]->Radio_Chan <= max_channel){

													}else{
														change_channel = 6;
														WID_RADIO_SET_CHAN(RadioID,change_channel);
														AC_RADIO[RadioID]->Radio_Chan = 6;
													}
										}else if(AC_RADIO[RadioID]->channel_offset == -1){
											if(AC_RADIO[RadioID]->Radio_Chan >= min_channel){

													}else{
														change_channel = 6;
														WID_RADIO_SET_CHAN(RadioID,change_channel);
														AC_RADIO[RadioID]->Radio_Chan = 6;
													}
											}
									}										
									break;
																	
			case COUNTRY_FRANCE_FR : 
									if ((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11A)||(AC_RADIO[RadioID]->Radio_Type == 10)){
										max_channel = 134;
										min_channel = 7;
										if((AC_RADIO[RadioID]->Radio_Chan == 36)||(AC_RADIO[RadioID]->Radio_Chan == 40)||(AC_RADIO[RadioID]->Radio_Chan == 44)\
											||(AC_RADIO[RadioID]->Radio_Chan == 48)||(AC_RADIO[RadioID]->Radio_Chan == 52)||(AC_RADIO[RadioID]->Radio_Chan == 56)\
											||(AC_RADIO[RadioID]->Radio_Chan == 60)||(AC_RADIO[RadioID]->Radio_Chan == 64)||(AC_RADIO[RadioID]->Radio_Chan == 100)\
											||(AC_RADIO[RadioID]->Radio_Chan == 104)||(AC_RADIO[RadioID]->Radio_Chan == 108)||(AC_RADIO[RadioID]->Radio_Chan == 112)\
											||(AC_RADIO[RadioID]->Radio_Chan == 116)||(AC_RADIO[RadioID]->Radio_Chan == 120)||(AC_RADIO[RadioID]->Radio_Chan == 124)\
											||(AC_RADIO[RadioID]->Radio_Chan == 128)||(AC_RADIO[RadioID]->Radio_Chan == 132)||(AC_RADIO[RadioID]->Radio_Chan == 136)\
											||(AC_RADIO[RadioID]->Radio_Chan == 140))
										{
											if(AC_RADIO[RadioID]->channel_offset == 1){
													if(AC_RADIO[RadioID]->Radio_Chan <= max_channel){

													}else{
														change_channel = 132;
														WID_RADIO_SET_CHAN(RadioID,change_channel);
														AC_RADIO[RadioID]->Radio_Chan = 132;
													}
												}else if(AC_RADIO[RadioID]->channel_offset == -1){
													if(AC_RADIO[RadioID]->Radio_Chan >= min_channel){
																				
													}else{
														change_channel = 36;
														WID_RADIO_SET_CHAN(RadioID,change_channel);
														AC_RADIO[RadioID]->Radio_Chan = 36;
													}

												}
												
											}else{
												if(AC_RADIO[RadioID]->channel_offset == 1){
													change_channel = 132;
													WID_RADIO_SET_CHAN(RadioID,change_channel);
													AC_RADIO[RadioID]->Radio_Chan = 132;
												}else if(AC_RADIO[RadioID]->channel_offset == -1){
													change_channel = 36;
													WID_RADIO_SET_CHAN(RadioID,change_channel);
													AC_RADIO[RadioID]->Radio_Chan = 36;
												}else{
													change_channel = 108;
													WID_RADIO_SET_CHAN(RadioID,change_channel);
													AC_RADIO[RadioID]->Radio_Chan = 108;

												}
											}
									}else{
										max_channel = 7;
										min_channel = 7;
										if(AC_RADIO[RadioID]->channel_offset == 1){
											if(AC_RADIO[RadioID]->Radio_Chan <= max_channel){

													}else{
														change_channel = 6;
														WID_RADIO_SET_CHAN(RadioID,change_channel);
														AC_RADIO[RadioID]->Radio_Chan = 6;
													}
										}else if(AC_RADIO[RadioID]->channel_offset == -1){
											if(AC_RADIO[RadioID]->Radio_Chan >= min_channel){

													}else{
														change_channel = 8;
														WID_RADIO_SET_CHAN(RadioID,change_channel);
														AC_RADIO[RadioID]->Radio_Chan = 8;
													}
											}
									}	
									break;
																	
			case COUNTRY_SPAIN_ES : 
									if ((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11A)||(AC_RADIO[RadioID]->Radio_Type == 10)){
										max_channel = 134;
										min_channel = 7;
										if((AC_RADIO[RadioID]->Radio_Chan == 36)||(AC_RADIO[RadioID]->Radio_Chan == 40)||(AC_RADIO[RadioID]->Radio_Chan == 44)\
											||(AC_RADIO[RadioID]->Radio_Chan == 48)||(AC_RADIO[RadioID]->Radio_Chan == 52)||(AC_RADIO[RadioID]->Radio_Chan == 56)\
											||(AC_RADIO[RadioID]->Radio_Chan == 60)||(AC_RADIO[RadioID]->Radio_Chan == 64)||(AC_RADIO[RadioID]->Radio_Chan == 100)\
											||(AC_RADIO[RadioID]->Radio_Chan == 104)||(AC_RADIO[RadioID]->Radio_Chan == 108)||(AC_RADIO[RadioID]->Radio_Chan == 112)\
											||(AC_RADIO[RadioID]->Radio_Chan == 116)||(AC_RADIO[RadioID]->Radio_Chan == 120)||(AC_RADIO[RadioID]->Radio_Chan == 124)\
											||(AC_RADIO[RadioID]->Radio_Chan == 128)||(AC_RADIO[RadioID]->Radio_Chan == 132)||(AC_RADIO[RadioID]->Radio_Chan == 136)\
											||(AC_RADIO[RadioID]->Radio_Chan == 140))
										{
											if(AC_RADIO[RadioID]->channel_offset == 1){
													if(AC_RADIO[RadioID]->Radio_Chan <= max_channel){

													}else{
														change_channel = 132;
														WID_RADIO_SET_CHAN(RadioID,change_channel);
														AC_RADIO[RadioID]->Radio_Chan = 132;
													}
												}else if(AC_RADIO[RadioID]->channel_offset == -1){
													if(AC_RADIO[RadioID]->Radio_Chan >= min_channel){
																				
													}else{
														change_channel = 36;
														WID_RADIO_SET_CHAN(RadioID,change_channel);
														AC_RADIO[RadioID]->Radio_Chan = 36;
													}

												}
												
											}else{
												if(AC_RADIO[RadioID]->channel_offset == 1){
													change_channel = 132;
													WID_RADIO_SET_CHAN(RadioID,change_channel);
													AC_RADIO[RadioID]->Radio_Chan = 132;
												}else if(AC_RADIO[RadioID]->channel_offset == -1){
													change_channel = 36;
													WID_RADIO_SET_CHAN(RadioID,change_channel);
													AC_RADIO[RadioID]->Radio_Chan = 36;
												}else{
													change_channel = 108;
													WID_RADIO_SET_CHAN(RadioID,change_channel);
													AC_RADIO[RadioID]->Radio_Chan = 108;

												}
											}
									}else{
										max_channel = 5;
										min_channel = 7;
										if(AC_RADIO[RadioID]->channel_offset == 1){
											if(AC_RADIO[RadioID]->Radio_Chan <= max_channel){

													}else{
														change_channel = 4;
														WID_RADIO_SET_CHAN(RadioID,change_channel);
														AC_RADIO[RadioID]->Radio_Chan = 4;
													}
										}else if(AC_RADIO[RadioID]->channel_offset == -1){
											if(AC_RADIO[RadioID]->Radio_Chan >= min_channel){

													}else{
														change_channel = 6;
														WID_RADIO_SET_CHAN(RadioID,change_channel);
														AC_RADIO[RadioID]->Radio_Chan = 6;
													}
											}
									}	
									break;
		
			default : 
			break;
		}		
	}
	return 0;
}
	
/*end*/
int wid_set_country_code_a8()
{
	int i = 0;
	int j = 0;
	char apcmd[WID_SYSTEM_CMD_LENTH];
	memset(apcmd, 0 ,WID_SYSTEM_CMD_LENTH);
	
	if (gCOUNTRYCODE == COUNTRY_USA_US)
	{
		sprintf(apcmd,"set regdmn FCC");
	}
	else if (gCOUNTRYCODE == COUNTRY_EUROPE_EU)
	{
		sprintf(apcmd,"set regdmn ETSI");
	}
	else
	{
		sprintf(apcmd,"set regdmn RoW");
	}
	
	wid_syslog_debug_debug(WID_DEFAULT,"set regdmn :%s",apcmd);
	
	for (i = 0; i < WTP_NUM; i++)
	{
		if (AC_WTP[i] != NULL)
		{
			for (j = 0; j < AC_WTP[i]->RadioCount; j++)
			{
				if ((AC_WTP[i]->WTP_Radio[j] != NULL) && (AC_WTP[i]->WTP_Radio[j]->REFlag != 0))
				{
					wid_radio_set_extension_command(i, apcmd);
				}
			}
		}
	}
    return 0;
}


int WID_RADIO_SET_SUPPORT_RATE(unsigned int RadioID, int RadioRate[],int flag,int num)
{
	int i = 0;
	int rate = 0;
	int drate[ACDBUSHANDLE_11BG_RATE_LIST_LEN] = {10,20,55,60,90,110,120,180,240,360,480,540};
	int wrate[ACDBUSHANDLE_11BG_RATE_LIST_LEN] = {0};
	msgq msg;
	
	struct Support_Rate_List *ptr = NULL;
	
	WID_CHECK_G_RADIOID_STANDARD_RET(RadioID, RADIO_ID_NOT_EXIST);
	
	if( NULL == AC_RADIO || NULL == AC_RADIO[RadioID]|| CW_FALSE == check_wtpid_func(AC_RADIO[RadioID]->WTPID))
	{
		return WTP_ID_NOT_EXIST;
	}
	
	if((gWTPs[AC_RADIO[RadioID]->WTPID].currentState == CW_ENTER_RUN)&&(AC_RADIO[RadioID]->AdStat == 2))
	{
		return RADIO_IS_DISABLE;
	}
	if(AC_RADIO[RadioID]->Support_Rate_Count < 1)//rate list is empty
	{
		return RADIO_SUPPORT_RATE_EMPTY;
	}
	//printf("the list have %d rates\n",AC_RADIO[RadioID]->Support_Rate_Count);
	if(AC_RADIO[RadioID]->Radio_Rate == NULL)//rate list is empty
	{
		//printf("the list is empty\n");
		//return RADIO_SUPPORT_RATE_EMPTY;
	}

	//check with the radio type
	for(i = 0; i < num; i++)
	{
		if((AC_RADIO[RadioID]->Radio_Type == Radio_11b)
			||(AC_RADIO[RadioID]->Radio_Type == Radio_11g)
			||(AC_RADIO[RadioID]->Radio_Type == Radio_11bg)
			||(AC_RADIO[RadioID]->Radio_Type == Radio_11a)
			||(AC_RADIO[RadioID]->Radio_Type == Radio_11an)
			||(AC_RADIO[RadioID]->Radio_Type == Radio_11gn)
			||(AC_RADIO[RadioID]->Radio_Type == Radio_11bgn)
			||(AC_RADIO[RadioID]->Radio_Type == Radio_11a_11an)
			||(AC_RADIO[RadioID]->Radio_Type == Radio_11g_11gn)
			||(AC_RADIO[RadioID]->Radio_Type == Radio_11ac)
			||(AC_RADIO[RadioID]->Radio_Type == Radio_11an_11ac)
            ||(AC_RADIO[RadioID]->Radio_Type == Radio_11a_11an_11ac))
		{
			if((RadioRate[i] == 10)||(RadioRate[i] == 20)||(RadioRate[i] == 55)||(RadioRate[i] == 110)
				|| (RadioRate[i] == 60)||(RadioRate[i] == 90)||(RadioRate[i] == 120)||(RadioRate[i] == 180)
				||(RadioRate[i] == 240)||(RadioRate[i] == 360)||(RadioRate[i] == 480)||(RadioRate[i] == 540))
			{
			}
			else
			{
				return WTP_NO_SURPORT_Rate;
			}
		}
		else
		{
			return WTP_NO_SURPORT_TYPE;
		}
					
		//added end
		switch(AC_RADIO[RadioID]->Radio_Type)
		{
			case Radio_11b :
			        if((RadioRate[i] == 10)||(RadioRate[i] == 20)||(RadioRate[i] == 55)||(RadioRate[i] == 110))
					{
					
					}
					else
					{
						return WTP_NO_SURPORT_Rate;
					}
					break;

			case Radio_11a :
			        if((RadioRate[i] == 60)||(RadioRate[i] == 90)||(RadioRate[i] == 120)||(RadioRate[i] == 180)
					   	||(RadioRate[i] == 240)||(RadioRate[i] == 360)||(RadioRate[i] == 480)||(RadioRate[i] == 540))
					{
					
					}
					else
					{
						return WTP_NO_SURPORT_Rate;
					}
					break;
					
			case Radio_11g :
			        if((RadioRate[i] == 60)||(RadioRate[i] == 90)||(RadioRate[i] == 120)||(RadioRate[i] == 180)
					   	||(RadioRate[i] == 240)||(RadioRate[i] == 360)||(RadioRate[i] == 480)||(RadioRate[i] == 540))
					{
					
					}
					else
					{
						return WTP_NO_SURPORT_Rate;
					}
					break;

			case Radio_11bg :
			        if((RadioRate[i] == 10)||(RadioRate[i] == 20)||(RadioRate[i] == 55)||(RadioRate[i] == 110)
					   	||(RadioRate[i] == 60)||(RadioRate[i] == 90)||(RadioRate[i] == 120)||(RadioRate[i] == 180)
					   	||(RadioRate[i] == 240)||(RadioRate[i] == 360)||(RadioRate[i] == 480)||(RadioRate[i] == 540))
					{
					
					}
					else
					{
						return WTP_NO_SURPORT_Rate;
					}
					break;

			case Radio_11an :
			        if((RadioRate[i] == 60)||(RadioRate[i] == 90)||(RadioRate[i] == 120)||(RadioRate[i] == 180)
					   	||(RadioRate[i] == 240)||(RadioRate[i] == 360)||(RadioRate[i] == 480)||(RadioRate[i] == 540))
					{
					
					}
					else
					{
						return WTP_NO_SURPORT_Rate;
					}
					break;

			case Radio_11gn :
			        if((RadioRate[i] == 60)||(RadioRate[i] == 90)||(RadioRate[i] == 120)||(RadioRate[i] == 180)
					   	||(RadioRate[i] == 240)||(RadioRate[i] == 360)||(RadioRate[i] == 480)||(RadioRate[i] == 540))
					{
					
					}
					else
					{
						return WTP_NO_SURPORT_Rate;
					}
					break;

			case Radio_11bgn : 
					if((RadioRate[i] == 10)||(RadioRate[i] == 20)||(RadioRate[i] == 55)||(RadioRate[i] == 110)
			   			||(RadioRate[i] == 60)||(RadioRate[i] == 90)||(RadioRate[i] == 120)||(RadioRate[i] == 180)
			   			||(RadioRate[i] == 240)||(RadioRate[i] == 360)||(RadioRate[i] == 480)||(RadioRate[i] == 540))
					{
					
					}
					else
					{
						return WTP_NO_SURPORT_Rate;
					}
					break;

			case Radio_11a_11an :
			        if((RadioRate[i] == 60)||(RadioRate[i] == 90)||(RadioRate[i] == 120)||(RadioRate[i] == 180)
					   	||(RadioRate[i] == 240)||(RadioRate[i] == 360)||(RadioRate[i] == 480)||(RadioRate[i] == 540))
					{
					
					}
					else
					{
						return WTP_NO_SURPORT_Rate;
					}
					break;
			
			case Radio_11g_11gn :
			        if((RadioRate[i] == 60)||(RadioRate[i] == 90)||(RadioRate[i] == 120)||(RadioRate[i] == 180)
					   	||(RadioRate[i] == 240)||(RadioRate[i] == 360)||(RadioRate[i] == 480)||(RadioRate[i] == 540))
					{
					
					}
					else
					{
						return WTP_NO_SURPORT_Rate;
					}
					break;

			case Radio_11ac :
			        if((RadioRate[i] == 60)||(RadioRate[i] == 90)||(RadioRate[i] == 120)||(RadioRate[i] == 180)
					   	||(RadioRate[i] == 240)||(RadioRate[i] == 360)||(RadioRate[i] == 480)||(RadioRate[i] == 540))
					{
					
					}
					else
					{
						return WTP_NO_SURPORT_Rate;
					}
					break;

			case Radio_11an_11ac :
			        if((RadioRate[i] == 60)||(RadioRate[i] == 90)||(RadioRate[i] == 120)||(RadioRate[i] == 180)
					   	||(RadioRate[i] == 240)||(RadioRate[i] == 360)||(RadioRate[i] == 480)||(RadioRate[i] == 540))
					{
					
					}
					else
					{
						return WTP_NO_SURPORT_Rate;
					}
					break;


			case Radio_11a_11an_11ac:
			        if((RadioRate[i] == 60)||(RadioRate[i] == 90)||(RadioRate[i] == 120)||(RadioRate[i] == 180)
					   	||(RadioRate[i] == 240)||(RadioRate[i] == 360)||(RadioRate[i] == 480)||(RadioRate[i] == 540))
					{
					
					}
					else
					{
						return WTP_NO_SURPORT_Rate;
					}
					break;

					
			default : return WTP_NO_SURPORT_TYPE;
			break;
		}			
	}

	//process append to the flag
	switch(flag)
	{
		//flag 1 means add
		case 1 :
				destroy_support_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				AC_RADIO[RadioID]->Support_Rate_Count = num;

				//AC_RADIO[RadioID]->Radio_Rate = (struct Support_Rate_List *)malloc(sizeof(struct Support_Rate_List));
				AC_RADIO[RadioID]->Radio_Rate = create_support_rate_list(1);//here add 0 first
				
				for(i=0;i<num;i++)
				{
					rate = RadioRate[i];
					AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
				}
				
				AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 0);
				AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				//printf("/////the list has %d element////\n",AC_RADIO[RadioID]->Support_Rate_Count);
				//display_support_rate_list(AC_RADIO[RadioID]->Radio_Rate);
							
				break;
				
		//flag 2 means delete  not use now
		case 2 :			
				for(i = 0; i < num; i++)
				{
					rate = RadioRate[i];
					
					ptr = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,rate);
					if(ptr == NULL)//rate is in the list 
					{
						return RADIO_SUPPORT_RATE_NOT_EXIST;
					}
					else//rate is not in the list 
					{
						/* Coverity: CID: 10187  Error-Type: Resource leak */
						ptr = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
						AC_RADIO[RadioID]->Radio_Rate = ptr;
						AC_RADIO[RadioID]->Support_Rate_Count--;

						//display_support_rate_list(AC_RADIO[RadioID]->Radio_Rate);
					}
				}
				break;

		//flag 3 means set max rate,first destroy the list,then create a new list append to the radio type
		case 3 :
				if(num > 1)
				{
					return RADIO_SUPPORT_MAX_RATE_NOT_ONE;
				}
				destroy_support_rate_list(AC_RADIO[RadioID]->Radio_Rate);

				if(AC_RADIO[RadioID]->Radio_Type == Radio_11b)
				{
					switch(RadioRate[0])
					{
						case 10 : wrate[0] = 10;
								  num = 1;
								  break;
						case 20 : wrate[0] = 10;
								  wrate[1] = 20;
								  num = 2;
								  break;
						case 55 : wrate[0] = 10;
								  wrate[1] = 20;
								  wrate[2] = 55;
								  num = 3;
								  break;
						case 110 : wrate[0] = 10;
								   wrate[1] = 20;
								   wrate[2] = 55;
								   wrate[3] = 110;
								   num = 4;
								   break;
						default : num = 0;
								  break;

					}
				}
				else if((AC_RADIO[RadioID]->Radio_Type == Radio_11g)
				        ||(AC_RADIO[RadioID]->Radio_Type == Radio_11a)
						||(AC_RADIO[RadioID]->Radio_Type == Radio_11an)
						||(AC_RADIO[RadioID]->Radio_Type == Radio_11gn)
						||(AC_RADIO[RadioID]->Radio_Type == Radio_11a_11an)
						||(AC_RADIO[RadioID]->Radio_Type == Radio_11g_11gn)
                        ||(AC_RADIO[RadioID]->Radio_Type == Radio_11ac)
                        ||(AC_RADIO[RadioID]->Radio_Type == Radio_11an_11ac)
                        ||(AC_RADIO[RadioID]->Radio_Type == Radio_11a_11an_11ac))
				{
					switch(RadioRate[0])
					{

						case 60 : wrate[0] = 60;
								  num = 1;
								  break;
						case 90 : wrate[0] = 60;
								  wrate[1] = 90;
								  num = 2;
								  break;
						case 120 : wrate[0] = 60;
								  wrate[1] = 90;
								  wrate[2] = 120;
								  num = 3;
								  break;
						case 180 : wrate[0] = 60;
								   wrate[1] = 90;
								   wrate[2] = 120;
								   wrate[3] = 180;
								   num = 4;
								   break;
						case 240 : wrate[0] = 60;
								   wrate[1] = 90;
								   wrate[2] = 120;
								   wrate[3] = 180;
								   wrate[4] = 240;
								   num = 5;
								   break;
						case 360 : wrate[0] = 60;
								   wrate[1] = 90;
								   wrate[2] = 120;
								   wrate[3] = 180;
								   wrate[4] = 240;
								   wrate[5] = 360;
								   num = 6;
								   break;
						case 480 : wrate[0] = 60;
								   wrate[1] = 90;
								   wrate[2] = 120;
								   wrate[3] = 180;
								   wrate[4] = 240;
								   wrate[5] = 360;
								   wrate[6] = 480;
								   num = 7;
								   break;
						case 540 : wrate[0] = 60;
								   wrate[1] = 90;
								   wrate[2] = 120;
								   wrate[3] = 180;
								   wrate[4] = 240;
								   wrate[5] = 360;
								   wrate[6] = 480;
								   wrate[7] = 540;
								   num = 8;
								   break;
						default : num = 0;
								  break;

					}
				}
				else if(AC_RADIO[RadioID]->Radio_Type == Radio_11bg || AC_RADIO[RadioID]->Radio_Type == Radio_11bgn)
				{
					switch(RadioRate[0])
					{
						
						case 10 : num = 1;
								  break;
						case 20 : num = 2;
								  break;
						case 55 : num = 3;
								  break;
						case 60 : num = 4;
								  break;
						case 90 : num = 5;
								  break;
						case 110 : num = 6;
								   break;
						case 120 : num = 7;
								  break;
						case 180 : num = 8;
								  break;
						case 240 : num = 9;
								  break;
						case 360 : num = 10;
								  break;
						case 480 : num = 11;
								  break;
						case 540 : num = 12;
								  break;
						default : num = 0;
								  break;
						
					}
					for(i = 0; i < num; i++)
					{
						wrate[i] = drate[i];
					}
				}		
				else//add 11n or others
				{
					return RADIO_SUPPORT_RATE_CONFLICT;
				}
				//create a new list
				ptr = create_support_rate_list(1);
				AC_RADIO[RadioID]->Support_Rate_Count = num;
				for(i = 0; i < num; i++)
				{
					ptr = insert_rate_into_list(ptr,wrate[i]);
				}
				AC_RADIO[RadioID]->Radio_Rate = ptr;
				AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 0);
				AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);

				//printf("/////the list has %d element////\n",AC_RADIO[RadioID]->Support_Rate_Count);
				
				//display_support_rate_list(AC_RADIO[RadioID]->Radio_Rate);

				break;
				
		default : break;
	}	
	
	if(AC_WTP[AC_RADIO[RadioID]->WTPID]->WTPStat == WID_RUN)
	{
		AC_RADIO[RadioID]->CMD |= 0x4;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->radioid[AC_RADIO[RadioID]->Radio_L_ID] += 1;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->setCMD = 1;	
		int WTPIndex = AC_RADIO[RadioID]->WTPID;
	
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_Rates;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
			msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}

		}
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}

	return 0;
}

int WID_RADIO_SET_MODE(unsigned int RadioID, unsigned int RadioMode)
{
	int rate = 0;
	int IGNORE_UBSV ret = 0;
	unsigned int old_radiotype = 0;
	msgq msg;
	if((gWTPs[AC_RADIO[RadioID]->WTPID].currentState == CW_ENTER_RUN)&&(AC_RADIO[RadioID]->AdStat == 2))
	{
		return RADIO_IS_DISABLE;
	}

	if(AC_RADIO[RadioID]->Radio_Type == RadioMode)
	{
		return 0;
	}
	
	if((RadioMode == Radio_11a) || (RadioMode == Radio_11b) || (RadioMode == Radio_11g) || (RadioMode == Radio_11bg)
	    || (RadioMode == Radio_11n) ||(RadioMode == Radio_11an)||(RadioMode == Radio_11gn)||(RadioMode == Radio_11bgn)
	    ||(RadioMode == Radio_11a_11an)||(RadioMode == Radio_11g_11gn)/*||(RadioMode == 37) fengwenchao modify 20111109 for GM*/
		||(RadioMode == Radio_11ac)||(RadioMode == Radio_11an_11ac)||(RadioMode == Radio_11a_11an_11ac)) 
	{
	}
	else
	{
		return WTP_NO_SURPORT_TYPE;
	}
	/*fengwenchao modify begin for GM 20111109*/
	if ((15 == AC_RADIO[RadioID]->Radio_Type_Bank) || (127 == AC_RADIO[RadioID]->Radio_Type_Bank))
	{
	}
	else if(Radio_11g_11gn == RadioMode)
	{
		if((13 == AC_RADIO[RadioID]->Radio_Type_Bank) || (44 == AC_RADIO[RadioID]->Radio_Type_Bank))
		{
				
		}
		else
		{
			return WTP_NO_SURPORT_TYPE;		
		}
	}
	else
	{
		if((AC_RADIO[RadioID]->Radio_Type_Bank | RadioMode) != AC_RADIO[RadioID]->Radio_Type_Bank)
		{
			return WTP_NO_SURPORT_TYPE;
		}		
	}
	/*fengwenchao modify end*/
	
    old_radiotype = AC_RADIO[RadioID]->Radio_Type;
	AC_RADIO[RadioID]->Radio_Type = RadioMode;
	wid_syslog_debug_debug(WID_DEFAULT,"%s:%d radio%d-%d type(%d) %s, set type (%d) %s\n",
							__func__,__LINE__,RadioID/L_RADIO_NUM,RadioID%L_RADIO_NUM,old_radiotype,
							WAI_RADIO_TYPE_STR(old_radiotype),RadioMode,WAI_RADIO_TYPE_STR(RadioMode));
	if(AC_WTP[AC_RADIO[RadioID]->WTPID]->WTPStat == WID_RUN)
	{
		AC_RADIO[RadioID]->CMD |= 0x8;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->radioid[AC_RADIO[RadioID]->Radio_L_ID] += 1;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->setCMD = 1;	
		int WTPIndex = AC_RADIO[RadioID]->WTPID;
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_Mode;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
			msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}

	//after set mode, rate is setting to default 
	destroy_support_rate_list(AC_RADIO[RadioID]->Radio_Rate);	

	AC_RADIO[RadioID]->Radio_Rate = create_support_rate_list(1);

	if((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11B) > 0)
	{
		AC_RADIO[RadioID]->Support_Rate_Count = 4;
		
		rate = 10;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

		rate = 20;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

		rate = 55;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

		rate = 110;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,0);
		AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
	}
	if(((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11A) > 0)||((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11AC) > 0))
	{
		AC_RADIO[RadioID]->Support_Rate_Count = 8;
	
		rate = 60;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

		rate = 90;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		rate = 120;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		rate = 180;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		rate = 240;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		rate = 360;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		rate = 480;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		

		rate = 540;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

				
		AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,0);
		delsame_rate_from_list(AC_RADIO[RadioID]->Radio_Rate);
		AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
	}
	if((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11G) > 0)
	{
		AC_RADIO[RadioID]->Support_Rate_Count = 8;

		rate = 60;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

		rate = 90;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

		rate = 120;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		rate = 180;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		rate = 240;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		rate = 360;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		rate = 480;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		

		rate = 540;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,0);
		delsame_rate_from_list(AC_RADIO[RadioID]->Radio_Rate);
		AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
	}
	if(((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11N) > 0) || ((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11AC) > 0))
	{
		if(AC_RADIO[RadioID]->chainmask_num == 1)
		{
			if((0 == AC_RADIO[RadioID]->cwmode) || (3 == AC_RADIO[RadioID]->cwmode))
			{
				if(0 == AC_RADIO[RadioID]->guardinterval)
				{
					rate = 650;
					AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
				}
				else if(1 == AC_RADIO[RadioID]->guardinterval)
				{
					rate = 722;
					AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
				}
			}
			else if((1 == AC_RADIO[RadioID]->cwmode)||(2 == AC_RADIO[RadioID]->cwmode)||(4 == AC_RADIO[RadioID]->cwmode))
			{
				if(0 == AC_RADIO[RadioID]->guardinterval)
				{
					rate = 1350;
					AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
				}
				else if(1 == AC_RADIO[RadioID]->guardinterval)
				{
					rate = 1500;
					AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
				}
			}
		}
		else if(AC_RADIO[RadioID]->chainmask_num == 2)
		{
			if((0 == AC_RADIO[RadioID]->cwmode) || (3 == AC_RADIO[RadioID]->cwmode))
			{
				if(0 == AC_RADIO[RadioID]->guardinterval)
				{
					rate = 1300;
					AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
				}
				else if(1 == AC_RADIO[RadioID]->guardinterval)
				{
					rate = 1444;
					AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
				}
			}
			else if((1 == AC_RADIO[RadioID]->cwmode)||(2 == AC_RADIO[RadioID]->cwmode)||(4 == AC_RADIO[RadioID]->cwmode))
			{
				if(0 == AC_RADIO[RadioID]->guardinterval)
				{
					rate = 2700;
					AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
				}
				else if(1 == AC_RADIO[RadioID]->guardinterval)
				{
					rate = 3000;
					AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
				}
			}
		}
        
        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 0);
        delsame_rate_from_list(AC_RADIO[RadioID]->Radio_Rate);
        AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
	}

	if(AC_WTP[AC_RADIO[RadioID]->WTPID]->WTPStat == WID_RUN)
	{
		AC_RADIO[RadioID]->CMD |= 0x4;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->radioid[AC_RADIO[RadioID]->Radio_L_ID] += 1;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->setCMD = 1;	
		int WTPIndex = AC_RADIO[RadioID]->WTPID;
	
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_Rates;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
			msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}

		}
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}
	if(((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11N) == IEEE80211_11N)
		|| ((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11AC) == IEEE80211_11AC))
	{
		wid_radio_set_mcs_list(RadioID);
        if(0 == AC_RADIO[RadioID]->QOSID)
        {
            WID_ADD_RADIO_APPLY_QOS(RadioID, QOS_NUM-1, 1);
        }
	}
	if(((3 == AC_RADIO[RadioID]->cwmode)||(4 == AC_RADIO[RadioID]->cwmode)||(5 == AC_RADIO[RadioID]->cwmode))
	    &&((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11AC) != 0)
    	&&((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11N) == IEEE80211_11N))
    {
        AC_RADIO[RadioID]->cwmode = 0;
        wid_radio_set_cmmode(RadioID);
    }
	if((IEEE80211_11N == (old_radiotype&IEEE80211_11N))
    	&& (0 == (AC_RADIO[RadioID]->Radio_Type&IEEE80211_11N))
	    && (IEEE80211_11N == (AC_RADIO[RadioID]->Radio_Type_Bank&IEEE80211_11N))
	    && (QOS_NUM-1 == AC_RADIO[RadioID]->QOSID))
	{
        ret = WID_ADD_RADIO_APPLY_QOS(RadioID, QOS_NUM-1, 0);
		if(AC_RADIO[RadioID]->QOSstate == 0)
		{							
			AC_RADIO[RadioID]->QOSID = 0;
		}
	}
	WID_RADIO_SET_CHAN(RadioID, 0);
	
	/*fengwenchao add 20120716 for autelan-3057*/
	if((AC_RADIO[RadioID]->Radio_Type == Radio_11an)||(AC_RADIO[RadioID]->Radio_Type == Radio_11gn))  // 10-an, 12-gn
	{
		AC_RADIO[RadioID]->MixedGreenfield.Mixed_Greenfield = 1;
		memset(AC_RADIO[RadioID]->MixedGreenfield.Wlan_Mixed, 1, WLAN_NUM);					
	}
	else if((AC_RADIO[RadioID]->Radio_Type & IEEE80211_11N) > 0)
	{
		AC_RADIO[RadioID]->MixedGreenfield.Mixed_Greenfield = 0;
		memset(AC_RADIO[RadioID]->MixedGreenfield.Wlan_Mixed, 0, WLAN_NUM);
	}
	/*fengwenchao add end*/
	
	return 0;
}

//added by weiay
int WID_RADIO_SET_BEACON(unsigned int RadioID, unsigned short beaconinterval)
{
	msgq msg;
	if((gWTPs[AC_RADIO[RadioID]->WTPID].currentState == CW_ENTER_RUN)&&(AC_RADIO[RadioID]->AdStat == 2))
	{
		return RADIO_IS_DISABLE;
	}

	if(AC_RADIO[RadioID]->BeaconPeriod == beaconinterval)
	{
		return 0;
	}
	
	AC_RADIO[RadioID]->BeaconPeriod = beaconinterval;
	wid_syslog_debug_debug(WID_DEFAULT,"set radio id is:%d, beaconinterval is %d",RadioID,beaconinterval);
	
	if(AC_WTP[AC_RADIO[RadioID]->WTPID]->WTPStat == WID_RUN)
	{
		AC_RADIO[RadioID]->CMD |= 0x10;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->radioid[AC_RADIO[RadioID]->Radio_L_ID] += 1;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->setCMD = 1;	
		int WTPIndex = AC_RADIO[RadioID]->WTPID;
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_BeaconPeriod;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
			msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}

		}
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}

	return 0;

}
int WID_RADIO_SET_FRAGMENTATION(unsigned int RadioID, unsigned short fragmentation)
{
	msgq msg;
	if((gWTPs[AC_RADIO[RadioID]->WTPID].currentState == CW_ENTER_RUN)&&(AC_RADIO[RadioID]->AdStat == 2))
	{
		return RADIO_IS_DISABLE;
	}

	if(AC_RADIO[RadioID]->FragThreshold== fragmentation)
	{
		return 0;
	}
	
	AC_RADIO[RadioID]->FragThreshold = fragmentation;
	wid_syslog_debug_debug(WID_DEFAULT,"set radio id is:%d, fragmentation is %d",RadioID,fragmentation);
	
	if(AC_WTP[AC_RADIO[RadioID]->WTPID]->WTPStat == WID_RUN)
	{
		AC_RADIO[RadioID]->CMD |= 0x20;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->radioid[AC_RADIO[RadioID]->Radio_L_ID] += 1;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->setCMD = 1;	
		int WTPIndex = AC_RADIO[RadioID]->WTPID;
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_FragThreshold;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
			msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}

	return 0;

}
int WID_RADIO_SET_DTIM(unsigned int RadioID, unsigned char dtim)
{
	msgq msg;
	if((gWTPs[AC_RADIO[RadioID]->WTPID].currentState == CW_ENTER_RUN)&&(AC_RADIO[RadioID]->AdStat == 2))
	{
		return RADIO_IS_DISABLE;
	}

	if(AC_RADIO[RadioID]->DTIMPeriod == dtim)
	{
		return 0;
	}
	
	AC_RADIO[RadioID]->DTIMPeriod = dtim;
	wid_syslog_debug_debug(WID_DEFAULT,"set radio id is:%d, dtim is %d",RadioID,dtim);
	
	if(AC_WTP[AC_RADIO[RadioID]->WTPID]->WTPStat == WID_RUN)
	{
		AC_RADIO[RadioID]->CMD |= 0x10;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->radioid[AC_RADIO[RadioID]->Radio_L_ID] += 1;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->setCMD = 1;	
		int WTPIndex = AC_RADIO[RadioID]->WTPID;
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_DTIMPeriod;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
			msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}

	return 0;

}
int WID_RADIO_SET_RTSTHRESHOLD(unsigned int RadioID, unsigned short rtsthreshold)
{
	msgq msg;
	if((gWTPs[AC_RADIO[RadioID]->WTPID].currentState == CW_ENTER_RUN)&&(AC_RADIO[RadioID]->AdStat == 2))
	{
		return RADIO_IS_DISABLE;
	}

	if(AC_RADIO[RadioID]->rtsthreshold == rtsthreshold)
	{
		return 0;
	}
	
	AC_RADIO[RadioID]->rtsthreshold = rtsthreshold;
	wid_syslog_debug_debug(WID_DEFAULT,"set radio id is:%d, rtsthreshold is %d",RadioID,rtsthreshold);
	
	if(AC_WTP[AC_RADIO[RadioID]->WTPID]->WTPStat == WID_RUN)
	{
		AC_RADIO[RadioID]->CMD |= 0x20;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->radioid[AC_RADIO[RadioID]->Radio_L_ID] += 1;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->setCMD = 1;	
		int WTPIndex = AC_RADIO[RadioID]->WTPID;
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_rtsthreshold;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
			msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}

		}
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}

	return 0;

}
int WID_RADIO_SET_STATUS(unsigned int RadioID, unsigned char status)
{
	msgq msg;
	
	/*fengwenchao add 20110922 for radio disable config save*/
	if(status == 1)
	{
		AC_RADIO[RadioID]->radio_disable_flag = 0; 
	}
	else if(status == 2)
	{
		AC_RADIO[RadioID]->radio_disable_flag = 1; 	
	}
	/*fengwenchao add end*/
	if(AC_RADIO[RadioID]->OpStat == status)
	{
		return 0;
	}
	if((gWTPs[AC_RADIO[RadioID]->WTPID].currentState != CW_ENTER_RUN))
	{
		return WTP_NOT_IN_RUN_STATE;
	}

	/* book add, 2011-1-25 */
	if(1 == status){
	    AC_RADIO[RadioID]->upcount++;
	}
	else if(2 == status){
	    AC_RADIO[RadioID]->downcount++;
	}
	
	AC_RADIO[RadioID]->OpStat = status;
	AC_RADIO[RadioID]->AdStat = status;
	wid_syslog_debug_debug(WID_DEFAULT,"set radio id is:%d, status is %d",RadioID,status);
	
	if(AC_WTP[AC_RADIO[RadioID]->WTPID]->WTPStat == WID_RUN)
	{
		AC_RADIO[RadioID]->CMD |= 0x80;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->radioid[AC_RADIO[RadioID]->Radio_L_ID] += 1;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->setCMD = 1;	
		int WTPIndex = AC_RADIO[RadioID]->WTPID;
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_STATUS;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
			msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
					wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}

	return 0;

}
int WID_RADIO_SET_PREAMBLE(unsigned int RadioID, unsigned char preamble)
{
	msgq msg;
	if((gWTPs[AC_RADIO[RadioID]->WTPID].currentState == CW_ENTER_RUN)&&(AC_RADIO[RadioID]->AdStat == 2))
	{
		return RADIO_IS_DISABLE;
	}

	if(AC_RADIO[RadioID]->IsShortPreamble == preamble)
	{
		return 0;
	}
	
	AC_RADIO[RadioID]->IsShortPreamble = preamble;
	wid_syslog_debug_debug(WID_DEFAULT,"set radio id is:%d, IsShortPreamble is %d",RadioID,preamble);
	
	if(AC_WTP[AC_RADIO[RadioID]->WTPID]->WTPStat == WID_RUN)
	{
		AC_RADIO[RadioID]->CMD |= 0x10;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->radioid[AC_RADIO[RadioID]->Radio_L_ID] += 1;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->setCMD = 1;	
		int WTPIndex = AC_RADIO[RadioID]->WTPID;
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_Preamble;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
			msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
					wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}

		}
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}

	return 0;

}
int WID_RADIO_SET_SHORTRETRY(unsigned int RadioID, unsigned char shortretry)
{
	msgq msg;
	if((gWTPs[AC_RADIO[RadioID]->WTPID].currentState == CW_ENTER_RUN)&&(AC_RADIO[RadioID]->AdStat == 2))
	{
		return RADIO_IS_DISABLE;
	}

	if(AC_RADIO[RadioID]->ShortRetry == shortretry)
	{
		return 0;
	}
	
	AC_RADIO[RadioID]->ShortRetry = shortretry;
	wid_syslog_debug_debug(WID_DEFAULT,"set radio id is:%d, ShortRetry is %d",RadioID,shortretry);
	
	if(AC_WTP[AC_RADIO[RadioID]->WTPID]->WTPStat == WID_RUN)
	{
		AC_RADIO[RadioID]->CMD |= 0x20;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->radioid[AC_RADIO[RadioID]->Radio_L_ID] += 1;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->setCMD = 1;	
		int WTPIndex = AC_RADIO[RadioID]->WTPID;
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_ShortRetry;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
			msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
					wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}

		}		
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}

	return 0;

}
int WID_RADIO_SET_LONGRETRY(unsigned int RadioID, unsigned char longretry)
{
	msgq msg;
	if((gWTPs[AC_RADIO[RadioID]->WTPID].currentState == CW_ENTER_RUN)&&(AC_RADIO[RadioID]->AdStat == 2))
	{
		return RADIO_IS_DISABLE;
	}

	if(AC_RADIO[RadioID]->LongRetry == longretry)
	{
		return 0;
	}
	
	AC_RADIO[RadioID]->LongRetry = longretry;
	wid_syslog_debug_debug(WID_DEFAULT,"set radio id is:%d, LongRetry is %d",RadioID,longretry);
	
	if(AC_WTP[AC_RADIO[RadioID]->WTPID]->WTPStat == WID_RUN)
	{
		AC_RADIO[RadioID]->CMD |= 0x20;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->radioid[AC_RADIO[RadioID]->Radio_L_ID] += 1;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->setCMD = 1;	
		int WTPIndex = AC_RADIO[RadioID]->WTPID;
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_LongRetry;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
			msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
					wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}

		}
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}

	return 0;

}


int WID_ADD_WLAN_APPLY_RADIO(unsigned int RadioID,unsigned char WlanID,int tosend)
{
	int ret = -1;
	int i = 0, k1 = 0;	
	char nas_id[NAS_IDENTIFIER_NAME] = {0};
	unsigned int nas_id_len = 0;
	int WtpID = RadioID/L_RADIO_NUM;
	int localradio_id = RadioID%L_RADIO_NUM;
	unsigned char IGNORE_UBSV aclgroupid = 0;
		
	if (AC_RADIO[RadioID]->BindingWlanCount >= L_BSS_NUM)
	{
		return WTP_OVER_MAX_BSS_NUM;
	}

	if (AC_WLAN[WlanID] == NULL)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d radio%d-%d bind wlan%d not exist\n",__func__,__LINE__,WtpID,localradio_id,WlanID);
		return WLAN_ID_NOT_EXIST;
	}

	if (AC_WLAN[WlanID]->Wlan_Ifi != NULL)
	{
		if (AC_WTP[WtpID]->BindingSystemIndex != -1)
		{
			struct ifi *wlan_ifi = AC_WLAN[WlanID]->Wlan_Ifi;
			while (wlan_ifi != NULL)
			{
				if (AC_WTP[WtpID]->BindingSystemIndex == wlan_ifi->ifi_index)
				{
					if (wlan_ifi->nas_id_len > 0)
					{
						nas_id_len = wlan_ifi->nas_id_len;
						memcpy(nas_id, wlan_ifi->nas_id, NAS_IDENTIFIER_NAME);
					}
					break;
				}
				wlan_ifi = wlan_ifi->ifi_next;
			}
			
			if (wlan_ifi == NULL)
			{
				wid_syslog_debug_debug(WID_DEFAULT,"%s:%d wtp%d binding interface doesn't match with wlan%d\n",__func__,__LINE__,WtpID,WlanID);
				//return WTP_WLAN_BINDING_NOT_MATCH;
			}			
		}
		else
		{
			wid_syslog_warning("<warning>%s:%d wtp%d WTP_IF_NOT_BE_BINDED\n",__func__,__LINE__,WtpID);
			//return WTP_IF_NOT_BE_BINDED;
		}
	}
	else
	{
		wid_syslog_warning("<warning>%s:%d wlan%d Wlan_IF_NOT_BE_BINDED\n",__func__,__LINE__,WlanID);
		//return Wlan_IF_NOT_BE_BINDED;
	}
		
	struct wlanid *wlan_id = NULL;
	struct wlanid *wlan_id_next = NULL;
	wlan_id = (struct wlanid*)malloc(sizeof(struct wlanid));
	if (NULL == wlan_id)
	{
		return MALLOC_ERROR;
	}
	memset(wlan_id, 0, sizeof(struct wlanid));
	wlan_id->wlanid = WlanID;
	wlan_id->next = NULL;
	
	if (AC_RADIO[RadioID]->Wlan_Id == NULL)
	{		
		AC_RADIO[RadioID]->Wlan_Id = wlan_id ;		
		AC_RADIO[RadioID]->isBinddingWlan = 1;
		AC_RADIO[RadioID]->BindingWlanCount++;
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d radio%d-%d binding first wlan id:%d\n",__func__,__LINE__,WtpID,localradio_id,WlanID);
	}
	else
	{	
		wlan_id_next = AC_RADIO[RadioID]->Wlan_Id;
		while (wlan_id_next != NULL)
		{	
			if (wlan_id_next->wlanid == WlanID)
			{
				wid_syslog_debug_debug(WID_DEFAULT,"%s:%d warnning radio%d-%d have binding wlan%d\n",__func__,__LINE__,WtpID,localradio_id,WlanID);
				CW_FREE_OBJECT(wlan_id);
				return 0;
			}
			else
			{
				if(((AC_WLAN[wlan_id_next->wlanid])
    				    && (AC_WLAN[wlan_id_next->wlanid]->SecurityID == AC_WLAN[WlanID]->SecurityID)
    					&& (AC_WLAN[WlanID]->KeyLen))
					|| ((AC_WLAN[wlan_id_next->wlanid])
					    && (AC_WLAN[WlanID]->KeyLen)
					    && (AC_WLAN[wlan_id_next->wlanid]->KeyLen == AC_WLAN[WlanID]->KeyLen)
						&& (strncmp(AC_WLAN[wlan_id_next->wlanid]->WlanKey, AC_WLAN[WlanID]->WlanKey, AC_WLAN[WlanID]->KeyLen) == 0)))
				{
			#if NOSOFTAC
					wid_dbug_trap_ssid_key_conflict(WtpID, (unsigned char)localradio_id, wlan_id_next->wlanid, WlanID);
			#endif
				}
			}
			wlan_id_next = wlan_id_next->next;
		}

		wlan_id_next = AC_RADIO[RadioID]->Wlan_Id;
		while(wlan_id_next->next!= NULL)
		{	
			wlan_id_next = wlan_id_next->next;//insert element int tail
		}
		
		wlan_id_next->next= wlan_id;
		AC_RADIO[RadioID]->BindingWlanCount++;
		
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d radio%d-%d binding more wlan:%d\n",__func__,__LINE__,WtpID,localradio_id,WlanID);
	}

	for(k1 = 0; k1 < L_BSS_NUM; k1++)
    {
		if(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1] == NULL)
		{
			if((RadioID)*L_BSS_NUM+k1 >= BSS_NUM)
			{
				WID_DELETE_WLAN_APPLY_RADIO(RadioID, WlanID);
				wid_syslog_err("<error>%s: invalid bssindex:%d\n",__func__,(RadioID)*L_BSS_NUM+k1);
				return BSS_ID_LARGE_THAN_MAX;
			}
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1] = (WID_BSS*)malloc(sizeof(WID_BSS));
			memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1], 0, sizeof(WID_BSS));
			memset(&(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSS_pkt_info), 0, sizeof(BSSStatistics));
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSID = (unsigned char*)malloc(MAC_LEN);
			memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSID, 0, MAC_LEN);
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->bss_max_allowed_sta_num = AC_WLAN[WlanID]->bss_allow_max_sta_num;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->WlanID = WlanID;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->Radio_G_ID = RadioID;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->Radio_L_ID = localradio_id;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->State = 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->keyindex = 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->band_width = 25;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->ath_l2_isolation = AC_WLAN[WlanID]->wlan_ath_l2_isolation;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->cwmmode = 1;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->traffic_limit_able = 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->traffic_limit = AC_WLAN[WlanID]->wlan_traffic_limit;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->average_rate = AC_WLAN[WlanID]->wlan_station_average_traffic_limit;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->send_traffic_limit = AC_WLAN[WlanID]->wlan_send_traffic_limit;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->send_average_rate = AC_WLAN[WlanID]->wlan_station_average_send_traffic_limit;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->ip_mac_binding = AC_WLAN[WlanID]->sta_ip_mac_bind;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->upcount= 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->downcount = 0;				
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->limit_sta_rssi = AC_WLAN[WlanID]->wlan_limit_sta_rssi; //fengwenchao add 20120222 for RDIR-25
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex = (RadioID)*L_BSS_NUM+k1;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSS_IF_POLICY = AC_WLAN[WlanID]->wlan_if_policy;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->vMAC_STATE = 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->WDSStat = AC_WLAN[WlanID]->WDSStat;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->wds_mesh = AC_WLAN[WlanID]->wds_mesh;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->wblwm= AC_WLAN[WlanID]->wds_mesh;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->wds_bss_list = NULL;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSS_TUNNEL_POLICY = AC_WLAN[WlanID]->WLAN_TUNNEL_POLICY;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->multi_user_optimize_switch = AC_WLAN[WlanID]->multi_user_optimize_switch;
			memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSS_IF_NAME, 0, ETH_IF_NAME_LEN);
			memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_id, 0, NAS_IDENTIFIER_NAME);
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_id_len = 0;
			if(nas_id_len > 0)
			{
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_id_len = nas_id_len;
				memcpy(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_id, nas_id, NAS_IDENTIFIER_NAME);
			}
			memset(&(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSS_pkt_info), 0, sizeof(BSSStatistics));
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf = (struct acl_config *)malloc(sizeof(struct acl_config));
			memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf, 0, sizeof(struct acl_config));
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->macaddr_acl = 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->accept_mac = NULL;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->num_accept_mac = 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->deny_mac = NULL;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->num_deny_mac = 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->vlanid = 0;
			//put wlan-vlan to bss
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->wlan_vlanid = AC_WLAN[WlanID]->vlanid;

			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->hotspot_id = AC_WLAN[WlanID]->hotspot_id;
			memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->arp_ifname, 0, ETH_IF_NAME_LEN);
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->sta_static_arp_policy = AC_WLAN[WlanID]->wlan_sta_static_arp_policy;
			memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_port_id, 0, NAS_PORT_ID_LEN);
			memcpy(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_port_id, AC_WLAN[WlanID]->nas_port_id, NAS_PORT_ID_LEN);
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->packet_power = AC_WLAN[WlanID]->packet_power;
			AC_BSS[AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex] = AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1];
			AC_RADIO[RadioID]->BSS[k1] = AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1];
			AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id] = AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex;
			AC_RADIO[RadioID]->BSS[k1]->muti_rate = AC_WLAN[WlanID]->wlan_muti_rate;
			AC_RADIO[RadioID]->BSS[k1]->noResToStaProReqSW = AC_WLAN[WlanID]->wlan_noResToStaProReqSW;
			AC_RADIO[RadioID]->BSS[k1]->muti_bro_cast_sw = AC_WLAN[WlanID]->wlan_muti_bro_cast_sw;
			AC_RADIO[RadioID]->BSS[k1]->unicast_sw = AC_WLAN[WlanID]->wlan_unicast_sw;
			AC_RADIO[RadioID]->BSS[k1]->wifi_sw = AC_WLAN[WlanID]->wlan_wifi_sw;
			//radio apply wep wlan
			if((AC_WLAN[WlanID]->EncryptionType == WEP)&&(AC_WLAN[WlanID]->SecurityType != IEEE8021X))
			{
				for (i = 0; i < WTP_WEP_NUM; i++)
				{
					if (AC_RADIO[RadioID]->wep_flag[i] == 0)
					{
						int k = 0;
						for (k = 0; k < i; k++)
						{
							if ((AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k]->keyindex == AC_WLAN[WlanID]->SecurityIndex)
								&& (AC_WLAN[AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k]->WlanID]->EncryptionType == WEP))
							{
								WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
								return SECURITYINDEX_IS_SAME;
							}
						}
					}
					int j = 0;
					j = AC_WLAN[WlanID]->SecurityIndex - 1;
					if (j < WTP_WEP_NUM)
					{
						if (AC_RADIO[RadioID]->wep_flag[j] == 0)
						{
							AC_RADIO[RadioID]->wep_flag[j] = (RadioID)*L_BSS_NUM+k1;
							AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->keyindex = AC_WLAN[WlanID]->SecurityIndex;															
							break;
						}
					}	
					else
					{
						wid_syslog_debug_debug(WID_DEFAULT,"%s:%d radio%d-%d apply wep wlan over 4\n",__func__,__LINE__,WtpID,localradio_id);
						WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
						return WTP_WEP_NUM_OVER;
					}
				}
			}
			
			if (AC_WLAN[WlanID]->wlan_if_policy == BSS_INTERFACE)
			{
				ret = Create_BSS_L3_Interface(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex);
				if (ret < 0)
				{
					//WID_DELETE_WLAN_APPLY_WTP(WtpID, WlanID);
					WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
					return WLAN_CREATE_L3_INTERFACE_FAIL;
				}
			}
			else if (AC_WLAN[WlanID]->wlan_if_policy == WLAN_INTERFACE)
			{
				ret = Create_BSS_L3_Interface(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex);
				if (ret < 0)
				{
					//WID_DELETE_WLAN_APPLY_WTP(WtpID, WlanID);
					WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
					return WLAN_CREATE_L3_INTERFACE_FAIL;
				}
				
				ret = ADD_BSS_L3_Interface_BR(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex);
				if (ret < 0)
				{
					//WID_DELETE_WLAN_APPLY_WTP(WtpID, WlanID);
					WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
                    return BSS_L3_INTERFACE_ADD_BR_FAIL;
				}
			}
			break;
		}
	}	
	
	if (k1 == L_BSS_NUM)
	{
		return WTP_OVER_MAX_BSS_NUM;
	}
	if (AC_WLAN[WlanID]->Status == 1)
	{
		wid_syslog_info("%s: wlan%d is disable, just bind not to send add wlan msg\n",__func__,WlanID);
		return 0;
	}

	if (tosend)
	{
        issued_wlan_enable(WtpID,localradio_id,WlanID,LEVEL_RADIO);
    }

	int bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id]; 
	
	char apcmd[WID_SYSTEM_CMD_LENTH];
	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);
	if ((AC_WLAN[WlanID]->eap_mac_switch == 1)
	    && (AC_WLAN[WlanID]->wlan_if_policy == NO_INTERFACE)
	    && (AC_BSS[bssindex] != NULL)
	    && (AC_BSS[bssindex]->BSS_IF_POLICY == NO_INTERFACE))
	{
	    sprintf(apcmd,"set_eap_mac ath.%d-%d %s",AC_RADIO[RadioID]->Radio_L_ID,WlanID,AC_WLAN[WlanID]->eap_mac);
	}
	else
	{
	    sprintf(apcmd,"set_eap_mac ath.%d-%d 0",AC_RADIO[RadioID]->Radio_L_ID,WlanID);
	}
	wid_syslog_debug_debug(WID_DEFAULT,"%s:%d wtp%d enable wlan%d: set eap mac cmd %s\n",__func__,__LINE__,WtpID,WlanID,apcmd);
	wid_radio_set_extension_command(WtpID,apcmd);
	
	/* wlan tunnel switch func for REQUIREMENTS-264 */
	memset(apcmd, 0, WID_SYSTEM_CMD_LENTH);
	if (AC_WLAN[WlanID]->wlan_tunnel_switch == 1)
	{
		sprintf(apcmd,TUNNEL_SWITCH_CMD";"AP_OPEN_IPFORWARD";"AP_SPFAST_DOWM";"AP_SPFAST_UP,AC_RADIO[RadioID]->Radio_L_ID,WlanID);
		wid_radio_set_extension_command(WtpID,apcmd);
	}
    
	if ((check_bssid_func(bssindex)) && (AC_BSS[bssindex] != NULL))
	{
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d wlan%d bss[%d]->traffic_limit = %d\n",__func__,__LINE__,WlanID,bssindex,AC_BSS[bssindex]->traffic_limit_able);
		WID_Save_Traffic_Limit(bssindex, WtpID);
	}
	
	if ((AC_BSS[bssindex]) && (AC_BSS[bssindex]->BSS_IF_POLICY != NO_INTERFACE)
		&& (AC_BSS[bssindex]->BSS_TUNNEL_POLICY != CW_802_DOT_11_TUNNEL))
	{
		msgq msg;
		struct msgqlist *elem = NULL;
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WtpID%THREAD_NUM+1;
		msg.mqinfo.WTPID = WtpID;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WLAN_S_TYPE;
		msg.mqinfo.u.WlanInfo.Wlan_Op = WLAN_CHANGE_TUNNEL;
		msg.mqinfo.u.WlanInfo.WLANID = WlanID;
		msg.mqinfo.u.WlanInfo.Radio_L_ID = localradio_id;		
		msg.mqinfo.u.WlanInfo.bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id];
		
		if ((AC_WTP[WtpID]->WTPStat == WID_RUN))
		{
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}
		else
		{
			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if (elem == NULL)
			{
				wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
				return 0;
			}
			memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
			elem->next = NULL;
			memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
			WID_INSERT_CONTROL_LIST(WtpID, elem);
		}
	}
	
	if ((0 != AC_WLAN[WlanID]->aclgrp_id) && (NULL != STA_ACL_GROUP[AC_WLAN[WlanID]->aclgrp_id]))
	{
		msgq msg;
		struct msgqlist *elem = NULL;
		aclgroupid = AC_WLAN[WlanID]->aclgrp_id;
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WtpID%THREAD_NUM+1;
		msg.mqinfo.WTPID = WtpID;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WTP_S_TYPE;
		msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_ACL_LIST;
		msg.mqinfo.u.WtpInfo.value[0] = WlanID;
		msg.mqinfo.u.WtpInfo.value[1] = localradio_id;
		msg.mqinfo.u.WtpInfo.value[2] = OVERWRITE;
		msg.mqinfo.u.WtpInfo.value[3] = LEVEL_WLAN;
		msg.mqinfo.u.WtpInfo.value[4] = AC_WLAN[WlanID]->aclgrp_id;
		
		if (AC_WTP[WtpID]->WTPStat == WID_RUN)
		{
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}
		else
		{
			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if (NULL == elem)
			{
				WID_MALLOC_ERR();			
				return 0;
			}
			memset(elem, 0, sizeof(struct msgqlist));
			elem->mqinfo.WTPID = WtpID;
			elem->mqinfo.type = CONTROL_TYPE;
			elem->mqinfo.subtype = WTP_S_TYPE;
			elem->mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_ACL_LIST;
			elem->mqinfo.u.WtpInfo.value[0] = WlanID;
			elem->mqinfo.u.WtpInfo.value[1] = localradio_id;
			elem->mqinfo.u.WtpInfo.value[2] = OVERWRITE;
			elem->mqinfo.u.WtpInfo.value[3] = LEVEL_WLAN;
			elem->mqinfo.u.WtpInfo.value[4] = AC_WLAN[WlanID]->aclgrp_id;

			WID_INSERT_CONTROL_LIST(WtpID, elem);
		}
	}
	
	if ((AC_BSS[bssindex]) && (AC_BSS[bssindex]->multi_user_optimize_switch == 1))
	{
		char wlanid = AC_BSS[bssindex]->WlanID;
		int radioid = AC_BSS[bssindex]->Radio_G_ID;
		muti_user_optimize_switch(wlanid,radioid,1);		
	}	
	if (check_bssid_func(bssindex) && (0 != AC_BSS[bssindex]->packet_power))
	{
		WID_RADIO_WLAN_PACKET_POWER(WtpID, localradio_id, WlanID, AC_BSS[bssindex]->packet_power);
	}
	
	if (0 != memcmp(QOS_AP_11E_TO_1P_DEFAULT, AC_WLAN[WlanID]->qos_ap_11e_to_1p, MAX_QOS_11E_VAL+1))
	{
		set_ap_bss_qos_map_default(WtpID, localradio_id, QOS_MAP_11E_TO_1P, WlanID);
	}
	if (0 != memcmp(QOS_AP_11E_TO_DSCP_DEFAULT, AC_WLAN[WlanID]->qos_ap_11e_to_dscp, MAX_QOS_11E_VAL+1))
	{
		set_ap_bss_qos_map_default(WtpID, localradio_id, QOS_MAP_11E_TO_DSCP, WlanID);
	}
	if (0 != memcmp(QOS_AP_DSCP_TO_11E_DEFAULT, AC_WLAN[WlanID]->qos_ap_dscp_to_11e, MAX_QOS_DSCP_VAL+1))
	{
		set_ap_bss_qos_map_default(WtpID, localradio_id, QOS_MAP_DSCP_TO_11E, WlanID);
	}
	if (0 != memcmp(QOS_AP_1P_TO_11E_DEFAULT, AC_WLAN[WlanID]->qos_ap_1p_to_11e, MAX_QOS_1P_VAL+1))
	{
		set_ap_bss_qos_map_default(WtpID, localradio_id, QOS_MAP_1P_TO_11E, WlanID);
	}
	if (0 != AC_WLAN[WlanID]->qos_ap_11e_to_1p_switch)
	{
		set_ap_bss_qos_map_switch(WtpID, localradio_id, WlanID, QOS_MAP_11E_TO_1P, AC_WLAN[WlanID]->qos_ap_11e_to_1p_switch);
	}
	if (0 != AC_WLAN[WlanID]->qos_ap_11e_to_dscp_switch)
	{
		set_ap_bss_qos_map_switch(WtpID, localradio_id, WlanID, QOS_MAP_11E_TO_DSCP, AC_WLAN[WlanID]->qos_ap_11e_to_dscp_switch);
	}
	if (check_bssid_func(bssindex) && (0 != AC_BSS[bssindex]->packet_power))
	{
		WID_RADIO_WLAN_PACKET_POWER(WtpID, localradio_id, WlanID, AC_BSS[bssindex]->packet_power);
	}
	if ((check_bssid_func(bssindex)) &&(0 != AC_WLAN[WlanID]->balance_switch))
	{											
		wid_bss_balance_switch(WtpID, localradio_id, WlanID);										
	}

	return 0;
}

int WID_ADD_WLAN_APPLY_RADIO_BASE_VLANID(unsigned int RadioID,unsigned char WlanID,unsigned int vlan_id)
{
	int ret = -1;
	int k1 = 0;
	int i = 0;
	int WtpID = 0;
	int localradio_id = 0;
	unsigned int nas_id_len = 0;
	char nas_id[NAS_IDENTIFIER_NAME] = {0};
	char apcmd[WID_SYSTEM_CMD_LENTH] = {0};
	unsigned char IGNORE_UBSV aclgroupid = 0;
	
	WID_CHECK_WLAN_EXIST_RET(WlanID, WLAN_ID_NOT_EXIST);
	
	if ((RadioID > G_RADIO_NUM) || (RadioID < L_RADIO_NUM) || (NULL == AC_RADIO[RadioID]))
	{
		return RADIO_ID_NOT_EXIST;
	}
	
	if (AC_RADIO[RadioID]->BindingWlanCount >= L_BSS_NUM)
	{
		return WTP_OVER_MAX_BSS_NUM;
	}
	
	WtpID = RadioID/L_RADIO_NUM;
	localradio_id = RadioID%L_RADIO_NUM;
	
	if (AC_WLAN[WlanID]->Wlan_Ifi != NULL)
	{
		if (AC_WTP[WtpID]->BindingSystemIndex != -1)
		{
			struct ifi *wlan_ifi = AC_WLAN[WlanID]->Wlan_Ifi;
			while (wlan_ifi != NULL)
			{
				if (AC_WTP[WtpID]->BindingSystemIndex == wlan_ifi->ifi_index)
				{
					if (wlan_ifi->nas_id_len > 0)
					{
						nas_id_len = wlan_ifi->nas_id_len;
						memcpy(nas_id, wlan_ifi->nas_id, NAS_IDENTIFIER_NAME);
					}
					break;
				}
				wlan_ifi = wlan_ifi->ifi_next;
			}
			
			if (wlan_ifi == NULL)
			{
				wid_syslog_debug_debug(WID_DEFAULT,"%s: wtp%d binding interface doesn't match with wlan%d\n",__func__, WtpID, WlanID);
				//return WTP_WLAN_BINDING_NOT_MATCH;
			}
		}
		else
		{
			wid_syslog_warning("<warning>%s:%d wtp%d WTP_IF_NOT_BE_BINDED\n", __func__, __LINE__, WtpID);
			//return WTP_IF_NOT_BE_BINDED;
		}
	}
	else
	{
		wid_syslog_warning("<warning>%s:%d wlan%d Wlan_IF_NOT_BE_BINDED\n", __func__, __LINE__, WlanID);
		//return Wlan_IF_NOT_BE_BINDED;
	}
	
	struct wlanid *wlan_id = NULL;
	struct wlanid *wlan_id_next = NULL;
	wlan_id = (struct wlanid*)malloc(sizeof(struct wlanid));
	if (NULL == wlan_id)
	{
		return MALLOC_ERROR;
	}
	memset(wlan_id, 0, sizeof(struct wlanid));
	wlan_id->wlanid = WlanID;
	wlan_id->next = NULL;
	
	if (AC_RADIO[RadioID]->Wlan_Id == NULL)
	{
		AC_RADIO[RadioID]->Wlan_Id = wlan_id ;
		AC_RADIO[RadioID]->isBinddingWlan = 1;
		AC_RADIO[RadioID]->BindingWlanCount++;
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d radio%d-%d binding first wlan%d base vlan%d\n",__func__, __LINE__, WtpID, localradio_id, WlanID, vlan_id);
	}
	else
	{
		wlan_id_next = AC_RADIO[RadioID]->Wlan_Id;
		while (wlan_id_next != NULL)
		{	
			if (wlan_id_next->wlanid == WlanID)
			{
				wid_syslog_debug_debug(WID_DEFAULT,"%s: radio%d-%d have binding wlan%d, don't bind again",__func__, WtpID, localradio_id, WlanID);
				//wtp have already binding this wlan ,only to add vlanid
				int i = 0;	
				for (i = 0; i < L_BSS_NUM; i++)
				{
					if (AC_RADIO[RadioID]->BSS[i] != NULL)
					{
						if (AC_RADIO[RadioID]->BSS[i]->WlanID == WlanID)
						{
							AC_RADIO[RadioID]->BSS[i]->vlanid = vlan_id;
							break;
						}
					}
				}
				CW_FREE_OBJECT(wlan_id);
				return 0;
			}
			wlan_id_next = wlan_id_next->next;
		}

		wlan_id_next = AC_RADIO[RadioID]->Wlan_Id;
		while (wlan_id_next->next != NULL)
		{	
			wlan_id_next = wlan_id_next->next;//insert element int tail
		}
		
		wlan_id_next->next = wlan_id;
		AC_RADIO[RadioID]->BindingWlanCount++;
		
		wid_syslog_debug_debug(WID_DEFAULT,"%s: radio%d-%d binding more wlan%d base vlan%d\n", __func__, WtpID, localradio_id, WlanID, vlan_id);
	}
	
	for (k1 = 0; k1 < L_BSS_NUM; k1++)
	{
		if (AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1] == NULL)
		{
			if ((RadioID)*L_BSS_NUM + k1 >= BSS_NUM)
			{
				WID_DELETE_WLAN_APPLY_RADIO(RadioID, WlanID);
				wid_syslog_err("<error>%s:%d invalid bssindex:%d\n",__func__,__LINE__,(RadioID)*L_BSS_NUM+k1);
				return BSS_ID_LARGE_THAN_MAX;
			}
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1] = (WID_BSS*)malloc(sizeof(WID_BSS));
			if (NULL == AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1])
			{
				WID_DELETE_WLAN_APPLY_RADIO(RadioID, WlanID);
				while (k1)
				{
					k1--;
					CW_FREE_OBJECT(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]);
				}
				return MALLOC_ERROR;
			}
			memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1], 0, sizeof(WID_BSS));
			memset(&(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSS_pkt_info), 0, sizeof(BSSStatistics));
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSID = (unsigned char*)malloc(MAC_LEN);
			if (NULL == AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSID)
			{
				WID_DELETE_WLAN_APPLY_RADIO(RadioID, WlanID);
				while (k1 >= 0)
				{
					if (AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSID != NULL)
					{
						CW_FREE_OBJECT(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSID);	
					}
					CW_FREE_OBJECT(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]);
					k1--;
				}
				return MALLOC_ERROR;
			}
			memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSID, 0, MAC_LEN);
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->bss_max_allowed_sta_num = AC_WLAN[WlanID]->bss_allow_max_sta_num;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->WlanID = WlanID;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->Radio_G_ID = RadioID;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->Radio_L_ID = localradio_id;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->State = 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->keyindex = 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->band_width = 25;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->WDSStat = AC_WLAN[WlanID]->WDSStat;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->wblwm= AC_WLAN[WlanID]->wds_mesh;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->wds_mesh = AC_WLAN[WlanID]->wds_mesh;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->ath_l2_isolation = AC_WLAN[WlanID]->wlan_ath_l2_isolation;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->cwmmode = 1;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->traffic_limit_able = 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->traffic_limit = AC_WLAN[WlanID]->wlan_traffic_limit;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->average_rate = AC_WLAN[WlanID]->wlan_station_average_traffic_limit;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->send_traffic_limit = AC_WLAN[WlanID]->wlan_send_traffic_limit;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->send_average_rate = AC_WLAN[WlanID]->wlan_station_average_send_traffic_limit;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->ip_mac_binding = AC_WLAN[WlanID]->sta_ip_mac_bind;
			memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->arp_ifname, 0, ETH_IF_NAME_LEN);
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->sta_static_arp_policy = AC_WLAN[WlanID]->wlan_sta_static_arp_policy;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->upcount = 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->downcount = 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex = (RadioID)*L_BSS_NUM+k1;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSS_IF_POLICY = AC_WLAN[WlanID]->wlan_if_policy;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSS_TUNNEL_POLICY = AC_WLAN[WlanID]->WLAN_TUNNEL_POLICY;
			memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSS_IF_NAME, 0, ETH_IF_NAME_LEN);
			memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_id, 0, NAS_IDENTIFIER_NAME);
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_id_len = 0;
			if (nas_id_len > 0)
			{
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_id_len = nas_id_len;
				memcpy(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_id, nas_id, NAS_IDENTIFIER_NAME);
			}
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->hotspot_id = AC_WLAN[WlanID]->hotspot_id;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->multi_user_optimize_switch = AC_WLAN[WlanID]->multi_user_optimize_switch;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf = (struct acl_config *)malloc(sizeof(struct acl_config));
			if (NULL == AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf)
			{
				WID_DELETE_WLAN_APPLY_RADIO(RadioID, WlanID);
				while (k1 >= 0)
				{
					CW_FREE_OBJECT(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSID);
					if (AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf != NULL)
					{
						CW_FREE_OBJECT(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf);	
					}
					CW_FREE_OBJECT(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]);
					k1--;
				}
					
				return MALLOC_ERROR;
			}
			memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf, 0, sizeof(struct acl_config));
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->macaddr_acl = 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->accept_mac = NULL;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->num_accept_mac = 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->deny_mac = NULL;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->num_deny_mac = 0;

			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->wlan_vlanid = AC_WLAN[WlanID]->vlanid;
			//put vlan to bss
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->vlanid = vlan_id;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->packet_power = AC_WLAN[WlanID]->packet_power;
			memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_port_id, 0, NAS_PORT_ID_LEN);
			memcpy(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_port_id, AC_WLAN[WlanID]->nas_port_id, NAS_PORT_ID_LEN);
			AC_BSS[AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex] = AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1];
			AC_RADIO[RadioID]->BSS[k1] = AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1];
			AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id] = AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex;

			AC_RADIO[RadioID]->BSS[k1]->muti_rate = AC_WLAN[WlanID]->wlan_muti_rate;
			AC_RADIO[RadioID]->BSS[k1]->noResToStaProReqSW = AC_WLAN[WlanID]->wlan_noResToStaProReqSW;
			AC_RADIO[RadioID]->BSS[k1]->muti_bro_cast_sw = AC_WLAN[WlanID]->wlan_muti_bro_cast_sw;
			AC_RADIO[RadioID]->BSS[k1]->unicast_sw = AC_WLAN[WlanID]->wlan_unicast_sw;
			AC_RADIO[RadioID]->BSS[k1]->wifi_sw = AC_WLAN[WlanID]->wlan_wifi_sw;
			//radio apply wep wlan
			if ((AC_WLAN[WlanID]->EncryptionType == WEP) && (AC_WLAN[WlanID]->SecurityType != IEEE8021X))
			{
				for (i = 0; i < WTP_WEP_NUM; i++)
				{
					if (AC_RADIO[RadioID]->wep_flag[i] == 0)
					{
						int k = 0;
						for (k = 0; k < i; k++)
						{
							if ((AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k]->keyindex == AC_WLAN[WlanID]->SecurityIndex)
								&& (AC_WLAN[AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k]->WlanID]->EncryptionType == WEP))
							{
								WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
								return SECURITYINDEX_IS_SAME;
							}
						}
					}
					int j = 0;
					j = AC_WLAN[WlanID]->SecurityIndex - 1;
					if (j < WTP_WEP_NUM)
					{
						if (AC_RADIO[RadioID]->wep_flag[j] == 0)
						{
							AC_RADIO[RadioID]->wep_flag[j] = (RadioID)*L_BSS_NUM+k1;
							AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->keyindex = AC_WLAN[WlanID]->SecurityIndex;															
							break;
						}
					}	
					else
					{
						wid_syslog_debug_debug(WID_DEFAULT,"%s:%d radio%d-%d apply wep wlan over 4\n",__func__,__LINE__,WtpID,localradio_id);
						WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
						return WTP_WEP_NUM_OVER;
					}
				}
			}
			if (AC_WLAN[WlanID]->wlan_if_policy == BSS_INTERFACE)
			{
				ret = Create_BSS_L3_Interface(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex);
					
				if (ret < 0)
				{
					//WID_DELETE_WLAN_APPLY_WTP(WtpID, WlanID);
					WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
					return WLAN_CREATE_L3_INTERFACE_FAIL;
				}
			}
			else if (AC_WLAN[WlanID]->wlan_if_policy == WLAN_INTERFACE)
			{
				ret = Create_BSS_L3_Interface(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex);
				
				if (ret < 0)
				{
					//WID_DELETE_WLAN_APPLY_WTP(WtpID, WlanID);
					WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
					return WLAN_CREATE_L3_INTERFACE_FAIL;
				}
				
				ret = ADD_BSS_L3_Interface_BR(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex);
				if (ret < 0)
				{
					//WID_DELETE_WLAN_APPLY_WTP(WtpID, WlanID);
					WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
					return BSS_L3_INTERFACE_ADD_BR_FAIL;
				}
			}
			break;
		}
	}
	
	if (k1 == L_BSS_NUM)
	{
		return WTP_OVER_MAX_BSS_NUM;
	}
	
	if (AC_WLAN[WlanID]->Status == 1)
	{
		wid_syslog_debug_debug(WID_DEFAULT, "%s: wlan%d disable,just binging, no send add wlan msg\n", __func__,WlanID);
		return 0;
	}
	
	issued_wlan_enable(WtpID,localradio_id,WlanID,LEVEL_RADIO);
	
	int bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id];
	if ((AC_BSS[bssindex])
		&& (AC_BSS[bssindex]->BSS_IF_POLICY != NO_INTERFACE)
		&& (AC_BSS[bssindex]->BSS_TUNNEL_POLICY != CW_802_DOT_11_TUNNEL))
	{
		msgq msg;
		struct msgqlist *elem = NULL;
		memset((char*)&msg, 0, sizeof(msg));
		wid_syslog_debug_debug(WID_DEFAULT,"*** %s,%d.**\n",__func__,__LINE__);
		msg.mqid = WtpID%THREAD_NUM+1;
		msg.mqinfo.WTPID = WtpID;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WLAN_S_TYPE;
		msg.mqinfo.u.WlanInfo.Wlan_Op = WLAN_CHANGE_TUNNEL;
		msg.mqinfo.u.WlanInfo.WLANID = WlanID;
		msg.mqinfo.u.WlanInfo.Radio_L_ID = localradio_id;
		
		msg.mqinfo.u.WlanInfo.bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id];
		
		if ((AC_WTP[WtpID]->WTPStat == WID_RUN))
		{ 
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}
		else
		{
			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if (elem == NULL)
			{
				wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
				return 0;
			}
			memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
			elem->next = NULL;
			memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
			WID_INSERT_CONTROL_LIST(WtpID, elem);
		}
	}
	
	/* wlan tunnel switch func for REQUIREMENTS-264 */
	memset(apcmd, 0, WID_SYSTEM_CMD_LENTH);
	
	if ((AC_WLAN[WlanID] != NULL)&&(AC_WLAN[WlanID]->wlan_tunnel_switch == 1))
	{
		sprintf(apcmd,TUNNEL_SWITCH_CMD";"AP_OPEN_IPFORWARD";"AP_SPFAST_DOWM";"AP_SPFAST_UP,AC_RADIO[RadioID]->Radio_L_ID,WlanID);
		wid_radio_set_extension_command(WtpID,apcmd);
	}

	msgq msg;
	struct msgqlist *elem = NULL;
	if ((0 != AC_WLAN[WlanID]->aclgrp_id) && (NULL != STA_ACL_GROUP[AC_WLAN[WlanID]->aclgrp_id]))
	{
		aclgroupid = AC_WLAN[WlanID]->aclgrp_id;
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WtpID%THREAD_NUM+1;
		msg.mqinfo.WTPID = WtpID;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WTP_S_TYPE;
		msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_ACL_LIST;
		msg.mqinfo.u.WtpInfo.value[0] = WlanID;
		msg.mqinfo.u.WtpInfo.value[1] = localradio_id;
		msg.mqinfo.u.WtpInfo.value[2] = OVERWRITE;
		msg.mqinfo.u.WtpInfo.value[3] = LEVEL_WLAN;
		msg.mqinfo.u.WtpInfo.value[4] = AC_WLAN[WlanID]->aclgrp_id;
		/*
		msg.mqinfo.u.WtpInfo.value3 = STA_ACL_GROUP[aclgroupid]->rule_cnt;
		rulelist = STA_ACL_GROUP[aclgroupid]->rule_list;
		for (i = 0; i < STA_ACL_GROUP[aclgroupid]->rule_cnt; i++)
		{
			msg.mqinfo.u.WtpInfo.value[i] = rulelist->rule_id;
			rulelist = rulelist->next;
		}
		*/
		if(AC_WTP[WtpID]->WTPStat == WID_RUN)
		{ 
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}
		else
		{
			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if (NULL == elem)
			{			
				WID_MALLOC_ERR();			
				return 0;
			}			
			memset(elem, 0, sizeof(struct msgqlist));
			elem->mqinfo.type = CONTROL_TYPE;
			elem->mqinfo.subtype = WTP_S_TYPE;
			elem->mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_ACL_LIST;
			elem->mqinfo.u.WtpInfo.value[0] = WlanID;
			elem->mqinfo.u.WtpInfo.value[1] = localradio_id;
			elem->mqinfo.u.WtpInfo.value[2] = OVERWRITE;
			elem->mqinfo.u.WtpInfo.value[3] = LEVEL_WLAN;
			elem->mqinfo.u.WtpInfo.value[4] = AC_WLAN[WlanID]->aclgrp_id;
			
			WID_INSERT_CONTROL_LIST(WtpID, elem);
		}
	}
	
	if (AC_WTP[WtpID] != NULL)
	{
		if ((AC_WLAN[WlanID]) && (AC_WLAN[WlanID]->Status == 0))
		{
			WLAN_FLOW_CHECK(WlanID);
		}
	}
	if ((AC_RADIO[RadioID]->BSS[k1]) && (AC_RADIO[RadioID]->BSS[k1]->multi_user_optimize_switch == 1))
	{
		char wlanid = WlanID;
		int radioid = AC_RADIO[RadioID]->BSS[k1]->Radio_G_ID;
		muti_user_optimize_switch(wlanid, radioid, 1);
	}
	
	if (check_bssid_func(bssindex) && (0 != AC_BSS[bssindex]->packet_power))
	{
		WID_RADIO_WLAN_PACKET_POWER(WtpID, localradio_id, WlanID, AC_BSS[bssindex]->packet_power);
	}
	if (0 != memcmp(QOS_AP_11E_TO_1P_DEFAULT, AC_WLAN[WlanID]->qos_ap_11e_to_1p, MAX_QOS_11E_VAL+1))
	{
		set_ap_bss_qos_map_default(WtpID, localradio_id, QOS_MAP_11E_TO_1P, WlanID);
	}
	if (0 != memcmp(QOS_AP_11E_TO_DSCP_DEFAULT, AC_WLAN[WlanID]->qos_ap_11e_to_dscp, MAX_QOS_11E_VAL+1))
	{
		set_ap_bss_qos_map_default(WtpID, localradio_id, QOS_MAP_11E_TO_DSCP, WlanID);
	}
	if (0 != memcmp(QOS_AP_DSCP_TO_11E_DEFAULT, AC_WLAN[WlanID]->qos_ap_dscp_to_11e, MAX_QOS_DSCP_VAL+1))
	{
		set_ap_bss_qos_map_default(WtpID, localradio_id, QOS_MAP_DSCP_TO_11E, WlanID);
	}
	if (0 != memcmp(QOS_AP_1P_TO_11E_DEFAULT, AC_WLAN[WlanID]->qos_ap_1p_to_11e, MAX_QOS_1P_VAL+1))
	{
		set_ap_bss_qos_map_default(WtpID, localradio_id, QOS_MAP_1P_TO_11E, WlanID);
	}
	if (0 != AC_WLAN[WlanID]->qos_ap_11e_to_1p_switch)
	{
		set_ap_bss_qos_map_switch(WtpID, localradio_id, WlanID, QOS_MAP_11E_TO_1P, AC_WLAN[WlanID]->qos_ap_11e_to_1p_switch);
	}
	if (0 != AC_WLAN[WlanID]->qos_ap_11e_to_dscp_switch)
	{
		set_ap_bss_qos_map_switch(WtpID, localradio_id, WlanID, QOS_MAP_11E_TO_DSCP, AC_WLAN[WlanID]->qos_ap_11e_to_dscp_switch);
	}
	if ((check_bssid_func(bssindex)) &&(0 != AC_WLAN[WlanID]->balance_switch))
	{											
		wid_bss_balance_switch(WtpID, localradio_id, WlanID);										
	}
	
	return 0;
}


int WID_ADD_WLAN_APPLY_RADIO_CLEAN_VLANID(unsigned int RadioID,unsigned char WlanID)
{
	int isfind = 0; 
	int i = 0;
	int WtpID = RadioID/L_RADIO_NUM;
	int localradio_id = RadioID%L_RADIO_NUM;
	
	if (AC_WTP[WtpID] == NULL)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"*** you binding wlan does not exist **\n");
		return WTP_ID_NOT_EXIST;
	}
	if (AC_WLAN[WlanID] == NULL)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"*** you binding wlan does not exist **\n");
		return WLAN_ID_NOT_EXIST;
	}
	
	for (i = 0; i < L_BSS_NUM; i++)
	{
		if (AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[i] != NULL)
		{
			if (AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[i]->WlanID == WlanID)
			{
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[i]->vlanid = 0;
				isfind = 1;
				break;
			}
		}
	}
	if (isfind != 1)
	{
		return WTP_WLAN_BINDING_NOT_MATCH;
	}
	return 0;
}

 
int WID_ADD_WLAN_APPLY_RADIO_ALIAS_ESSID
(
	unsigned int RadioID,
	unsigned char WlanID,
	char *ali_essid
)
{
	int ret = -1;
	int k1 = 0;
	int WtpID = 0;
	int localradio_id = 0;
	unsigned int nas_id_len = 0;
	char nas_id[NAS_IDENTIFIER_NAME] = {0};
	
	if (NULL == ali_essid)
	{
		wid_syslog_debug_debug(WID_DEFAULT, "%s: radio%d wlan%d the alias essid is NULL.\n",__func__,RadioID,WlanID);
		return PARAM_NULL_POINTER;
	}
	
	WID_CHECK_WLAN_EXIST_RET(WlanID, WLAN_ID_NOT_EXIST);

	if ((RadioID > G_RADIO_NUM) || (RadioID < L_RADIO_NUM) || (NULL == AC_RADIO[RadioID]))
	{
		return RADIO_ID_NOT_EXIST;
	}
		
	if (AC_RADIO[RadioID]->BindingWlanCount >= L_BSS_NUM
		&& 1 != wid_check_radio_is_apply_wlan(RadioID, WlanID))
	{
		return WTP_OVER_MAX_BSS_NUM;
	}

	WtpID = RadioID / L_RADIO_NUM;
	localradio_id = RadioID % L_RADIO_NUM;
    
	if (AC_WLAN[WlanID]->Wlan_Ifi != NULL)
	{
		if (AC_WTP[WtpID] && AC_WTP[WtpID]->BindingSystemIndex != -1)
		{
			struct ifi *wlan_ifi = AC_WLAN[WlanID]->Wlan_Ifi;
			while (wlan_ifi != NULL)
			{
				if (AC_WTP[WtpID]->BindingSystemIndex == wlan_ifi->ifi_index)
				{
					if (wlan_ifi->nas_id_len > 0)
					{
						nas_id_len = wlan_ifi->nas_id_len;
						memcpy(nas_id, wlan_ifi->nas_id, NAS_IDENTIFIER_NAME);
					}
					break;
				}
				wlan_ifi = wlan_ifi->ifi_next;
			}
			
			if (wlan_ifi == NULL)
			{
				wid_syslog_debug_debug(WID_DEFAULT,"%s: wtp%d binding interface doesn't match with wlan%d\n",__func__,WtpID,WlanID);
				//return WTP_WLAN_BINDING_NOT_MATCH;
			}			
		}
		else
		{
			//return WTP_IF_NOT_BE_BINDED;
		}
	}
	else
	{
		//return WLAN_NOT_BINDING_IF;
	}
		
	struct wlanid *wlan_id = NULL;
	struct wlanid *wlan_id_next = NULL;
	wlan_id = (struct wlanid*)malloc(sizeof(struct wlanid));
	if (NULL == wlan_id)
	{
		wid_syslog_debug_debug(WID_DEFAULT,	"%s:%d malloc mem erro\n",__func__,__LINE__);
		return MALLOC_ERROR;
	}
	memset(wlan_id, 0, sizeof(struct wlanid));
	wlan_id->wlanid = WlanID;
	wlan_id->next = NULL;
	
	if (AC_RADIO[RadioID] && AC_RADIO[RadioID]->Wlan_Id == NULL)
	{		
		AC_RADIO[RadioID]->Wlan_Id = wlan_id ;		
		AC_RADIO[RadioID]->isBinddingWlan = 1;
		AC_RADIO[RadioID]->BindingWlanCount++;
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d radio%d-%d binding first wlan %d\n", __func__, __LINE__, WtpID, localradio_id, WlanID);
	}
	else
	{	
		wlan_id_next = AC_RADIO[RadioID]->Wlan_Id;
		while (wlan_id_next != NULL)
		{	
			if (wlan_id_next->wlanid == WlanID)
			{
				/* set alias-ESSID to BSS(radio + wlan)*/
				if (NULL != ali_essid && check_bssid_func(AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id]))
				{
					AC_BSS[AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id]]->aliasSetFlag = 1;
					memset(AC_BSS[AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id]]->aliasESSID, 0, ESSID_LENGTH);
					memcpy(AC_BSS[AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id]]->aliasESSID, ali_essid, strlen(ali_essid));
				}

				wid_syslog_debug_debug(WID_DEFAULT, "%s:%d radio%d-%d has binding wlan%d\n", __func__, __LINE__, WtpID, localradio_id, WlanID);
				CW_FREE_OBJECT(wlan_id);
				
				if (1 == AC_BSS[AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id]]->State)
				{
					return BSS_BE_ENABLE;
				}
				else
				{
					return 0;
				}
			}
			else
			{
				if (((AC_WLAN[wlan_id_next->wlanid]->SecurityID == AC_WLAN[WlanID]->SecurityID)
					  && (AC_WLAN[WlanID]->KeyLen))
					|| ((AC_WLAN[WlanID]->KeyLen)
						 && (AC_WLAN[wlan_id_next->wlanid]->KeyLen == AC_WLAN[WlanID]->KeyLen)
						 && (strncmp(AC_WLAN[wlan_id_next->wlanid]->WlanKey, AC_WLAN[WlanID]->WlanKey, AC_WLAN[WlanID]->KeyLen) == 0)))
				{
				#if NOSOFTAC
					wid_dbug_trap_ssid_key_conflict(WtpID, (unsigned char)localradio_id, wlan_id_next->wlanid, WlanID);
				#endif
				}
			}
			wlan_id_next = wlan_id_next->next;
		}

		wlan_id_next = AC_RADIO[RadioID]->Wlan_Id;
		while (wlan_id_next->next != NULL)
		{	
			wlan_id_next = wlan_id_next->next;
		}
		
		wlan_id_next->next = wlan_id;
		AC_RADIO[RadioID]->BindingWlanCount++;
			
		wid_syslog_debug_debug(WID_DEFAULT, "%s:%d radio%d-%d binding more wlan :%d\n", __func__, __LINE__, WtpID, localradio_id, WlanID);
	}

	for (k1 = 0; k1 < L_BSS_NUM; k1++)
	{
		if (AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1] == NULL)
		{
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1] = (WID_BSS*)malloc(sizeof(WID_BSS));
			if (NULL == AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1])
			{
				WID_DELETE_WLAN_APPLY_RADIO(RadioID, WlanID);
				wid_syslog_crit("Crit: %s malloc error!\n", __func__);
				return MALLOC_ERROR;
			}
			
			memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1], 0, sizeof(WID_BSS));
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSID = (unsigned char*)malloc(MAC_LEN);
			memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSID, 0, MAC_LEN);
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->bss_max_allowed_sta_num = AC_WLAN[WlanID]->bss_allow_max_sta_num;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->WlanID = WlanID;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->Radio_G_ID = RadioID;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->Radio_L_ID = localradio_id;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->State = 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->keyindex = 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->band_width = 25;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->ath_l2_isolation = AC_WLAN[WlanID]->wlan_ath_l2_isolation;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->cwmmode = 1;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->traffic_limit = AC_WLAN[WlanID]->wlan_traffic_limit;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->average_rate = AC_WLAN[WlanID]->wlan_station_average_traffic_limit;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->send_traffic_limit = AC_WLAN[WlanID]->wlan_send_traffic_limit;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->send_average_rate = AC_WLAN[WlanID]->wlan_station_average_send_traffic_limit;

			if ((0 < AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->traffic_limit)
				|| (0 < AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->average_rate)
				|| (0 < AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->send_traffic_limit)
				|| (0 < AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->send_average_rate))
			{
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->traffic_limit_able = 1;
			}
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->ip_mac_binding = AC_WLAN[WlanID]->sta_ip_mac_bind;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->upcount= 0;

#if 0
// by jinpc
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->wsm_sta_info_reportswitch = 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->wsm_sta_info_reportinterval = 1800;
#endif
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->downcount = 0;	
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->limit_sta_rssi = AC_WLAN[WlanID]->wlan_limit_sta_rssi;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex = (RadioID)*L_BSS_NUM + k1;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSS_IF_POLICY = AC_WLAN[WlanID]->wlan_if_policy;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->vMAC_STATE = 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->WDSStat = AC_WLAN[WlanID]->WDSStat;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->wds_bss_list = NULL;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSS_TUNNEL_POLICY = AC_WLAN[WlanID]->WLAN_TUNNEL_POLICY;
			memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_id, 0, NAS_IDENTIFIER_NAME);
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_id_len = 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->multi_user_optimize_switch = AC_WLAN[WlanID]->multi_user_optimize_switch;
			if (nas_id_len > 0)
			{
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_id_len = nas_id_len;
				memcpy(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_id, nas_id, NAS_IDENTIFIER_NAME);
			}
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf = (struct acl_config *)malloc(sizeof(struct acl_config));
			memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf, 0, sizeof(struct acl_config));
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->macaddr_acl = 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->accept_mac = NULL;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->num_accept_mac = 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->deny_mac = NULL;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->num_deny_mac = 0;				
			//put wlan-vlan to bss
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->wlan_vlanid = AC_WLAN[WlanID]->vlanid;				
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->sta_static_arp_policy = AC_WLAN[WlanID]->wlan_sta_static_arp_policy;			
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->packet_power = AC_WLAN[WlanID]->packet_power;
			AC_BSS[AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex] = AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1];
			AC_RADIO[RadioID]->BSS[k1] = AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1];
			AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id] = AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex;
			AC_RADIO[RadioID]->BSS[k1]->muti_rate = AC_WLAN[WlanID]->wlan_muti_rate;
			AC_RADIO[RadioID]->BSS[k1]->noResToStaProReqSW = AC_WLAN[WlanID]->wlan_noResToStaProReqSW;
			AC_RADIO[RadioID]->BSS[k1]->muti_bro_cast_sw = AC_WLAN[WlanID]->wlan_muti_bro_cast_sw;
			AC_RADIO[RadioID]->BSS[k1]->unicast_sw = AC_WLAN[WlanID]->wlan_unicast_sw;
			AC_RADIO[RadioID]->BSS[k1]->wifi_sw = AC_WLAN[WlanID]->wlan_wifi_sw;
			/* extend function would modify the value below*/
			if (NULL != ali_essid)
			{
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->aliasSetFlag = 1;
				memcpy(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->aliasESSID, ali_essid, strlen(ali_essid));
			}
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->vlanid = 0;
			memcpy(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_port_id, AC_WLAN[WlanID]->nas_port_id, NAS_PORT_ID_LEN);
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->hotspot_id = AC_WLAN[WlanID]->hotspot_id;

#if 0
// jinpc
			//radio apply wep wlan
			if ((AC_WLAN[WlanID]->EncryptionType == WEP) && (AC_WLAN[WlanID]->SecurityType != IEEE8021X))
			{

				for(i = 0; i < WTP_WEP_NUM; i++)
				{
					if(AC_WTP[WtpID]->wep_flag[i] == 0)
					{
						int k =0;
						for (k = 0; k < i; k++)
						{
							if((AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k] != NULL) && (AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k]->keyindex == AC_WLAN[WlanID]->SecurityIndex)&&(AC_WLAN[AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k]->WlanID]->EncryptionType == WEP))
							{
								WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
								return SECURITYINDEX_IS_SAME;
							}
						}
					}
					int j =0;
					j = AC_WLAN[WlanID]->SecurityIndex - 1;
					if(j < WTP_WEP_NUM)
					{
						if(AC_WTP[WtpID]->wep_flag[j] == 0)
						{
							AC_WTP[WtpID]->wep_flag[j] = (RadioID)*L_BSS_NUM+k1;
							AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->keyindex = AC_WLAN[WlanID]->SecurityIndex;															
							break;
						}
					}	
					else
					{
						wid_syslog_debug_debug(WID_DEFAULT, "radio apply wep wlan over 4\n");
						WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
						return WTP_WEP_NUM_OVER;
					}
				}
			}
#endif

			if (AC_WLAN[WlanID]->wlan_if_policy == BSS_INTERFACE)
			{
				ret = Create_BSS_L3_Interface(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex);
				if (ret < 0)
				{
					WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
					return WLAN_CREATE_L3_INTERFACE_FAIL;
				}
			}
			else if (AC_WLAN[WlanID]->wlan_if_policy == WLAN_INTERFACE)
			{
				ret = Create_BSS_L3_Interface(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex);
				if (ret < 0)
				{
					WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
					return WLAN_CREATE_L3_INTERFACE_FAIL;
				}

				ret = ADD_BSS_L3_Interface_BR(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex);
				if (ret < 0)
				{
					WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
					return BSS_L3_INTERFACE_ADD_BR_FAIL;
				}
			}
			break;
		}
	}
	
	if (k1 == L_BSS_NUM)
	{
		return WTP_OVER_MAX_BSS_NUM;
	}
	
	if (AC_WLAN[WlanID]->Status == 1)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"%s wlan%d disable, so just binding, not to send add wlan msg\n",__func__,WlanID);
		return 0;
	}
	
	issued_wlan_enable(WtpID, localradio_id, WlanID, LEVEL_RADIO);
	
	if (AC_WTP[WtpID] != NULL)
	{
		if ((AC_WLAN[WlanID]) && (AC_WLAN[WlanID]->Status == 0))
		{
			WLAN_FLOW_CHECK(WlanID);
		}
	}
    
	int bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id];
	char apcmd[WID_SYSTEM_CMD_LENTH] = {0};

	/* config for eap-mac */
	memset(apcmd, 0, WID_SYSTEM_CMD_LENTH);
	if ((AC_WLAN[WlanID]->eap_mac_switch == 1)
		&& (AC_WLAN[WlanID]->wlan_if_policy == NO_INTERFACE)
		&& (AC_BSS[bssindex] != NULL)
		&& (AC_BSS[bssindex]->BSS_IF_POLICY == NO_INTERFACE))
	{
	    sprintf(apcmd, "set_eap_mac ath.%d-%d %s", AC_RADIO[RadioID]->Radio_L_ID, WlanID, AC_WLAN[WlanID]->eap_mac);
	}
	else
	{
	    sprintf(apcmd, "set_eap_mac ath.%d-%d 0", AC_RADIO[RadioID]->Radio_L_ID, WlanID);
	}
	wid_syslog_debug_debug(WID_DEFAULT, "Enable Wlan: set eap mac cmd %s\n", apcmd);
	wid_radio_set_extension_command(WtpID, apcmd);

	/* config for wlan-tunnel mode TL */
	memset(apcmd, 0, WID_SYSTEM_CMD_LENTH);
	if (AC_WLAN[WlanID]->wlan_tunnel_switch == 1)
	{
		sprintf(apcmd,TUNNEL_SWITCH_CMD";"AP_OPEN_IPFORWARD";"AP_SPFAST_DOWM";"AP_SPFAST_UP,AC_RADIO[RadioID]->Radio_L_ID,WlanID);
		wid_radio_set_extension_command(WtpID, apcmd);
	}

	/* config for traffic-limit switch */
	if ((check_bssid_func(AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id]))
		&& (AC_BSS[(AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id])] != NULL))
	{                                                                                        
		unsigned int bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id];
		wid_syslog_debug_debug(WID_DEFAULT, "%s:%d wlan%d bss[%d]->traffic_limit %s\n",
        						__func__, __LINE__, WlanID, bssindex, AC_BSS[bssindex]->traffic_limit_able == 1 ? "enable" : "disable");
		if (1 == AC_BSS[bssindex]->traffic_limit_able)
		{
			WID_Save_Traffic_Limit(bssindex, WtpID);
		}
	}

	/* config for multi-user-optimize */
	if ((AC_BSS[bssindex]) && (AC_BSS[bssindex]->multi_user_optimize_switch == 1))
	{
		char wlanid = AC_BSS[bssindex]->WlanID;
		int radioid = AC_BSS[bssindex]->Radio_G_ID;
		muti_user_optimize_switch(wlanid, radioid, 1);
	}

	/* config for */
	if ((AC_BSS[bssindex])
		&& (AC_BSS[bssindex]->BSS_IF_POLICY != NO_INTERFACE)
		&& (AC_BSS[bssindex]->BSS_TUNNEL_POLICY != CW_802_DOT_11_TUNNEL))
	{
		msgq msg;
		struct msgqlist *elem = NULL;
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WtpID % THREAD_NUM + 1;
		msg.mqinfo.WTPID = WtpID;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WLAN_S_TYPE;
		msg.mqinfo.u.WlanInfo.Wlan_Op = WLAN_CHANGE_TUNNEL;
		msg.mqinfo.u.WlanInfo.WLANID = WlanID;
		msg.mqinfo.u.WlanInfo.Radio_L_ID = localradio_id;
		msg.mqinfo.u.WlanInfo.SecurityType = AC_WLAN[WlanID]->SecurityType;
		msg.mqinfo.u.WlanInfo.bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id];
		
		if (AC_WTP[WtpID]->WTPStat == WID_RUN)
		{ 
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s", __func__, strerror(errno));
			}
		}
		else
		{
			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if (NULL == elem)
			{			
				WID_MALLOC_ERR();			
				return 0;
			}			
			memset(elem, 0, sizeof(struct msgqlist));
			elem->mqinfo.WTPID = WtpID;
			elem->mqinfo.type = CONTROL_TYPE;
			elem->mqinfo.subtype = WLAN_S_TYPE;
			elem->mqinfo.u.WlanInfo.Wlan_Op = WLAN_CHANGE_TUNNEL;
			elem->mqinfo.u.WlanInfo.WLANID = WlanID;
			elem->mqinfo.u.WlanInfo.Radio_L_ID = localradio_id;
			elem->mqinfo.u.WlanInfo.SecurityType = AC_WLAN[WlanID]->SecurityType;
			elem->mqinfo.u.WlanInfo.bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id];
			
			WID_INSERT_CONTROL_LIST(WtpID, elem);
		}
	}

//delete for no support STA-ACL
#if 0

	if ((0 != AC_WLAN[WlanID]->aclgrp_id)
		&& (NULL != STA_ACL_GROUP[AC_WLAN[WlanID]->aclgrp_id]))
	{
		aclgroupid = AC_WLAN[WlanID]->aclgrp_id;
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WtpID % THREAD_NUM + 1;
		msg.mqinfo.WTPID = WtpID;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WTP_S_TYPE;
		msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_ACL_LIST;
		msg.mqinfo.u.WtpInfo.value[0] = WlanID;
		msg.mqinfo.u.WtpInfo.value[1] = localradio_id;
		msg.mqinfo.u.WtpInfo.value[2] = OVERWRITE;
		msg.mqinfo.u.WtpInfo.value[3] = LEVEL_WLAN;
		msg.mqinfo.u.WtpInfo.value[4] = AC_WLAN[WlanID]->aclgrp_id;

		if(AC_WTP[WtpID]->WTPStat == WID_RUN)
		{ 
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}
		else
		{
			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if (NULL == elem)
			{			
				WID_MALLOC_ERR();			
				return 0;
			}			
			memset(elem, 0, sizeof(struct msgqlist));
			elem->mqinfo.WTPID = WtpID;
			elem->mqinfo.type = CONTROL_TYPE;
			elem->mqinfo.subtype = WTP_S_TYPE;
			elem->mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_ACL_LIST;
			elem->mqinfo.u.WtpInfo.value[0] = WlanID;
			elem->mqinfo.u.WtpInfo.value[1] = localradio_id;
			elem->mqinfo.u.WtpInfo.value[2] = OVERWRITE;
			elem->mqinfo.u.WtpInfo.value[3] = LEVEL_WLAN;
			elem->mqinfo.u.WtpInfo.value[4] = AC_WLAN[WlanID]->aclgrp_id;
			
			WID_INSERT_CONTROL_LIST(WtpID, elem);
		}
	}
#endif
	if (0 != memcmp(QOS_AP_11E_TO_1P_DEFAULT, AC_WLAN[WlanID]->qos_ap_11e_to_1p, MAX_QOS_11E_VAL+1))
	{
		set_ap_bss_qos_map_default(WtpID, localradio_id, QOS_MAP_11E_TO_1P, WlanID);
	}
	if (0 != memcmp(QOS_AP_11E_TO_DSCP_DEFAULT, AC_WLAN[WlanID]->qos_ap_11e_to_dscp, MAX_QOS_11E_VAL+1))
	{
		set_ap_bss_qos_map_default(WtpID, localradio_id, QOS_MAP_11E_TO_DSCP, WlanID);
	}
	if (0 != memcmp(QOS_AP_DSCP_TO_11E_DEFAULT, AC_WLAN[WlanID]->qos_ap_dscp_to_11e, MAX_QOS_DSCP_VAL+1))
	{
		set_ap_bss_qos_map_default(WtpID, localradio_id, QOS_MAP_DSCP_TO_11E, WlanID);
	}
	if (0 != memcmp(QOS_AP_1P_TO_11E_DEFAULT, AC_WLAN[WlanID]->qos_ap_1p_to_11e, MAX_QOS_1P_VAL+1))
	{
		set_ap_bss_qos_map_default(WtpID, localradio_id, QOS_MAP_1P_TO_11E, WlanID);
	}
	if (0 != AC_WLAN[WlanID]->qos_ap_11e_to_1p_switch)
	{
		set_ap_bss_qos_map_switch(WtpID, localradio_id, WlanID, QOS_MAP_11E_TO_1P, AC_WLAN[WlanID]->qos_ap_11e_to_1p_switch);
	}
	if (0 != AC_WLAN[WlanID]->qos_ap_11e_to_dscp_switch)
	{
		set_ap_bss_qos_map_switch(WtpID, localradio_id, WlanID, QOS_MAP_11E_TO_DSCP, AC_WLAN[WlanID]->qos_ap_11e_to_dscp_switch);
	}
	if (check_bssid_func(bssindex) && (0 != AC_BSS[bssindex]->packet_power))
	{
		WID_RADIO_WLAN_PACKET_POWER(WtpID, localradio_id, WlanID, AC_BSS[bssindex]->packet_power);
	}
	if ((check_bssid_func(bssindex)) && (0 != AC_WLAN[WlanID]->balance_switch))
	{											
		wid_bss_balance_switch(WtpID, localradio_id, WlanID);										
	}

	return 0;
}


int WID_ADD_WLAN_APPLY_RADIO_CLEAN_ALIAS_ESSID
(
	unsigned int RadioID,
	unsigned char WlanID
)
{
	int i = 0;;
	int WtpID = RadioID / L_RADIO_NUM;
	int localradio_id = RadioID % L_RADIO_NUM;

	/* check RadioID WtpID WlanID */
	if (AC_RADIO[RadioID] == NULL)
	{
		wid_syslog_debug_debug(WID_DEFAULT, "radio %d does not exist\n", RadioID);
		return RADIO_ID_NOT_EXIST;
	}
	
	if (AC_WTP[WtpID] == NULL)
	{
		wid_syslog_debug_debug(WID_DEFAULT, "wtp %d does not exist\n", WtpID);
		return WTP_ID_NOT_EXIST;
	}
	
	if (AC_WLAN[WlanID] == NULL)
	{
		wid_syslog_debug_debug(WID_DEFAULT, "binding wlan %d does not exist\n", WlanID);
		return WLAN_ID_NOT_EXIST;
	}

	/* find BSS(radio+wlan), and clear alias-ESSID */
	for (i = 0; i < L_BSS_NUM; i++)
	{
		if (AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[i] != NULL)
		{
			if (AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[i]->WlanID == WlanID)
			{
				/* found! clear aliassetflag and alias-ESSID */
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[i]->aliasSetFlag = 0;
				memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[i]->aliasESSID, 0, ESSID_LENGTH);
				return 0;
			}
		}
	}
	
	/* not found */
	return WTP_WLAN_BINDING_NOT_MATCH;
}


int WID_ADD_WLAN_APPLY_RADIO_BASE_VLANID_ALIAS_ESSID
(
	unsigned int RadioID,
	unsigned char WlanID,
	unsigned int vlan_id,
	char *ali_essid
)
{
	int ret = -1;
	int k1 = 0;
	int WtpID = 0;
	int localradio_id = 0;
	unsigned int nas_id_len = 0;
	char nas_id[NAS_IDENTIFIER_NAME] = {0};
	
	if (NULL == ali_essid)
	{
		wid_syslog_debug_debug(WID_DEFAULT, "%s:%d radio%d wlan%d the alias essid is NULL.\n",__func__,__LINE__,RadioID,WlanID);
		return PARAM_NULL_POINTER;
	}
	
	WID_CHECK_WLAN_EXIST_RET(WlanID, WLAN_ID_NOT_EXIST);

	if ((RadioID > G_RADIO_NUM) || (RadioID < L_RADIO_NUM) || (NULL == AC_RADIO[RadioID]))
	{
		return RADIO_ID_NOT_EXIST;
	}
	
	if (AC_RADIO[RadioID]->BindingWlanCount >= L_BSS_NUM
		&& 1 != wid_check_radio_is_apply_wlan(RadioID, WlanID))
	{
		return WTP_OVER_MAX_BSS_NUM;
	}
	
	WtpID = RadioID / L_RADIO_NUM;
	localradio_id = RadioID % L_RADIO_NUM;
	
	if (AC_WLAN[WlanID]->Wlan_Ifi != NULL)
	{
		if (AC_WTP[WtpID]->BindingSystemIndex != -1)
		{
			struct ifi *wlan_ifi = AC_WLAN[WlanID]->Wlan_Ifi;
			while (wlan_ifi != NULL)
			{
				if (AC_WTP[WtpID]->BindingSystemIndex == wlan_ifi->ifi_index)
				{
					if (wlan_ifi->nas_id_len > 0)
					{
						nas_id_len = wlan_ifi->nas_id_len;
						memcpy(nas_id, wlan_ifi->nas_id, NAS_IDENTIFIER_NAME);
					}
					break;
				}
				wlan_ifi = wlan_ifi->ifi_next;
			}
			
			if (wlan_ifi == NULL)
			{
				wid_syslog_debug_debug(WID_DEFAULT,"%s wtp%d binding interface doesn't match with wlan%d\n",__func__,WtpID,WlanID);
				//return WTP_WLAN_BINDING_NOT_MATCH;
			}
		}
		else
		{
			//return WTP_IF_NOT_BE_BINDED;
		}
	}
	else
	{
		//return WLAN_NOT_BINDING_IF;
	}
		
	struct wlanid *wlan_id = NULL;
	struct wlanid *wlan_id_next = NULL;
	wlan_id = (struct wlanid*)malloc(sizeof(struct wlanid));
	if (NULL == wlan_id)
	{
		wid_syslog_debug_debug(WID_DEFAULT,	"malloc mem erro\n");
		return MALLOC_ERROR;
	}
	memset(wlan_id, 0, sizeof(struct wlanid));
	wlan_id->wlanid = WlanID;
	wlan_id->next = NULL;
	
	if (AC_RADIO[RadioID]->Wlan_Id == NULL)
	{
		AC_RADIO[RadioID]->Wlan_Id = wlan_id ;	
		AC_RADIO[RadioID]->isBinddingWlan = 1;
		AC_RADIO[RadioID]->BindingWlanCount++;
		wid_syslog_debug_debug(WID_DEFAULT, "%s:%d radio%d-%d binding first wlan%d base vlan%d alias essid %s\n",__func__,__LINE__,WtpID,localradio_id,WlanID,vlan_id,ali_essid);
	}
	else
	{
		wlan_id_next = AC_RADIO[RadioID]->Wlan_Id;
		while (wlan_id_next != NULL)
		{	
			if (wlan_id_next->wlanid == WlanID)
			{
				/* set alias-ESSID to BSS(radio+wlan) */
				if (NULL != ali_essid && check_bssid_func(AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id]))
				{
					AC_BSS[AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id]]->aliasSetFlag = 1;
					memset(AC_BSS[AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id]]->aliasESSID, 0, ESSID_LENGTH);
					memcpy(AC_BSS[AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id]]->aliasESSID, ali_essid, strlen(ali_essid));
				}
				
				wid_syslog_debug_debug(WID_DEFAULT,"%s: radio%d-%d have binding wlan%d, don't bind again",__func__, WtpID, localradio_id, WlanID);
				//wtp have already binding this wlan ,only to add vlanid

				/* set VLAN to BSS(radio+wlan) */
				int i = 0;	
				for (i = 0; i < L_BSS_NUM; i++)
				{
					if (AC_RADIO[RadioID]->BSS[i] != NULL)
					{
						if (AC_RADIO[RadioID]->BSS[i]->WlanID == WlanID)
						{
							AC_RADIO[RadioID]->BSS[i]->vlanid = vlan_id;
							break;
						}
					}
				}

				CW_FREE_OBJECT(wlan_id);

				if(1 == AC_BSS[AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id]]->State)
				{
					return BSS_BE_ENABLE;
				}
				else
				{
					return 0;
				}
			}
			wlan_id_next = wlan_id_next->next;
		}

		wlan_id_next = AC_RADIO[RadioID]->Wlan_Id;
		while (wlan_id_next->next != NULL)
		{	
			wlan_id_next = wlan_id_next->next;
		}
		
		wlan_id_next->next = wlan_id;
		AC_RADIO[RadioID]->BindingWlanCount++;
		
		wid_syslog_debug_debug(WID_DEFAULT, "%s:%d radio%d-%d binding more wlan%d base vlan%d alias essid %s\n",__func__,__LINE__,WtpID,localradio_id,WlanID,vlan_id,ali_essid);
	}

	for (k1 = 0; k1 < L_BSS_NUM; k1++)
	{
		if (AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1] == NULL)
		{
			if ((RadioID)*L_BSS_NUM + k1 >= BSS_NUM)
			{
				WID_DELETE_WLAN_APPLY_RADIO(RadioID, WlanID);
				wid_syslog_err("<error>%s:%d invalid bssindex:%d\n",__func__,__LINE__,(RadioID)*L_BSS_NUM+k1);
				return BSS_ID_LARGE_THAN_MAX;
			}
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1] = (WID_BSS*)malloc(sizeof(WID_BSS));
			if (NULL == AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1])
			{
				WID_DELETE_WLAN_APPLY_RADIO(RadioID, WlanID);
				while (k1)
				{
					k1--;
					CW_FREE_OBJECT(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]);
				}
				wid_syslog_crit("Crit: %s:%d malloc error!\n", __func__, __LINE__);
				return MALLOC_ERROR;
			}
			memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1], 0, sizeof(WID_BSS));
			memset(&(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSS_pkt_info), 0, sizeof(BSSStatistics));
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSID = (unsigned char*)malloc(MAC_LEN);
			if (NULL == AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSID)
			{
				WID_DELETE_WLAN_APPLY_RADIO(RadioID, WlanID);
				while (k1 >= 0)
				{
					if (AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSID != NULL)
					{
						CW_FREE_OBJECT(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSID);	
					}
					CW_FREE_OBJECT(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]);
					k1--;
				}
				wid_syslog_crit("Crit: %s:%d malloc error!\n", __func__, __LINE__);
				return MALLOC_ERROR;
			}
			memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSID, 0, MAC_LEN);
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->bss_max_allowed_sta_num = AC_WLAN[WlanID]->bss_allow_max_sta_num;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->WlanID = WlanID;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->Radio_G_ID = RadioID;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->Radio_L_ID = localradio_id;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->State = 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->keyindex = 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->band_width = 25;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->WDSStat = AC_WLAN[WlanID]->WDSStat;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->wblwm= AC_WLAN[WlanID]->wds_mesh;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->wds_mesh = AC_WLAN[WlanID]->wds_mesh;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->ath_l2_isolation = AC_WLAN[WlanID]->wlan_ath_l2_isolation;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->cwmmode = 1;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->traffic_limit_able = 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->traffic_limit = AC_WLAN[WlanID]->wlan_traffic_limit;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->average_rate = AC_WLAN[WlanID]->wlan_station_average_traffic_limit;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->send_traffic_limit = AC_WLAN[WlanID]->wlan_send_traffic_limit;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->send_average_rate = AC_WLAN[WlanID]->wlan_station_average_send_traffic_limit;

			if ((0 < AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->traffic_limit)
				|| (0 < AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->average_rate)
				|| (0 < AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->send_traffic_limit)
				|| (0 < AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->send_average_rate))
			{
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->traffic_limit_able = 1;
			}
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->ip_mac_binding = AC_WLAN[WlanID]->sta_ip_mac_bind;
			memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->arp_ifname, 0, ETH_IF_NAME_LEN);
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->sta_static_arp_policy = AC_WLAN[WlanID]->wlan_sta_static_arp_policy;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->upcount = 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->downcount = 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->multi_user_optimize_switch = AC_WLAN[WlanID]->multi_user_optimize_switch;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->limit_sta_rssi = AC_WLAN[WlanID]->wlan_limit_sta_rssi;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex = (RadioID)*L_BSS_NUM + k1;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSS_IF_POLICY = AC_WLAN[WlanID]->wlan_if_policy;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSS_TUNNEL_POLICY = AC_WLAN[WlanID]->WLAN_TUNNEL_POLICY;
			memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSS_IF_NAME, 0, ETH_IF_NAME_LEN);

			memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_id, 0, NAS_IDENTIFIER_NAME);
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_id_len = 0;
			if (nas_id_len > 0)
			{
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_id_len = nas_id_len;
				memcpy(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_id, nas_id, NAS_IDENTIFIER_NAME);
			}

			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf = (struct acl_config *)malloc(sizeof(struct acl_config));
            if (NULL == AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf)
            {
				WID_DELETE_WLAN_APPLY_RADIO(RadioID, WlanID);
				while (k1 >= 0)
				{
					CW_FREE_OBJECT(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSID);
					if (AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf != NULL)
					{
						CW_FREE_OBJECT(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf); 
					}
					CW_FREE_OBJECT(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]);
					k1--;
                }
				
				wid_syslog_crit("Crit: %s:%d malloc error!\n", __func__, __LINE__);
				return MALLOC_ERROR;
			}
			
			memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf, 0, sizeof(struct acl_config));
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->macaddr_acl = 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->accept_mac = NULL;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->num_accept_mac = 0;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->deny_mac = NULL;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->num_deny_mac = 0;

			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->wlan_vlanid = AC_WLAN[WlanID]->vlanid;
			//put vlan to bss
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->vlanid = vlan_id;
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->packet_power = AC_WLAN[WlanID]->packet_power;
			memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_port_id, 0, NAS_PORT_ID_LEN);		       
			memcpy(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_port_id, AC_WLAN[WlanID]->nas_port_id, NAS_PORT_ID_LEN);
			AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->hotspot_id = AC_WLAN[WlanID]->hotspot_id;
			AC_BSS[AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex] = AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1];
			AC_RADIO[RadioID]->BSS[k1] = AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1];
			AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id] = AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex;

			if(NULL != ali_essid)
			{
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->aliasSetFlag = 1;
				memcpy(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->aliasESSID, ali_essid, strlen(ali_essid));
			}

			AC_RADIO[RadioID]->BSS[k1]->muti_rate = AC_WLAN[WlanID]->wlan_muti_rate;
			AC_RADIO[RadioID]->BSS[k1]->noResToStaProReqSW = AC_WLAN[WlanID]->wlan_noResToStaProReqSW;
			AC_RADIO[RadioID]->BSS[k1]->muti_bro_cast_sw = AC_WLAN[WlanID]->wlan_muti_bro_cast_sw;
			AC_RADIO[RadioID]->BSS[k1]->unicast_sw = AC_WLAN[WlanID]->wlan_unicast_sw;
			AC_RADIO[RadioID]->BSS[k1]->wifi_sw = AC_WLAN[WlanID]->wlan_wifi_sw;

			if (AC_WLAN[WlanID]->wlan_if_policy == BSS_INTERFACE)
			{
				ret = Create_BSS_L3_Interface(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex);
				if (ret < 0)
				{
					WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
					return WLAN_CREATE_L3_INTERFACE_FAIL;
				}
			}
			else if (AC_WLAN[WlanID]->wlan_if_policy == WLAN_INTERFACE)
			{
				ret = Create_BSS_L3_Interface(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex);
				if (ret < 0)
				{
					WID_DELETE_WLAN_APPLY_RADIO(RadioID, WlanID);
					return WLAN_CREATE_L3_INTERFACE_FAIL;
				}

				ret = ADD_BSS_L3_Interface_BR(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex);
				if (ret < 0)
				{
					WID_DELETE_WLAN_APPLY_RADIO(RadioID, WlanID);
					return BSS_L3_INTERFACE_ADD_BR_FAIL;
				}
			}
			break;
		}
	}	
	
	if(k1 == L_BSS_NUM)
	{
		return WTP_OVER_MAX_BSS_NUM;
	}

	if (1 == AC_WLAN[WlanID]->Status)
	{
		wid_syslog_debug_debug(WID_DEFAULT, "%s: wlan%d disable,just binging, no send add wlan msg\n", __func__, WlanID);
		return 0;
	}
	
	issued_wlan_enable(WtpID, localradio_id, WlanID, LEVEL_RADIO);
	
	if(AC_WTP[WtpID] != NULL)
	{
		if ((AC_WLAN[WlanID]) && (AC_WLAN[WlanID]->Status == 0))
		{
			WLAN_FLOW_CHECK(WlanID);
		}	
	}
	int bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id];
	
	char apcmd[WID_SYSTEM_CMD_LENTH];

	/* config for eap-mac */
	memset(apcmd, 0, WID_SYSTEM_CMD_LENTH);
	if ((AC_WLAN[WlanID]->eap_mac_switch == 1)
		&& (AC_WLAN[WlanID]->wlan_if_policy == NO_INTERFACE)
		&& (AC_BSS[bssindex]!=NULL)
		&& (AC_BSS[bssindex]->BSS_IF_POLICY == NO_INTERFACE))
	{
	    sprintf(apcmd, "set_eap_mac ath.%d-%d %s", AC_RADIO[RadioID]->Radio_L_ID, WlanID, AC_WLAN[WlanID]->eap_mac);
	}
	else
	{
	    sprintf(apcmd,"set_eap_mac ath.%d-%d 0", AC_RADIO[RadioID]->Radio_L_ID, WlanID);
	}
	wid_syslog_debug_debug(WID_DEFAULT, "%s:%d radio%d-%d enable wlan%d: set eap mac cmd %s\n",__func__,__LINE__,WtpID,localradio_id,WlanID,apcmd);
	wid_radio_set_extension_command(WtpID, apcmd);

	/* config for traffic-limit */
	if ((check_bssid_func(AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id]))
		&& (AC_BSS[(AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id])] != NULL))
	{                                                                                        
		unsigned int bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id];
		wid_syslog_debug_debug(WID_DEFAULT, "%s:%d wlan%d bss[%d]->traffic_limit %s\n",
								__func__,__LINE__,WlanID, bssindex,AC_BSS[bssindex]->traffic_limit_able? "enable" : "disable");
		if (1 == AC_BSS[bssindex]->traffic_limit_able)
		{
			WID_Save_Traffic_Limit(bssindex, WtpID);
		}
	}

	/* config for multi-user-optimize */
	if ((AC_BSS[bssindex]) && (AC_BSS[bssindex]->multi_user_optimize_switch == 1))
	{
		char wlanid = AC_BSS[bssindex]->WlanID;
		int radioid = AC_BSS[bssindex]->Radio_G_ID;
		muti_user_optimize_switch(wlanid, radioid, 1);
	}

	/* config for WLAN_CHANGE_TUNNEL */
	if ((AC_BSS[bssindex])
		&& (AC_BSS[bssindex]->BSS_IF_POLICY != NO_INTERFACE)
		&& (AC_BSS[bssindex]->BSS_TUNNEL_POLICY != CW_802_DOT_11_TUNNEL))
	{
		msgq msg;
		struct msgqlist *elem = NULL;
		memset((char*)&msg, 0, sizeof(msg));

		msg.mqid = WtpID % THREAD_NUM + 1;
		msg.mqinfo.WTPID = WtpID;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WLAN_S_TYPE;
		msg.mqinfo.u.WlanInfo.Wlan_Op = WLAN_CHANGE_TUNNEL;
		msg.mqinfo.u.WlanInfo.WLANID = WlanID;
		msg.mqinfo.u.WlanInfo.Radio_L_ID = localradio_id;
		msg.mqinfo.u.WlanInfo.SecurityType = AC_WLAN[WlanID]->SecurityType;
		msg.mqinfo.u.WlanInfo.bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id];
		
		if ((AC_WTP[WtpID]->WTPStat == WID_RUN))
		{ 
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}
		else
		{
			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if (NULL == elem)
			{			
				WID_MALLOC_ERR();			
				return 0;
			}			
			memset(elem, 0, sizeof(struct msgqlist));
			
			elem->mqinfo.WTPID = WtpID;
			elem->mqinfo.type = CONTROL_TYPE;
			elem->mqinfo.subtype = WLAN_S_TYPE;
			elem->mqinfo.u.WlanInfo.Wlan_Op = WLAN_CHANGE_TUNNEL;
			elem->mqinfo.u.WlanInfo.WLANID = WlanID;
			elem->mqinfo.u.WlanInfo.Radio_L_ID = localradio_id;
			elem->mqinfo.u.WlanInfo.SecurityType = AC_WLAN[WlanID]->SecurityType;
			elem->mqinfo.u.WlanInfo.bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id];
			
			WID_INSERT_CONTROL_LIST(WtpID, elem);
		}
	}

	/*config for wlan-tunnel mode TL */
	memset(apcmd, 0, WID_SYSTEM_CMD_LENTH);
	if ((AC_WLAN[WlanID] != NULL) && (AC_WLAN[WlanID]->wlan_tunnel_switch == 1))
	{
		sprintf(apcmd,TUNNEL_SWITCH_CMD";"AP_OPEN_IPFORWARD";"AP_SPFAST_DOWM";"AP_SPFAST_UP,AC_RADIO[RadioID]->Radio_L_ID,WlanID);
		wid_radio_set_extension_command(WtpID, apcmd);
	}

	//delete for no support STA-ACL
#if 0

	if ((0 != AC_WLAN[WlanID]->aclgrp_id) && (NULL != STA_ACL_GROUP[AC_WLAN[WlanID]->aclgrp_id]))
	{
        msgq msg;
        struct msgqlist *elem = NULL;
		aclgroupid = AC_WLAN[WlanID]->aclgrp_id;
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WtpID%THREAD_NUM+1;
		msg.mqinfo.WTPID = WtpID;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WTP_S_TYPE;
		msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_ACL_LIST;
		msg.mqinfo.u.WtpInfo.value[0] = WlanID;
		msg.mqinfo.u.WtpInfo.value[1] = localradio_id;
		msg.mqinfo.u.WtpInfo.value[2] = OVERWRITE;
		msg.mqinfo.u.WtpInfo.value[3] = LEVEL_WLAN;
		msg.mqinfo.u.WtpInfo.value[4] = AC_WLAN[WlanID]->aclgrp_id;

		if(AC_WTP[WtpID]->WTPStat == WID_RUN)
		{ 
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}
		else
		{

			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if (NULL == elem)
			{			
				WID_MALLOC_ERR();			
				return 0;
			}			
			memset(elem, 0, sizeof(struct msgqlist));
			elem->mqinfo.WTPID = WtpID;
			elem->mqinfo.type = CONTROL_TYPE;
			elem->mqinfo.subtype = WTP_S_TYPE;
			elem->mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_ACL_LIST;
			elem->mqinfo.u.WtpInfo.value[0] = WlanID;
			elem->mqinfo.u.WtpInfo.value[1] = localradio_id;
			elem->mqinfo.u.WtpInfo.value[2] = OVERWRITE;
			elem->mqinfo.u.WtpInfo.value[3] = LEVEL_WLAN;
			elem->mqinfo.u.WtpInfo.value[4] = AC_WLAN[WlanID]->aclgrp_id;
			
			WID_INSERT_CONTROL_LIST(WtpID, elem);
		}
	}
#endif
	if(0 != memcmp(QOS_AP_11E_TO_1P_DEFAULT, AC_WLAN[WlanID]->qos_ap_11e_to_1p, MAX_QOS_11E_VAL+1))
	{
		set_ap_bss_qos_map_default(WtpID, localradio_id, QOS_MAP_11E_TO_1P, WlanID);
	}
	if(0 != memcmp(QOS_AP_11E_TO_DSCP_DEFAULT, AC_WLAN[WlanID]->qos_ap_11e_to_dscp, MAX_QOS_11E_VAL+1))
	{
		set_ap_bss_qos_map_default(WtpID, localradio_id, QOS_MAP_11E_TO_DSCP, WlanID);
	}
	if(0 != memcmp(QOS_AP_DSCP_TO_11E_DEFAULT, AC_WLAN[WlanID]->qos_ap_dscp_to_11e, MAX_QOS_DSCP_VAL+1))
	{
		set_ap_bss_qos_map_default(WtpID, localradio_id, QOS_MAP_DSCP_TO_11E, WlanID);
	}
	if(0 != memcmp(QOS_AP_1P_TO_11E_DEFAULT, AC_WLAN[WlanID]->qos_ap_1p_to_11e, MAX_QOS_1P_VAL+1))
	{
		set_ap_bss_qos_map_default(WtpID, localradio_id, QOS_MAP_1P_TO_11E, WlanID);
	}
	if(0 != AC_WLAN[WlanID]->qos_ap_11e_to_1p_switch)
	{
		set_ap_bss_qos_map_switch(WtpID, localradio_id, WlanID, QOS_MAP_11E_TO_1P, AC_WLAN[WlanID]->qos_ap_11e_to_1p_switch);
	}
	if(0 != AC_WLAN[WlanID]->qos_ap_11e_to_dscp_switch)
	{
		set_ap_bss_qos_map_switch(WtpID, localradio_id, WlanID, QOS_MAP_11E_TO_DSCP, AC_WLAN[WlanID]->qos_ap_11e_to_dscp_switch);
	}

	if(check_bssid_func(bssindex) && (0 != AC_BSS[bssindex]->packet_power))
	{
		WID_RADIO_WLAN_PACKET_POWER(WtpID, localradio_id, WlanID, AC_BSS[bssindex]->packet_power);
	}

	if ((check_bssid_func(bssindex)) &&(0 != AC_WLAN[WlanID]->balance_switch))
	{											
		wid_bss_balance_switch(WtpID, localradio_id, WlanID);										
	}

	return 0;
}


int WID_ADD_WLAN_CPE_CHANNEL_APPLY_RADIO_BASE_VLANID(unsigned int RadioID,unsigned char WlanID,unsigned int vlanid)
{
	int WtpID = RadioID/L_RADIO_NUM;
	int localradio_id = RadioID%L_RADIO_NUM;
	int i = 0, IGNORE_UBSV is_founded = 0, j = 0, is_added = 0, wlan_founded = 0, count = 0, is_bonded = 0;
	struct vlan_id *head = NULL, *tmp = NULL;
		
	if(AC_RADIO[RadioID]->BindingWlanCount >= L_BSS_NUM)
	{
		return WTP_OVER_MAX_BSS_NUM;
	}

	if(AC_WLAN[WlanID] == NULL)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"***%s: wlan%d does not exist **\n",__func__, WlanID);
		return WLAN_ID_NOT_EXIST;
	}

	struct wlanid *wlan_id = NULL;
	
	if(AC_RADIO[RadioID]->Wlan_Id == NULL)
	{
		return INTERFACE_NOT_BE_BINDED;
	}
	else
	{
		wlan_id = AC_RADIO[RadioID]->Wlan_Id;
		while(wlan_id != NULL)
		{	
			if(wlan_id->wlanid == WlanID)
			{
				is_bonded = 1;
				break;
			}
			wlan_id = wlan_id->next;
		}
		if(is_bonded == 0)
		{
			return INTERFACE_NOT_BE_BINDED;
		}
	}

	for(i = 0; i < 8;i++)
	{
		if(AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].wlanid == WlanID)
		{
			head = AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].vlanid;
			count = AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].vlan_count;
			for(j = 0; j < count; j++)
			{
				if(head->vlanId == vlanid)
				{
					is_founded = 1;
					return RADIO_ID_BE_USED;/*need add*/
				}
				head=head->next;
			}
			wlan_founded = 1;
			break;
		}
	}
	
	if(wlan_founded == 1)
	{
		AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].wlanid = WlanID;
		head = AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].vlanid;
		tmp = (struct vlan_id*)malloc(sizeof(struct vlan_id));
		if (NULL == tmp)
		{
			return MALLOC_ERROR;
		}
		memset(tmp, 0, sizeof(struct vlan_id));
		tmp->vlanId = vlanid;
		tmp->next = NULL;
		while(head && head->next)
		{
			head = head->next;
		}

		head->next = tmp;
		AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].vlan_count++;
	}
	else
	{
		for(i = 0; i < 8; i++)
		{
			if((AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].wlanid == 0))
			{
				head = (struct vlan_id*)malloc(sizeof(struct vlan_id));
				if (NULL == head)
				{
					return MALLOC_ERROR;
				}
				memset(head, 0, sizeof(struct vlan_id));
				head->next = NULL;
				head->vlanId = vlanid;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].wlanid = WlanID;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].vlanid = head;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].vlan_count++;
				is_added = 1;
				break;
			}
		}
		if(is_added == 0)
		{
			return VALUE_OUT_OF_RANGE;
		}
	}

	if(AC_WLAN[WlanID]->Status == 1)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"wlan is disable,so just binging this wlan,not to send add wlan msg\n");
		return 0;
	}
	msgq msg;
	if((AC_WTP[WtpID] != NULL) && (AC_WTP[WtpID]->WTPStat == WID_RUN))
	{
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WtpID%THREAD_NUM+1;
		msg.mqinfo.WTPID = WtpID;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = Radio_S_TYPE;
		msg.mqinfo.u.RadioInfo.op = 1;//enable
		msg.mqinfo.u.RadioInfo.Radio_Op = Radio_set_cpe_channel;
		msg.mqinfo.u.RadioInfo.wlanid = WlanID;
		msg.mqinfo.u.RadioInfo.vlan_id = vlanid;
		msg.mqinfo.u.RadioInfo.Radio_L_ID = localradio_id;
		msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
		
		if(AC_WTP[WtpID]->WTPStat == WID_RUN)
		{
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}
	}
	
	return 0;
}


int WID_ADD_WLAN_CPE_CHANNEL_APPLY_RADIO_CLEAN_VLANID(unsigned int RadioID,unsigned char WlanID,unsigned int vlanid)
{
	int WtpID = RadioID/L_RADIO_NUM;
	int localradio_id = RadioID%L_RADIO_NUM;
	int i = 0, j = 0, is_founded = 0, count = 0;
	struct vlan_id *head = NULL, *tmp = NULL;
	struct msgqlist *elem = NULL;
	msgq msg;
	
	if(AC_WTP[WtpID] == NULL)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"%s: wtp%d does not exist\n", __func__, WtpID);
		return WTP_ID_NOT_EXIST;
	}
	if(AC_WLAN[WlanID] == NULL)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"%s: wlan%d does not exist\n", __func__, WlanID);
		return WLAN_ID_NOT_EXIST;
	}

	for(i = 0; i < 8; i++)
	{
		if(AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].wlanid == WlanID)
		{
			if(vlanid == 0)
			{
				count = AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].vlan_count;
				for(j = 0; j < count; j++)
				{
					head = AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].vlanid;
					if(head && (head->vlanId != 0))
					{
						tmp = head;
						memset((char*)&msg, 0, sizeof(msg));
						msg.mqid = WtpID%THREAD_NUM+1;
						msg.mqinfo.WTPID = WtpID;
						msg.mqinfo.type = CONTROL_TYPE;
						msg.mqinfo.subtype = Radio_S_TYPE;
						msg.mqinfo.u.RadioInfo.op = 0;//disable
						msg.mqinfo.u.RadioInfo.Radio_Op = Radio_set_cpe_channel;
						msg.mqinfo.u.RadioInfo.wlanid = WlanID;
						msg.mqinfo.u.RadioInfo.vlan_id = AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].vlanid->vlanId;
						msg.mqinfo.u.RadioInfo.Radio_L_ID = localradio_id;
						msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
						
						if(AC_WTP[WtpID]->WTPStat == WID_RUN)
						{
							if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
							{
								wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
							}
						}
						else
						{
							elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
							if(elem == NULL)
							{
								WID_MALLOC_ERR();
								return MALLOC_ERROR;
							}
							memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
							elem->next = NULL;
							memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
							WID_INSERT_CONTROL_LIST(WtpID, elem);
						}
						
						AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].vlanid=tmp->next;
						if(NULL == tmp->next)
						{
							AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].vlanid = NULL;
							AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].wlanid = 0;
						}
						AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].vlan_count--;
						CW_FREE_OBJECT(head);
					}
				}
				return 0;
			}
			else
			{
				head = AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].vlanid;
				tmp = head;
				while(head && (head->vlanId != vlanid))
				{
					tmp = head;
					head = head->next;
				}

				if(!head)
				{
					return BSS_NOT_EXIST;
				}
				else
				{
					if(tmp == head)
					{
						AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].vlanid = tmp->next;
						if(NULL == tmp->next)
						{
							AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].vlanid = NULL;
							AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].wlanid = 0;
						}
					}
					else
					{
						tmp->next = head->next;
					}
					is_founded = 1;
					AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].vlan_count--;
					CW_FREE_OBJECT(head);
					break;
				}
			}
		}
	}
	#if 0
	for(i = 0; i < 8; i++)
	{
		if(AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].wlanid == WlanID)
		{
			head = AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].vlanid;
			tmp = head;
			while(head && (head->vlanId != vlanid))
			{
				tmp = head;
				head = head->next;
			}

			if(!head)
			{
				return BSS_NOT_EXIST;
			}
			else
			{
				if(tmp == head)
				{
					AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].vlanid=tmp->next;
					if(NULL == tmp->next)
					{
						AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].vlanid = NULL;
						AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].wlanid = 0;
					}
				}
				else
				{
					tmp->next = head->next;
				}
				is_founded = 1;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->cpe_intf[i].vlan_count--;
				CW_FREE_OBJECT(head);
				break;
			}
		}
	}
	#endif
	if(is_founded == 0)
		return BSS_NOT_EXIST;
	if((AC_WTP[WtpID] != NULL) && (is_founded == 1))
	{
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WtpID%THREAD_NUM+1;
		msg.mqinfo.WTPID = WtpID;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = Radio_S_TYPE;
		msg.mqinfo.u.RadioInfo.op = 0;//disable
		msg.mqinfo.u.RadioInfo.Radio_Op = Radio_set_cpe_channel;
		msg.mqinfo.u.RadioInfo.wlanid = WlanID;
		msg.mqinfo.u.RadioInfo.vlan_id = vlanid;
		msg.mqinfo.u.RadioInfo.Radio_L_ID = localradio_id;
		msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
		
		if(AC_WTP[WtpID]->WTPStat == WID_RUN)
		{
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}
		/*
		else
		{
			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if(elem == NULL)
			{
				wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
				return 0;
			}
			memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
			elem->next = NULL;
			memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
			WID_INSERT_CONTROL_LIST(WtpID, elem);
		}
		*/
	}
	
	return 0;
}

//mahz add 2011.5.30
int WID_ADD_WLAN_APPLY_RADIO_BASE_NAS_PORT_ID(unsigned int RadioID,unsigned char WlanID,char* nas_port_id)
{
	int ret = -1;
	int k1 = 0; 
	int i = 0;
	char nas_id[NAS_IDENTIFIER_NAME];//zhanglei add
	unsigned int nas_id_len = 0;//zhanglei add
	int WtpID = RadioID/L_RADIO_NUM;
	int localradio_id = RadioID%L_RADIO_NUM;
	char apcmd[WID_SYSTEM_CMD_LENTH] = {0};
	unsigned char IGNORE_UBSV aclgroupid = 0;
	
	if(AC_RADIO[RadioID]->BindingWlanCount >= L_BSS_NUM)
	{
		return WTP_OVER_MAX_BSS_NUM;
	}

	if(AC_WLAN[WlanID] == NULL){
		wid_syslog_debug_debug(WID_DEFAULT,"*** you binding wlan does not exist **\n");
		return WLAN_ID_NOT_EXIST;
	}
	
	if(AC_WLAN[WlanID]->Wlan_Ifi != NULL)
	{
		if(AC_WTP[WtpID]->BindingSystemIndex != -1)
		{
			struct ifi * wlan_ifi = AC_WLAN[WlanID]->Wlan_Ifi;
			while(wlan_ifi != NULL)
			{
				if(AC_WTP[WtpID]->BindingSystemIndex == wlan_ifi->ifi_index)
				{
					if(wlan_ifi->nas_id_len > 0)
					{
						nas_id_len = wlan_ifi->nas_id_len;//zhanglei add
						memcpy(nas_id,wlan_ifi->nas_id,NAS_IDENTIFIER_NAME);//zhanglei add
					}
					break;
				}
				wlan_ifi = wlan_ifi->ifi_next;
			}
			
			if(wlan_ifi == NULL)
			{
				wid_syslog_debug_debug(WID_DEFAULT,"*** wtp binding interface doesn't match with wlan binding interface **\n");
				//return WTP_WLAN_BINDING_NOT_MATCH;
			}
			
		}
		else
		{
			wid_syslog_warning("<warning>,%s,%d,WTP_IF_NOT_BE_BINDED\n",__func__,__LINE__);
			//return WTP_IF_NOT_BE_BINDED;
		}
	}
	else
	{
		wid_syslog_warning("<warning>,%s,%d,Wlan_IF_NOT_BE_BINDED\n",__func__,__LINE__);
		//return Wlan_IF_NOT_BE_BINDED;
	}

	//added end
		
	struct wlanid *wlan_id = NULL;
	struct wlanid *wlan_id_next = NULL;
	wlan_id = (struct wlanid*)malloc(sizeof(struct wlanid));
	
	wlan_id->wlanid= WlanID;
	wlan_id->next = NULL;
	wid_syslog_debug_debug(WID_DEFAULT,"*** wtp binding wlan id  is %d*\n", wlan_id->wlanid);
	
	if(AC_RADIO[RadioID]->Wlan_Id == NULL){
		AC_RADIO[RadioID]->Wlan_Id = wlan_id ;
		AC_RADIO[RadioID]->isBinddingWlan = 1;
		AC_RADIO[RadioID]->BindingWlanCount++;
		wid_syslog_debug_debug(WID_DEFAULT,"*** wtp id:%d binding first wlan id:%d	\n",WtpID,WlanID);
	}
	else{
		wlan_id_next = AC_RADIO[RadioID]->Wlan_Id;
		while(wlan_id_next != NULL)
		{	
			if(wlan_id_next->wlanid == WlanID){
				wid_syslog_debug_debug(WID_DEFAULT,"warnning you have binding this wlan id,please do not binding this again");
				//wtp have already binding this wlan ,only to add nas_port_id
				int i = 0;	
				for(i=0;i<L_BSS_NUM;i++)
				{
					if(AC_RADIO[RadioID]->BSS[i] != NULL)
					{
						if(AC_RADIO[RadioID]->BSS[i]->WlanID == WlanID)
						{
							memset(AC_RADIO[RadioID]->BSS[i]->nas_port_id,0,NAS_PORT_ID_LEN);
							memcpy(AC_RADIO[RadioID]->BSS[i]->nas_port_id,nas_port_id,strlen(nas_port_id));
							break;
						}
					}
				}
				CW_FREE_OBJECT(wlan_id);
				return 0;
			}
			wlan_id_next = wlan_id_next->next;
		}

		wlan_id_next = AC_RADIO[RadioID]->Wlan_Id;
		while(wlan_id_next->next!= NULL){	
			wlan_id_next = wlan_id_next->next;//insert element int tail
		}
		
		wlan_id_next->next= wlan_id;
		AC_RADIO[RadioID]->BindingWlanCount++;
		
		wid_syslog_debug_debug(WID_DEFAULT,"*** wtp id:%d binding more wlan id:%d  \n",WtpID,WlanID);
	}

	for(k1=0;k1<L_BSS_NUM;k1++){
			if(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1] == NULL){
				//printf("BSSIndex:%d\n",k1);
				if((RadioID)*L_BSS_NUM+k1 >= BSS_NUM){
					wid_syslog_err("<error>invalid bssindex:%d,%s\n",(RadioID)*L_BSS_NUM+k1,__func__);
					return BSS_ID_LARGE_THAN_MAX;
				}
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1] = (WID_BSS*)malloc(sizeof(WID_BSS));
				memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1],0,sizeof(WID_BSS));	//mahz add 2011.6.15
				/*zhaoruijia,BSS_pkt_infostar*/
				memset(&(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSS_pkt_info),0,sizeof(BSSStatistics));
                /*zhaoruijia,BSS_pkt_infoend*/
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSID = (unsigned char*)malloc(6);
				memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSID,0,6);
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->bss_max_allowed_sta_num= AC_WLAN[WlanID]->bss_allow_max_sta_num;//fengwenchap modify 20120323
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->WlanID = WlanID;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->Radio_G_ID = RadioID;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->Radio_L_ID = localradio_id;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->State = 0;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->keyindex = 0;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->band_width = 25;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->WDSStat = AC_WLAN[WlanID]->WDSStat;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->wblwm= AC_WLAN[WlanID]->wds_mesh;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->wds_mesh = AC_WLAN[WlanID]->wds_mesh;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->ath_l2_isolation = AC_WLAN[WlanID]->wlan_ath_l2_isolation; //fengwenchao modify 20120323
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->cwmmode = 1;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->traffic_limit_able = 0;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->traffic_limit = AC_WLAN[WlanID]->wlan_traffic_limit;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->average_rate = AC_WLAN[WlanID]->wlan_station_average_traffic_limit;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->send_traffic_limit = AC_WLAN[WlanID]->wlan_send_traffic_limit;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->send_average_rate = AC_WLAN[WlanID]->wlan_station_average_send_traffic_limit;;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->ip_mac_binding = AC_WLAN[WlanID]->sta_ip_mac_bind; //fengwenchao modify 20120323
				memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->arp_ifname,0,ETH_IF_NAME_LEN);      //fengwenchao  add	20120323
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->sta_static_arp_policy = AC_WLAN[WlanID]->wlan_sta_static_arp_policy;      //fengwenchao   add 20120323				
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->upcount = 0;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->downcount = 0;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex = (RadioID)*L_BSS_NUM+k1;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSS_IF_POLICY = AC_WLAN[WlanID]->wlan_if_policy;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSS_TUNNEL_POLICY = AC_WLAN[WlanID]->WLAN_TUNNEL_POLICY;
				memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSS_IF_NAME, 0, ETH_IF_NAME_LEN);
				memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_id, 0, NAS_IDENTIFIER_NAME);//zhanglei add
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_id_len = 0;//zhanglei add
				if(nas_id_len > 0){
					AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_id_len = nas_id_len;//zhanglei add
					memcpy(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_id, nas_id, NAS_IDENTIFIER_NAME);//zhanglei add
				}
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf = (struct acl_config *)malloc(sizeof(struct acl_config));
				memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf,0,sizeof(struct acl_config));
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->macaddr_acl = 0;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->accept_mac = NULL;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->num_accept_mac = 0;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->deny_mac = NULL;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->num_deny_mac = 0;

				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->multi_user_optimize_switch = AC_WLAN[WlanID]->multi_user_optimize_switch;//weichao add 
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->wlan_vlanid = AC_WLAN[WlanID]->vlanid;
				//put vlan to bss
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->vlanid = 0;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->packet_power = AC_WLAN[WlanID]->packet_power;
				AC_BSS[AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex] = AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1];
				AC_RADIO[RadioID]->BSS[k1] = AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1];
				AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id] = AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->hotspot_id = AC_WLAN[WlanID]->hotspot_id;

				AC_RADIO[RadioID]->BSS[k1]->muti_rate = AC_WLAN[WlanID]->wlan_muti_rate;
				AC_RADIO[RadioID]->BSS[k1]->noResToStaProReqSW = AC_WLAN[WlanID]->wlan_noResToStaProReqSW;
				AC_RADIO[RadioID]->BSS[k1]->muti_bro_cast_sw = AC_WLAN[WlanID]->wlan_muti_bro_cast_sw;
				AC_RADIO[RadioID]->BSS[k1]->unicast_sw = AC_WLAN[WlanID]->wlan_unicast_sw;
				AC_RADIO[RadioID]->BSS[k1]->wifi_sw = AC_WLAN[WlanID]->wlan_wifi_sw;
				//mahz add 2011.5.26
				unsigned int BSSIndex = AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex;
				memset(AC_BSS[BSSIndex]->nas_port_id,0,NAS_PORT_ID_LEN);
				memcpy(AC_BSS[BSSIndex]->nas_port_id,nas_port_id,strlen(nas_port_id));
				wid_syslog_debug_info("AC_BSS->nas_port_id : %s\n",AC_BSS[BSSIndex]->nas_port_id); 	//for test

				//radio apply wep wlan
				if((AC_WLAN[WlanID]->EncryptionType == WEP)&&(AC_WLAN[WlanID]->SecurityType != IEEE8021X))
				{
					//fengwenchao change begin
					//
					/*for(i=0;i<WTP_WEP_NUM;i++)
					{
						if(AC_WTP[WtpID]->wep_flag[i] == 0)
						{
							AC_WTP[WtpID]->wep_flag[i] = (RadioID)*L_BSS_NUM+k1;
							AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->keyindex = i+1;
							break;
						}
						if(i == WTP_WEP_NUM-1)
						{
							wid_syslog_debug_debug(WID_DEFAULT,"radio apply wep wlan over 4\n");
							WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
							return WTP_WEP_NUM_OVER;
						}
					}*/
					//
					
					//
					for(i=0;i<WTP_WEP_NUM;i++)
					{
						if(AC_RADIO[RadioID]->wep_flag[i] == 0)
						{
							int k =0;
							for(k=0;k<i;k++)
							{
								if((AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k]->keyindex == AC_WLAN[WlanID]->SecurityIndex)&&(AC_WLAN[AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k]->WlanID]->EncryptionType == WEP))
								{
										WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
										return SECURITYINDEX_IS_SAME;
								}
							}
						}
						int j =0;
						j = AC_WLAN[WlanID]->SecurityIndex - 1;
						if(j<WTP_WEP_NUM)
						{
							if(AC_RADIO[RadioID]->wep_flag[j] == 0)
							{
								AC_RADIO[RadioID]->wep_flag[j] = (RadioID)*L_BSS_NUM+k1;
								AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->keyindex = AC_WLAN[WlanID]->SecurityIndex;															
								break;
							}
						}	
						else
						{
							wid_syslog_debug_debug(WID_DEFAULT,"radio apply wep wlan over 4\n");
							WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
							return WTP_WEP_NUM_OVER;
						}
						//if(AC_WTP[WtpID]-)
					}
					//
					//fengwenchao change end
				}
				if(AC_WLAN[WlanID]->wlan_if_policy == BSS_INTERFACE)
				{		
				
					ret = Create_BSS_L3_Interface(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex);
					
					if(ret < 0)
					{
						//WID_DELETE_WLAN_APPLY_WTP(WtpID, WlanID);
						WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
						return WLAN_CREATE_L3_INTERFACE_FAIL;
					}
	
				}
				else if(AC_WLAN[WlanID]->wlan_if_policy == WLAN_INTERFACE)
				{
					ret = Create_BSS_L3_Interface(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex);
					
					if(ret < 0)
					{
						//WID_DELETE_WLAN_APPLY_WTP(WtpID, WlanID);
						WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
						return WLAN_CREATE_L3_INTERFACE_FAIL;
					}

					ret = ADD_BSS_L3_Interface_BR(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex);
					if(ret < 0)
					{
						//WID_DELETE_WLAN_APPLY_WTP(WtpID, WlanID);
						WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
						return BSS_L3_INTERFACE_ADD_BR_FAIL;
					}
				}
				break;
			}
		}	

	
	if(k1 == L_BSS_NUM)
	{
		return WTP_OVER_MAX_BSS_NUM;
	}
	if(AC_WLAN[WlanID]->Status == 1)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"wlan is disable,so just binging this wlan,not to send add wlan msg\n");
		return 0;
	}
	msgq msg;
	struct msgqlist *elem;
	//add to control list
	if((AC_WTP[WtpID] != NULL)&&(AC_WTP[WtpID]->WTPStat == WID_RUN))
	{
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WtpID%THREAD_NUM+1;
		msg.mqinfo.WTPID = WtpID;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WLAN_S_TYPE;
		msg.mqinfo.u.WlanInfo.Wlan_Op = WLAN_ADD;
		msg.mqinfo.u.WlanInfo.WLANID = WlanID;
		msg.mqinfo.u.WlanInfo.Radio_L_ID = localradio_id;

		msg.mqinfo.u.WlanInfo.HideESSid = AC_WLAN[WlanID]->HideESSid;
		memset(msg.mqinfo.u.WlanInfo.WlanKey,0,DEFAULT_LEN);
		memcpy(msg.mqinfo.u.WlanInfo.WlanKey,AC_WLAN[WlanID]->WlanKey,DEFAULT_LEN);
		msg.mqinfo.u.WlanInfo.KeyLen = AC_WLAN[WlanID]->KeyLen;
		msg.mqinfo.u.WlanInfo.wpa_group_rekey = AC_WLAN[WlanID]->wpa_group_rekey;
		msg.mqinfo.u.WlanInfo.SecurityType = AC_WLAN[WlanID]->SecurityType;
		msg.mqinfo.u.WlanInfo.SecurityIndex = AC_WLAN[WlanID]->SecurityIndex;
		msg.mqinfo.u.WlanInfo.asic_hex = AC_WLAN[WlanID]->asic_hex;/* 0 asic; 1 hex*/
		msg.mqinfo.u.WlanInfo.Roaming_Policy = AC_WLAN[WlanID]->Roaming_Policy;			/*Roaming (1 enable /0 disable)*/
		memset(msg.mqinfo.u.WlanInfo.WlanEssid,0,ESSID_LENGTH);
		memcpy(msg.mqinfo.u.WlanInfo.WlanEssid,AC_WLAN[WlanID]->ESSID,ESSID_LENGTH);
		msg.mqinfo.u.WlanInfo.bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id];
		
		if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
			wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
		}
	}
	else if((AC_WTP[WtpID] != NULL))
	{
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WtpID%THREAD_NUM+1;
		msg.mqinfo.WTPID = WtpID;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WLAN_S_TYPE;
		msg.mqinfo.u.WlanInfo.Wlan_Op = WLAN_ADD;
		msg.mqinfo.u.WlanInfo.WLANID = WlanID;
		msg.mqinfo.u.WlanInfo.Radio_L_ID = localradio_id;

		msg.mqinfo.u.WlanInfo.HideESSid = AC_WLAN[WlanID]->HideESSid;
		memset(msg.mqinfo.u.WlanInfo.WlanKey,0,DEFAULT_LEN);
		memcpy(msg.mqinfo.u.WlanInfo.WlanKey,AC_WLAN[WlanID]->WlanKey,DEFAULT_LEN);
		msg.mqinfo.u.WlanInfo.KeyLen = AC_WLAN[WlanID]->KeyLen;
		msg.mqinfo.u.WlanInfo.wpa_group_rekey = AC_WLAN[WlanID]->wpa_group_rekey;
		msg.mqinfo.u.WlanInfo.SecurityType = AC_WLAN[WlanID]->SecurityType;
		msg.mqinfo.u.WlanInfo.SecurityIndex = AC_WLAN[WlanID]->SecurityIndex;
		msg.mqinfo.u.WlanInfo.asic_hex = AC_WLAN[WlanID]->asic_hex;/* 0 asic; 1 hex*/
		msg.mqinfo.u.WlanInfo.Roaming_Policy = AC_WLAN[WlanID]->Roaming_Policy;			/*Roaming (1 enable /0 disable)*/
		memset(msg.mqinfo.u.WlanInfo.WlanEssid, 0, ESSID_LENGTH);
		memcpy(msg.mqinfo.u.WlanInfo.WlanEssid, AC_WLAN[WlanID]->ESSID, ESSID_LENGTH);
		msg.mqinfo.u.WlanInfo.bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id];
		
		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if (NULL == elem)
		{			
			WID_MALLOC_ERR();			
			return 0;
		}
		memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
		elem->next = NULL;
		memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
		WID_INSERT_CONTROL_LIST(WtpID, elem);		
	}	
	if(AC_WTP[WtpID]!=NULL){
		if((AC_WLAN[WlanID])&&(AC_WLAN[WlanID]->Status == 0))
			WLAN_FLOW_CHECK(WlanID);
	}
	int bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id];
	if((AC_BSS[bssindex])&&(AC_BSS[bssindex]->BSS_IF_POLICY != NO_INTERFACE)&&(AC_BSS[bssindex]->BSS_TUNNEL_POLICY != CW_802_DOT_11_TUNNEL)){
		msgq msg;
		struct msgqlist *elem;
		memset((char*)&msg, 0, sizeof(msg));
		wid_syslog_debug_debug(WID_DEFAULT,"*** %s,%d.**\n",__func__,__LINE__);
		msg.mqid = WtpID%THREAD_NUM+1;
		msg.mqinfo.WTPID = WtpID;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WLAN_S_TYPE;
		msg.mqinfo.u.WlanInfo.Wlan_Op = WLAN_CHANGE_TUNNEL;
		msg.mqinfo.u.WlanInfo.WLANID = WlanID;
		msg.mqinfo.u.WlanInfo.Radio_L_ID = localradio_id;
		
		msg.mqinfo.u.WlanInfo.bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id];
		
		if((AC_WTP[WtpID]->WTPStat == WID_RUN)){ 
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}
		else{
			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if(elem == NULL){
				wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
				perror("malloc");
				return 0;
			}
			memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
			elem->next = NULL;
			memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
			WID_INSERT_CONTROL_LIST(WtpID, elem);
		}
	}
	/* wlan tunnel switch func for REQUIREMENTS-264 */
	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);
	
	if((AC_WLAN[WlanID]!=NULL)&&(AC_WLAN[WlanID]->wlan_tunnel_switch == 1))
	{
		//sprintf(apcmd,"echo 3 > /proc/sys/net/ath.%d-%d/vap_splitmac",AC_RADIO[RadioID]->Radio_L_ID,WlanID);
		sprintf(apcmd,TUNNEL_SWITCH_CMD";"AP_OPEN_IPFORWARD";"AP_SPFAST_DOWM";"AP_SPFAST_UP,AC_RADIO[RadioID]->Radio_L_ID,WlanID);
		wid_radio_set_extension_command(WtpID,apcmd);
	}
	/* end */
	if ((0 != AC_WLAN[WlanID]->aclgrp_id) && (NULL != STA_ACL_GROUP[AC_WLAN[WlanID]->aclgrp_id]))
	{
		aclgroupid = AC_WLAN[WlanID]->aclgrp_id;
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WtpID%THREAD_NUM+1;
		msg.mqinfo.WTPID = WtpID;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WTP_S_TYPE;
		msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_ACL_LIST;
		msg.mqinfo.u.WtpInfo.value[0] = WlanID;
		msg.mqinfo.u.WtpInfo.value[1] = localradio_id;
		msg.mqinfo.u.WtpInfo.value[2] = OVERWRITE;
		msg.mqinfo.u.WtpInfo.value[3] = LEVEL_WLAN;
		msg.mqinfo.u.WtpInfo.value[4] = AC_WLAN[WlanID]->aclgrp_id;
		/*
		msg.mqinfo.u.WtpInfo.value3 = STA_ACL_GROUP[aclgroupid]->rule_cnt;
		rulelist = STA_ACL_GROUP[aclgroupid]->rule_list;
		for (i = 0; i < STA_ACL_GROUP[aclgroupid]->rule_cnt; i++)
		{
			msg.mqinfo.u.WtpInfo.value[i] = rulelist->rule_id;
			rulelist = rulelist->next;
		}
		*/
		if(AC_WTP[WtpID]->WTPStat == WID_RUN)
		{ 
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}
		else
		{

			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if (NULL == elem)
			{			
				WID_MALLOC_ERR();			
				return 0;
			}			
			memset(elem, 0, sizeof(struct msgqlist));
			elem->mqinfo.WTPID = WtpID;
			elem->mqinfo.type = CONTROL_TYPE;
			elem->mqinfo.subtype = WTP_S_TYPE;
			elem->mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_ACL_LIST;
			elem->mqinfo.u.WtpInfo.value[0] = WlanID;
			elem->mqinfo.u.WtpInfo.value[1] = localradio_id;
			elem->mqinfo.u.WtpInfo.value[2] = OVERWRITE;
			elem->mqinfo.u.WtpInfo.value[3] = LEVEL_WLAN;
			elem->mqinfo.u.WtpInfo.value[4] = AC_WLAN[WlanID]->aclgrp_id;
			
			WID_INSERT_CONTROL_LIST(WtpID, elem);
		}
	}
	if(0 != memcmp(QOS_AP_11E_TO_1P_DEFAULT, AC_WLAN[WlanID]->qos_ap_11e_to_1p, MAX_QOS_11E_VAL+1))
	{
		set_ap_bss_qos_map_default(WtpID, localradio_id, QOS_MAP_11E_TO_1P, WlanID);
	}
	if(0 != memcmp(QOS_AP_11E_TO_DSCP_DEFAULT, AC_WLAN[WlanID]->qos_ap_11e_to_dscp, MAX_QOS_11E_VAL+1))
	{
		set_ap_bss_qos_map_default(WtpID, localradio_id, QOS_MAP_11E_TO_DSCP, WlanID);
	}
	if(0 != memcmp(QOS_AP_DSCP_TO_11E_DEFAULT, AC_WLAN[WlanID]->qos_ap_dscp_to_11e, MAX_QOS_DSCP_VAL+1))
	{
		set_ap_bss_qos_map_default(WtpID, localradio_id, QOS_MAP_DSCP_TO_11E, WlanID);
	}
	if(0 != memcmp(QOS_AP_1P_TO_11E_DEFAULT, AC_WLAN[WlanID]->qos_ap_1p_to_11e, MAX_QOS_1P_VAL+1))
	{
		set_ap_bss_qos_map_default(WtpID, localradio_id, QOS_MAP_1P_TO_11E, WlanID);
	}
	if(0 != AC_WLAN[WlanID]->qos_ap_11e_to_1p_switch)
	{
		set_ap_bss_qos_map_switch(WtpID, localradio_id, WlanID, QOS_MAP_11E_TO_1P, AC_WLAN[WlanID]->qos_ap_11e_to_1p_switch);
	}
	if(0 != AC_WLAN[WlanID]->qos_ap_11e_to_dscp_switch)
	{
		set_ap_bss_qos_map_switch(WtpID, localradio_id, WlanID, QOS_MAP_11E_TO_DSCP, AC_WLAN[WlanID]->qos_ap_11e_to_dscp_switch);
	}
	
	if((AC_RADIO[RadioID]->BSS[k1])&&(AC_RADIO[RadioID]->BSS[k1]->multi_user_optimize_switch == 1))
	{
		char wlanid =WlanID;
		int radioid = AC_RADIO[RadioID]->BSS[k1]->Radio_G_ID;
		muti_user_optimize_switch(wlanid,radioid,1);
		
	}
	if(check_bssid_func(bssindex) && (0 != AC_BSS[bssindex]->packet_power))
	{
		WID_RADIO_WLAN_PACKET_POWER(WtpID, localradio_id, WlanID, AC_BSS[bssindex]->packet_power);
	}
	if(0 != AC_WLAN[WlanID]->balance_switch)
	{											
		wid_bss_balance_switch(WtpID, localradio_id, WlanID);										
	}
	return 0;

}

int WID_ADD_WLAN_APPLY_RADIO_CLEAN_NAS_PORT_ID(unsigned int RadioID,unsigned char WlanID){

	int isfind = 0; 
	int i = 0;
	int WtpID = RadioID/L_RADIO_NUM;
	int localradio_id = RadioID%L_RADIO_NUM;
	if(AC_WTP[WtpID] == NULL)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"*** you binding wlan does not exist **\n");
		return WTP_ID_NOT_EXIST;
	}
	if(AC_WLAN[WlanID] == NULL)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"*** you binding wlan does not exist **\n");
		return WLAN_ID_NOT_EXIST;
	}
	
	for(i=0;i<L_BSS_NUM;i++)
	{
		if(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[i] != NULL)
		{
			if(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[i]->WlanID == WlanID)
			{
				memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[i]->nas_port_id, 0, NAS_PORT_ID_LEN);
				isfind = 1;
				break;
			}
		}
	}
	if(isfind != 1)
	{
		return WTP_WLAN_BINDING_NOT_MATCH;
	}
	return 0;
}

//weichao copy from vlan 
int WID_ADD_WLAN_APPLY_RADIO_BASE_HOTSPOT_ID(unsigned int RadioID,unsigned char WlanID,unsigned int  hotspot_id){

	int ret = -1;
	int k1 = 0; 
	int i = 0;
	char nas_id[NAS_IDENTIFIER_NAME];//zhanglei add
	unsigned int nas_id_len = 0;//zhanglei add
	int WtpID = RadioID/L_RADIO_NUM;
	int localradio_id = RadioID%L_RADIO_NUM;
	char apcmd[WID_SYSTEM_CMD_LENTH] = {0};
	unsigned char IGNORE_UBSV aclgroupid = 0;
		
	if(AC_RADIO[RadioID]->BindingWlanCount >= L_BSS_NUM){
		return WTP_OVER_MAX_BSS_NUM;
	}

	if(AC_WLAN[WlanID] == NULL){
		wid_syslog_debug_debug(WID_DEFAULT,"*** you binding wlan does not exist **\n");
		return WLAN_ID_NOT_EXIST;
	}
	if(AC_WLAN[WlanID]->Wlan_Ifi != NULL)
	{
		if(AC_WTP[WtpID]->BindingSystemIndex != -1)
		{
			struct ifi * wlan_ifi = AC_WLAN[WlanID]->Wlan_Ifi;
			while(wlan_ifi != NULL)
			{
				if(AC_WTP[WtpID]->BindingSystemIndex == wlan_ifi->ifi_index)
				{
					if(wlan_ifi->nas_id_len > 0)
					{
						nas_id_len = wlan_ifi->nas_id_len;//zhanglei add
						memcpy(nas_id,wlan_ifi->nas_id,NAS_IDENTIFIER_NAME);//zhanglei add
					}
					break;
				}
				wlan_ifi = wlan_ifi->ifi_next;
			}
			
			if(wlan_ifi == NULL)
			{
				wid_syslog_debug_debug(WID_DEFAULT,"*** wtp binding interface doesn't match with wlan binding interface **\n");
				//return WTP_WLAN_BINDING_NOT_MATCH;
			}
			
		}
		else
		{
			return WTP_IF_NOT_BE_BINDED;
		}
	}
	else
	{
		//return Wlan_IF_NOT_BE_BINDED;
	}
	
	//added end
		
	struct wlanid *wlan_id;
	struct wlanid *wlan_id_next;
	wlan_id = (struct wlanid*)malloc(sizeof(struct wlanid));
	
	wlan_id->wlanid= WlanID;
	wlan_id->next = NULL;
	wid_syslog_debug_debug(WID_DEFAULT,"*** wtp binding wlan id  is %d*\n", wlan_id->wlanid);
	
	if(AC_RADIO[RadioID]->Wlan_Id == NULL){
		AC_RADIO[RadioID]->Wlan_Id = wlan_id ;
		AC_RADIO[RadioID]->isBinddingWlan = 1;
		AC_RADIO[RadioID]->BindingWlanCount++;
		wid_syslog_debug_debug(WID_DEFAULT,"*** wtp id:%d binding first wlan id:%d	\n",WtpID,WlanID);
	}
	else{
		wlan_id_next = AC_RADIO[RadioID]->Wlan_Id;
		while(wlan_id_next != NULL)
		{	
			if(wlan_id_next->wlanid == WlanID){
				wid_syslog_debug_debug(WID_DEFAULT,"warnning you have binding this wlan id,please do not binding this again");
				int i = 0;	
				for(i=0;i<L_BSS_NUM;i++)
				{
					if(AC_RADIO[RadioID]->BSS[i] != NULL)
					{
						if(AC_RADIO[RadioID]->BSS[i]->WlanID == WlanID)
						{
							AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[i]->hotspot_id = hotspot_id;
							break;
						}
					}
				}
				CW_FREE_OBJECT(wlan_id);
				return 0;
			}
			wlan_id_next = wlan_id_next->next;
		}

		wlan_id_next = AC_RADIO[RadioID]->Wlan_Id;
		while(wlan_id_next->next!= NULL){	
			wlan_id_next = wlan_id_next->next;//insert element int tail
		}
		
		wlan_id_next->next= wlan_id;
		AC_RADIO[RadioID]->BindingWlanCount++;
		
		wid_syslog_debug_debug(WID_DEFAULT,"*** wtp id:%d binding more wlan id:%d  \n",WtpID,WlanID);
	}

	for(k1=0;k1<L_BSS_NUM;k1++){
			if(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1] == NULL){
				//printf("BSSIndex:%d\n",k1);
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1] = (WID_BSS*)malloc(sizeof(WID_BSS));
				memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1],0,sizeof(WID_BSS));	//mahz add 2011.6.14
				/*zhaoruijia,BSS_pkt_infostar*/
				memset(&(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSS_pkt_info),0,sizeof(BSSStatistics));
                /*zhaoruijia,BSS_pkt_infoend*/
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSID = (unsigned char*)malloc(6);
				memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSID,0,6);
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->bss_max_allowed_sta_num=128;//xm add
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->WlanID = WlanID;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->Radio_G_ID = RadioID;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->Radio_L_ID = localradio_id;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->State = 0;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->keyindex = 0;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->band_width = 25;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->WDSStat = AC_WLAN[WlanID]->WDSStat;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->wblwm= AC_WLAN[WlanID]->wds_mesh;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->wds_mesh = AC_WLAN[WlanID]->wds_mesh;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->ath_l2_isolation = 0;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->cwmmode = 1;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->traffic_limit_able = 0;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->traffic_limit = AC_WLAN[WlanID]->wlan_traffic_limit;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->average_rate = AC_WLAN[WlanID]->wlan_station_average_traffic_limit;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->send_traffic_limit = AC_WLAN[WlanID]->wlan_send_traffic_limit;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->send_average_rate = AC_WLAN[WlanID]->wlan_station_average_send_traffic_limit;;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->ip_mac_binding = 0;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->upcount = 0;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->downcount = 0;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex = (RadioID)*L_BSS_NUM+k1;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSS_IF_POLICY = AC_WLAN[WlanID]->wlan_if_policy;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSS_TUNNEL_POLICY = AC_WLAN[WlanID]->WLAN_TUNNEL_POLICY;
				memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSS_IF_NAME, 0, ETH_IF_NAME_LEN);
				memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_id, 0, NAS_IDENTIFIER_NAME);//zhanglei add
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_id_len = 0;//zhanglei add
				if(nas_id_len > 0){
					AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_id_len = nas_id_len;//zhanglei add
					memcpy(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_id, nas_id, NAS_IDENTIFIER_NAME);//zhanglei add
				}
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf = (struct acl_config *)malloc(sizeof(struct acl_config));
				memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf,0,sizeof(struct acl_config));
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->macaddr_acl = 0;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->accept_mac = NULL;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->num_accept_mac = 0;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->deny_mac = NULL;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->acl_conf->num_deny_mac = 0;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->wlan_vlanid = AC_WLAN[WlanID]->vlanid;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->hotspot_id =  hotspot_id;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->multi_user_optimize_switch = AC_WLAN[WlanID]->multi_user_optimize_switch;//weichao add 
				//put vlan to bss
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->vlanid = 0;
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->packet_power = AC_WLAN[WlanID]->packet_power;
				AC_BSS[AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex] = AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1];
				AC_RADIO[RadioID]->BSS[k1] = AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1];
				AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id] = AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex;

				
				AC_RADIO[RadioID]->BSS[k1]->muti_rate = AC_WLAN[WlanID]->wlan_muti_rate;
				AC_RADIO[RadioID]->BSS[k1]->noResToStaProReqSW = AC_WLAN[WlanID]->wlan_noResToStaProReqSW;
				AC_RADIO[RadioID]->BSS[k1]->muti_bro_cast_sw = AC_WLAN[WlanID]->wlan_muti_bro_cast_sw;
				AC_RADIO[RadioID]->BSS[k1]->unicast_sw = AC_WLAN[WlanID]->wlan_unicast_sw;
				AC_RADIO[RadioID]->BSS[k1]->wifi_sw = AC_WLAN[WlanID]->wlan_wifi_sw;
				memset(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_port_id,0,NAS_PORT_ID_LEN);		       
				memcpy(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->nas_port_id,AC_WLAN[WlanID]->nas_port_id,NAS_PORT_ID_LEN);

				if((AC_WLAN[WlanID]->EncryptionType == WEP)&&(AC_WLAN[WlanID]->SecurityType != IEEE8021X))
				{
					//fengwenchao change begin
					//
					/*for(i=0;i<WTP_WEP_NUM;i++)
					{
						if(AC_WTP[WtpID]->wep_flag[i] == 0)
						{
							AC_WTP[WtpID]->wep_flag[i] = (RadioID)*L_BSS_NUM+k1;
							AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->keyindex = i+1;
							break;
						}
						if(i == WTP_WEP_NUM-1)
						{
							wid_syslog_debug_debug(WID_DEFAULT,"radio apply wep wlan over 4\n");
							WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
							return WTP_WEP_NUM_OVER;
						}
					}*/
					//
					
					//
					for(i=0;i<WTP_WEP_NUM;i++)
					{
						if(AC_RADIO[RadioID]->wep_flag[i] == 0)
						{
							int k =0;
							for(k=0;k<i;k++)
							{
								if((AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k]->keyindex == AC_WLAN[WlanID]->SecurityIndex)&&(AC_WLAN[AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k]->WlanID]->EncryptionType == WEP))
								{
										WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
										return SECURITYINDEX_IS_SAME;
								}
							}
						}
						int j =0;
						j = AC_WLAN[WlanID]->SecurityIndex - 1;
						if(j<WTP_WEP_NUM)
						{
							if(AC_RADIO[RadioID]->wep_flag[j] == 0)
							{
								AC_RADIO[RadioID]->wep_flag[j] = (RadioID)*L_BSS_NUM+k1;
								AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->keyindex = AC_WLAN[WlanID]->SecurityIndex;															
								break;
							}
						}	
						else
						{
							wid_syslog_debug_debug(WID_DEFAULT,"radio apply wep wlan over 4\n");
							WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
							return WTP_WEP_NUM_OVER;
						}
						//if(AC_WTP[WtpID]-)
					}
					//
					//fengwenchao change end
				}
				if(AC_WLAN[WlanID]->wlan_if_policy == BSS_INTERFACE)
				{		
				
					ret = Create_BSS_L3_Interface(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex);
					
					if(ret < 0)
					{
						//WID_DELETE_WLAN_APPLY_WTP(WtpID, WlanID);
						WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
						return WLAN_CREATE_L3_INTERFACE_FAIL;
					}
	
				}
				else if(AC_WLAN[WlanID]->wlan_if_policy == WLAN_INTERFACE)
				{
					ret = Create_BSS_L3_Interface(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex);
					
					if(ret < 0)
					{
						//WID_DELETE_WLAN_APPLY_WTP(WtpID, WlanID);
						WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
						return WLAN_CREATE_L3_INTERFACE_FAIL;
					}

					ret = ADD_BSS_L3_Interface_BR(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[k1]->BSSIndex);
					if(ret < 0)
					{
						//WID_DELETE_WLAN_APPLY_WTP(WtpID, WlanID);
						WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
						return BSS_L3_INTERFACE_ADD_BR_FAIL;
					}
				}
				break;
			}
		}	

	
	if(k1 == L_BSS_NUM)
	{
		return WTP_OVER_MAX_BSS_NUM;
	}	
	if(AC_WLAN[WlanID]->Status == 1)
	{
		printf("wlan is disable,so just binging this wlan,not to send add wlan msg\n");
		return 0;
	}
	msgq msg;
	struct msgqlist *elem;
	//add to control list
	if((AC_WTP[WtpID] != NULL)&&(AC_WTP[WtpID]->WTPStat == WID_RUN))
	{
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WtpID%THREAD_NUM+1;
		msg.mqinfo.WTPID = WtpID;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WLAN_S_TYPE;
		msg.mqinfo.u.WlanInfo.Wlan_Op = WLAN_ADD;
		msg.mqinfo.u.WlanInfo.WLANID = WlanID;
		msg.mqinfo.u.WlanInfo.Radio_L_ID = localradio_id;

		msg.mqinfo.u.WlanInfo.HideESSid = AC_WLAN[WlanID]->HideESSid;
		memset(msg.mqinfo.u.WlanInfo.WlanKey,0,DEFAULT_LEN);
		memcpy(msg.mqinfo.u.WlanInfo.WlanKey,AC_WLAN[WlanID]->WlanKey,DEFAULT_LEN);
		msg.mqinfo.u.WlanInfo.KeyLen = AC_WLAN[WlanID]->KeyLen;
		msg.mqinfo.u.WlanInfo.wpa_group_rekey = AC_WLAN[WlanID]->wpa_group_rekey;
		msg.mqinfo.u.WlanInfo.SecurityType = AC_WLAN[WlanID]->SecurityType;
		msg.mqinfo.u.WlanInfo.SecurityIndex = AC_WLAN[WlanID]->SecurityIndex;
		msg.mqinfo.u.WlanInfo.asic_hex = AC_WLAN[WlanID]->asic_hex;/* 0 asic; 1 hex*/
		msg.mqinfo.u.WlanInfo.Roaming_Policy = AC_WLAN[WlanID]->Roaming_Policy;			/*Roaming (1 enable /0 disable)*/
		memset(msg.mqinfo.u.WlanInfo.WlanEssid,0,ESSID_LENGTH);
		memcpy(msg.mqinfo.u.WlanInfo.WlanEssid,AC_WLAN[WlanID]->ESSID,ESSID_LENGTH);
		msg.mqinfo.u.WlanInfo.bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id];
		
		if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
			wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
		}
	}
	else if((AC_WTP[WtpID] != NULL))
	{
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WtpID%THREAD_NUM+1;
		msg.mqinfo.WTPID = WtpID;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WLAN_S_TYPE;
		msg.mqinfo.u.WlanInfo.Wlan_Op = WLAN_ADD;
		msg.mqinfo.u.WlanInfo.WLANID = WlanID;
		msg.mqinfo.u.WlanInfo.Radio_L_ID = localradio_id;

		msg.mqinfo.u.WlanInfo.HideESSid = AC_WLAN[WlanID]->HideESSid;
		memset(msg.mqinfo.u.WlanInfo.WlanKey,0,DEFAULT_LEN);
		memcpy(msg.mqinfo.u.WlanInfo.WlanKey,AC_WLAN[WlanID]->WlanKey,DEFAULT_LEN);
		msg.mqinfo.u.WlanInfo.KeyLen = AC_WLAN[WlanID]->KeyLen;
		msg.mqinfo.u.WlanInfo.wpa_group_rekey = AC_WLAN[WlanID]->wpa_group_rekey;
		msg.mqinfo.u.WlanInfo.SecurityType = AC_WLAN[WlanID]->SecurityType;
		msg.mqinfo.u.WlanInfo.SecurityIndex = AC_WLAN[WlanID]->SecurityIndex;
		msg.mqinfo.u.WlanInfo.asic_hex = AC_WLAN[WlanID]->asic_hex;/* 0 asic; 1 hex*/
		msg.mqinfo.u.WlanInfo.Roaming_Policy = AC_WLAN[WlanID]->Roaming_Policy;			/*Roaming (1 enable /0 disable)*/
		memset(msg.mqinfo.u.WlanInfo.WlanEssid, 0, ESSID_LENGTH);
		memcpy(msg.mqinfo.u.WlanInfo.WlanEssid, AC_WLAN[WlanID]->ESSID, ESSID_LENGTH);
		msg.mqinfo.u.WlanInfo.bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id];
		
		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if (NULL == elem)
		{			
			WID_MALLOC_ERR();			
			return 0;
		}
		memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
		elem->next = NULL;
		memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
		WID_INSERT_CONTROL_LIST(WtpID, elem);		
	}	
	if(AC_WTP[WtpID]!=NULL){
		if((AC_WLAN[WlanID])&&(AC_WLAN[WlanID]->Status == 0))
			WLAN_FLOW_CHECK(WlanID);
	}
	int bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id];
	if((AC_BSS[bssindex])&&(AC_BSS[bssindex]->BSS_IF_POLICY != NO_INTERFACE)&&(AC_BSS[bssindex]->BSS_TUNNEL_POLICY != CW_802_DOT_11_TUNNEL)){
		msgq msg;
		struct msgqlist *elem;
		memset((char*)&msg, 0, sizeof(msg));
		wid_syslog_debug_debug(WID_DEFAULT,"*** %s,%d.**\n",__func__,__LINE__);
		msg.mqid = WtpID%THREAD_NUM+1;
		msg.mqinfo.WTPID = WtpID;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WLAN_S_TYPE;
		msg.mqinfo.u.WlanInfo.Wlan_Op = WLAN_CHANGE_TUNNEL;
		msg.mqinfo.u.WlanInfo.WLANID = WlanID;
		msg.mqinfo.u.WlanInfo.Radio_L_ID = localradio_id;
		
		msg.mqinfo.u.WlanInfo.bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[WtpID][localradio_id];
		
		if((AC_WTP[WtpID]->WTPStat == WID_RUN)){ 
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}
		else{
			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if(elem == NULL){
				wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
				perror("malloc");
				return 0;
			}
			memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
			elem->next = NULL;
			memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
			WID_INSERT_CONTROL_LIST(WtpID, elem);
		}
	}	
	
	if ((0 != AC_WLAN[WlanID]->aclgrp_id) && (NULL != STA_ACL_GROUP[AC_WLAN[WlanID]->aclgrp_id]))
	{
		aclgroupid = AC_WLAN[WlanID]->aclgrp_id;
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WtpID%THREAD_NUM+1;
		msg.mqinfo.WTPID = WtpID;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WTP_S_TYPE;
		msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_ACL_LIST;
		msg.mqinfo.u.WtpInfo.value[0] = WlanID;
		msg.mqinfo.u.WtpInfo.value[1] = localradio_id;
		msg.mqinfo.u.WtpInfo.value[2] = OVERWRITE;
		msg.mqinfo.u.WtpInfo.value[3] = LEVEL_WLAN;
		msg.mqinfo.u.WtpInfo.value[4] = AC_WLAN[WlanID]->aclgrp_id;
		/*
		msg.mqinfo.u.WtpInfo.value3 = STA_ACL_GROUP[aclgroupid]->rule_cnt;
		rulelist = STA_ACL_GROUP[aclgroupid]->rule_list;
		for (i = 0; i < STA_ACL_GROUP[aclgroupid]->rule_cnt; i++)
		{
			msg.mqinfo.u.WtpInfo.value[i] = rulelist->rule_id;
			rulelist = rulelist->next;
		}
		*/
		if(AC_WTP[WtpID]->WTPStat == WID_RUN)
		{ 
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}
		else
		{

			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if (NULL == elem)
			{			
				WID_MALLOC_ERR();			
				return 0;
			}			
			memset(elem, 0, sizeof(struct msgqlist));
			elem->mqinfo.WTPID = WtpID;
			elem->mqinfo.type = CONTROL_TYPE;
			elem->mqinfo.subtype = WTP_S_TYPE;
			elem->mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_ACL_LIST;
			elem->mqinfo.u.WtpInfo.value[0] = WlanID;
			elem->mqinfo.u.WtpInfo.value[1] = localradio_id;
			elem->mqinfo.u.WtpInfo.value[2] = OVERWRITE;
			elem->mqinfo.u.WtpInfo.value[3] = LEVEL_WLAN;
			elem->mqinfo.u.WtpInfo.value[4] = AC_WLAN[WlanID]->aclgrp_id;
			
			WID_INSERT_CONTROL_LIST(WtpID, elem);
		}
	}
	
	/* wlan tunnel switch func for REQUIREMENTS-264 */
	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);
	
	if((AC_WLAN[WlanID]!=NULL)&&(AC_WLAN[WlanID]->wlan_tunnel_switch == 1))
	{
		//sprintf(apcmd,"echo 3 > /proc/sys/net/ath.%d-%d/vap_splitmac",AC_RADIO[RadioID]->Radio_L_ID,WlanID);
		sprintf(apcmd,TUNNEL_SWITCH_CMD";"AP_OPEN_IPFORWARD";"AP_SPFAST_DOWM";"AP_SPFAST_UP,AC_RADIO[RadioID]->Radio_L_ID,WlanID);
		wid_radio_set_extension_command(WtpID,apcmd);
	}
	/* end */
	if((AC_RADIO[RadioID]->BSS[k1])&&(AC_RADIO[RadioID]->BSS[k1]->multi_user_optimize_switch == 1))
	{
		char wlanid =AC_RADIO[RadioID]->BSS[k1]->WlanID;
		int radioid = AC_RADIO[RadioID]->BSS[k1]->Radio_G_ID;
		muti_user_optimize_switch(wlanid,radioid,1);
		
	}
	if(0 != memcmp(QOS_AP_11E_TO_1P_DEFAULT, AC_WLAN[WlanID]->qos_ap_11e_to_1p, MAX_QOS_11E_VAL+1))
	{
		set_ap_bss_qos_map_default(WtpID, localradio_id, QOS_MAP_11E_TO_1P, WlanID);
	}
	if(0 != memcmp(QOS_AP_11E_TO_DSCP_DEFAULT, AC_WLAN[WlanID]->qos_ap_11e_to_dscp, MAX_QOS_11E_VAL+1))
	{
		set_ap_bss_qos_map_default(WtpID, localradio_id, QOS_MAP_11E_TO_DSCP, WlanID);
	}
	if(0 != memcmp(QOS_AP_DSCP_TO_11E_DEFAULT, AC_WLAN[WlanID]->qos_ap_dscp_to_11e, MAX_QOS_DSCP_VAL+1))
	{
		set_ap_bss_qos_map_default(WtpID, localradio_id, QOS_MAP_DSCP_TO_11E, WlanID);
	}
	if(0 != memcmp(QOS_AP_1P_TO_11E_DEFAULT, AC_WLAN[WlanID]->qos_ap_1p_to_11e, MAX_QOS_1P_VAL+1))
	{
		set_ap_bss_qos_map_default(WtpID, localradio_id, QOS_MAP_1P_TO_11E, WlanID);
	}
	if(0 != AC_WLAN[WlanID]->qos_ap_11e_to_1p_switch)
	{
		set_ap_bss_qos_map_switch(WtpID, localradio_id, WlanID, QOS_MAP_11E_TO_1P, AC_WLAN[WlanID]->qos_ap_11e_to_1p_switch);
	}
	if(0 != AC_WLAN[WlanID]->qos_ap_11e_to_dscp_switch)
	{
		set_ap_bss_qos_map_switch(WtpID, localradio_id, WlanID, QOS_MAP_11E_TO_DSCP, AC_WLAN[WlanID]->qos_ap_11e_to_dscp_switch);
	}
	if(check_bssid_func(bssindex) && (0 != AC_BSS[bssindex]->packet_power))
	{
		WID_RADIO_WLAN_PACKET_POWER(WtpID, localradio_id, WlanID, AC_BSS[bssindex]->packet_power);
	}
	if ((check_bssid_func(bssindex)) &&(0 != AC_WLAN[WlanID]->balance_switch))
	{											
		wid_bss_balance_switch(WtpID, localradio_id, WlanID);										
	}

	return 0;

}

int WID_ADD_WLAN_APPLY_RADIO_CLEAN_HOTSPOT_ID(unsigned int RadioID,unsigned char WlanID){
	wid_syslog_debug_debug(WID_DEFAULT,"*** in func %s**\n",__func__);

	int isfind = 0; 
	int i = 0;
	int WtpID = RadioID/L_RADIO_NUM;
	int localradio_id = RadioID%L_RADIO_NUM;
	if(AC_WTP[WtpID] == NULL)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"*** you binding wlan does not exist **\n");
		return WTP_ID_NOT_EXIST;
	}
	if(AC_WLAN[WlanID] == NULL)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"*** you binding wlan does not exist **\n");
		return WLAN_ID_NOT_EXIST;
	}
	
	for(i=0;i<L_BSS_NUM;i++)
	{
		if(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[i] != NULL)
		{
			if(AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[i]->WlanID == WlanID)
			{
				AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[i]->hotspot_id = AC_WLAN[WlanID]->hotspot_id;
				wid_syslog_debug_debug(WID_DEFAULT,"hotspot id is %d\n",AC_WTP[WtpID]->WTP_Radio[localradio_id]->BSS[i]->hotspot_id);
				isfind = 1;
				break;
			}
		}
	}
	if(isfind != 1)
	{
		return WTP_WLAN_BINDING_NOT_MATCH;
	}
	return 0;
}


int WID_BINDING_IF_APPLY_WTP(unsigned int WtpID, char *ifname)
{
    WID_CHECK_WTP_STANDARD_RET(WtpID,WTP_ID_NOT_EXIST);
    
	if(AC_WTP[WtpID]->isused == 1)
	{
	
		wid_syslog_err(WAI_FUNC_LINE_FMT""WAI_AFI_FMT"bind interface %s but in used state\n", \
				WAI_FUNC_LINE_LITERAL, WtpID,AC_WTP[WtpID]->WTPNAME, ifname);
		return WTP_BE_USING;
	}
	int sockfd = -1;
	int isystemindex = -1;
	//int sockdes = -1;
	//CWBool bretflag = CW_FALSE;
	struct ifreq	ifr;
	int ret = Check_And_Bind_Interface_For_WID(ifname);
	if(ret != 0)
	{
	    return ret;
    }
	if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
	{
		wid_syslog_err(WAI_FUNC_LINE_FMT""WAI_AFI_FMT"bind interface %s create socket error(%d) %s\n", \
				WAI_FUNC_LINE_LITERAL, WtpID, AC_WTP[WtpID]->WTPNAME,ifname, errno , strerror(errno));
		return INTERFACE_NOT_EXIST;
	}
	
	//we should check ifname error
	strncpy(ifr.ifr_name,ifname, sizeof(ifr.ifr_name));
	
	if (ioctl(sockfd, SIOCGIFINDEX, &ifr) == -1)    //Retrieve  the interface index
	{
		wid_syslog_err(WAI_FUNC_LINE_FMT""WAI_AFI_FMT"bind interface %s get gindex via socket%d error(%d) %s\n", \
				WAI_FUNC_LINE_LITERAL, WtpID,AC_WTP[WtpID]->WTPNAME, ifname, sockfd, errno , strerror(errno));
		close(sockfd);
		return INTERFACE_NOT_EXIST;
	}
	close(sockfd);
	isystemindex = ifr.ifr_ifindex;

	//bretflag = get_sock_descriper(isystemindex, &sockdes);
	//printf("*** binding iterface name isystemindex is %d socket is %d flag is %d ***\n",isystemindex,sockdes,bretflag);
	
	/*
	***** Input wtp id is 1
	***** Input wtp id binding interface name is eth1
	*** binding iterface name isystemindex is 3 ***
	*** binding iterface name isystemindex is 3 socket is -1 flag is 0 ***
	*** can't binding iterface name, please make sure input correct interface name ***
	*/
	

	//we should add a variables into WID_WTP struct
	//AC_WTP[WTPID]->sock = sockdes;

	//delete bingding wlan id 
	//if(AC_WTP[WtpID]->Wlan_Id != NULL)
	//{
		//return WID_BINDING_WLAN;
	//}
	
	AC_WTP[WtpID]->BindingSystemIndex = isystemindex;
	memset(AC_WTP[WtpID]->BindingIFName, 0, ETH_IF_NAME_LEN);
	memcpy(AC_WTP[WtpID]->BindingIFName,ifname, strlen(ifname));
	
	return 0;
}


int WID_BINDING_IF_APPLY_WTP_ipv6(unsigned int WtpID, char * ifname)
{
	
	if(AC_WTP[WtpID]->isused == 1)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"*** error this WTP is used and active, you can not binding interface ***\n");
		return WTP_BE_USING;
	}
//	int sockfd = -1;
	int isystemindex = 1;
	int ret;
	int i = 0;
	struct ifi * tmp;
	struct ifi * tmp2;
	struct ifi_info *ifi_tmp = (struct ifi_info*)calloc(1, sizeof(struct ifi_info));
	memset(ifi_tmp->ifi_name,0,sizeof(ifi_tmp->ifi_name));
	strncpy(ifi_tmp->ifi_name,ifname,sizeof(ifi_tmp->ifi_name));

	struct tag_ipv6_addr_list *ipv6list = (struct tag_ipv6_addr_list *)malloc(sizeof(struct tag_ipv6_addr_list));
	if(ipv6list == NULL)
	{
		free(ifi_tmp);
		ifi_tmp = NULL;
		return BINDING_IPV6_ADDRE_RROR;
	}
	ipv6list->ifindex = 0;
	ipv6list->ipv6list = NULL;
	ipv6list->ipv6num = 0;
	
	ret = get_if_addr_ipv6_list(ifname, ipv6list);
	if(ret != 0)
	{
		free(ifi_tmp);
		ifi_tmp = NULL;
		free_ipv6_addr_list(ipv6list);
		ret = BINDING_IPV6_ADDRE_RROR;
		return ret;
	}
	struct tag_ipv6_addr *ipv6addr = ipv6list->ipv6list;
		
	ifi_tmp->ifi_addr6 = (struct sockaddr*)calloc(1, sizeof(struct sockaddr_in6));
	isystemindex = ipv6list->ifindex;
	
	if(WID_IF_V6 == NULL)
	{
		for(i=0; i<ipv6list->ipv6num; i++)
		{
			inet_pton(AF_INET6, (char*)ipv6addr->ipv6addr, &(((struct sockaddr_in6*)ifi_tmp->ifi_addr6)->sin6_addr));
			ret = ipv6_bind_interface_for_wid(ifi_tmp,CW_CONTROL_PORT);
		//	ret = ipv6_bind_interface_for_wid(ifi_tmp,CW_CONTROL_PORT_AU);
			WIDWsm_VRRPIFOp_IPv6(ifi_tmp,VRRP_REG_IF);
			ipv6addr = ipv6addr->next;
		}	

		if(ret == 0)
		{
		   	tmp = (struct ifi*)malloc(sizeof(struct ifi));
			memset(tmp,0,sizeof(struct ifi));
			memcpy(tmp->ifi_name,ifname,strlen(ifname));
			tmp->ifi_index = isystemindex;
			WID_IF_V6 = tmp;
		}
		else
		{
			free(ifi_tmp->ifi_addr6);
			ifi_tmp->ifi_addr6 = NULL;
			free(ifi_tmp);
			ifi_tmp = NULL;
			free_ipv6_addr_list(ipv6list);
			return ret;
		}
		
	}
	else
	{
		tmp = WID_IF_V6;
		while(tmp != NULL)
		{
			printf("ifname = %s name = %s\n",tmp->ifi_name,ifname);
			if(( strlen(ifname) ==  strlen(tmp->ifi_name))&&(strcmp(tmp->ifi_name,ifname)==0))
			{	
				free(ifi_tmp->ifi_addr6);
				ifi_tmp->ifi_addr6 = NULL;
				free(ifi_tmp);
				ifi_tmp = NULL;
				free_ipv6_addr_list(ipv6list);

				if(AC_WTP[WtpID] != NULL)
				{
					
					AC_WTP[WtpID]->BindingSystemIndex= tmp->ifi_index;
					printf("AC_WTP[WtpID]->BindingSystemIndex = %d\n",AC_WTP[WtpID]->BindingSystemIndex);
					AC_WTP[WtpID]->isipv6addr = 1;
					memset(AC_WTP[WtpID]->BindingIFName, 0, ETH_IF_NAME_LEN);
					memcpy(AC_WTP[WtpID]->BindingIFName,ifname, strlen(ifname));
					
					wid_syslog_debug_debug(WID_DEFAULT,"*** binding iterface name to wtp success ***\n");
					return 0;
				}
				else
				{
					wid_syslog_debug_debug(WID_DEFAULT,"*** can't binding iterface name, please make sure you have create wtp ***\n");
					return WTP_ID_NOT_EXIST;
				}
				
				return 0;
			}
			tmp = tmp->ifi_next;
		}

		for(i=0; i<ipv6list->ipv6num; i++)
		{
			inet_pton(AF_INET6, (char*)ipv6addr->ipv6addr, &(((struct sockaddr_in6*)ifi_tmp->ifi_addr6)->sin6_addr));
			ret = ipv6_bind_interface_for_wid(ifi_tmp,CW_CONTROL_PORT);
			//ret = ipv6_bind_interface_for_wid(ifi_tmp,CW_CONTROL_PORT_AU);
			WIDWsm_VRRPIFOp_IPv6(ifi_tmp,VRRP_REG_IF);
			ipv6addr = ipv6addr->next;
		}	

		if(ret == 0)
		{
			tmp = (struct ifi*)malloc(sizeof(struct ifi));
			memset(tmp,0,sizeof(struct ifi));
			memcpy(tmp->ifi_name,ifname,strlen(ifname));
			tmp->ifi_index = isystemindex;
			tmp2 = WID_IF_V6;
			WID_IF_V6 = tmp;
			WID_IF_V6->ifi_next = tmp2;	
		}
		else
		{
			free(ifi_tmp->ifi_addr6);
			ifi_tmp->ifi_addr6 = NULL;
			free(ifi_tmp);
			ifi_tmp = NULL;
			free_ipv6_addr_list(ipv6list);
			return ret;
		}
	
	}	
		
	gInterfacesCount = CWNetworkCountInterfaceAddresses(&gACSocket);
	gInterfacesCountIpv4 = CWNetworkCountInterfaceAddressesIpv4(&gACSocket);
	gInterfacesCountIpv6 = CWNetworkCountInterfaceAddressesIpv6(&gACSocket);
	free(ifi_tmp->ifi_addr6);
	ifi_tmp->ifi_addr6 = NULL;
	free(ifi_tmp);
	ifi_tmp = NULL;
	free_ipv6_addr_list(ipv6list);

	if(ret != 0)
	return ret;

	
	if(AC_WTP[WtpID] != NULL)
	{
		
		AC_WTP[WtpID]->BindingSystemIndex= isystemindex;
		AC_WTP[WtpID]->isipv6addr = 1;
		memset(AC_WTP[WtpID]->BindingIFName, 0, ETH_IF_NAME_LEN);
		memcpy(AC_WTP[WtpID]->BindingIFName,ifname, strlen(ifname));
		
		wid_syslog_debug_debug(WID_DEFAULT,"*** binding iterface name to wtp success ***\n");
		return 0;
	}
	else
	{
		wid_syslog_debug_debug(WID_DEFAULT,"*** can't binding iterface name, please make sure you have create wtp ***\n");
		return WTP_ID_NOT_EXIST;
	}
		
}


//add wtp binding special wlan weiay 20080604
int WID_BINDING_WLAN_APPLY_WTP(unsigned int WtpID, unsigned char WlanId)
{
	int i = 0;
	int ret = 0;
	int fail_num = 0;
	int radioid = 0;
	
	WID_CHECK_WTP_STANDARD_RET(WtpID, WTP_ID_NOT_EXIST);
	WID_CHECK_WLAN_EXIST_RET(WlanId, WLAN_ID_NOT_EXIST);
	
	for (i = 0; i < AC_WTP[WtpID]->RadioCount; i++)
	{
		radioid = WtpID*L_RADIO_NUM+i;
		ret = WID_ADD_WLAN_APPLY_RADIO(radioid, WlanId, 0);
		if (ret != WID_DBUS_SUCCESS)
		{
			wid_syslog_info("%s: radio%d-%d apply wlan%d %s\n",__func__,WtpID,i,WlanId,wid_opcode2string(ret));
			fail_num++;
		}
	}
	if (fail_num == AC_WTP[WtpID]->RadioCount)
	{
		return WID_DBUS_ERROR;
	}
	
	struct wlanid *wlan_id = NULL;
	struct wlanid *wlan_id_next = NULL;
	wlan_id = (struct wlanid*)malloc(sizeof(struct wlanid));
	wlan_id->wlanid = WlanId;
	wlan_id->next = NULL;
	
	if (AC_WTP[WtpID]->Wlan_Id == NULL)
	{
		AC_WTP[WtpID]->Wlan_Id = wlan_id;
		AC_WTP[WtpID]->isBinddingWlan = 1;
		AC_WTP[WtpID]->BindingWlanCount++;
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d wtp%d binding first wlan%d\n",__func__,__LINE__,WtpID,WlanId);
	}
	else
	{
		wlan_id_next = AC_WTP[WtpID]->Wlan_Id;
		while (wlan_id_next != NULL)
		{
			if (wlan_id_next->wlanid == WlanId)
			{
				wid_syslog_warning("%s:%d you have binding wlan%d, do not binding this again",__func__,__LINE__,WlanId);
				CW_FREE_OBJECT(wlan_id);
				return 0;
			}
			wlan_id_next = wlan_id_next->next;
		}

		wlan_id_next = AC_WTP[WtpID]->Wlan_Id;
		while (wlan_id_next->next!= NULL)
		{	
			wlan_id_next = wlan_id_next->next;//insert element int tail
		}
		
		wlan_id_next->next = wlan_id;
		AC_WTP[WtpID]->BindingWlanCount++;
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d wtp%d binding more wlan%d\n",__func__,__LINE__,WtpID,WlanId);
	}
	
	if (AC_WLAN[WlanId]->Status == 0)
	{
		issued_wlan_enable(WtpID,0,WlanId,LEVEL_AP);
        
		WLAN_FLOW_CHECK(WlanId);
	}
	
	return 0;		
}

int CONFIG_WLAN_CHECK_APPLY_WTP(unsigned int WtpID, unsigned char WlanId)
{
	struct wlanid *wlan_id = NULL;
	
	WID_CHECK_WTP_STANDARD_RET(WtpID,WTP_ID_NOT_EXIST);
	
	wlan_id = AC_WTP[WtpID]->Wlan_Id;
	
	if (AC_WTP[WtpID]->isBinddingWlan == 0)
	{
		return WTP_IS_NOT_BINDING_WLAN_ID;
	}
	
	while (wlan_id != NULL)
	{
		if (wlan_id->wlanid == WlanId)
		{
			return 0;
		}
		wlan_id = wlan_id->next;
	}
	
	return WTP_IS_NOT_BINDING_WLAN_ID;
}


int WID_DELETE_WLAN_APPLY_WTP(unsigned int WtpID, unsigned char WlanId)
{
    int i = 0;
    int ret = 0;
	int radioid = 0;
	struct wlanid *wlan_id = NULL;
	struct wlanid *wlan_id_next = NULL;

	WID_CHECK_WLAN_EXIST_RET(WlanId,WLAN_ID_NOT_EXIST);
	WID_CHECK_WTP_STANDARD_RET(WtpID,WTP_ID_NOT_EXIST);
	
	for(i = 0; i < AC_WTP[WtpID]->RadioCount; i++)
	{
    	radioid = WtpID*L_RADIO_NUM+i;
        ret = WID_DELETE_WLAN_APPLY_RADIO(radioid, WlanId);
        if(ret == WID_DBUS_SUCCESS)
        {
             WID_ADD_WLAN_CPE_CHANNEL_APPLY_RADIO_CLEAN_VLANID(radioid,WlanId,0);   
        }
        else
        {
			wid_syslog_info("%s:%d radio%d-%d delete wlan%d %s\n",__func__,__LINE__,WtpID,i,WlanId,wid_opcode2string(ret));
            continue;
        }
	}
	
	if(AC_WTP[WtpID]->isBinddingWlan == 0)
	{
		return WTP_IS_NOT_BINDING_WLAN_ID;
	}
	
	wlan_id = AC_WTP[WtpID]->Wlan_Id;
	if(wlan_id->wlanid == WlanId)
	{
		AC_WTP[WtpID]->Wlan_Id = wlan_id->next;
		CW_FREE_OBJECT(wlan_id);
		AC_WTP[WtpID]->BindingWlanCount--;
		if(AC_WTP[WtpID]->Wlan_Id == NULL)
		{
			AC_WTP[WtpID]->isBinddingWlan = 0;
			AC_WTP[WtpID]->BindingWlanCount = 0;
		}
		return 0;
	}
	else
	{
		while(wlan_id->next != NULL)
		{	
			if(wlan_id->next->wlanid == WlanId)
			{
				wlan_id_next = wlan_id->next;
				wlan_id->next = wlan_id->next->next;
				CW_FREE_OBJECT(wlan_id_next);
				AC_WTP[WtpID]->BindingWlanCount--;
				return 0;
			}
			wlan_id = wlan_id->next;
		}
	}

	return WTP_IS_NOT_BINDING_WLAN_ID;
}

int WID_DISABLE_WLAN_APPLY_WTP(unsigned int WtpID, unsigned char WlanId)
{
	int ret = 0;
	int j = 0, k = 0;
	
	WID_CHECK_WLAN_EXIST_RET(WlanId,WLAN_ID_NOT_EXIST);
	
	ret = CONFIG_WLAN_CHECK_APPLY_WTP(WtpID,WlanId);
	if (0 != ret)
	{
		return ret;
	}
	
	for (j = 0; j < AC_WTP[WtpID]->RadioCount; j++)
	{
		for (k = 0; k < L_BSS_NUM; k++)
		{
			if (AC_WTP[WtpID]->WTP_Radio[j]->BSS[k] != NULL)
			{
				if (AC_WTP[WtpID]->WTP_Radio[j]->BSS[k]->WlanID == WlanId)
				{
					if (AC_WTP[WtpID]->WTP_Radio[j]->BSS[k]->State != 0)
					{
						ret += 1;
					}
				}
			}
		}
	}
	
	wid_syslog_info(WAI_FUNC_LINE_FMT"wtp%d radiocount %d, %d radio(s) state enable %s\n",
					WAI_FUNC_LINE_LITERAL, WtpID, AC_WTP[WtpID]->RadioCount, ret, (0 == ret) ? "return":"");
	if (ret == 0)
	{
		//return 0;
	}
	
	issued_wlan_disable(WtpID, 0, WlanId, LEVEL_AP);
	
	for (j = 0; j < AC_WTP[WtpID]->RadioCount; j++)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d radio%d-%d wlan%d bssindex %d need disable\n",
								__func__,__LINE__,WtpID,j,WlanId,AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][j]);
		
		if (AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][j] != 0)
		{
			unsigned int BSSIndex = AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][j];
			if (!check_bssid_func(BSSIndex))
			{
				wid_syslog_err("<error>%s bssindex %d\n",__func__,BSSIndex);
				continue;
			}
#if NOSOFTAC
			AsdWsm_BSSOp(BSSIndex, WID_DEL, 1);	
			wid_update_bss_to_wifi(BSSIndex, WtpID, 0);/*resolve send capwap message,before ath be created*/	
#endif
			asd_free_stas(BSSIndex);
			
			if ((AC_BSS[BSSIndex] != NULL)
				&& (AC_WTP[WtpID] != NULL)
				//&&(AC_WTP[WtpID]->CMD->radiowlanid[j][WlanId] == 2)
				&& (AC_BSS[BSSIndex]->WlanID == WlanId))
			{
				wid_syslog_debug_debug(WID_DEFAULT,"%s:%d AC_WTP[%d]->CMD->radiowlanid[%d][%d] = %d\n",
									__func__,__LINE__,WtpID,j,WlanId,AC_WTP[WtpID]->CMD->radiowlanid[j][WlanId]);
				
				if (gtrapflag >= 4)
				{
#if NOSOFTAC
					int type = 1;//manual
					int flag = 0;//disable
					wid_dbus_trap_ap_ath_error(WtpID,j,WlanId,type,flag);
#endif
				}
				
				AC_BSS[BSSIndex]->downcount++;
				
				AC_WTP[WtpID]->CMD->wlanCMD -= 1;
				AC_WTP[WtpID]->CMD->radiowlanid[j][WlanId] = 0;
				if (AC_BSS[BSSIndex] != NULL)
				{
					AC_BSS[BSSIndex]->State = 0;
					if (AC_BSS[BSSIndex]->BSSID != NULL)
					{
						memset(AC_BSS[BSSIndex]->BSSID, 0, MAC_LEN);
					}
					if (AC_BSS[BSSIndex]->BSS_TUNNEL_POLICY == CW_802_IPIP_TUNNEL)
					{
						delete_ipip_tunnel(BSSIndex);
					}
				}
			}
			else if ((AC_BSS[BSSIndex] == NULL) || (AC_WTP[WtpID] == NULL))
			{
				AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][j] = 0;
			}
			else if ((AC_WTP[WtpID] != NULL)&&(AC_WTP[WtpID]->CMD->radiowlanid[j][WlanId] == 1))
			{
				AC_WTP[WtpID]->CMD->wlanCMD -= 1;
				AC_WTP[WtpID]->CMD->radiowlanid[j][WlanId] = 0;
			}
		}
	}
	
	return 0;
}


int WID_ENABLE_WLAN_APPLY_WTP(unsigned int WtpID, unsigned char WlanId)
{
	struct msgqlist *elem2 = NULL;
	WTPQUITREASON quitreason = WTP_INIT;
	int j = 0, k = 0;
	int ret = 0, ret2 = 0;
	int ifind = 0;
	msgq msg;	
	char buf[DEFAULT_LEN] = {0};
	char ifiname[ETH_IF_NAME_LEN-1] = {0};
	struct wds_bssid *wds = NULL;
	
	WID_CHECK_WLAN_EXIST_RET(WlanId,WLAN_ID_NOT_EXIST);
	
	if(AC_WTP[WtpID]->WTPStat != WID_RUN)
	{
		return WTP_NOT_IN_RUN_STATE;
	}

	if(AC_WLAN[WlanId]->Status == 1)
	{
		return WLAN_BE_DISABLE;
	}
	
	//ret1 = WID_WTP_TUNNEL_MODE_CHECK(WtpID);
	//if(ret1 > 0)
	//	return IF_POLICY_CONFLICT;

	ret = CONFIG_WLAN_CHECK_APPLY_WTP(WtpID,WlanId);
	if(0 != ret)
	{
		return ret;
	}
	
	ifind = 1;
	for(j = 0; j < AC_WTP[WtpID]->RadioCount; j++)
	{
		for(k = 0; k < L_BSS_NUM; k++)
		{
			if(AC_WTP[WtpID]->WTP_Radio[j]->BSS[k] != NULL)
			{
				if(AC_WTP[WtpID]->WTP_Radio[j]->BSS[k]->WlanID == WlanId)
				{
					if(AC_WTP[WtpID]->WTP_Radio[j]->BSS[k]->State != 1)
					{
						ret2 += 1;
					}
				}
			}
		}
	}
	if(ret2 == 0)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d wtp%d wlan%d all bss enable\n",__func__,__LINE__,WtpID,WlanId);
		return 0;
	}
	
	issued_wlan_enable(WtpID,0,WlanId,LEVEL_AP);
	
	for(j = 0; j < AC_WTP[WtpID]->RadioCount; j++)
	{
		int bssindex = AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][j];
		if((bssindex == 0) || (!check_bssid_func(bssindex)))
		{
			wid_syslog_err("<error>%s:%d wtp%d radio%d wlan%d bssindex %d\n",__func__,__LINE__,WtpID,j,WlanId,bssindex);
			continue;
		}
		
		if(AC_BSS[bssindex]->State == 1)
			//continue;
		//if(((AC_BSS[bssindex]->BSS_IF_POLICY != NO_INTERFACE)&&(AC_WTP[WtpID]->tunnel_mode == CW_LOCAL_BRIDGING))||((AC_BSS[bssindex]->BSS_IF_POLICY == NO_INTERFACE)&&(AC_WTP[WtpID]->tunnel_mode != CW_LOCAL_BRIDGING)))
		//	return IF_POLICY_CONFLICT;
		if(AC_BSS[bssindex]->BSS_IF_POLICY == BSS_INTERFACE)
		{
			memset(ifiname,0,ETH_IF_NAME_LEN-1);
			//snprintf(ifiname,ETH_IF_NAME_LEN,"BSS%d",AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][j]);
			if(local)
            {      
				snprintf(ifiname,ETH_IF_NAME_LEN - 1,"r%d-%d-%d.%d",vrrid,WtpID,j,WlanId);
			}
			else
			{
				snprintf(ifiname,ETH_IF_NAME_LEN - 1,"r%d-%d-%d-%d.%d",slotid,vrrid,WtpID,j,WlanId);
			}
			ret = Check_Interface_Config(ifiname,&quitreason);
			
			if(ret != 0)
			{
				wid_syslog_err("<error>%s:%d check interface %s ret=%d.\n",__func__,__LINE__,ifiname,ret);
				continue;
			}
		}
		if(0 == ifind)
		{
			issued_wlan_enable(WtpID, j, WlanId, LEVEL_RADIO);
		}
		
		wid_syslog_debug_debug(WID_DEFAULT,"!@#$ AC_BSS[%d]->traffic_limit_able = %d\n",
											bssindex,AC_BSS[bssindex]->traffic_limit_able);
		if(AC_BSS[bssindex]->traffic_limit_able == 1)
		{
			WID_Save_Traffic_Limit(bssindex, WtpID);
		}
		
		if((AC_BSS[bssindex])&&(AC_BSS[bssindex]->multi_user_optimize_switch == 1))
		{
			char wlanid =AC_BSS[bssindex]->WlanID;
			int radioid = AC_BSS[bssindex]->Radio_G_ID;
			muti_user_optimize_switch(wlanid,radioid,1);
		}
		if ((check_bssid_func(bssindex)) &&(0 != AC_WLAN[WlanId]->balance_switch))
		{
			wid_bss_balance_switch(WtpID, j, WlanId);
		}
		
		if(AC_BSS[(AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][j])]->WDSStat == WDS_ANY)
		{
			msg.mqid = WtpID%THREAD_NUM +1;
			msg.mqinfo.WTPID = WtpID;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WDS_S_TYPE;
			msg.mqinfo.u.WlanInfo.Wlan_Op = WLAN_WDS_ENABLE;
			msg.mqinfo.u.WlanInfo.WLANID = WlanId;
			msg.mqinfo.u.WlanInfo.Radio_L_ID = j;
			
			elem2 = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if(elem2 == NULL)
			{
				wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
				perror("malloc");
				return 0;
			}
			memset((char*)&(elem2->mqinfo), 0, sizeof(msgqdetail));
			elem2->next = NULL;
			memcpy((char*)&(elem2->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
			WID_INSERT_CONTROL_LIST(WtpID, elem2);
		}
		//wds state end
		else
		{
			if(AC_BSS[bssindex]->WDSStat == WDS_SOME)
			{
				wds = AC_BSS[bssindex]->wds_bss_list;
				while(wds != NULL)
				{
					memset(buf,0,DEFAULT_LEN);
					sprintf(buf,"/usr/sbin/wds_add ath.%d-%d %02X:%02X:%02X:%02X:%02X:%02X\n",
								AC_BSS[bssindex]->Radio_L_ID,WlanId,MAC2STR(wds->BSSID));
					
					wid_radio_set_extension_command(WtpID,buf);
					wds = wds->next;
				}
			}
		}
		if(gtrapflag >= 4)
		{
#if NOSOFTAC
			int type = 1;//manual
			int flag = 1;//enable
			
			wid_dbus_trap_ap_ath_error(WtpID,j,WlanId,type,flag);
#endif
		}
	}
	
	return 0;
}



/*fengwenchao add 20120509 for onlinebug-271*/
int DELETE_WLAN_CHECK_APPLY_RADIO(unsigned int RadioId, unsigned char WlanId)
{
	int ebr_id = 0;
	int WtpID = RadioId/L_RADIO_NUM;
	int local_radioid = RadioId%L_RADIO_NUM;
	struct wlanid *wlan_id = NULL;

	if(AC_WLAN[WlanId] == NULL)
	{
		wid_syslog_warning("%s wlan%d does not exist **\n",__func__,WlanId);
		return WLAN_ID_NOT_EXIST;
	}
	
	wlan_id = AC_RADIO[RadioId]->Wlan_Id;	

	while(wlan_id != NULL)
	{
		if(wlan_id->wlanid == WlanId)
		{
			if(check_whether_in_ebr(vrrid,WtpID,local_radioid,wlan_id->wlanid,&ebr_id))
			{
				wid_syslog_warning("<error> %s check interface in ebr \n",__func__);
				return RADIO_IN_EBR;
			}
            return 0;
		}
		wlan_id = wlan_id->next;	
	}	
	return RADIO_NO_BINDING_WLAN;
}
/*fengwenchao add end*/

int WID_DELETE_WLAN_APPLY_RADIO(unsigned int RadioId, unsigned char WlanId)
{
	int ret = 0;
	int ebr_id = 0;
	int WtpID = RadioId/L_RADIO_NUM;
	int local_radioid = RadioId%L_RADIO_NUM;
	struct wlanid *wlan_id = NULL;
	struct wlanid *wlan_id_next = NULL;
	
	WID_CHECK_WLAN_EXIST_RET(WlanId,WLAN_ID_NOT_EXIST);
	
	if(check_whether_in_ebr(vrrid,WtpID,local_radioid,WlanId,&ebr_id))
	{
		wid_syslog_debug_debug(WID_DEFAULT,"<error> %s check interface in ebr \n",__func__);
		return RADIO_IN_EBR;
	}	
    
	wlan_id = AC_RADIO[RadioId]->Wlan_Id;
	while(wlan_id != NULL)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d, vrrid = %d radio%d-%d wlan_id->wlanid = %d\n",
		                       __func__,__LINE__,vrrid,WtpID,local_radioid,wlan_id->wlanid);

		wlan_id = wlan_id->next;
	}
	
	if(AC_RADIO[RadioId]->isBinddingWlan == 0)
	{
		return RADIO_NO_BINDING_WLAN;
	}
	
	wlan_id_next = AC_RADIO[RadioId]->Wlan_Id;
	if(wlan_id_next->wlanid == WlanId)
	{
        int BSSIndex = AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][local_radioid];           
		if((BSSIndex != 0) && (AC_BSS[BSSIndex] != NULL))
		{			
			if((AC_BSS[BSSIndex] != NULL)&&(AC_BSS[BSSIndex]->State == 1))
			{
				wid_syslog_info("%s:%d radio%d-%d wlan%d bss[%d] enable\n",__func__,__LINE__,WtpID,local_radioid,WlanId,BSSIndex);
				return BSS_BE_ENABLE;
			}
		}
		ret = delete_wlan_bss_by_radioId(RadioId,WlanId);
		if(ret == -1)
		{
			wid_syslog_info("%s:%d radio%d-%d wlan%d bss enable\n",__func__,__LINE__,WtpID,local_radioid,WlanId);
			return BSS_BE_ENABLE;
		}
		else if(ret == BSS_NOT_EXIST)  //fengwenchao add 20120131 for TESTBED-17
		{
			return BSS_NOT_EXIST;
		}
		AC_RADIO[RadioId]->Wlan_Id = wlan_id_next->next;
		CW_FREE_OBJECT(wlan_id_next);
		AC_RADIO[RadioId]->BindingWlanCount--;
		if(AC_RADIO[RadioId]->Wlan_Id == NULL)
		{
			AC_RADIO[RadioId]->isBinddingWlan = 0;
			AC_RADIO[RadioId]->BindingWlanCount = 0;
		}
		return 0;
	}
	else
	{
		while(wlan_id_next->next != NULL)
		{	
			if(wlan_id_next->next->wlanid == WlanId)
			{
				ret = delete_wlan_bss_by_radioId(RadioId,WlanId);
				if(ret == -1)
				{
					wid_syslog_info("%s:%d radio%d-%d wlan%d bss enable\n",__func__,__LINE__,WtpID,local_radioid,WlanId);
					return BSS_BE_ENABLE;
				}
				else if(ret == BSS_NOT_EXIST)  //fengwenchao add 20120131 for TESTBED-17
				{
					return BSS_NOT_EXIST;
				}				
				wlan_id = wlan_id_next->next;
				wlan_id_next->next = wlan_id_next->next->next;
				CW_FREE_OBJECT(wlan_id);
				AC_RADIO[RadioId]->BindingWlanCount--;
				return 0;
			}
			wlan_id_next = wlan_id_next->next;
		}
	}

	return INTERFACE_NOT_BE_BINDED;
}


int WID_DISABLE_WLAN_APPLY_RADIO(unsigned int RadioId, unsigned char WlanId)
{
	int j = 0;
	int ret = 0;
	int ifind = 0;
	int WtpID = RadioId/L_RADIO_NUM;
	int local_radioid = RadioId%L_RADIO_NUM;
	struct wlanid *wlan_id_next = NULL;
	
	if (gtrapflag >= 4)
	{
#if NOSOFTAC
		wid_dbus_trap_wtp_wireless_interface_down(WtpID);
#endif
	}
	if (AC_WLAN[WlanId] == NULL)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"%s wlan%d not exist\n",__func__,WlanId);
		return WLAN_ID_NOT_EXIST;
	}
	
	if (AC_RADIO[RadioId]->isBinddingWlan == 0)
	{
		return INTERFACE_NOT_BE_BINDED;
	}
	
	wlan_id_next = AC_RADIO[RadioId]->Wlan_Id;
	if (wlan_id_next->wlanid == WlanId)
	{
		ifind = 1;

		for (j = 0; j < L_BSS_NUM; j++)
		{
			if (AC_RADIO[RadioId]->BSS[j] != NULL)
			{
				if (AC_RADIO[RadioId]->BSS[j]->WlanID == WlanId)
				{
					if (AC_RADIO[RadioId]->BSS[j]->State != 0)
					{
						ret = 1;
					}
					break;
				}
			}
		}
		
		if (ret == 0)
		{
			return 0;
		}
	}
	else
	{
		while (wlan_id_next->next != NULL)
		{
			if (wlan_id_next->next->wlanid == WlanId)
			{
				ifind = 1;
				ret = 0;
				
				for (j = 0; j < L_BSS_NUM; j++)
				{
					if (AC_RADIO[RadioId]->BSS[j] != NULL)
					{
						if (AC_RADIO[RadioId]->BSS[j]->WlanID == WlanId)
						{
							if (AC_RADIO[RadioId]->BSS[j]->State != 0)
							{
								ret = 1;
							}
							break;
						}
					}
				}
				
				if (ret == 0)
				{
					return 0;
				}
			}
			wlan_id_next = wlan_id_next->next;
		}
	}

	if (gtrapflag >= 4)
	{
#if NOSOFTAC
		wid_dbus_trap_wtp_wireless_interface_down(WtpID);
#endif
	}
	if (ifind == 0)
	{
		return WTP_WLAN_BINDING_NOT_MATCH;
	}
	
	int bssindex = AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][local_radioid];
	if ((bssindex != 0) && (check_bssid_func(bssindex)) && (AC_BSS[bssindex] != NULL))
	{
		if (!check_bssid_func(bssindex))
		{
			wid_syslog_err("<error>%s bssindex %d\n",__func__,bssindex);
			return BSS_NOT_EXIST;
		}
		if ((AC_BSS[bssindex] != NULL) && (AC_BSS[bssindex]->State == 0))
		{
			return 0;
		}
		if ((AC_BSS[bssindex] != NULL)
			&& (AC_BSS[bssindex]->WlanID == WlanId)
			&& (AC_WTP[WtpID] != NULL)
			&& (AC_WTP[WtpID]->CMD->radiowlanid[local_radioid][WlanId] == 2))
		{
	#if NOSOFTAC
			AsdWsm_BSSOp(bssindex, WID_DEL, 1);	
			wid_update_bss_to_wifi(bssindex, WtpID, 0);/*resolve send capwap message,before ath be created*/	
	#endif
	
            issued_wlan_disable(WtpID,local_radioid,WlanId,LEVEL_RADIO);
			asd_free_stas(bssindex);
			
			if (gtrapflag >= 4)
			{
#if NOSOFTAC
				wid_dbus_trap_wtp_wireless_interface_down(WtpID);
#endif
			}

			if (gtrapflag >= 4)
			{
#if NOSOFTAC
				int type = 1;//manual
				int flag = 0;//disable
				
				wid_dbus_trap_ap_ath_error(WtpID,local_radioid,WlanId,type,flag);
#endif
			}

			/*fengwenchao add 20121213 for onlinebug-767*/
			AC_WTP[WtpID]->CMD->wlanCMD -= 1;
			AC_WTP[WtpID]->CMD->radiowlanid[local_radioid][WlanId] = 0;
			if (AC_BSS[bssindex] != NULL)
			{
				AC_BSS[bssindex]->State = 0;
				if (AC_BSS[bssindex]->BSSID != NULL)
				{
					memset(AC_BSS[bssindex]->BSSID, 0, MAC_LEN);
				}
				if (AC_BSS[bssindex]->BSS_TUNNEL_POLICY == CW_802_IPIP_TUNNEL)
				{
					delete_ipip_tunnel(bssindex);
				}
			}
			/*fengwenchao add end*/	
		}
		else if ((AC_BSS[bssindex] == NULL) || (AC_WTP[WtpID] == NULL))
		{
			AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][local_radioid] = 0;
		}
		else if ((AC_WTP[WtpID] != NULL) && (AC_WTP[WtpID]->CMD->radiowlanid[local_radioid][WlanId] == 1))
		{
			AC_WTP[WtpID]->CMD->wlanCMD -= 1;
			AC_WTP[WtpID]->CMD->radiowlanid[local_radioid][WlanId] = 0;
		}
	}
	
	if ((check_bssid_func(bssindex)) && (AC_BSS[bssindex] != NULL))
	{
		AC_BSS[bssindex]->downcount++;
	}
	
	return 0;
}


int WID_ENABLE_WLAN_APPLY_RADIO(unsigned int RadioId, unsigned char WlanId)
{
	msgq msg, msg2, msg4 ;
	WTPQUITREASON quitreason = WTP_INIT;
	unsigned char pcy = 0;
	unsigned char IGNORE_UBSV aclgroupid = 0;
	int ret = 0, ret2 = 0;
	int j = 0, ifind = 0;
	int WtpID = RadioId/L_RADIO_NUM;
	int local_radioid = RadioId%L_RADIO_NUM;
	unsigned int bssindex = 0;
	char buf[DEFAULT_LEN] = {0};
	char ifiname[ETH_IF_NAME_LEN-1] = {0};
	char *command = NULL;
	char *ath_str = NULL;
	WID_BSS *BSS = NULL;
	struct msgqlist *elem4 = NULL; 
	struct msgqlist *elem2 = NULL;
	struct wds_bssid *wds = NULL;
	struct wlanid *wlan_id_next = NULL;
	memset(&msg, 0, sizeof(msgq));
	memset(&msg2, 0, sizeof(msgq));
	memset(&msg4, 0, sizeof(msgq));
	
	if (gtrapflag >= 4)
	{
#if NOSOFTAC
		wid_dbus_trap_wtp_wireless_interface_down_clear(WtpID);
#endif
	}
	if (AC_WTP[WtpID]->WTPStat != WID_RUN)
	{
		return WTP_NOT_IN_RUN_STATE;
	}

	if (AC_WLAN[WlanId]->Status == 1)
	{
		return WLAN_BE_DISABLE;
	}
	
	if (AC_RADIO[RadioId]->isBinddingWlan == 0)
	{
		return INTERFACE_NOT_BE_BINDED;
	}
	
	wlan_id_next = AC_RADIO[RadioId]->Wlan_Id;
	if (wlan_id_next->wlanid == WlanId)
	{
		ifind = 1;

		for (j = 0; j < L_BSS_NUM; j++)
		{
			if (AC_RADIO[RadioId]->BSS[j] != NULL)
			{
				if (AC_RADIO[RadioId]->BSS[j]->WlanID == WlanId)
				{
					if (AC_RADIO[RadioId]->BSS[j]->State != 1)
					{
						ret2 = 1;
					}
					BSS = AC_RADIO[RadioId]->BSS[j]; 
				}
			}
		}
	
		if (ret2 == 0)
		{
			return VALUE_IS_NONEED_TO_CHANGE;
		}
	}
	else
	{
		while (wlan_id_next->next != NULL)
		{	
			if (wlan_id_next->next->wlanid == WlanId)
			{
				ifind = 1;
				ret2 = 0;
				
				for (j = 0; j < L_BSS_NUM; j++)
				{
					if(AC_RADIO[RadioId]->BSS[j] != NULL)
					{
						if (AC_RADIO[RadioId]->BSS[j]->WlanID == WlanId)
						{
							if (AC_RADIO[RadioId]->BSS[j]->State != 1)
							{
								ret2 = 1;
							}
							BSS = AC_RADIO[RadioId]->BSS[j];
						}
					}
				}
				
				if (ret2 == 0)
				{
					return VALUE_IS_NONEED_TO_CHANGE;
				}
			}
			wlan_id_next = wlan_id_next->next;
		}
	}

	if (ifind == 0)
	{
		return WTP_IS_NOT_BINDING_WLAN_ID;
	}
	
	ifind = 0;
	int if_index = 0;
	if_index = AC_WTP[WtpID]->BindingSystemIndex; 
	struct ifi *wlan_interface = NULL;
	wlan_interface = AC_WLAN[WlanId]->Wlan_Ifi;
	while (wlan_interface != NULL)
	{
		if (wlan_interface->ifi_index == if_index)
		{
			ifind = 1;
			break;
		}
		wlan_interface = wlan_interface->ifi_next;
	}
	if (ifind == 0)
	{
		wid_syslog_warning("<warning>%s:%d afi%d with wlan%d bindings do not match.\n",__func__,__LINE__,WtpID,WlanId);
		//return WTP_WLAN_BINDING_NOT_MATCH;		
	}
	
	bssindex = AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][local_radioid];
	if ((bssindex != 0) && (check_bssid_func(bssindex)) && (AC_BSS[bssindex] != NULL))
	{		
		if ((check_bssid_func(bssindex)) && (AC_BSS[bssindex]->State == 1))
		{
			return VALUE_IS_NONEED_TO_CHANGE;
		}

		if ((check_bssid_func(bssindex)) && (AC_BSS[bssindex]->BSS_IF_POLICY == BSS_INTERFACE))
		{
			memset(ifiname, 0, ETH_IF_NAME_LEN-1);
			if (local)
            {   
				snprintf(ifiname, ETH_IF_NAME_LEN - 1, "r%d-%d-%d.%d", vrrid, WtpID, local_radioid, WlanId);
            }
			else
			{
				snprintf(ifiname, ETH_IF_NAME_LEN - 1, "r%d-%d-%d-%d.%d", slotid, vrrid, WtpID, local_radioid, WlanId);
            }
			ret = Check_Interface_Config(ifiname,&quitreason);
			
			if (ret != 0)
			{
				return L3_INTERFACE_ERROR;
			}
		}
#if 0
		if(AC_WLAN[WlanId]->EncryptionType == WEP)
		{
			if(AC_BSS[bssindex]->keyindex == 0)//means should be wep bss but not now
			{
				int i = 0;
				int result = 0;
				for(i=0;i<WTP_WEP_NUM;i++)
				{
					if(AC_WTP[WtpID]->wep_flag[i] == bssindex)
					{
						result = 1;// bssindex is in the wep flag
						break;
					}
				}

				if(result == 0)// bssindex is not in the wep flag
				{
					for(i=0;i<WTP_WEP_NUM;i++)
					{
						if(AC_WTP[WtpID]->wep_flag[i] == 0)
						{
							AC_WTP[WtpID]->wep_flag[i] = bssindex;
							AC_BSS[bssindex]->keyindex = i+1;
							result = 1;//put bssindex in the wep flag
							break;
						}
					}

					if(result == 0)//no room to put the wep wlan 
					{
						return WTP_WEP_NUM_OVER;
					}
				}
			}
			else
			{
				
			}
		}
#endif
		AC_WTP[WtpID]->CMD->wlanCMD += 1;
		AC_WTP[WtpID]->CMD->radiowlanid[local_radioid][WlanId] = 1;
	}
		
    issued_wlan_enable(WtpID,local_radioid,WlanId,LEVEL_RADIO);
	
	//wds state
	if ((check_bssid_func(bssindex)) && (AC_BSS[bssindex]->WDSStat == WDS_ANY))
	{
		msg2.mqid = WtpID%THREAD_NUM +1;
		msg2.mqinfo.WTPID = WtpID;;
		msg2.mqinfo.type = CONTROL_TYPE;
		msg2.mqinfo.subtype = WDS_S_TYPE;
		msg2.mqinfo.u.WlanInfo.Wlan_Op = WLAN_WDS_ENABLE;
		msg2.mqinfo.u.WlanInfo.WLANID = WlanId;
		msg2.mqinfo.u.WlanInfo.Radio_L_ID = local_radioid;
		
		elem2 = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if (elem2 == NULL)
		{
			wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
			return 0;
		}
		memset((char*)&(elem2->mqinfo), 0, sizeof(msgqdetail));
		elem2->next = NULL;
		memcpy((char*)&(elem2->mqinfo),(char*)&(msg2.mqinfo),sizeof(msg2.mqinfo));
		WID_INSERT_CONTROL_LIST(WtpID, elem2);
	}	
	//wds state end
	else
	{
		if (BSS->WDSStat == WDS_SOME)
		{
			wds = BSS->wds_bss_list;
			while (wds != NULL)
			{
				memset(buf, 0, DEFAULT_LEN);
				sprintf(buf,"/usr/sbin/wds_add ath.%d-%d %02X:%02X:%02X:%02X:%02X:%02X\n",
						BSS->Radio_L_ID,WlanId,MAC2STR(wds->BSSID));
				wid_radio_set_extension_command(WtpID,buf);
				wds = wds->next;
			}
		}
	}
	if ((AC_WLAN[WlanId]->SecurityType == IEEE8021X)
		||(AC_WLAN[WlanId]->SecurityType == WPA_E)
		||(AC_WLAN[WlanId]->SecurityType == WPA2_E)
		||(AC_WLAN[WlanId]->SecurityType == MD5))
	{
		msgq msg3;
		struct msgqlist *elem3 = NULL;
		memset(&msg3, 0, sizeof(msgq));
		msg3.mqid = WtpID%THREAD_NUM +1;
		msg3.mqinfo.WTPID = WtpID;
		msg3.mqinfo.type = CONTROL_TYPE;
		msg3.mqinfo.subtype = WTP_S_TYPE;
		msg3.mqinfo.u.WtpInfo.Wtp_Op = WTP_FLOW_CHECK;
		msg3.mqinfo.u.WlanInfo.WLANID = WlanId;
		msg3.mqinfo.u.WlanInfo.Radio_L_ID = local_radioid;
		msg3.mqinfo.u.WlanInfo.flow_check = AC_WLAN[WlanId]->flow_check;
		msg3.mqinfo.u.WlanInfo.no_flow_time = AC_WLAN[WlanId]->no_flow_time;
		msg3.mqinfo.u.WlanInfo.limit_flow = AC_WLAN[WlanId]->limit_flow;
		if (AC_WTP[WtpID]->WTPStat == WID_RUN)
		{	
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg3, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
				perror("msgsnd");
			}
		}
		else
		{
			elem3 = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if (elem3 == NULL)
			{			
				wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
				return 0;
			}
			
			memset((char*)&(elem3->mqinfo), 0, sizeof(msgqdetail));
			elem3->next = NULL;
			memcpy((char*)&(elem3->mqinfo),(char*)&(msg3.mqinfo),sizeof(msg3.mqinfo));
			WID_INSERT_CONTROL_LIST(WtpID, elem3);
		}
	}
	
	if (AC_WLAN[WlanId]->Status == 0)
	{
		command = (char *)malloc(sizeof(char)*100);
		if (NULL == command)
		{							
			wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
			return 0;
		}
		ath_str = (char *)malloc(sizeof(char)*20);
		if (NULL == ath_str)
		{
			wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
            CW_FREE_OBJECT(command);
			return 0;
		}
		memset(command, 0, 100);
		memset(ath_str, 0, 20);
		memset(&msg4, 0, sizeof(msg4));
		msg4.mqid = WtpID%THREAD_NUM +1;
		msg4.mqinfo.WTPID = WtpID;
		msg4.mqinfo.type = CONTROL_TYPE;
		msg4.mqinfo.subtype = WTP_S_TYPE;
		msg4.mqinfo.u.WtpInfo.Wtp_Op = WTP_EXTEND_CMD;
			
		sprintf(ath_str,"ath.%d-%d",local_radioid,WlanId);
		sprintf(command,"ifconfig %s down;iwpriv %s inact %u;ifconfig %s up",
						ath_str,ath_str,AC_WLAN[WlanId]->ap_max_inactivity,ath_str);
		memcpy(msg4.mqinfo.u.WtpInfo.value, command, strlen(command));
		if (AC_WTP[WtpID]->WTPStat == WID_RUN)
		{	
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg4, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}
		else
		{
			elem4 = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if (elem4 == NULL)
			{		
				wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
                CW_FREE_OBJECT(command);
                CW_FREE_OBJECT(ath_str);
				return 0;
			}
				
			memset((char*)&(elem4->mqinfo), 0, sizeof(msgqdetail));
			elem4->next = NULL;
			memcpy((char*)&(elem4->mqinfo),(char*)&(msg4.mqinfo),sizeof(msg4.mqinfo));
			WID_INSERT_CONTROL_LIST(WtpID, elem4);
		}
		CW_FREE_OBJECT(command);
		CW_FREE_OBJECT(ath_str);
	}
	
#if NOSOFTAC
	int type = 1;//manual
	int flag = 1;//enable

	if (gtrapflag >= 4)
	{
		wid_dbus_trap_wtp_wireless_interface_down_clear(WtpID);
		
		wid_dbus_trap_ap_ath_error(WtpID,local_radioid,WlanId,type,flag);
	}
#endif
	if ((check_bssid_func(bssindex)) && (AC_BSS[bssindex] != NULL))
	{
		AC_BSS[bssindex]->upcount++;

		wid_syslog_debug_debug(WID_DEFAULT,"!@#$ AC_BSS[%d]->traffic_limit_able = %d\n",
											bssindex,AC_BSS[bssindex]->traffic_limit_able);
		if (AC_BSS[bssindex]->traffic_limit_able == 1)
		{
		    WID_Save_Traffic_Limit(bssindex, WtpID);
		}
	}
	//AC_RADIO[RadioId]->upcount++;
	if ((AC_BSS[bssindex]) && (AC_BSS[bssindex]->multi_user_optimize_switch == 1))
	{
		char wlanid = AC_BSS[bssindex]->WlanID;
		int radioid = AC_BSS[bssindex]->Radio_G_ID;
		muti_user_optimize_switch(wlanid,radioid,1);
	}

	/* send eap switch & mac to ap ,zhangshu add 2010-10-28 */
	char apcmd[WID_SYSTEM_CMD_LENTH];
	memset(apcmd, 0, WID_SYSTEM_CMD_LENTH);

	if ((AC_WLAN[WlanId]->eap_mac_switch == 1)
		&&(AC_WLAN[WlanId]->wlan_if_policy == NO_INTERFACE)
		&&(AC_BSS[bssindex] != NULL)
		&&(AC_BSS[bssindex]->BSS_IF_POLICY == NO_INTERFACE))
	{
	    sprintf(apcmd,"set_eap_mac ath.%d-%d %s",AC_RADIO[RadioId]->Radio_L_ID,WlanId,AC_WLAN[WlanId]->eap_mac);
	}
	else
	{
	    sprintf(apcmd,"set_eap_mac ath.%d-%d 0",AC_RADIO[RadioId]->Radio_L_ID,WlanId);
	}
	wid_syslog_debug_debug(WID_DEFAULT,"Radio enable Wlan: set eap mac cmd %s\n",apcmd);
	wid_radio_set_extension_command(WtpID,apcmd);
	/* end */

	if ((check_bssid_func(AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][local_radioid]))
		&& ((AC_BSS[(AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][local_radioid])]->unicast_sw == 1)
			|| (AC_BSS[(AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][local_radioid])]->muti_bro_cast_sw == 1)
			|| (AC_BSS[(AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][local_radioid])]->muti_rate != 10)))
    {
		int bssindex1 = AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][local_radioid];
		if ((1 == AC_BSS[bssindex1]->muti_bro_cast_sw) && (1 == AC_BSS[bssindex1]->unicast_sw))
		{
			pcy = 3;
		}
		else if (1 == AC_BSS[bssindex1]->muti_bro_cast_sw)
		{
			pcy = 2;
		}
		else if (1 == AC_BSS[bssindex1]->unicast_sw)
		{
			pcy = 1;
		}
		else
		{
			pcy = 0;
		}
		if (AC_BSS[bssindex1]->wifi_sw == 1)
		{
			pcy = pcy|0x4;
		}
		else
		{
			pcy = pcy&~0x4;
		}
		setWtpUniMutiBroCastIsolation(WtpID,local_radioid,WlanId,pcy);
		wid_syslog_debug_debug(WID_DBUS,"%s,%d,radio %d-%d wlan:%d,bssindex=%d.config save.\n",__func__,__LINE__,WtpID,local_radioid,WlanId,(AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][local_radioid]));
	}
	if ((check_bssid_func(AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][local_radioid]))
		&& (AC_BSS[(AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][local_radioid])]->noResToStaProReqSW == 1))
	{
		setWtpNoRespToStaProReq(WtpID,local_radioid,WlanId,AC_BSS[(AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][local_radioid])]->noResToStaProReqSW);
		wid_syslog_debug_debug(WID_DBUS,"%s,%d,radio %d-%d wlan:%d,bssindex=%d.config save.\n",__func__,__LINE__,WtpID,local_radioid,WlanId,(AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][local_radioid]));
	}
	if ((check_bssid_func(AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][local_radioid]))
		&& (AC_BSS[(AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][local_radioid])]->muti_rate != 10))
    {
		setWtpUniMutiBroCastRate(WtpID,local_radioid,WlanId,AC_BSS[(AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][local_radioid])]->muti_rate);
		wid_syslog_debug_debug(WID_DBUS,"%s,%d,radio %d-%d wlan:%d,bssindex=%d.config save.\n",__func__,__LINE__,WtpID,local_radioid,WlanId,(AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][local_radioid]));
	}
	/* wlan tunnel switch func for REQUIREMENTS-264 */
	memset(apcmd, 0, WID_SYSTEM_CMD_LENTH);
	
	if (AC_WLAN[WlanId]->wlan_tunnel_switch == 1)
	{
		sprintf(apcmd,TUNNEL_SWITCH_CMD";"AP_OPEN_IPFORWARD";"AP_SPFAST_DOWM";"AP_SPFAST_UP,AC_RADIO[RadioId]->Radio_L_ID,WlanId);
		wid_radio_set_extension_command(WtpID,apcmd);
	}

	if ((0 != AC_WLAN[WlanId]->aclgrp_id) && (NULL != STA_ACL_GROUP[AC_WLAN[WlanId]->aclgrp_id]))
	{
		aclgroupid = AC_WLAN[WlanId]->aclgrp_id;
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WtpID%THREAD_NUM+1;
		msg.mqinfo.WTPID = WtpID;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WTP_S_TYPE;
		msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_ACL_LIST;
		msg.mqinfo.u.WtpInfo.value[0] = WlanId;
		msg.mqinfo.u.WtpInfo.value[1] = local_radioid;
		msg.mqinfo.u.WtpInfo.value[2] = OVERWRITE;
		msg.mqinfo.u.WtpInfo.value[3] = LEVEL_WLAN;
		msg.mqinfo.u.WtpInfo.value[4] = AC_WLAN[WlanId]->aclgrp_id;
		/*
		msg.mqinfo.u.WtpInfo.value3 = STA_ACL_GROUP[aclgroupid]->rule_cnt;
		rulelist = STA_ACL_GROUP[aclgroupid]->rule_list;
		for (i = 0; i < STA_ACL_GROUP[aclgroupid]->rule_cnt; i++)
		{
			msg.mqinfo.u.WtpInfo.value[i] = rulelist->rule_id;
			rulelist = rulelist->next;
		}
		*/
		if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
		{
			wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
		}
	}
	
	if (check_bssid_func(bssindex) && (0 != AC_BSS[bssindex]->packet_power))
	{
		WID_RADIO_WLAN_PACKET_POWER(WtpID, local_radioid, WlanId, AC_BSS[bssindex]->packet_power);
	}
	if (0 != memcmp(QOS_AP_11E_TO_1P_DEFAULT, AC_WLAN[WlanId]->qos_ap_11e_to_1p, MAX_QOS_11E_VAL+1))
	{
		set_ap_bss_qos_map_default(WtpID, local_radioid, QOS_MAP_11E_TO_1P, WlanId);
	}
	if (0 != memcmp(QOS_AP_11E_TO_DSCP_DEFAULT, AC_WLAN[WlanId]->qos_ap_11e_to_dscp, MAX_QOS_11E_VAL+1))
	{
		set_ap_bss_qos_map_default(WtpID, local_radioid, QOS_MAP_11E_TO_DSCP, WlanId);
	}
	if (0 != memcmp(QOS_AP_DSCP_TO_11E_DEFAULT, AC_WLAN[WlanId]->qos_ap_dscp_to_11e, MAX_QOS_DSCP_VAL+1))
	{
		set_ap_bss_qos_map_default(WtpID, local_radioid, QOS_MAP_DSCP_TO_11E, WlanId);
	}
	if (0 != memcmp(QOS_AP_1P_TO_11E_DEFAULT, AC_WLAN[WlanId]->qos_ap_1p_to_11e, MAX_QOS_1P_VAL+1))
	{
		set_ap_bss_qos_map_default(WtpID, local_radioid, QOS_MAP_1P_TO_11E, WlanId);
	}
	if (0 != AC_WLAN[WlanId]->qos_ap_11e_to_1p_switch)
	{
		set_ap_bss_qos_map_switch(WtpID, local_radioid, WlanId, QOS_MAP_11E_TO_1P, AC_WLAN[WlanId]->qos_ap_11e_to_1p_switch);
	}
	if (0 != AC_WLAN[WlanId]->qos_ap_11e_to_dscp_switch)
	{
		set_ap_bss_qos_map_switch(WtpID, local_radioid, WlanId, QOS_MAP_11E_TO_DSCP, AC_WLAN[WlanId]->qos_ap_11e_to_dscp_switch);
	}
	if ((check_bssid_func(bssindex)) && (0 != AC_WLAN[WlanId]->balance_switch))
	{
		wid_bss_balance_switch(WtpID, local_radioid, WlanId);										
	}
	
	return 0;
}


int WID_WTP_TUNNEL_MODE_CHECK(int WtpID)
{
	int j= 0, k = 0;
	int check1 = 0, check2 = 0;
	
	for (j = 0; j < AC_WTP[WtpID]->RadioCount; j++)
	{
		for (k = 0; k < L_BSS_NUM; k++)
		{
			if (AC_WTP[WtpID]->WTP_Radio[j]->BSS[k] != NULL)
			{
				if (AC_WTP[WtpID]->WTP_Radio[j]->BSS[k]->BSS_IF_POLICY == NO_INTERFACE)
				{
					check1++;
				}
				else
				{
					check2++;
				}
				if ((check1 != 0)&&(check2 != 0))
				{
					return IF_POLICY_CONFLICT;
				}
			}
		}	
	}
	if (check1 != 0)
	{
		AC_WTP[WtpID]->tunnel_mode = CW_LOCAL_BRIDGING;
	}
	else if (check2 != 0)
	{
		AC_WTP[WtpID]->tunnel_mode = CW_802_DOT_11_TUNNEL;
	}
	
	return 0;
}

int delete_wlan_bss(unsigned int WtpID, unsigned char WlanId)
{
	int RCount = 0,	RadioID = 0;
	struct wds_bssid *wds = NULL;
	struct wds_bssid *wds1 = NULL;
	
	wid_syslog_debug_debug(WID_DEFAULT,"%s:%d wtp%d delete wlan%d\n",__func__,__LINE__,WtpID,WlanId);
	
	RCount = AC_WTP[WtpID]->RadioCount;
	for (RadioID = 0; RadioID < RCount; RadioID++)
	{
		if (AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][RadioID] != 0)
		{
			unsigned int BSSIndex = AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][RadioID];
			
			if (!check_bssid_func(BSSIndex))
			{
				wid_syslog_err("<error>%s:%d bssindex %d illegal\n",__func__,__LINE__,BSSIndex);
				return BSS_NOT_EXIST;
			}
			
			if ((AC_BSS[BSSIndex] != NULL) && (AC_BSS[BSSIndex]->State == 0) && (AC_BSS[BSSIndex]->WlanID == WlanId))
			{
				wid_syslog_debug_debug(WID_DEFAULT,"%s:%d wtp%d delete wlan%d success\n",__func__,__LINE__,WtpID,WlanId);
				unsigned char L_ID = BSSIndex%L_BSS_NUM;
				
				AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][RadioID] = 0;
				AC_WTP[WtpID]->CMD->radiowlanid[0][WlanId] = 0;

				if (AC_BSS[BSSIndex]->BSS_IF_POLICY == BSS_INTERFACE)
				{
					//should added delete l3 interface
					Delete_BSS_L3_Interface(BSSIndex);
				}
				
				AC_BSS[BSSIndex]->WlanID = 0;
				AC_BSS[BSSIndex]->Radio_G_ID = 0;
				AC_BSS[BSSIndex]->Radio_L_ID = 0;
				AC_BSS[BSSIndex]->State = 0;
				AC_BSS[BSSIndex]->BSSIndex = 0;
				
				if (AC_BSS[BSSIndex]->acl_conf != NULL)
				{	
					if (AC_BSS[BSSIndex]->acl_conf->accept_mac != NULL)
					{
						free_maclist(AC_BSS[BSSIndex]->acl_conf,AC_BSS[BSSIndex]->acl_conf->accept_mac);
						AC_BSS[BSSIndex]->acl_conf->accept_mac = NULL;
					}
					if (AC_BSS[BSSIndex]->acl_conf->deny_mac != NULL)
					{
						free_maclist(AC_BSS[BSSIndex]->acl_conf,AC_BSS[BSSIndex]->acl_conf->deny_mac);
						AC_BSS[BSSIndex]->acl_conf->deny_mac = NULL;
					}
					CW_FREE_OBJECT(AC_BSS[BSSIndex]->acl_conf);
				}
				memset(AC_BSS[BSSIndex]->BSSID, 0, MAC_LEN);
				CW_FREE_OBJECT(AC_BSS[BSSIndex]->BSSID);
				
				wds = AC_BSS[BSSIndex]->wds_bss_list;
				while (wds)
				{
					wds1 = wds;
					wds = wds->next;
					CW_FREE_OBJECT(wds1);
				}
				AC_BSS[BSSIndex]->wds_bss_list = NULL;
				
				CW_FREE_OBJECT(AC_BSS[BSSIndex]);
				
				AC_WTP[WtpID]->WTP_Radio[RadioID]->BSS[L_ID] = NULL;

				//return 0;
			}
			else if ((AC_BSS[BSSIndex] != NULL) && (AC_BSS[BSSIndex]->State == 1))
			{
				wid_syslog_debug_debug(WID_DEFAULT,"%s:%d wtp%d delete wlan%d error bss[%d] is enable",__func__,__LINE__,WtpID,WlanId,BSSIndex);
				return -1;
			}
		}			
	}

	return 0;	
}

int delete_wlan_bss_by_radioId(unsigned int RadioId, unsigned char WlanId)
{
	wid_syslog_debug_debug(WID_DEFAULT,"%s:%d radio%d delete wlan%d\n",__func__,__LINE__,RadioId,WlanId);

	int	WtpID = RadioId/L_RADIO_NUM;
	int L_RadioId = RadioId%L_RADIO_NUM;
	int i = 0;

	for (i = 0; i < L_BSS_NUM; i++)
	{
		if ((AC_RADIO[RadioId]->BSS[i] != NULL)&&(AC_RADIO[RadioId]->BSS[i]->WlanID == WlanId))
		{
			break;
		}
	}

	if (i == L_BSS_NUM)
	{
		return RADIO_NO_BINDING_WLAN;
	}
	
	unsigned int BSSIndex = AC_RADIO[RadioId]->BSS[i]->BSSIndex;
	if (!check_bssid_func(BSSIndex))
	{
		wid_syslog_err("<error>%s BSSINDEX %d\n",__func__,BSSIndex);
		return BSS_NOT_EXIST;
	}
	
	if ((AC_BSS[BSSIndex] != NULL) && (AC_BSS[BSSIndex]->State == 0) && (AC_BSS[BSSIndex]->WlanID == WlanId))
	{
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d radio%d-%d delete wlan%d success\n",__func__,__LINE__,WtpID,L_RadioId,WlanId);
		unsigned char L_ID = BSSIndex%L_BSS_NUM;
		
		AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][L_RadioId] = 0;
		AC_WTP[WtpID]->CMD->radiowlanid[L_RadioId][WlanId] = 0;
		
		//AC_RADIO[RadioId]->CMD_radio->wlanid[WlanId] = 0;

		if (AC_BSS[BSSIndex]->BSS_IF_POLICY == BSS_INTERFACE)
		{
			//should added delete l3 interface
			Delete_BSS_L3_Interface(BSSIndex);
		}
		else if (AC_BSS[BSSIndex]->BSS_IF_POLICY == WLAN_INTERFACE)
		{
			//remove bss if from wlan br
			Del_BSS_L3_Interface_BR(BSSIndex);
			//should added delete l3 interface
			Delete_BSS_L3_Interface(BSSIndex);
		}
		//wep wlan area
		if (AC_BSS[BSSIndex]->keyindex != 0)
		{
			int keyindex = AC_BSS[BSSIndex]->keyindex-1;
			AC_RADIO[RadioId]->wep_flag[keyindex] = 0;
			AC_BSS[BSSIndex]->keyindex = 0;
		}
		AC_BSS[BSSIndex]->WlanID = 0;
		AC_BSS[BSSIndex]->Radio_G_ID = 0;
		AC_BSS[BSSIndex]->Radio_L_ID = 0;
		AC_BSS[BSSIndex]->State = 0;
		AC_BSS[BSSIndex]->BSSIndex = 0;
		
		if (AC_BSS[BSSIndex]->acl_conf != NULL)
		{
			if (AC_BSS[BSSIndex]->acl_conf->accept_mac != NULL)
			{
				free_maclist(AC_BSS[BSSIndex]->acl_conf,AC_BSS[BSSIndex]->acl_conf->accept_mac);
				AC_BSS[BSSIndex]->acl_conf->accept_mac = NULL;
			}
			if (AC_BSS[BSSIndex]->acl_conf->deny_mac != NULL)
			{
				free_maclist(AC_BSS[BSSIndex]->acl_conf,AC_BSS[BSSIndex]->acl_conf->deny_mac);
				AC_BSS[BSSIndex]->acl_conf->deny_mac = NULL;
			}
			CW_FREE_OBJECT(AC_BSS[BSSIndex]->acl_conf);
		}
		memset(AC_BSS[BSSIndex]->BSSID, 0, MAC_LEN);
		CW_FREE_OBJECT(AC_BSS[BSSIndex]->BSSID);
		CW_FREE_OBJECT(AC_BSS[BSSIndex]);
		
		AC_WTP[WtpID]->WTP_Radio[L_RadioId]->BSS[L_ID] = NULL;
	}
	else if ((AC_BSS[BSSIndex] != NULL) && (AC_BSS[BSSIndex]->State == 1))
	{
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d radio%d-%d delete wlan%d error bss[%d] is enable",__func__,__LINE__,WtpID,L_RadioId,WlanId,BSSIndex);
		return -1;
	}
	
	return 0;	
}


int delete_wlan_all_bss(unsigned int WtpID)
{
	int i = 0, k = 0;
	int bssindex = 0;
	int ret = 0;
	int num = AC_WTP[WtpID]->RadioCount;
	unsigned int RID = AC_WTP[WtpID]->WFR_Index;
	
	for (i = 0; i < num; i++)
	{
		for (k = 0; k < L_BSS_NUM; k++)
		{
			if (AC_RADIO[RID]->BSS[k] != NULL)
			{
				bssindex = AC_RADIO[RID]->BSS[k]->BSSIndex;
				if ((AC_BSS[bssindex] != NULL) && (AC_BSS[bssindex]->State == 1))
				{
					ret = 1;
					break;
				}
			}
		}
		if (1 == ret)
		{
			break;
		}
		
		RID++;
	}
	
	if (ret == 1)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d delete wlan error bss[%d] is enable",__func__,__LINE__,bssindex);
		return BSS_BE_ENABLE;
	}

	//delete all bss
	RID = AC_WTP[WtpID]->WFR_Index;
	for (i = 0; i < num; i++)
	{
		for (k = 0; k < L_BSS_NUM; k++)
		{
			if (AC_RADIO[RID]->BSS[k] != NULL)
			{
				if (AC_RADIO[RID]->BSS[k]->BSS_IF_POLICY == BSS_INTERFACE)
				{
					//should added delete l3 interface
					Delete_BSS_L3_Interface(AC_RADIO[RID]->BSS[k]->BSSIndex);
				}
				
				bssindex = AC_RADIO[RID]->BSS[k]->BSSIndex;
				
				if (AC_BSS[bssindex]->acl_conf != NULL)
				{
					if (AC_BSS[bssindex]->acl_conf->accept_mac != NULL)
					{
						free_maclist(AC_BSS[bssindex]->acl_conf, AC_BSS[bssindex]->acl_conf->accept_mac);
						AC_BSS[bssindex]->acl_conf->accept_mac = NULL;
					}
					if (AC_BSS[bssindex]->acl_conf->deny_mac != NULL)
					{
						free_maclist(AC_BSS[bssindex]->acl_conf, AC_BSS[bssindex]->acl_conf->deny_mac);
						AC_BSS[bssindex]->acl_conf->deny_mac = NULL;
					}
					CW_FREE_OBJECT(AC_BSS[bssindex]->acl_conf);
				}
				unsigned char WlanId = AC_BSS[bssindex]->WlanID;
				AC_RADIO[RID]->BSS[k]->WlanID = 0;
				AC_RADIO[RID]->BSS[k]->Radio_G_ID = 0;
				AC_RADIO[RID]->BSS[k]->Radio_L_ID = 0;
				AC_RADIO[RID]->BSS[k]->State = 0;
				AC_RADIO[RID]->BSS[k]->BSSIndex = 0;
				memset(AC_RADIO[RID]->BSS[k]->BSSID, 0, MAC_LEN);
				CW_FREE_OBJECT(AC_RADIO[RID]->BSS[k]->BSSID);
				CW_FREE_OBJECT(AC_RADIO[RID]->BSS[k]);
				AC_WTP[WtpID]->WTP_Radio[i]->BSS[k] = NULL;	
				if (AC_WLAN[WlanId])
				{
					AC_WLAN[WlanId]->S_WTP_BSS_List[WtpID][i] = 0;
				}
				AC_BSS[bssindex] = NULL;
			}
		}

		RID++;
	}
	
	struct wlanid *wlan_id = AC_WTP[WtpID]->WTP_Radio[0]->Wlan_Id;
	while (wlan_id != NULL)
	{
		AC_WTP[WtpID]->WTP_Radio[0]->Wlan_Id = wlan_id->next;
		CW_FREE_OBJECT(wlan_id);
		wlan_id = AC_WTP[WtpID]->WTP_Radio[0]->Wlan_Id;
	}

	AC_WTP[WtpID]->WTP_Radio[0]->isBinddingWlan = 0;
	AC_WTP[WtpID]->WTP_Radio[0]->BindingWlanCount = 0;

	return WTP_CLEAR_BINDING_WLAN_SUCCESS;
}

int wid_set_ap_scanning(APScanningSetting scansetting)
{
	int i = 0;
	msgq msg;
	
	for (i = 0; i < WTP_NUM; i++)
	{
		if ((AC_WTP[i] != NULL)&&(AC_WTP[i]->WTPStat == WID_RUN))
		{
			AC_WTP[i]->WTP_Radio[0]->CMD |= 0x40;
			AC_WTP[i]->CMD->radioid[0] += 1;
			AC_WTP[i]->CMD->setCMD = 1;	
			int WTPIndex = i;
			CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
			if (gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
			{
				memset((char*)&msg, 0, sizeof(msg));
				msg.mqid = WTPIndex%THREAD_NUM+1;
				msg.mqinfo.WTPID = WTPIndex;
				msg.mqinfo.type = CONTROL_TYPE;
				msg.mqinfo.subtype = WTP_S_TYPE;
				msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_SCANNING_OP;
				msg.mqinfo.u.WtpInfo.value1 = scansetting.opstate;
				msg.mqinfo.u.WtpInfo.value2 = scansetting.reportinterval;
				if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
				{
					wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
				}
			}		
			CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
			if (gtrapflag >= 4)
			{
    		#if NOSOFTAC
				wid_dbus_trap_ap_rrm_state_change(WTPIndex,scansetting.opstate);
			#endif
			}
		}
	}

	return 0;
}

int Create_BSS_L3_Interface(unsigned int BSSIndex)
{
	if_basic_info ifinfo;
	ifinfo.wlanID = 0;
	ifinfo.BSSIndex = BSSIndex;
	ifinfo.vrid = local*MAX_INSTANCE+vrrid;
	int wtpid = 0;
	int l_radioid = 0;
	int wlanid = 0;
	int reason = 0;
	memset(ifinfo.if_name,0,ETH_IF_NAME_LEN-1);
	//assemble radio1-1.1
	wtpid = BSSIndex/(L_BSS_NUM*L_RADIO_NUM);
	l_radioid = AC_BSS[BSSIndex]->Radio_L_ID;
	wlanid = AC_BSS[BSSIndex]->WlanID;
//	printf("radio%d-%d.%d\n",wtpid,l_radioid,wlanid);
	//snprintf(ifinfo.if_name,ETH_IF_NAME_LEN-1,"radio%d-%d-%d.%d",vrrid,wtpid,l_radioid,wlanid);
	if(local)
    {   
		snprintf(ifinfo.if_name,ETH_IF_NAME_LEN - 1,"r%d-%d-%d.%d",vrrid,wtpid,l_radioid,wlanid);
    }
	else
    {   
		snprintf(ifinfo.if_name,ETH_IF_NAME_LEN - 1,"r%d-%d-%d-%d.%d",slotid,vrrid,wtpid,l_radioid,wlanid);
    }
	//snprintf(ifinfo.if_name,ETH_IF_NAME_LEN,"BSS%d",BSSIndex);
	memcpy(AC_BSS[BSSIndex]->BSS_IF_NAME, ifinfo.if_name, ETH_IF_NAME_LEN-1);
	wid_syslog_debug_debug(WID_DEFAULT,"*** Create_BSS ifname:%s ***\n",ifinfo.if_name);
	wid_syslog_debug_debug(WID_DEFAULT,"Create_BSS ifname:%s\n",AC_BSS[BSSIndex]->BSS_IF_NAME);
	
	int ret = -1;
	
	int fd = open("/dev/wifi0", O_RDWR);
	wid_syslog_debug_debug(WID_DEFAULT,"*** fd:%d ***\n",fd);

	if(fd < 0)
	{
		return -1;//create failure
	}
	
	ret = ioctl(fd, WIFI_IOC_IF_CREATE, &ifinfo);
	
	wid_syslog_debug_debug(WID_DEFAULT,"*** Create_BSS_L3_Interface ret:%d ***\n",ret);
	close(fd);
	if(ret < 0)
	{
		return -1;
	}
	if((is_secondary != 2)&&(set_vmac_state == 1))
	{
		hwaddr_set(AC_BSS[BSSIndex]->BSS_IF_NAME,v_mac,MAC_LEN);
		AC_BSS[BSSIndex]->vMAC_STATE = 1;
	}
	
	char systemcmd[WID_SYSTEM_CMD_LENTH];
	memset(systemcmd,0,WID_SYSTEM_CMD_LENTH);
	//sprintf(systemcmd,"ifconfig radio%d-%d-%d.%d up",vrrid,wtpid,l_radioid,wlanid);
	if(local)
		sprintf(systemcmd,"ifconfig r%d-%d-%d.%d up",vrrid,wtpid,l_radioid,wlanid);
	else	
		sprintf(systemcmd,"ifconfig r%d-%d-%d-%d.%d up",slotid,vrrid,wtpid,l_radioid,wlanid);
//	printf("systemcmd:%s\n",systemcmd);

	ret = system(systemcmd);
	reason = WEXITSTATUS(ret);
	if(reason != 0)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"system cmd error,error code %d\n",reason);
		return SYSTEM_CMD_ERROR;
	}
	
	return 0;
}

int Delete_BSS_L3_Interface(unsigned int BSSIndex)
{
	if_basic_info ifinfo;
	ifinfo.wlanID = 0;
	ifinfo.BSSIndex = BSSIndex;
	ifinfo.vrid = local*MAX_INSTANCE+vrrid;
	int wtpid = 0;
	int l_radioid = 0;
	int wlanid = 0;
	memset(ifinfo.if_name,0,ETH_IF_NAME_LEN-1);
	//snprintf(ifinfo.if_name,ETH_IF_NAME_LEN,"BSS%d",BSSIndex);
	//assemble radio1-0.1
	wtpid = BSSIndex/(L_BSS_NUM*L_RADIO_NUM);
	l_radioid = AC_BSS[BSSIndex]->Radio_L_ID;
	wlanid = AC_BSS[BSSIndex]->WlanID;
//	printf("radio%d-%d.%d\n",wtpid,l_radioid,wlanid);
	//snprintf(ifinfo.if_name,ETH_IF_NAME_LEN-1,"radio%d-%d-%d.%d",vrrid,wtpid,l_radioid,wlanid);
	if(local)
    {   
		snprintf(ifinfo.if_name,ETH_IF_NAME_LEN - 1,"r%d-%d-%d.%d",vrrid,wtpid,l_radioid,wlanid);
    }
	else
    {   
		snprintf(ifinfo.if_name,ETH_IF_NAME_LEN - 1,"r%d-%d-%d-%d.%d",slotid,vrrid,wtpid,l_radioid,wlanid);
    }   
	memset(AC_BSS[BSSIndex]->BSS_IF_NAME, 0, ETH_IF_NAME_LEN-1);
	wid_syslog_debug_debug(WID_DEFAULT,"*** Delete_BSS ifname:%s ***\n",ifinfo.if_name);
	
	int ret = -1;
	int fd = open("/dev/wifi0", O_RDWR);
	wid_syslog_debug_debug(WID_DEFAULT,"*** fd:%d ***\n",fd);

	if(fd < 0)
	{
		return -1;//create failure
	}
	wid_syslog_debug_debug(WID_DEFAULT,"*** macro:%x ***\n",WIFI_IOC_IF_DELETE);
	
	ret = ioctl(fd, WIFI_IOC_IF_DELETE, &ifinfo);
	
	wid_syslog_debug_debug(WID_DEFAULT,"*** Delete_BSS_L3_Interface ret:%d ***\n",ret);
	close(fd);
	if(ret < 0)
	{
		return -1;
	}

	return 0;
}


int ADD_BSS_L3_Interface_BR(unsigned int BSSIndex)
{
	int ret = 0;
	WTPQUITREASON quitreason = WTP_INIT;
	char addifcmd[WID_SYSTEM_CMD_LENTH];
	memset(addifcmd,0,WID_SYSTEM_CMD_LENTH);
	
	int wtpid = 0;
	int l_radioid = 0;
	int wlanid = 0;
	int reason = 0;
	wtpid = BSSIndex/(L_BSS_NUM*L_RADIO_NUM);
	l_radioid = AC_BSS[BSSIndex]->Radio_L_ID;
	wlanid = AC_BSS[BSSIndex]->WlanID;
	int G_radio_id = 0;
	char bssifname[ETH_IF_NAME_LEN];
	char ifcheck[WID_SYSTEM_CMD_LENTH];
	memset(bssifname,0,ETH_IF_NAME_LEN);
	memset(ifcheck,0,WID_SYSTEM_CMD_LENTH);
//	sprintf(bssifname,"radio%d-%d-%d.%d",vrrid,wtpid,l_radioid,wlanid);
	if(local)
		sprintf(bssifname,"r%d-%d-%d.%d",vrrid,wtpid,l_radioid,wlanid);
	else
		sprintf(bssifname,"r%d-%d-%d-%d.%d",slotid,vrrid,wtpid,l_radioid,wlanid);

	if(local)
		sprintf(ifcheck,"/sys/class/net/wlanl%d-%d-%d/brif/%s/port_id",slotid,vrrid,wlanid,bssifname);
	else
		sprintf(ifcheck,"/sys/class/net/wlan%d-%d-%d/brif/%s/port_id",slotid,vrrid,wlanid,bssifname);

	G_radio_id = wtpid*L_RADIO_NUM+l_radioid;
//	printf("radio%d-%d.%d\n",wtpid,l_radioid,wlanid);
	wid_syslog_debug_debug(WID_DEFAULT,"ADD_BSS_L3_Interface_BR ifname:%s\n",bssifname);

	//check bss if validity
	ret = Check_Interface_Config(bssifname,&quitreason);
	if(ret != 0)
	{
		return -1;
	}
	ret = file_check(ifcheck);
	if(ret == 1)
	{
		ret = 0;
	}
	else
	{
		//add if to br
		if(local)
			sprintf(addifcmd,"brctl addif wlanl%d-%d-%d %s\n",slotid,vrrid,wlanid,bssifname);
		else
			sprintf(addifcmd,"brctl addif wlan%d-%d-%d %s\n",slotid,vrrid,wlanid,bssifname);
	//	printf("system cmd: %s\n",addifcmd);
		wid_syslog_debug_debug(WID_DEFAULT,"ADD_BSS_L3_Interface_BR addifcmd:%s\n",addifcmd);
		
		ret = system(addifcmd);

		wid_syslog_debug_debug(WID_DEFAULT,"ret:%d(0 success)\n",ret);
		reason = WEXITSTATUS(ret);
		if(reason != 0)
		{
			wid_syslog_warning("<warnning>system cmd error,error code %d\n",reason);
			wid_syslog_warning("<warnning>interface %s may have been in other br.\n",bssifname);
			time_t now = 0;
			time(&now);
			syslog(LOG_INFO|LOG_LOCAL7, "br wlan%d add %s fail at Time:%s.(it may have been in other br,if we need add it to br wlan,please add it in manual,when peel it off other br)\n",wlanid,bssifname,ctime(&now));

			return WID_ADD_RADIO_IF_FAIL;
		}
	}
	if(ret != 0)
	{
		//return -1;//create failure
		return WID_ADD_RADIO_IF_FAIL;//wu wl change 2010-12-28
	}
	else
	{	
		if(AC_RADIO[G_radio_id] != NULL)
		{
			if(local)
				sprintf(AC_RADIO[G_radio_id]->br_ifname[wlanid],"wlanl%d-%d-%d",slotid,vrrid,wlanid);
			else
				sprintf(AC_RADIO[G_radio_id]->br_ifname[wlanid],"wlan%d-%d-%d",slotid,vrrid,wlanid);
			wid_syslog_debug_debug(WID_DEFAULT,"interface wlan br_ifname:%s.\n",AC_RADIO[G_radio_id]->br_ifname[wlanid]);
		}
		return 0;//create success
	}
}

int Del_BSS_L3_Interface_BR(unsigned int BSSIndex)
{
	int ret = 0;
	WTPQUITREASON quitreason = WTP_INIT;
	char delifcmd[WID_SYSTEM_CMD_LENTH];
	memset(delifcmd,0,WID_SYSTEM_CMD_LENTH);
	
	int wtpid = 0;
	int l_radioid = 0;
	int wlanid = 0;
	int reason = 0;
	wtpid = BSSIndex/(L_BSS_NUM*L_RADIO_NUM);
	l_radioid = AC_BSS[BSSIndex]->Radio_L_ID;
	wlanid = AC_BSS[BSSIndex]->WlanID;
	
	int G_radio_id = 0;
	G_radio_id = wtpid*L_RADIO_NUM+l_radioid;

	char bssifname[ETH_IF_NAME_LEN];
	memset(bssifname,0,ETH_IF_NAME_LEN);
//	sprintf(bssifname,"radio%d-%d-%d.%d",vrrid,wtpid,l_radioid,wlanid);
	if(local)
		sprintf(bssifname,"r%d-%d-%d.%d",vrrid,wtpid,l_radioid,wlanid);
	else
		sprintf(bssifname,"r%d-%d-%d-%d.%d",slotid,vrrid,wtpid,l_radioid,wlanid);
//	printf("radio%d-%d.%d\n",wtpid,l_radioid,wlanid);
	wid_syslog_debug_debug(WID_DEFAULT,"Del_BSS_L3_Interface_BR ifname:%s\n",bssifname);

	//check bss if validity
	ret = Check_Interface_Config(bssifname,&quitreason);
	if(ret != 0)
	{
		return -1;
	}

	//remove if from br
	if(local)
		sprintf(delifcmd,"brctl delif wlanl%d-%d-%d %s\n",slotid,vrrid,wlanid,bssifname);
	else
		sprintf(delifcmd,"brctl delif wlan%d-%d-%d %s\n",slotid,vrrid,wlanid,bssifname);		
//	printf("system cmd: %s\n",delifcmd);
	wid_syslog_debug_debug(WID_DEFAULT,"Del_BSS_L3_Interface_BR delifcmd:%s\n",delifcmd);
	
	ret = system(delifcmd);

	wid_syslog_debug_debug(WID_DEFAULT,"ret:%d(0 success)\n",ret);

	reason = WEXITSTATUS(ret);
	if(reason != 0)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"system cmd error,error code %d\n",reason);
		return -1;
	}
	if(ret != 0)
	{
		return -1;//delete failure
	}
	else
	{
		if(AC_RADIO[G_radio_id] != NULL)
		{
			memset(AC_RADIO[G_radio_id]->br_ifname[wlanid],0,IF_NAME_MAX);
			wid_syslog_debug_debug(WID_DEFAULT,"interface wlan br_ifname:%s\n",AC_RADIO[G_radio_id]->br_ifname[wlanid]);
		}
		return 0;//delete success
	}
}

int Create_Wlan_L3_Interface(unsigned 	char WlanID)
{
	if_basic_info ifinfo;
	ifinfo.BSSIndex = 0;
	ifinfo.wlanID = WlanID;
	
	memset(ifinfo.if_name,0,ETH_IF_NAME_LEN-1);
	//snprintf(ifinfo.if_name,ETH_IF_NAME_LEN,"WLAN%d",WlanID);	
	if(local)
		snprintf(ifinfo.if_name,ETH_IF_NAME_LEN-1,"wlanl%d-%d-%d",slotid,vrrid,WlanID);	
	else
		snprintf(ifinfo.if_name,ETH_IF_NAME_LEN-1,"wlan%d-%d-%d",slotid,vrrid,WlanID);	
		
	memcpy(AC_WLAN[WlanID]->WlanL3IFName,ifinfo.if_name,ETH_IF_NAME_LEN-1);
	wid_syslog_debug_debug(WID_DEFAULT,"*** Create_Wlan ifname:%s ***\n",ifinfo.if_name);
	
	int ret = -1;

	int fd = open("/dev/wifi0", O_RDWR);
	
	wid_syslog_debug_debug(WID_DEFAULT,"*** fd:%d ***\n",fd);

	if(fd < 0)
	{
		return -1;//create failure
	}
	wid_syslog_debug_debug(WID_DEFAULT,"*** macro:%x ***\n",WIFI_IOC_IF_CREATE);

	ret = ioctl(fd, WIFI_IOC_IF_CREATE, &ifinfo);

	wid_syslog_debug_debug(WID_DEFAULT,"*** Create_Wlan_L3_Interface ret:%d ***\n",ret);
	close(fd);
	if(ret < 0)
	{
		return -1;//create failure
	}	

	return 0;//create success
}

int Delete_Wlan_L3_Interface(unsigned char WlanID)
{
	if_basic_info ifinfo;
	ifinfo.BSSIndex = 0;
	ifinfo.wlanID = WlanID;
	ifinfo.vrid = local*MAX_INSTANCE +vrrid;
	wid_syslog_debug_debug(WID_DEFAULT,"way test 0002 \n");
	memset(ifinfo.if_name,0,ETH_IF_NAME_LEN-1);
	//snprintf(ifinfo.if_name,ETH_IF_NAME_LEN,"WLAN%d",WlanID);
	if(local)
		snprintf(ifinfo.if_name,ETH_IF_NAME_LEN-1,"wlanl%d-%d-%d",slotid,vrrid,WlanID);	
	else
		snprintf(ifinfo.if_name,ETH_IF_NAME_LEN-1,"wlan%d-%d-%d",slotid,vrrid,WlanID);	
		
	memset(AC_WLAN[WlanID]->WlanL3IFName,0,ETH_IF_NAME_LEN-1);
	wid_syslog_debug_debug(WID_DEFAULT,"*** Delete_Wlan ifname:%s ***\n",ifinfo.if_name);
	
	int ret = -1;
	int fd = open("/dev/wifi0", O_RDWR);

	wid_syslog_debug_debug(WID_DEFAULT,"*** fd:%d ***\n",fd);

	if(fd < 0)
	{
		return -1;//create failure
	}
	wid_syslog_debug_debug(WID_DEFAULT,"*** macro:%x ***\n",WIFI_IOC_IF_DELETE);

	ret = ioctl(fd, WIFI_IOC_IF_DELETE, &ifinfo);

	wid_syslog_debug_debug(WID_DEFAULT,"*** Delete_Wlan_L3_Interface ret:%d ***\n",ret);
	close(fd);
	if(ret < 0)
	{
		return -1;//create failure
	}	

	return 0;//create success
}

int Create_Wlan_L3_BR_Interface(unsigned 	char WlanID)
{
	int ret = -1;
	int reason = 0;
	WTPQUITREASON quitreason = WTP_INIT;
	char brname[ETH_IF_NAME_LEN];
	memset(brname,0,ETH_IF_NAME_LEN);
	
	char addbrcmd[WID_SYSTEM_CMD_LENTH];
	memset(addbrcmd,0,WID_SYSTEM_CMD_LENTH);
	if(local)
		sprintf(brname,"wlanl%d-%d-%d",slotid,vrrid,WlanID);
	else
		sprintf(brname,"wlan%d-%d-%d",slotid,vrrid,WlanID);
		
	ret = Check_Interface_Config(brname,&quitreason);

	wid_syslog_debug_debug(WID_DEFAULT,"Check_Interface_Config ifname:%s quitreason:%d\n",brname,quitreason);
	if(ret == 0)
	{
#if 0
		memset(addbrcmd,0,WID_SYSTEM_CMD_LENTH);
		if(local)
			sprintf(addbrcmd,"ifconfig wlanl%d-%d-%d down\n",slotid,vrrid,WlanID); 
		else
			sprintf(addbrcmd,"ifconfig wlan%d-%d-%d down\n",slotid,vrrid,WlanID);	
			
//		printf("system cmd: %s\n",addbrcmd);
		ret = system(addbrcmd);

		reason = WEXITSTATUS(ret);
		if(reason != 0)
		{
			wid_syslog_debug_debug(WID_DEFAULT,"system cmd error,error code %d\n",reason);
			return -1;
		}
		if(ret != 0)
		{
			return -1;
		}
	
		memset(addbrcmd,0,WID_SYSTEM_CMD_LENTH);
		if(local)
			sprintf(addbrcmd,"brctl delbr wlanl%d-%d-%d\n",slotid,vrrid,WlanID);
		else
			sprintf(addbrcmd,"brctl delbr wlan%d-%d-%d\n",slotid,vrrid,WlanID);
			
//		printf("system cmd: %s\n",addbrcmd);
		wid_syslog_debug_debug(WID_DEFAULT,"Delete_Wlan_L3_BR_Interface addbrcmd:%s\n",addbrcmd);
		
		ret = system(addbrcmd);

		wid_syslog_debug_debug(WID_DEFAULT,"ret:%d(0 success)\n",ret);
		reason = WEXITSTATUS(ret);
		if(reason != 0)
		{
			wid_syslog_debug_debug(WID_DEFAULT,"system cmd error,error code %d\n",reason);
			return -1;
		}
		if(ret != 0)
		{
			return -1;
		}
#endif
	}
	else
	{
		memset(addbrcmd,0,WID_SYSTEM_CMD_LENTH);
		if(local)
			sprintf(addbrcmd,"brctl addbr wlanl%d-%d-%d\n",slotid,vrrid,WlanID);	
		else
			sprintf(addbrcmd,"brctl addbr wlan%d-%d-%d\n",slotid,vrrid,WlanID);	
			
//		printf("system cmd: %s\n",addbrcmd);
		wid_syslog_debug_debug(WID_DEFAULT,"Create_Wlan_L3_BR_Interface addbrcmd:%s\n",addbrcmd);
		
		ret = system(addbrcmd);
		wid_syslog_debug_debug(WID_DEFAULT,"ret:%d(0 success)\n",ret);
		reason = WEXITSTATUS(ret);
		if(reason != 0)
		{
			wid_syslog_debug_debug(WID_DEFAULT,"system cmd error,error code %d\n",reason);
			return -1;
		}
		if(ret != 0)
		{
			return -1;//create failure
		}
	}
	//set the br if up
	
	memset(addbrcmd,0,WID_SYSTEM_CMD_LENTH);
	if(local)
		sprintf(addbrcmd,"ifconfig wlanl%d-%d-%d up\n",slotid,vrrid,WlanID);	
	else
		sprintf(addbrcmd,"ifconfig wlan%d-%d-%d up\n",slotid,vrrid,WlanID);			
	//printf("system cmd: %s\n",addbrcmd);
	//ret = system(addbrcmd);

	if(ret != 0)
	{
		return -1;//create failure
	}	
	else
	{
		wid_set_wlan_br_isolation(WlanID,1);
		wid_set_wlan_br_multicast_isolation(WlanID,1);
		wid_set_wlan_br_sameportswitch(WlanID,0);
		return 0;//create success
	}
}

int Delete_Wlan_L3_BR_Interface(unsigned char WlanID)
{
	int ret = -1;
	int reason = 0;
	WTPQUITREASON quitreason = WTP_INIT;
	char brname[ETH_IF_NAME_LEN];
	memset(brname,0,ETH_IF_NAME_LEN);
	
	char addbrcmd[WID_SYSTEM_CMD_LENTH];
	memset(addbrcmd,0,WID_SYSTEM_CMD_LENTH);

	if(local)
		sprintf(brname,"wlanl%d-%d-%d",slotid,vrrid,WlanID);
	else
		sprintf(brname,"wlan%d-%d-%d",slotid,vrrid,WlanID);
		
	ret = Check_Interface_Config(brname,&quitreason);

	if(ret == 0)
	{
		if(local)
			sprintf(addbrcmd,"ifconfig wlanl%d-%d-%d down\n",slotid,vrrid,WlanID);	
		else
			sprintf(addbrcmd,"ifconfig wlan%d-%d-%d down\n",slotid,vrrid,WlanID);	
			
//		printf("system cmd: %s\n",addbrcmd);
		ret = system(addbrcmd);

		reason = WEXITSTATUS(ret);
		if(reason != 0)
		{
			wid_syslog_debug_debug(WID_DEFAULT,"system cmd error,error code %d\n",reason);
			return -1;
		}
		if(ret != 0)
		{
			return -1;
		}
	
		memset(addbrcmd,0,WID_SYSTEM_CMD_LENTH);
		if(local)
			sprintf(addbrcmd,"brctl delbr wlanl%d-%d-%d\n",slotid,vrrid,WlanID);
		else
			sprintf(addbrcmd,"brctl delbr wlan%d-%d-%d\n",slotid,vrrid,WlanID);
			
//		printf("system cmd: %s\n",addbrcmd);
		wid_syslog_debug_debug(WID_DEFAULT,"Delete_Wlan_L3_BR_Interface addbrcmd:%s\n",addbrcmd);
		
		ret = system(addbrcmd);

		wid_syslog_debug_debug(WID_DEFAULT,"ret:%d(0 success)\n",ret);
		reason = WEXITSTATUS(ret);
		if(reason != 0)
		{
			wid_syslog_debug_debug(WID_DEFAULT,"system cmd error,error code %d\n",reason);
			return -1;
		}
		if(ret != 0)
		{
			return -1;//delete failure
		}
		else
		{
			return 0;//delete success
		}
	}

	return -1;
}


void display_ap_info_list(Neighbor_AP_INFOS *paplist)
{
	if((paplist == NULL)||(paplist->neighborapInfos == NULL)||(paplist->neighborapInfosCount == 0))
	{
		printf("display_ap_info_list parameter error\n");
		return;
	}
	
	int i = 0;
	struct Neighbor_AP_ELE *phead = paplist->neighborapInfos;
		
	printf("## display The ap info list total count is = %d: ##\n",paplist->neighborapInfosCount);
	for(i = 0; i < paplist->neighborapInfosCount; i++)
	{
		printf("## the count i = %d##\n",i);
		printf("mac = "MACSTR"\n",MAC2STR(phead->BSSID));

		printf("rate = %d\n", phead->Rate);
		printf("Channel = %d\n", phead->Channel);
		printf("RSSI = %d\n", phead->RSSI);
		printf("NOISE = %d\n", phead->NOISE);
		
		printf("BEACON_INT = %d\n", phead->BEACON_INT);
		printf("status = %d\n", phead->status);
		printf("opstatus = %d\n", phead->opstatus);
		printf("capabilityinfo = %d\n", phead->capabilityinfo);
		
		printf("ESSID = %s\n", phead->ESSID);
		printf("IEs_INFO = %s\n", phead->IEs_INFO);

		phead = phead->next;
		printf("info #################################\n");
	}
}

void destroy_sta_info_list(struct sta_info **stalist)
{
	if(stalist == NULL)
	{
		return;
	}
	
	struct sta_info *phead = NULL;
	struct sta_info *pnext = NULL;
	phead = *stalist;
	*stalist = NULL;
		
	while(phead != NULL)
	{	
		pnext = phead->next;
		CW_FREE_OBJECT(phead->in_addr);
		CW_FREE_OBJECT(phead->add_time);
		phead = pnext;
	}
}

void destroy_ap_info_list(Neighbor_AP_INFOS **paplist)
{
	if(((*paplist) == NULL)||((*paplist)->neighborapInfosCount == 0))
	{
		CW_FREE_OBJECT(*paplist);
		return;
	}
	
	struct Neighbor_AP_ELE *phead = NULL;
	struct Neighbor_AP_ELE *pnext = NULL;
	
	phead = (*paplist)->neighborapInfos;
	(*paplist)->neighborapInfos = NULL;
		
	while(phead != NULL)
	{	
		pnext = phead->next;
		
		CW_FREE_OBJECT(phead->IEs_INFO);
		CW_FREE_OBJECT(phead);

		phead = pnext;
	}

	(*paplist)->neighborapInfosCount = 0;
	CW_FREE_OBJECT(*paplist);
}

Neighbor_AP_INFOS * create_ap_info_list(int count)
{
	int i = 0;
	Neighbor_AP_INFOS *create_ap_info = NULL;
	CW_CREATE_OBJECT_ERR(create_ap_info, Neighbor_AP_INFOS, return NULL;);	
				
	create_ap_info->neighborapInfosCount = count;
	create_ap_info->neighborapInfos = NULL;
	
	struct Neighbor_AP_ELE *neighborapelem = NULL;
	struct Neighbor_AP_ELE *phead = NULL;

	for(i = 0; i < create_ap_info->neighborapInfosCount; i++)
	{
		CW_CREATE_OBJECT_SIZE_ERR(neighborapelem, sizeof(struct Neighbor_AP_ELE), {destroy_ap_info_list(&(create_ap_info)); return NULL;});		
		
		char str[3][6] = {{"111111"},{"222222"},{"333333"}};
		memcpy(neighborapelem->BSSID ,str[i], 6);
		
		neighborapelem->Rate = 110;

		neighborapelem->Channel = 1;
		neighborapelem->RSSI = 1;
		neighborapelem->NOISE = 1;
		neighborapelem->BEACON_INT = 10;
		
		neighborapelem->status = 0;
		neighborapelem->opstatus = 0;
		neighborapelem->capabilityinfo = 0;

		char *essid = (char *)malloc(5);
		memset(essid, 0, 5);
		memcpy(essid, "way", 3);

		memset(neighborapelem->ESSID, 0, strlen(essid)+1);
		memcpy(neighborapelem->ESSID, essid, strlen(essid));
		//neighborapelem->ESSID = essid;
		CW_FREE_OBJECT(essid);

		char *ie = (char *)malloc(7);
		memset(ie, 0, 7);
		memcpy(ie, "capwap", 6);
		neighborapelem->IEs_INFO = ie;
		neighborapelem->next = NULL;

		if(i == 0)
		{
			//printf("parse first ap info\n");
			create_ap_info->neighborapInfos = neighborapelem;
			phead = neighborapelem;
			neighborapelem = NULL;
		}
		else
		{
			//printf("parse more ap info\n");
			phead->next = neighborapelem;
			phead = neighborapelem;
			neighborapelem = NULL;
		}
		//printf("######002####\n");
	}	

	return create_ap_info;
	//display_ap_info_list(create_ap_info);
}

Neighbor_AP_INFOS * wid_check_rogue_ap_all()
{
	Neighbor_AP_INFOS * rouge_ap_info = wid_get_neighbor_ap_list();	
	if(rouge_ap_info == NULL)
	{
		return NULL;
	}

	//printf("######wid_check_rogue_ap_all display_ap_info_list####\n");	
	//display_ap_info_list(rouge_ap_info);
	
	white_mac_list * maclist = wid_check_white_mac();
	
	//printf("######wid_check_rogue_ap_all wid_check_white_mac####\n");	
	//display_mac_info_list(maclist);

	struct white_mac *pmacnode = NULL;
	if(maclist != NULL)
	{
		pmacnode = maclist->list_mac;
	}

	while(pmacnode != NULL)
	{
		delete_elem_from_ap_list_bymac(&rouge_ap_info, pmacnode);
		pmacnode = pmacnode->next;
	}

	if(maclist != NULL)
	{
		wid_destroy_white_mac(&maclist);
	}
	
	return rouge_ap_info;
}


Neighbor_AP_INFOS *wid_check_rogue_ap_mac(int wtpid, unsigned int radioid)
{
    WID_CHECK_WTP_STANDARD_RET(wtpid,NULL);

	if((AC_WTP[wtpid] == NULL)
	    ||(AC_WTP[wtpid]->NeighborAPInfos[radioid]== NULL)
	    ||(AC_WTP[wtpid]->NeighborAPInfos[radioid]->neighborapInfosCount == 0))
	{
		return NULL;
	}

	Neighbor_AP_INFOS *rouge_ap_info = NULL;
	struct Neighbor_AP_ELE *neighborapelem = NULL;
	struct Neighbor_AP_ELE *prougehead = NULL;
	struct Neighbor_AP_ELE *phead = AC_WTP[wtpid]->NeighborAPInfos[radioid]->neighborapInfos;
	int i = 0, j = 0, k = 0;
	int charlen = 0, flag = 0;

	CW_CREATE_OBJECT_ERR(rouge_ap_info, Neighbor_AP_INFOS, return NULL;);
	rouge_ap_info->checkrogueapcount = 0;
	rouge_ap_info->neighborapInfosCount = 0;
	rouge_ap_info->neighborapInfos = NULL;
	memset(rouge_ap_info, 0, sizeof(*rouge_ap_info));

	while(phead != NULL)
	{
		for(i = 0; i < WTP_NUM; i++)
		{
			if ((AC_WTP[i] != NULL)&&(AC_WTP[i]->WTPStat == WID_RUN))
			{
				for(j = 0; j < AC_WTP[i]->RadioCount; j++)
				{
					if(AC_WTP[i]->WTP_Radio[j] != NULL)
					{
						for(k = 0; k < L_BSS_NUM; k++)
						{
							if((AC_WTP[i]->WTP_Radio[j]->BSS[k] != NULL)&&(AC_WTP[i]->WTP_Radio[j]->BSS[k]->BSSID != NULL))
							{
								if (memcmp((AC_WTP[i]->WTP_Radio[j]->BSS[k]->BSSID), phead->BSSID, MAC_LEN) == 0)
								{
									wid_syslog_debug_debug(WID_DEFAULT,"%s:%d BSSID["MACSTR"] normal ap match AC_WTP[%d]->WTP_Radio[%d]->BSS[%d]->BSSIndex %d\n",
															__func__, __LINE__, MAC2STR(phead->BSSID), i, j, k, AC_WTP[i]->WTP_Radio[j]->BSS[k]->BSSIndex);
									flag = 1;
									break;
								}
							}
						}
					}
					if(flag == 1)
					{
					    break;
					}	
				}

			}
			if(flag == 1)
			{
			    break;
            }
		}

		if(flag == 0)
		{
			CW_CREATE_OBJECT_SIZE_ERR(neighborapelem, sizeof(struct Neighbor_AP_ELE), {destroy_ap_info_list(&(rouge_ap_info)); return NULL;});		
			memset(neighborapelem, 0,sizeof(struct Neighbor_AP_ELE));
			/////////////////copy information//////////////////////
			memcpy(neighborapelem->BSSID, phead->BSSID, MAC_LEN);
			neighborapelem->Rate = phead->Rate;
			
			neighborapelem->Channel = phead->Channel;
			neighborapelem->RSSI = phead->RSSI;
			neighborapelem->NOISE = phead->NOISE;
			neighborapelem->BEACON_INT = phead->BEACON_INT;
			
			neighborapelem->status = phead->status;
			neighborapelem->opstatus = phead->opstatus;
			neighborapelem->capabilityinfo = phead->capabilityinfo;
			
			wid_syslog_debug_debug(WID_DEFAULT,"%s: BSSID: "MACSTR" rogue ap status %d opstatus %d channel %d\n",
									__func__,MAC2STR(phead->BSSID),phead->status,phead->opstatus,neighborapelem->Channel);
            
			charlen = strlen((char *)phead->ESSID);
			if(charlen > 32)
			{
			    charlen = 32;
			} 
			memset(neighborapelem->ESSID, 0, charlen+1);
			memcpy(neighborapelem->ESSID, phead->ESSID, charlen);

			charlen = strlen(phead->IEs_INFO);
			neighborapelem->IEs_INFO = (char *)malloc(charlen+1);
			memset(neighborapelem->IEs_INFO, 0, charlen+1);
			memcpy(neighborapelem->IEs_INFO, phead->IEs_INFO, charlen);
				
			neighborapelem->next = NULL;

			if(rouge_ap_info->neighborapInfos == NULL)
			{
				rouge_ap_info->neighborapInfos = neighborapelem;
				prougehead = neighborapelem;
				neighborapelem = NULL;
			}
			else
			{
				prougehead->next = neighborapelem;
				prougehead = neighborapelem;
				neighborapelem = NULL;
			}

			rouge_ap_info->neighborapInfosCount++;
		}
		else
		{
			flag = 0;
		}

		phead = phead->next;
	}
	
	//display_ap_info_list(rouge_ap_info);	
	
	if(rouge_ap_info->neighborapInfosCount != 0)
	{
		return rouge_ap_info;
	}
	else
	{
		CW_FREE_OBJECT(rouge_ap_info);
		return NULL;
	}
}		

void wid_mark_rogue_ap(Neighbor_AP_INFOS *paplist)
{
	if((paplist == NULL)||(paplist->neighborapInfos == NULL)||(paplist->neighborapInfosCount == 0))
	{
		//printf("wid_mark_rogue_ap parameter error\n");
		return ;
	}

	struct Neighbor_AP_ELE *phead = paplist->neighborapInfos;
	int i = 0, j = 0, k = 0;
	int breakflag = 0;

	while(phead != NULL)
	{
		for(i = 0; i < WTP_NUM; i++)
		{
			if ((AC_WTP[i] != NULL)&&(AC_WTP[i]->WTPStat == WID_RUN))
			{
				for(j = 0; j < AC_WTP[i]->RadioCount; j++)
				{				
					if(AC_WTP[i]->WTP_Radio[j] != NULL)
					{
						for(k = 0; k < L_BSS_NUM; k++)
						{
							if((AC_WTP[i]->WTP_Radio[j]->BSS[k] != NULL)&&(AC_WTP[i]->WTP_Radio[j]->BSS[k]->BSSID != NULL))
							{
								if (memcmp((AC_WTP[i]->WTP_Radio[j]->BSS[k]->BSSID),phead->BSSID, MAC_LEN) == 0)
								{
									phead->wtpid = i;
									phead->l_radioid = j;
									phead->status = 2;
									if(AC_WTP[i]->WTP_Radio[j]->Radio_Chan == 0)
									{
									    AC_WTP[i]->WTP_Radio[j]->Radio_Chan = phead->Channel;
									}
									
									wid_syslog_debug_debug(WID_DEFAULT,"%s: BSSID["MACSTR"] channel %d normal wtp%d radio%d\n",
															__func__,MAC2STR(phead->BSSID),phead->Channel,i, j);
									breakflag = 1;
									break;
								}
							}
						}
					}
					if(breakflag == 1)
					{
					    break;
					}
				}
			}		
			if(breakflag == 1)
			{
			    break;
	        }
		}
		if(breakflag == 1)
			breakflag = 0;
		//phead->wtpid = 0;
		//phead->status = 1;
		phead = phead->next;
	}
}

int wid_count_rogue_ap(Neighbor_AP_INFOS *paplist,int wtpid)
{
	int i = 0;
	unsigned int count = 0;
	struct Neighbor_AP_ELE *phead = NULL;
	unsigned int m = 0;
	unsigned int interval = 0;
	unsigned int times = 0;
	wid_syslog_debug_debug(WID_DEFAULT,"%s: wtp%d\n",__func__,wtpid);
	
	if((paplist == NULL)||(paplist->neighborapInfos == NULL)||(paplist->neighborapInfosCount == 0))
	{
		//printf("wid_mark_rogue_ap parameter error\n");
		return -1;
	}
	
	phead = paplist->neighborapInfos;	
	while(phead != NULL)
	{
		for(i = 0; i < WTP_NUM; i++)
		{
			if(phead->status == 1)
			{
				count ++;
				break;
			}
		}
		phead = phead->next;
	}
	wid_syslog_debug_debug(WID_DEFAULT,"%s: wtp%d cur rogue ap count is %d \n",__func__,wtpid,count);
	
	if(count >= neighborrogueapcount)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"***wid_count_rogue_ap***gtrapflag is %d \n",gtrapflag);
		//printf("count>neighborrogueapcount ,and neighborrogueapcount is %d \n",neighborrogueapcount);
		m = AC_WTP[wtpid]->trap_collect_time%AC_WTP[wtpid]->wifi_extension_reportinterval;
		interval = gapscanset.reportinterval;
		if(interval != 0)
		{
			if(m == 0)
			{
				times = AC_WTP[wtpid]->trap_collect_time/interval;
			}
			else
			{
				times = AC_WTP[wtpid]->trap_collect_time/interval + 1;
			}
		}
		AC_WTP[wtpid]->rogueaptrap_resend_times ++;
		if(gtrapflag >= 4)
		{
			if(AC_WTP[wtpid]->ap_rogue_threshold_flag == 1)
			{
//				char flag=0;
				if((gtrap_rogue_ap_threshold_switch  == 1)&&(AC_WTP[wtpid]->wtp_rogue_ap_threshold <= count))
				{
					if(AC_WTP[wtpid]->rogueaptrap_resend_times >= times)
					{
						AC_WTP[wtpid]->rogueaptrap_resend_times = 0;
					#if NOSOFTAC
						wid_dbus_trap_ap_rogue_threshold(wtpid,count,flag);
					#endif
						AC_WTP[wtpid]->ap_rogue_threshold_flag = 0;
					}
				}
			}
		}
	}
	//printf("count<neighborrogueapcount ,and neighborrogueapcount is %d \n",neighborrogueapcount);
	return CW_TRUE;
}

struct Neighbor_AP_ELE *find_elem_from_ap_list(Neighbor_AP_INFOS *paplist,struct Neighbor_AP_ELE *elem)     
{
	struct Neighbor_AP_ELE *ptr = NULL;  
	if((NULL == paplist) || (NULL == paplist->neighborapInfos))
	{
        return NULL;
	}
	ptr = paplist->neighborapInfos;  
		 
	while(ptr != NULL)              
	{
		if(memcmp((ptr->BSSID), elem->BSSID, MAC_LEN) == 0)
		{
			//printf("find it\n");
			return ptr;
		}
		else
		{
			ptr = ptr->next;       
		}
	}
	//printf("no find\n");
	return ptr;//here return null
}

CWBool copy_elem_into_ap_list(Neighbor_AP_INFOS *paplist,struct Neighbor_AP_ELE *elem)
{
	struct Neighbor_AP_ELE *neighborapelem = NULL;
	struct Neighbor_AP_ELE *pnext = NULL;
	int charlen = 0;

	if(paplist == NULL)
	{
		return CW_FALSE;
	}

	CW_CREATE_OBJECT_SIZE_ERR(neighborapelem, sizeof(struct Neighbor_AP_ELE), {return CW_FALSE;});
	memset(neighborapelem, 0,sizeof(struct Neighbor_AP_ELE));
	/////////////////copy information//////////////////////
	memcpy(neighborapelem->BSSID, elem->BSSID, MAC_LEN);
	neighborapelem->Rate = elem->Rate;
	
	neighborapelem->Channel = elem->Channel;
	neighborapelem->RSSI = elem->RSSI;
	neighborapelem->NOISE = elem->NOISE;
	neighborapelem->BEACON_INT = elem->BEACON_INT;
	
	neighborapelem->status = elem->status;
	neighborapelem->opstatus = elem->opstatus;
	neighborapelem->capabilityinfo = elem->capabilityinfo;
	
	wid_syslog_debug_debug(WID_DEFAULT,"%s: BSSID: "MACSTR" rogue ap status %d opstatus %d channel %d\n",
							__func__,MAC2STR(elem->BSSID),elem->status,elem->opstatus,elem->Channel);
    
	charlen = strlen((char *)elem->ESSID);
	if(charlen > 32)
	{
	    charlen = 32;
	} 
	memset(neighborapelem->ESSID, 0, charlen+1);
	memcpy(neighborapelem->ESSID, elem->ESSID, charlen);

	charlen = strlen(elem->IEs_INFO);
	neighborapelem->IEs_INFO = (char *)malloc(charlen+1);
	memset(neighborapelem->IEs_INFO, 0, charlen+1);
	memcpy(neighborapelem->IEs_INFO, elem->IEs_INFO, charlen);
		
	neighborapelem->next = NULL;

	if(paplist->neighborapInfos == NULL)
	{
		paplist->neighborapInfos = neighborapelem;
		neighborapelem = NULL;
	}
	else
	{
	    pnext = paplist->neighborapInfos;
	    while(NULL != pnext->next)
	    {
            pnext = pnext->next;
	    }
	    pnext->next = neighborapelem;
		neighborapelem = NULL;
	}

	paplist->neighborapInfosCount++;

	return CW_TRUE;
}

CWBool insert_elem_into_ap_list(Neighbor_AP_INFOS *paplist,struct Neighbor_AP_ELE *elem)
{
	if((elem == NULL)||(paplist == NULL))
	{
		//printf("insert_elem_into_ap_list parameter error\n");
		wid_syslog_debug_debug(WID_DEFAULT,"insert_elem_into_ap_list parameter error\n");
		return CW_FALSE;
	}	

	if(paplist->neighborapInfosCount == 0)
	{
		paplist->neighborapInfos = elem;
		elem->next = NULL;
		paplist->neighborapInfosCount++;	
		return CW_TRUE;
	}
	/*
	struct Neighbor_AP_ELE *pnode = paplist->neighborapInfos;

	paplist->neighborapInfos = elem;
	elem->next = pnode;
	paplist->neighborapInfosCount++;	
	*/

	elem->next = paplist->neighborapInfos;
	paplist->neighborapInfos = elem;
	paplist->neighborapInfosCount++;	
	
	//printf("insert_elem_into_ap_list insert success\n");

	return CW_TRUE;//insert success
}

CWBool modify_elem_into_ap_list(Neighbor_AP_INFOS *paplist,struct Neighbor_AP_ELE *elem)
{
	if((elem == NULL)||((paplist) == NULL)||((paplist)->neighborapInfos == NULL)||((paplist)->neighborapInfosCount == 0))
	{
		//printf("modify_elem_into_ap_list parameter error\n");
		return CW_FALSE;
	}	

	struct Neighbor_AP_ELE *pnode = paplist->neighborapInfos;
	struct Neighbor_AP_ELE *pnext = pnode->next;

	if(memcmp((pnode->BSSID), elem->BSSID, MAC_LEN) == 0)
	{
		pnode->Channel = elem->Channel;
		pnode->RSSI = elem->RSSI;
		pnode->NOISE = elem->NOISE;

		return CW_TRUE;
	}

	while(pnext != NULL)
	{
		if(memcmp((pnext->BSSID), elem->BSSID, MAC_LEN) == 0)
		{
			pnext->Channel = elem->Channel;
			pnext->RSSI = elem->RSSI;
			pnext->NOISE = elem->NOISE;

			return CW_TRUE;
		}	

		pnode = pnode->next;
		pnext = pnext->next;
	}
	//printf("modify_elem_into_ap_list modify success\n");

	return CW_FALSE;//insert success
}

CWBool delete_elem_from_ap_list_wtpid(Neighbor_AP_INFOS *paplist,struct Neighbor_AP_ELE *elem,int wtpid)
{
	if((elem == NULL)||((paplist) == NULL)||((paplist)->neighborapInfos == NULL)||((paplist)->neighborapInfosCount == 0))
	{
		//printf("delete_elem_from_ap_list parameter error\n");
		return CW_FALSE;
	}	

//	char currentchannel = AC_WTP[wtpid]->WTP_Radio[0]->Radio_Chan;
	
	struct Neighbor_AP_ELE *pnode = (paplist)->neighborapInfos;
	struct Neighbor_AP_ELE *pnext = pnode->next;

	if(memcmp((pnode->BSSID), elem->BSSID, MAC_LEN) == 0)
	{
		(paplist)->neighborapInfos = (paplist)->neighborapInfos->next;

		if(gtrapflag >= 4)
		{
			if(AC_WTP[wtpid]->channel_device_interference_flag == 1)
			{
			#if NOSOFTAC
				wid_dbus_trap_wtp_channel_device_interference_clear(wtpid,currentchannel);
			#endif
				
				AC_WTP[wtpid]->channel_device_interference_flag = 0;
			}
		}
					
		if((pnode->IEs_INFO != NULL)&&(strncmp(pnode->IEs_INFO,"E",1) == 0))
		{
			if(gtrapflag >= 4)
			{
				if(AC_WTP[wtpid]->samechannel_trap_flag == 1)
				{
				#if NOSOFTAC
					wid_dbus_trap_wtp_channel_ap_interference_clear(wtpid,currentchannel);
				#endif
					AC_WTP[wtpid]->samechannel_trap_flag = 0;
				}
    		}			
		}
		else if((pnode->IEs_INFO != NULL)&&(strncmp(pnode->IEs_INFO,"I",1) == 0))
		{
			if(gtrapflag >= 4)
			{
				if(AC_WTP[wtpid]->wid_trap.rogue_terminal_trap_flag == 1)
				{
				#if NOSOFTAC
					wid_dbus_trap_wtp_channel_terminal_interference_clear(wtpid,0,currentchannel,NULL);	
				#endif
					AC_WTP[wtpid]->wid_trap.rogue_terminal_trap_flag = 0;
				}
			}
		}
		else
		{
		}

		CW_FREE_OBJECT(pnode->IEs_INFO);
		CW_FREE_OBJECT(pnode);
		(paplist)->neighborapInfosCount--;
		//printf("delete_elem_from_ap_list delete node success\n");
		return CW_TRUE;
	}

	while(pnext != NULL)
	{
		if(memcmp((pnext->BSSID), elem->BSSID, MAC_LEN) == 0)
		{		
			if(gtrapflag >= 4)
			{
				if(AC_WTP[wtpid]->channel_device_interference_flag == 1)
				{
				#if NOSOFTAC
					wid_dbus_trap_wtp_channel_device_interference_clear(wtpid,currentchannel);
				#endif
					AC_WTP[wtpid]->channel_device_interference_flag = 0;
				}
			}
						
			if((pnext->IEs_INFO != NULL)&&(strncmp(pnext->IEs_INFO,"E",1) == 0))
			{
				if(gtrapflag >= 4)
				{
					if(AC_WTP[wtpid]->samechannel_trap_flag == 1)
					{
					#if NOSOFTAC
						wid_dbus_trap_wtp_channel_ap_interference_clear(wtpid,currentchannel);
					#endif
						AC_WTP[wtpid]->samechannel_trap_flag = 0;
					}
				}
			}
			else if((pnext->IEs_INFO != NULL) && (strncmp(pnext->IEs_INFO,"I",1) == 0))
			{
				if(gtrapflag >= 4)
				{
					if(AC_WTP[wtpid]->wid_trap.rogue_terminal_trap_flag == 1)
					{
					#if NOSOFTAC
						wid_dbus_trap_wtp_channel_terminal_interference_clear(wtpid, 0, currentchannel, NULL);
					#endif
						AC_WTP[wtpid]->wid_trap.rogue_terminal_trap_flag = 0;
					}
				}
			}
			else
			{
			}
			
			pnode->next = pnext->next;

			CW_FREE_OBJECT(pnext->IEs_INFO);
			CW_FREE_OBJECT(pnext);	
			(paplist)->neighborapInfosCount--;
			
			//printf("delete_elem_from_ap_list delete node success\n");

			return CW_TRUE;
		}

		pnode = pnode->next;
		pnext = pnext->next;
	}
	
	//printf("delete_elem_from_ap_list delete node fail\n");

	return CW_FALSE;
}

CWBool delete_elem_from_ap_list(Neighbor_AP_INFOS *paplist,struct Neighbor_AP_ELE *elem)
{
	if((elem == NULL)||((paplist) == NULL)||((paplist)->neighborapInfos == NULL)||((paplist)->neighborapInfosCount == 0))
	{
		//printf("delete_elem_from_ap_list parameter error\n");
		return CW_FALSE;
	}	

	struct Neighbor_AP_ELE *pnode = (paplist)->neighborapInfos;
	struct Neighbor_AP_ELE *pnext = pnode->next;

	if(memcmp((pnode->BSSID), elem->BSSID, MAC_LEN) == 0)
	{
		(paplist)->neighborapInfos = (paplist)->neighborapInfos->next;

		CW_FREE_OBJECT(pnode->IEs_INFO);
		CW_FREE_OBJECT(pnode);
		
		(paplist)->neighborapInfosCount--;

		//printf("delete_elem_from_ap_list delete node success\n");
		return CW_TRUE;
	}

	while(pnext != NULL)
	{
		if(memcmp((pnext->BSSID), elem->BSSID, MAC_LEN) == 0)
		{
			pnode->next = pnext->next;

			CW_FREE_OBJECT(pnext->IEs_INFO);
			CW_FREE_OBJECT(pnext);

			(paplist)->neighborapInfosCount--;
			
			//printf("delete_elem_from_ap_list delete node success\n");

			return CW_TRUE;
		}	

		pnode = pnode->next;
		pnext = pnext->next;
	}
	
	//printf("delete_elem_from_ap_list delete node fail\n");

	return CW_FALSE;
}

void merge_ap_list(Neighbor_AP_INFOS *pdestlist,Neighbor_AP_INFOS **psrclist,int wtpid)
{
	if((pdestlist == NULL)||(pdestlist->neighborapInfos == NULL)||(pdestlist->neighborapInfosCount == 0))
	{
		return ;
	}	
	
	if(((*psrclist) == NULL)||((*psrclist)->neighborapInfos == NULL)||((*psrclist)->neighborapInfosCount == 0))
	{
		CW_FREE_OBJECT(*psrclist);
		return ;
	}	

	struct Neighbor_AP_ELE *pnode = (*psrclist)->neighborapInfos;
	struct Neighbor_AP_ELE *pnext = pnode->next;

	if(pnode->opstatus == 1) //add element
	{
		insert_elem_into_ap_list(pdestlist,pnode);
	}
	else if(pnode->opstatus == 2)//delete element
	{
		delete_elem_from_ap_list_wtpid(pdestlist,pnode,wtpid);

		CW_FREE_OBJECT(pnode->IEs_INFO);
		CW_FREE_OBJECT(pnode);
	}
	else //change element
	{
		modify_elem_into_ap_list(pdestlist,pnode);

		CW_FREE_OBJECT(pnode->IEs_INFO);
		CW_FREE_OBJECT(pnode);
	}

	while(pnext != NULL)
	{
		pnode = pnext ->next;
		
		if(pnext->opstatus == 1) //add element
		{
			insert_elem_into_ap_list(pdestlist,pnext);
		}
		else if(pnext->opstatus == 2)//delete element
		{
			delete_elem_from_ap_list(pdestlist,pnext);
		
			CW_FREE_OBJECT(pnext->IEs_INFO);
			CW_FREE_OBJECT(pnext);
		}
		else //change element
		{
			modify_elem_into_ap_list(pdestlist,pnext);
		
			CW_FREE_OBJECT(pnext->IEs_INFO);
			CW_FREE_OBJECT(pnext);
		}

		pnext = pnode;
	}

	CW_FREE_OBJECT(*psrclist);
		
	return ;
}


void merge_rogue_list(Neighbor_AP_INFOS *pdestlist,Neighbor_AP_INFOS **psrclist, unsigned int l_radioid)
{
	if((pdestlist == NULL)||(pdestlist->neighborapInfos == NULL)||(pdestlist->neighborapInfosCount == 0))
	{
		return ;
	}	

	if(((*psrclist) == NULL)||((*psrclist)->neighborapInfos == NULL)||((*psrclist)->neighborapInfosCount == 0))
	{	
		CW_FREE_OBJECT(*psrclist);
		return ;
	}

	struct Neighbor_AP_ELE *pnode = (*psrclist)->neighborapInfos;
	struct Neighbor_AP_ELE *pnext = NULL;
	while(pnode != NULL)
	{
		pnext = pnode ->next;
		if ((pnode->opstatus == 1) && (pnode->status != 2)) //add element
		{
			struct Neighbor_AP_ELE *p = NULL;
			p = find_elem_from_ap_list(pdestlist,pnode);
			if (p == NULL)//elem not in the list
			{
				pnode->agingstatus = 0;
				copy_elem_into_ap_list(pdestlist,pnode);				
			}
			wid_syslog_debug_debug(WID_DEFAULT,"%s: BSSID:"MACSTR" channel %d operate %d %s\n",
									__func__,MAC2STR(pnode->BSSID),pnode->Channel,pnode->opstatus,
									(p)? "exit":"insert");
		}
		else if(pnode->opstatus == 2)//delete element
		{
			struct Neighbor_AP_ELE *p = NULL;
			p = find_elem_from_ap_list(pdestlist,pnode);

			if (p != NULL)//elem is in the list
			{
                p->agingstatus = 2;
			}

			wid_syslog_debug_debug(WID_DEFAULT,"%s: BSSID:"MACSTR" channel %d operate %d %s\n",
								__func__,MAC2STR(pnode->BSSID),pnode->Channel,pnode->opstatus,
								(p)? "delete":"not exit");
		}
		else if(pnode->status != 2)//change element
		{
			struct Neighbor_AP_ELE *p = NULL;
			p = find_elem_from_ap_list(pdestlist,pnode);

			if (p != NULL)//elem is in the list
			{
                if(pnode->Channel != p->Channel)
                {
                    p->agingstatus = 2;
                    copy_elem_into_ap_list(pdestlist,pnode); 
                    
                    wid_syslog_debug_debug(WID_DEFAULT,"%s: BSSID:"MACSTR" operate %d channel %d-%d\n",
                                        __func__,MAC2STR(pnode->BSSID),pnode->opstatus,p->Channel,pnode->Channel);
                }
                else
                {
                    modify_elem_into_ap_list(pdestlist,pnode);
                }
			}
		}

		pnode = pnext;
	}

	return ;
}

struct white_mac *check_elem_in_white_list(struct Neighbor_AP_ELE *elem)     
{	 
    if(pwhite_mac_list != NULL)
    {
        struct white_mac *white_mac_list = pwhite_mac_list->list_mac;  
        
        while(white_mac_list != NULL)
        {
            if(memcmp((white_mac_list->elem_mac),elem->BSSID, MAC_LEN) == 0)
            {
                wid_syslog_debug_debug(WID_DBUS,"%s: mac in white list\n",__func__);
                return white_mac_list;
            }
            
            white_mac_list = white_mac_list->next;
        }
    }
    return NULL;
}

void delete_rouge_ap_list_by_ouilist(Neighbor_AP_INFOS **paplist)
{
	if(((*paplist) == NULL) || ((*paplist)->neighborapInfos == NULL) || ((*paplist)->neighborapInfosCount == 0))
	{
		//printf("delete_rouge_ap_list_by_ouilist parameter error\n");
		return ;
	}	

	struct oui_node *node_oui = NULL;           //filter   oui
	if(g_oui_list.oui_list != NULL)
	{
		node_oui = g_oui_list.oui_list;
	}

	while(node_oui != NULL)
	{
		delete_elem_from_ap_list_byoui(paplist,node_oui);
		node_oui = node_oui->next;
	}
}

void delete_rouge_ap_list_by_essidlist(Neighbor_AP_INFOS **paplist)
{
	if(((*paplist) == NULL)||((*paplist)->neighborapInfos == NULL)||((*paplist)->neighborapInfosCount == 0))
	{
		//printf("delete_rouge_ap_list_by_essid_list parameter error\n");
		return ;
	}
	
	struct essid_node *node_essid =NULL;           //filter   essid
	if(g_essid_list.essid_list != NULL)
	{
		node_essid= g_essid_list.essid_list;
	}

	while(node_essid != NULL)
	{
		delete_elem_from_ap_list_byessid(paplist,node_essid);
		node_essid=node_essid->next;
	}
}

void delete_rouge_ap_list_by_whitelist(Neighbor_AP_INFOS **paplist)
{
	if(((*paplist) == NULL)||((*paplist)->neighborapInfos == NULL)||((*paplist)->neighborapInfosCount == 0))
	{
		//printf("delete_rouge_ap_list_by_whitelist parameter error\n");
		return ;
	}	

	struct white_mac *pmacnode = NULL;
	
	if(pwhite_mac_list != NULL)
	{
		pmacnode = pwhite_mac_list->list_mac;
	}

	while(pmacnode != NULL)
	{
		delete_elem_from_ap_list_bymac(paplist, pmacnode);
		pmacnode = pmacnode->next;
	}
}

struct Neighbor_AP_ELE * create_mac_elem(char *mac)
{
	struct Neighbor_AP_ELE *neighborapelem = NULL;
	CW_CREATE_OBJECT_SIZE_ERR(neighborapelem, sizeof(struct Neighbor_AP_ELE), return NULL;);		

	memcpy(neighborapelem->BSSID, mac, MAC_LEN);
	
	neighborapelem->Rate = 110;
	
	neighborapelem->Channel = 1;
	neighborapelem->RSSI = 1;
	neighborapelem->NOISE = 1;
	neighborapelem->BEACON_INT = 10;
	
	neighborapelem->status = 0;
	neighborapelem->opstatus = 0;
	neighborapelem->capabilityinfo = 0;
	
	char *essid = (char *)malloc(5);
	memset(essid, 0, 5);
	memcpy(essid, "way", 3);

	memset(neighborapelem->ESSID, 0, strlen(essid)+1);
	memcpy(neighborapelem->ESSID, essid, strlen(essid));
	//neighborapelem->ESSID = essid;
	
	char *ie = (char *)malloc(7);
	memset(ie, 0, 7);
	memcpy(ie, "capwap", 6);
	neighborapelem->IEs_INFO = ie;
	
	neighborapelem->next = NULL;
	CW_FREE_OBJECT(essid);

	return neighborapelem;
}

Neighbor_AP_INFOS * create_ap_info_list_test(int count)//just for test will delete later
{
	int i = 0;	
	Neighbor_AP_INFOS *create_ap_info = NULL;
	struct Neighbor_AP_ELE *neighborapelem = NULL;
	struct Neighbor_AP_ELE *phead = NULL;
	
	CW_CREATE_OBJECT_ERR(create_ap_info, Neighbor_AP_INFOS, return NULL;);	
	create_ap_info->neighborapInfosCount = count;
	create_ap_info->neighborapInfos = NULL;
    
	for(i = 0; i < create_ap_info->neighborapInfosCount; i++)
	{
		CW_CREATE_OBJECT_SIZE_ERR(neighborapelem, sizeof(struct Neighbor_AP_ELE), {destroy_ap_info_list(&(create_ap_info)); return NULL;});		
		
		char str[3][6] = {{"444444"},{"222222"},{"333333"}};
		memcpy(neighborapelem->BSSID ,str[i], MAC_LEN);
		
		neighborapelem->Rate = 110;
		neighborapelem->Channel = 1;
		neighborapelem->RSSI = 1;
		neighborapelem->NOISE = 1;
		neighborapelem->BEACON_INT = 10;
		
		neighborapelem->status = 0;
		neighborapelem->opstatus = 0;
		neighborapelem->capabilityinfo = 0;

		char *essid = (char *)malloc(5);
		memset(essid, 0, 5);
		memcpy(essid, "way", 3);
		//neighborapelem->ESSID = essid;
		memset(neighborapelem->ESSID, 0, strlen(essid)+1);
		memcpy(neighborapelem->ESSID, essid, strlen(essid));
        CW_FREE_OBJECT(essid);

		char *ie = (char *)malloc(7);
		memset(ie, 0, 7);
		memcpy(ie, "capwap", 6);
		neighborapelem->IEs_INFO = ie;
		neighborapelem->next = NULL;

		if(i == 0)
		{
			//printf("parse first ap info\n");
			create_ap_info->neighborapInfos = neighborapelem;
			phead = neighborapelem;
			neighborapelem = NULL;
		}
		else
		{
			//printf("parse more ap info\n");
			phead->next = neighborapelem;
			phead = neighborapelem;
			neighborapelem = NULL;
		}
	}	

	return create_ap_info;
	//display_ap_info_list(create_ap_info);
}

white_mac_list * wid_check_white_mac()
{
	int i = 0, j = 0, k = 0;
	struct white_mac *pmac = NULL;
	struct white_mac *phead = NULL;
	white_mac_list *maclist = NULL;
	
	CW_CREATE_OBJECT_ERR(maclist, white_mac_list, return NULL;);
	maclist->imaccount = 0;
	maclist->list_mac = NULL;

	for(i = 0; i < WTP_NUM; i++)
	{		
		if ((AC_WTP[i] != NULL) && (AC_WTP[i]->WTPStat == WID_RUN))
		{
			for(j = 0; j < AC_WTP[i]->RadioCount; j++)
			{				
				if(AC_WTP[i]->WTP_Radio[j] != NULL)
				{
					for(k = 0; k < L_BSS_NUM; k++)
					{
						if((AC_WTP[i]->WTP_Radio[j]->BSS[k] != NULL)&&(AC_WTP[i]->WTP_Radio[j]->BSS[k]->BSSID != NULL))
						{
							CW_CREATE_OBJECT_SIZE_ERR(pmac,sizeof(struct white_mac),{wid_destroy_white_mac(&(maclist)); return NULL;});

							memcpy(pmac->elem_mac, AC_WTP[i]->WTP_Radio[j]->BSS[k]->BSSID, MAC_LEN);
							pmac->next = NULL;

							if(maclist->list_mac == NULL)
							{
								maclist->list_mac = pmac;
								maclist->imaccount++;
							}
							else
							{
								phead = maclist->list_mac;
								maclist->list_mac = pmac;
								pmac->next = phead;
								maclist->imaccount++;
							}
						}
					}
				}
			}
		}
	}
	
	return maclist;
}

Neighbor_AP_INFOS * wid_get_neighbor_ap_list()
{
	int i = 0;
	CWBool ret = CW_FALSE;
	struct Neighbor_AP_ELE *phead = NULL;
	struct Neighbor_AP_ELE *Pnode = NULL;
	Neighbor_AP_INFOS *create_ap_info = NULL;
	
	CW_CREATE_OBJECT_ERR(create_ap_info, Neighbor_AP_INFOS, return NULL;);		
	create_ap_info->neighborapInfosCount = 0;
	create_ap_info->neighborapInfos = NULL;

	for(i = 0; i < WTP_NUM; i++)
	{
		if ((AC_WTP[i] != NULL)&&(AC_WTP[i]->WTPStat == WID_RUN))
		{
			CWThreadMutexLock(&(gWTPs[i].RRMThreadMutex));
			if(AC_WTP[i]->NeighborAPInfos[0] != NULL)
			{
				phead = AC_WTP[i]->NeighborAPInfos[0]->neighborapInfos;
				while(phead != NULL)
				{
					ret = check_elem_in_ap_list(create_ap_info,phead);
					if(ret == CW_FALSE)
					{
						Pnode = create_ap_elem(phead);
						if(Pnode != NULL)
						{
							if(insert_elem_into_ap_list_head(create_ap_info,Pnode) == CW_FALSE)
							{
								//CW_FREE_OBJECT(Pnode->ESSID);
								CW_FREE_OBJECT(Pnode->IEs_INFO);

								CW_FREE_OBJECT(Pnode);
							}
						}
					}
					phead = phead->next;
				}
			}		
			CWThreadMutexUnlock(&(gWTPs[i].RRMThreadMutex));
		}		
	}

	if((create_ap_info->neighborapInfos == NULL)||(create_ap_info->neighborapInfosCount == 0))
	{
		CW_FREE_OBJECT(create_ap_info);
		return NULL;
	}
	
	return create_ap_info;
}
//==================================================================
CWBool delete_elem_from_ap_list_byoui(Neighbor_AP_INFOS **paplist,struct oui_node *oui)
{
	if((oui == NULL)||((*paplist) == NULL)||((*paplist)->neighborapInfos == NULL)||((*paplist)->neighborapInfosCount== 0))
	{
		wid_syslog_debug_debug(WID_DEFAULT,"delete_elem_from_ap_list_byoui parameter error\n");
		return CW_FALSE;
	}	
	/*
	struct Neighbor_AP_ELE *pnode = (*paplist)->neighborapInfos;
	struct Neighbor_AP_ELE *pn = (*paplist)->neighborapInfos;

	while(pnode != NULL)
	{
		if(memcmp((pnode->BSSID),oui->oui,3) == 0){	
			if(pnode==pn){
				(*paplist)->neighborapInfos=pnode->next;
			}else{
				pn->next = pnode->next;
			}
			
			CW_FREE_OBJECT(pnode->ESSID);
			CW_FREE_OBJECT(pnode->IEs_INFO);

			CW_FREE_OBJECT(pnode);

			(*paplist)->neighborapInfosCount--;
			
			printf("delete_elem_from_ap_list_byoui delete node success\n");

			pnode=pn->next;
		}else{
			pn=pnode;
			pnode=pnode->next;
				printf("2\n");
		}
	}

	printf("1\n");
	*/

	struct Neighbor_AP_ELE *pnode = (*paplist)->neighborapInfos;
	struct Neighbor_AP_ELE *pnext = pnode->next;

	if(memcmp((pnode->BSSID), oui->oui, 3) == 0)
	{
		(*paplist) ->neighborapInfos = (*paplist)->neighborapInfos->next;

		//CW_FREE_OBJECT(pnode->ESSID);
		CW_FREE_OBJECT(pnode->IEs_INFO);

		CW_FREE_OBJECT(pnode);

		(*paplist)->neighborapInfosCount--;

		if((*paplist)->neighborapInfosCount == 0)
		{
			CW_FREE_OBJECT((*paplist));
		}
//		printf("delete_elem_from_ap_list_byoui delete node success\n");
		//return CW_TRUE;
		pnode = pnext;
		if(pnext != NULL)
		{
			pnext = pnext->next;
		}
		else
		{
			return CW_TRUE;
		}
	}

	while(pnext != NULL)
	{
		if(memcmp((pnext->BSSID), oui->oui, 3) == 0)
		{
			pnode->next = pnext->next;

			CW_FREE_OBJECT(pnext->IEs_INFO);
			CW_FREE_OBJECT(pnext);
			
			(*paplist)->neighborapInfosCount--;
			
//			printf("delete_elem_from_ap_list_byoui delete node success\n");

			//return CW_TRUE;
			pnext = pnode->next;
		}
		else
		{
			pnode = pnode->next;
			pnext = pnext->next;
		}
	}
	
	wid_syslog_debug_debug(WID_DEFAULT,"delete_elem_from_ap_list_byoui delete no this node \n");

	return CW_FALSE;	
}

CWBool delete_elem_from_ap_list_byessid(Neighbor_AP_INFOS **paplist,struct essid_node *essid)
{
	if((essid == NULL)||((*paplist) == NULL)||((*paplist)->neighborapInfos == NULL)||((*paplist)->neighborapInfosCount== 0))
	{
		//printf("delete_elem_from_ap_list_byessid parameter error\n");
		wid_syslog_debug_debug(WID_DEFAULT,"delete_elem_from_ap_list_byessid parameter error\n");
		return CW_FALSE;
	}	
/*
	struct Neighbor_AP_ELE *pnode = (*paplist)->neighborapInfos;
	struct Neighbor_AP_ELE *pn = (*paplist)->neighborapInfos;

	while(pnode != NULL)
	{
		if(strcmp((pnode->ESSID),essid->essid) == 0){	
			if(pnode==pn){
				(*paplist)->neighborapInfos=pnode->next;
			}else{
				pn->next = pnode->next;
			}
			
			CW_FREE_OBJECT(pnode->ESSID);
			CW_FREE_OBJECT(pnode->IEs_INFO);

			CW_FREE_OBJECT(pnode);

			(*paplist)->neighborapInfosCount--;
			
			printf("delete_elem_from_ap_list_byessid delete node success\n");

			pnode=pn->next;
		}else{
			pn=pnode;
			pnode=pnode->next;
		}
	}
*/
	
	struct Neighbor_AP_ELE *pnode = (*paplist)->neighborapInfos;
	struct Neighbor_AP_ELE *pnext = pnode->next;

	if(memcmp((pnode->ESSID),essid->essid,essid->len) == 0)
	{
		(*paplist) ->neighborapInfos = (*paplist)->neighborapInfos->next;

		//CW_FREE_OBJECT(pnode->ESSID);
		CW_FREE_OBJECT(pnode->IEs_INFO);

		CW_FREE_OBJECT(pnode);

		(*paplist)->neighborapInfosCount--;

		if((*paplist)->neighborapInfosCount == 0)
		{
			CW_FREE_OBJECT((*paplist));
		}
//		printf("delete_elem_from_ap_list_byessid delete node success\n");
		//return CW_TRUE;

		pnode = pnext;
		if(pnext != NULL)
		{
			pnext = pnext->next;
		}
		else
		{
			return CW_TRUE;
		}
	}

	while(pnext != NULL)
	{
		if(memcmp((pnext->ESSID),essid->essid,essid->len) == 0)
		{
			pnode->next = pnext->next;

			CW_FREE_OBJECT(pnext->IEs_INFO);

			CW_FREE_OBJECT(pnext);
			
			(*paplist)->neighborapInfosCount--;
			
			//return CW_TRUE;
			pnext = pnode->next;
		}
		else
		{
			pnode = pnode->next;
			pnext = pnext->next;
		}
	}
	
	wid_syslog_debug_debug(WID_DEFAULT,"delete_elem_from_ap_list_byessid delete no this node \n");
	return CW_FALSE;	
}

//==================================================================

CWBool delete_elem_from_ap_list_bymac(Neighbor_AP_INFOS **paplist,struct white_mac *pmac)
{
	if((pmac == NULL)||((*paplist) == NULL)||((*paplist)->neighborapInfos == NULL)||((*paplist)->neighborapInfosCount== 0))
	{
		//printf("delete_elem_from_ap_list_bymac parameter error\n");
		return CW_FALSE;
	}	
	
	struct Neighbor_AP_ELE *pnode = (*paplist)->neighborapInfos;
	struct Neighbor_AP_ELE *pnext = pnode->next;

	if(memcmp((pnode->BSSID), pmac->elem_mac, MAC_LEN) == 0)
	{
		(*paplist) ->neighborapInfos = (*paplist)->neighborapInfos->next;

		CW_FREE_OBJECT(pnode->IEs_INFO);

		CW_FREE_OBJECT(pnode);

		(*paplist)->neighborapInfosCount--;

		if((*paplist)->neighborapInfosCount == 0)
		{
			CW_FREE_OBJECT((*paplist));
		}
		//printf("delete_elem_from_ap_list_bymac delete node success\n");
		return CW_TRUE;
	}

	while(pnext != NULL)
	{
		if(memcmp((pnext->BSSID), pmac->elem_mac, MAC_LEN) == 0)
		{
			pnode->next = pnext->next;

			CW_FREE_OBJECT(pnext->IEs_INFO);

			CW_FREE_OBJECT(pnext);
			
			(*paplist)->neighborapInfosCount--;
			
			//printf("delete_elem_from_ap_list_bymac delete node success\n");
			return CW_TRUE;
		}	

		pnode = pnode->next;
		pnext = pnext->next;
	}
	//printf("delete_elem_from_ap_list_bymac delete no this node \n");

	return CW_FALSE;	
}


void wid_destroy_white_mac(white_mac_list **pmaclist)
{
	//int i = 0;
	if(((*pmaclist) == NULL)||((*pmaclist)->list_mac == NULL))
	{
		//printf("wid_destroy_white_mac parameter error\n");
		return;
	}

	struct white_mac *phead = NULL;
	struct white_mac *pnext = NULL;
	phead = (*pmaclist)->list_mac;
	(*pmaclist)->list_mac = NULL;
		
	//printf("## wid_destroy_white_mac total count is = %d: ##\n",(*pmaclist)->imaccount);
	while(phead != NULL)
	{	
		//printf("## the count i = %d##\n",i++);
		
		pnext = phead->next;

		CW_FREE_OBJECT(phead);

		phead = pnext;
	}

	(*pmaclist)->imaccount = 0;
	CW_FREE_OBJECT(*pmaclist);
}

void display_mac_info_list(white_mac_list *pmaclist)
{
	if((pmaclist == NULL)||(pmaclist->list_mac == NULL)||(pmaclist->imaccount == 0))
	{
		printf("display_mac_info_list parameter error\n");
		return;
	}
	
	int i = 0;	
	struct white_mac *phead = pmaclist->list_mac;
		
	printf("## display The mac info list total count is = %d: ##\n",pmaclist->imaccount);
	for(i = 0; i < pmaclist->imaccount; i++)
	{
		printf("## the count i = %d##\n",i);
		printf("mac = "MACSTR"\n",MAC2STR(phead->elem_mac));

		phead = phead->next;
	}
}

CWBool check_elem_in_ap_list(Neighbor_AP_INFOS *paplist,struct Neighbor_AP_ELE *elem)
{
	if((elem == NULL)||((paplist) == NULL)||((paplist)->neighborapInfos == NULL)||((paplist)->neighborapInfosCount== 0))
	{
		//printf("check_elem_in_ap_list parameter error\n");
		return CW_FALSE;
	}
	
	struct Neighbor_AP_ELE *pnode = (paplist)->neighborapInfos;
	struct Neighbor_AP_ELE *pnext = pnode->next;

	if(memcmp((pnode->BSSID), elem->BSSID, MAC_LEN) == 0)
	{
		return CW_TRUE;
	}

	while(pnext != NULL)
	{
		if(memcmp((pnext->BSSID), elem->BSSID, MAC_LEN) == 0)
		{
			return CW_TRUE;
		}	

		pnode = pnode->next;
		pnext = pnext->next;
	}

	return CW_FALSE;
}

CWBool insert_elem_into_ap_list_head(Neighbor_AP_INFOS *paplist,struct Neighbor_AP_ELE *elem)
{
	if((elem == NULL)||(paplist == NULL))
	{
		//printf("insert_elem_into_ap_list_heads parameter error\n");
		return CW_FALSE;
	}	

	if(paplist->neighborapInfosCount == 0)
	{
		paplist->neighborapInfos = elem;
		paplist->neighborapInfosCount++;	
		return CW_TRUE;
	}
	
	struct Neighbor_AP_ELE *pnode = paplist->neighborapInfos;

	paplist->neighborapInfos = elem;
	elem->next = pnode;
	paplist->neighborapInfosCount++;	

	return CW_TRUE;
}

struct Neighbor_AP_ELE * create_ap_elem(struct Neighbor_AP_ELE *apelem)
{
	struct Neighbor_AP_ELE *neighborapelem = NULL;
	CW_CREATE_OBJECT_SIZE_ERR(neighborapelem, sizeof(struct Neighbor_AP_ELE), return NULL;);
	//CW_CREATE_OBJECT_SIZE_ERR(neighborapelem->ESSID,(strlen(apelem->ESSID)+1),return NULL;);
    
	CW_CREATE_OBJECT_SIZE_ERR(neighborapelem->IEs_INFO,(strlen(apelem->IEs_INFO)+1),{free(neighborapelem); return NULL;});
	
	memcpy(neighborapelem->BSSID ,apelem->BSSID, MAC_LEN);
	
	neighborapelem->Rate = apelem->Rate;
	neighborapelem->Channel = apelem->Channel;
	neighborapelem->RSSI = apelem->RSSI;
	neighborapelem->NOISE = apelem->NOISE;
	neighborapelem->BEACON_INT = apelem->BEACON_INT;
	
	neighborapelem->status = apelem->status;
	neighborapelem->opstatus = apelem->opstatus;
	neighborapelem->capabilityinfo = apelem->capabilityinfo;

	memset(neighborapelem->ESSID, 0, strlen((char*)apelem->ESSID)+1);
	memcpy(neighborapelem->ESSID, apelem->ESSID, strlen((char*)apelem->ESSID));

	memset(neighborapelem->IEs_INFO, 0, strlen(apelem->IEs_INFO)+1);
	memcpy(neighborapelem->IEs_INFO, apelem->IEs_INFO, strlen(apelem->IEs_INFO));

	neighborapelem->fst_dtc_tm = apelem->fst_dtc_tm;
	time(&neighborapelem->lst_dtc_tm);
	neighborapelem->encrp_type = apelem->encrp_type;
	neighborapelem->polcy = apelem->polcy;

	neighborapelem->next = NULL;	

	return neighborapelem;
}

struct sta_info *find_elem_from_sta_list(struct sta_info *paplist,struct sta_info *elem)     
{
	struct sta_info *ptr = NULL;  
	if((NULL == paplist) || (NULL == elem))
	{
        return NULL;
	}
	ptr = paplist;  
		 
	while(ptr != NULL)              
	{
		if(memcmp((ptr->addr),elem->addr,MAC_LEN) == 0)
		{
			//printf("find it\n");
			return ptr;
		}
		else
		{
			ptr = ptr->next;       
		}
	}
	//printf("no find\n");
	return ptr;//here return null
}

void wid_check_wtp_apply_wlan(unsigned char WlanID, char *ifname)
{
	int i = 0;

	for(i = 0; i < WTP_NUM; i++)
	{	
		if((AC_WTP[i] != NULL)
		    &&(strlen(AC_WTP[i]->BindingIFName) == strlen(ifname))
		    &&(strncmp(AC_WTP[i]->BindingIFName,ifname,strlen(ifname)) == 0))
		{
			WID_DELETE_WLAN_APPLY_WTP(i,WlanID);
		}
	}
}

void display_support_rate_list(struct Support_Rate_List *ratelist)  
{
	if(ratelist == NULL)
	{
		printf("the list is empty\n");
		return;
	}

	 while(ratelist != NULL) 
	 {
		  printf("support rate: %d\n",ratelist->Rate);
		  ratelist = ratelist->next;
	 }	 
}

void destroy_support_rate_list(struct Support_Rate_List *ratelist)
{

	if(ratelist == NULL)
	{
		//printf("the list is empty\n");
		return;
	}
	//int i = 0;
	struct Support_Rate_List *phead = NULL;
	struct Support_Rate_List *pnext = NULL;
	phead = ratelist;
	ratelist = NULL;
		
	//printf("## destroy The list ##\n");
	
	while(phead != NULL)
	{	
		//printf("## the count i = %d##\n",i++);
		
		pnext = phead->next;
	
		CW_FREE_OBJECT(phead);

		phead = pnext;
		
		//printf("###########################################\n");
	}
}

struct Support_Rate_List *create_support_rate_list(int count)
{
	struct Support_Rate_List *create_rate_list = NULL;
	int i = 0;

	/* coverity-CID:10943  Resource leak */
	//CW_CREATE_OBJECT_ERR(create_rate_list,struct Support_Rate_List, return NULL;);	
	
	struct Support_Rate_List *supportrate = NULL;
	struct Support_Rate_List *temp = NULL;

	for(i=0; i<count; i++)
	{
        /* coverity-CID:10190  Resource leak */
		CW_CREATE_OBJECT_SIZE_ERR(supportrate, sizeof(struct Support_Rate_List), {destroy_support_rate_list(create_rate_list);return NULL;});		
		
		supportrate->Rate = 0;

		supportrate->next = NULL;

		if(i== 0)
		{
			
			create_rate_list = supportrate;
			temp = supportrate;
			supportrate = NULL;
		}
		else
		{
			
			temp->next = supportrate;
			temp = supportrate;
			supportrate = NULL;
		}

	}	

	return create_rate_list;
}

int compare_radio_max_rate(struct Support_Rate_List *ratelist)     
{
	struct Support_Rate_List *ptr = NULL; 
    
	ptr = ratelist;		 
	while(ptr != NULL)              
	{
		if(ptr->Rate > 540)     
		{
			//printf("find it\n");
			return 1;
		}
		else
		{
			ptr = ptr->next;       
		}
	}
	//printf("no find\n");
	return 0;//here return null
}

struct Support_Rate_List *find_rate_from_list(struct Support_Rate_List *ratelist,int rate)     
{
	struct Support_Rate_List *ptr = NULL;       
	ptr = ratelist;  
		 
	while(ptr != NULL)              
	{
		if(ptr->Rate == rate)     
		{
			//printf("find it\n");
			return ptr;
		}
		else
		{
			ptr = ptr->next;       
		}
	}
	//printf("no find\n");
	return ptr;//here return null
}

struct Support_Rate_List *insert_rate_into_list(struct Support_Rate_List *ratelist,int rate)
{
	//find first
	struct Support_Rate_List *p = NULL;
	p = find_rate_from_list(ratelist,rate);

	if (p != NULL)//rate is in the list
	{
		//printf("the rate is in the list,no insert\n");
		return ratelist;
	}

	else//insert
	{
		//create new element
		struct Support_Rate_List *newnode = NULL;
		newnode=(struct Support_Rate_List *)malloc(sizeof(struct Support_Rate_List));
		if(!newnode)  
		{
			//printf("malloc error\n");
			wid_syslog_info("malloc error\n");
			return NULL;
		}

		newnode->Rate = rate;          
		newnode->next = NULL;


		//compare the new rate with the first rate,if bigger,add at head
		
		if(rate > ratelist->Rate)    
		{
			newnode->next = ratelist;         //head
			return newnode;
		}
		else//find the smaller one,then add in front of it
		{
			struct Support_Rate_List *ptr = NULL;
			struct Support_Rate_List *temp = NULL;
			ptr = ratelist;
			temp = ratelist;
			while(ptr != NULL)              
			{
				if(rate > ptr->Rate)     
				{
					temp->next = newnode;  //newnode catch front

					newnode->next = ptr;         //front
					return ratelist;
				}
				else
				{
					temp = ptr;
					ptr = ptr->next;       
				}
			}
			temp->next = newnode;
			
		}
		return ratelist;
	}
}


struct Support_Rate_List *delete_rate_from_list(struct Support_Rate_List *ratelist,int rate)
{
	//find first
	struct Support_Rate_List *ptr = NULL;
	struct Support_Rate_List *temp = NULL;
	
	if(NULL == ratelist)
	{
		return NULL;
	}
	
	if(ratelist->Rate == rate)
	{
		temp = ratelist;
		ratelist = ratelist->next;
		CW_FREE_OBJECT(temp);
	}
	else
	{
		ptr = ratelist;
		while(ptr->next != NULL)				
		{
			if(ptr->next->Rate == rate)	  
			{
				temp = ptr->next;
				ptr->next = ptr->next->next;
				CW_FREE_OBJECT(temp);
				break;
			}
			ptr = ptr->next; 
		}
	}
	//printf("not find\n");
	
	return ratelist;
}


void delsame_rate_from_list
(
	struct Support_Rate_List *ratelist
)
{
	struct Support_Rate_List *p = NULL;
	struct Support_Rate_List *q = NULL;
	struct Support_Rate_List *temp1 = NULL;
	struct Support_Rate_List *temp2 = NULL;
	
	p = ratelist;
	if (p == NULL)
	{
		return;
	}
	
	q = p->next;
	if (q == NULL)
	{
		return;
	}
	
	while ((p != NULL) && (p->next != NULL))
	{
		temp1 = p;
		q = p->next;  
		
		while(q)
		{
			if(p->Rate != q->Rate)
			{
				q = q->next;
				temp1 = temp1->next;
			}
			else
			{
				temp2 = q;
				q = q->next;
				temp1->next = q;
				free(temp2);
				temp2 = NULL;
			}
		}
		p = p->next;
	}
}


int length_of_rate_list(struct Support_Rate_List *ratelist)   
{   
      struct Support_Rate_List *p = NULL;
	  p = ratelist;   
      int k = 0;   
      while(p != NULL)   
      {   
        k++;   
        p = p->next;   
      }   
      return k;   
} 

CWBool wid_add_mac_blacklist(unsigned char *pmac)
{
	if(pblack_mac_list == NULL)
	{
		CW_CREATE_OBJECT_ERR(pblack_mac_list, white_mac_list, return CW_FALSE;);
		pblack_mac_list->imaccount = 0;
	 	pblack_mac_list->list_mac = NULL;
	} 

	struct white_mac *phead = pblack_mac_list->list_mac;		
	struct white_mac *pnode = phead;
	
	while(phead != NULL)
	{
		if(memcmp((phead->elem_mac),pmac,6) == 0)
		{
			break;
		}
		pnode = phead;
		phead = phead->next;
	}

	if(phead == NULL)
	{
		struct white_mac *pnewnode = NULL;
		CW_CREATE_OBJECT_SIZE_ERR(pnewnode,sizeof(struct white_mac),return CW_FALSE;);

	 	memcpy(pnewnode->elem_mac,pmac, 6);
		pnewnode->next = NULL;

		if(pnode == NULL)
		{
			pblack_mac_list->imaccount++;
	 		pblack_mac_list->list_mac = pnewnode;	
		}
		else
		{
			pblack_mac_list->imaccount++;
	 		pnode->next = pnewnode;				
		}
	}

	return CW_TRUE;
}

CWBool wid_add_mac_whitelist(unsigned char * pmac)
{
	if(pwhite_mac_list == NULL)
	{
		CW_CREATE_OBJECT_ERR(pwhite_mac_list, white_mac_list, return CW_FALSE;);
		pwhite_mac_list->imaccount = 0;
	 	pwhite_mac_list->list_mac = NULL;
	} 

	struct white_mac *phead = pwhite_mac_list->list_mac;		
	struct white_mac *pnode = phead;
	
	while(phead != NULL)
	{
		if(memcmp((phead->elem_mac),pmac,6) == 0)
		{
			break;
		}
		pnode = phead;
		phead = phead->next;
	}

	if(phead == NULL)
	{
		struct white_mac *pnewnode = NULL;
		CW_CREATE_OBJECT_SIZE_ERR(pnewnode,sizeof(struct white_mac),return CW_FALSE;);

	 	memcpy(pnewnode->elem_mac,pmac, 6);
		pnewnode->next = NULL;

		if(pnode == NULL)
		{
			pwhite_mac_list->imaccount++;
	 		pwhite_mac_list->list_mac = pnewnode;	
		}
		else
		{
			pwhite_mac_list->imaccount++;
	 		pnode->next = pnewnode;				
		}
	}

	return CW_TRUE;

}
CWBool wid_delete_mac_blacklist(unsigned char *pmac)
{
	if(pblack_mac_list != NULL)
	{
		struct white_mac *phead = pblack_mac_list->list_mac;		
		struct white_mac *pnode = phead;
		
		while(phead != NULL)
		{
			if(memcmp((phead->elem_mac),pmac,6) == 0)
			{
				//delete node
				if(phead == pnode)
				{
					pblack_mac_list->list_mac = phead->next;
					pblack_mac_list->imaccount--;
					CW_FREE_OBJECT(phead);
					if(pblack_mac_list->imaccount == 0)
					{
						CW_FREE_OBJECT(pblack_mac_list);
					}
					break;
				}
				else
				{
					pnode->next = phead->next;
					CW_FREE_OBJECT(phead);
					pblack_mac_list->imaccount--;
					break;
					
				}
			}
			pnode = phead;
			phead = phead->next;
		}
	}
	
	return CW_TRUE;

}


CWBool wid_delete_mac_whitelist(unsigned char * pmac)
{
	if(pwhite_mac_list != NULL)
	{
		struct white_mac *phead = pwhite_mac_list->list_mac;		
		struct white_mac *pnode = phead;
		
		while(phead != NULL)
		{
			if(memcmp((phead->elem_mac),pmac,6) == 0)
			{
				//delete node
				if(phead == pnode)
				{
					pwhite_mac_list->list_mac = phead->next;
					pwhite_mac_list->imaccount--;
					CW_FREE_OBJECT(phead);

					if(pwhite_mac_list->imaccount == 0)
					{
						CW_FREE_OBJECT(pwhite_mac_list);
					}
					break;
				}
				else
				{
					pnode->next = phead->next;
					CW_FREE_OBJECT(phead);
					pwhite_mac_list->imaccount--;
					break;
					
				}
			}
			pnode = phead;
			phead = phead->next;
		}
	}
	
	return CW_TRUE;
}


CWBool wid_change_mac_whitelist(unsigned char * pmac,unsigned char *pmacdest)
{
	if(pwhite_mac_list == NULL)
	{
		return MAC_DOESNOT_EXIT;
	}

	int ihavesrc = 0;
	int inodest = 0;

	struct white_mac *phead = pwhite_mac_list->list_mac;		
	struct white_mac *IGNORE_UBSV pnode = phead;
	
	while(phead != NULL)
	{
		if(memcmp((phead->elem_mac),pmac,6) == 0)
		{
			ihavesrc = 1;
		}
		
		if(memcmp((phead->elem_mac),pmacdest,6) == 0)
		{
			inodest = 1;
		}		
		pnode = phead;
		phead = phead->next;
	}

	if(ihavesrc == 0)
	{
		return MAC_DOESNOT_EXIT;
	}
	if(inodest == 1)
	{
		return MAC_ALREADY_EXIT;
	}
	phead = pwhite_mac_list->list_mac;		
	pnode = phead;
	
	while(phead != NULL)
	{
		if(memcmp((phead->elem_mac),pmac,6) == 0)
		{
			memcpy(phead->elem_mac,pmacdest, 6);
			break;
		}
		
		pnode = phead;
		phead = phead->next;
	}

	return 0;	

}

CWBool wid_change_mac_blacklist(unsigned char * pmac,unsigned char *pmacdest)
{
	if(pblack_mac_list == NULL)
	{
		return MAC_DOESNOT_EXIT;
	}

	int ihavesrc = 0;
	int inodest = 0;

	struct white_mac *phead = pblack_mac_list->list_mac;		
	struct white_mac *IGNORE_UBSV pnode = phead;
	
	while(phead != NULL)
	{
		if(memcmp((phead->elem_mac),pmac,6) == 0)
		{
			ihavesrc = 1;
		}
		
		if(memcmp((phead->elem_mac),pmacdest,6) == 0)
		{
			inodest = 1;
		}		
		pnode = phead;
		phead = phead->next;
	}

	if(ihavesrc == 0)
	{
		return MAC_DOESNOT_EXIT;
	}
	if(inodest == 1)
	{
		return MAC_ALREADY_EXIT;
	}
	phead = pblack_mac_list->list_mac;		
	pnode = phead;
	
	while(phead != NULL)
	{
		if(memcmp((phead->elem_mac),pmac,6) == 0)
		{
			memcpy(phead->elem_mac,pmacdest, 6);
			break;
		}
		
		pnode = phead;
		phead = phead->next;
	}

	return 0;	

}

void get_power_control_info(transmit_power_control *txpoer_control_info, Neighbor_AP_INFOS *paplist)
{
	if((txpoer_control_info == NULL)||(paplist == NULL))
	{
		return ;
	}
		
	struct Neighbor_AP_ELE *pnode = paplist->neighborapInfos;
	
	while(pnode != NULL)
	{
		if((pnode->wtpid != 0)||(control_scope == 1)) //should change for later
		{
			if((pnode->RSSI) > (txpoer_control_info->neighbor_rssi[0]))
			{
				txpoer_control_info->neighbor_rssi[3] = txpoer_control_info->neighbor_rssi[2];
				txpoer_control_info->neighbor_rssi[2] = txpoer_control_info->neighbor_rssi[1];
				txpoer_control_info->neighbor_rssi[1] = txpoer_control_info->neighbor_rssi[0];
				txpoer_control_info->neighbor_rssi[0] = pnode->RSSI;
			}
			else if((pnode->RSSI) > (txpoer_control_info->neighbor_rssi[1]))
			{
				txpoer_control_info->neighbor_rssi[3] = txpoer_control_info->neighbor_rssi[2];
				txpoer_control_info->neighbor_rssi[2] = txpoer_control_info->neighbor_rssi[1];
				txpoer_control_info->neighbor_rssi[1] = pnode->RSSI;
			}
			else if((pnode->RSSI) > (txpoer_control_info->neighbor_rssi[2]))
			{
				txpoer_control_info->neighbor_rssi[3] = txpoer_control_info->neighbor_rssi[2];
				txpoer_control_info->neighbor_rssi[2] = pnode->RSSI;
			}
			else if((pnode->RSSI) > (txpoer_control_info->neighbor_rssi[3]))
			{
				txpoer_control_info->neighbor_rssi[3] = pnode->RSSI;
			}
			else
			{
			}

			txpoer_control_info->wtp_cnt++;

			
		}
		
		pnode = pnode->next;
	}
}

void calc_transmit_power_control(unsigned int wtpid, Neighbor_AP_INFOS *paplist,int *setflag)
{
	int calret = 0;
	int ret = 0;
		
	transmit_power_control power_control_info = {0};
	power_control_info.wtpid = wtpid;
	power_control_info.txpower= AC_WTP[wtpid]->WTP_Radio[0]->Radio_TXP;
	power_control_info.pre_txpower =power_control_info.txpower;

	get_power_control_info(&power_control_info,paplist);

	//display information

	//display_power_control_info(power_control_info);

	//calc
	if(power_control_info.wtp_cnt == 0)
	{
		if((power_control_info.txpower)+6 <= tx_power_max)
		{
			*setflag = 2;
			if(ret == 0)
			{
				power_control_info.txpower = power_control_info.txpower + 6;
			}
		}
	}
	else if(power_control_info.wtp_cnt == 1)
	{

		if((power_control_info.txpower)+6 <= tx_power_max)
		{
			*setflag = 2;
			if(ret == 0)
			{
				power_control_info.txpower = power_control_info.txpower + 6;
			}
		}else if(power_control_info.neighbor_rssi[0] > tx_power_threshold){
		
			calret = tx_power_max + tx_power_threshold - power_control_info.neighbor_rssi[0];
			if(power_control_info.txpower > calret)
			{
				if((power_control_info.txpower)-3 >= 1)
				{
					*setflag = 1;
					if(ret == 0)
					{
						power_control_info.txpower = power_control_info.txpower - 3;
					}
				}
			}
		}

	}
	else if(power_control_info.wtp_cnt == 2)
	{
		if(power_control_info.neighbor_rssi[1] > tx_power_threshold)
		{
			calret = tx_power_max + tx_power_threshold - power_control_info.neighbor_rssi[1];

			if(power_control_info.txpower > calret)
			{
				if((power_control_info.txpower)-3 >= 1)
				{
					//set radio value
					//ret = WID_RADIO_SET_TXP(radioid,((power_control_info.txpower)-3));
					*setflag = 1;
					if(ret == 0)
					{
						power_control_info.txpower = power_control_info.txpower - 3;
					}
				}
			}
		}
		else if(power_control_info.neighbor_rssi[0] < coverage_threshold)
		{
			calret = power_control_info.txpower - power_constant - coverage_threshold;
			if(calret < 0)
			{
				calret = -calret;
			}

			if(calret > power_control_info.txpower)
			{
				if((power_control_info.txpower)+6 <= tx_power_max)
				{
					//set radio value
					//ret = WID_RADIO_SET_TXP(radioid,((power_control_info.txpower)+6));
					*setflag = 2;
					if(ret == 0)
					{
						power_control_info.txpower = power_control_info.txpower + 6;
					}
				}
			}
		}
	}
	else
	{
		if(power_control_info.neighbor_rssi[2] > tx_power_threshold)
		{
			calret = tx_power_max + tx_power_threshold - power_control_info.neighbor_rssi[2];

			if(power_control_info.txpower > calret)
			{
				if((power_control_info.txpower)-3 >= 1)
				{
					//set radio value
					//ret = WID_RADIO_SET_TXP(radioid,((power_control_info.txpower)-3));
					*setflag = 1;
					if(ret == 0)
					{
						power_control_info.txpower = power_control_info.txpower - 3;
					}
				}
			}
		}
		else if(power_control_info.neighbor_rssi[0] < coverage_threshold)
		{
			calret = power_control_info.txpower - power_constant - coverage_threshold;
			if(calret < 0)
			{
				calret = -calret;
			}

			if(calret > power_control_info.txpower)
			{
				if((power_control_info.txpower)+6 <= tx_power_max)
				{
					//set radio value
					//ret = WID_RADIO_SET_TXP(radioid,((power_control_info.txpower)+6));
					*setflag = 2;
					if(ret == 0)
					{
						power_control_info.txpower = power_control_info.txpower + 6;
					}
				}
			}
		}
	}

	
	//display information

	//display_power_control_info(power_control_info);
	
}

void display_power_control_info(transmit_power_control power_control_info)
{
	printf("### display power control information start ###\n");

	//printf("$$$ wtpid = %d $$$\n",power_control_info.wtpid);

	int i = 0;
	printf("$$$ wtp cnt = %d $$$\n",power_control_info.wtp_cnt);
	for(i=0; i<4; i++)
	{
		printf("$$$ RSSI[%d] = %d $$$\n",i,power_control_info.neighbor_rssi[i]);
	}
	
	printf("### display power control information end ###\n");
		
}

unsigned int Wid_Find_Wtp(WID_WTP **WTP){
	int i = 0;
	unsigned int wtp_num = 0;
	while(i<WTP_NUM){
		CWThreadMutexLock(&(gWTPs[i].WTPThreadMutex));//fengwenchao add 20121123 for AXSSZFI-1050
		if((AC_WTP[i]!= NULL)
			&&(AC_WTP[i]->WTPID < WTP_NUM)
			&&(AC_WTP[i]->WTPID > 0)){
			WTP[wtp_num]  = AC_WTP[i];
			wtp_num ++;
		}
		CWThreadMutexUnlock(&(gWTPs[i].WTPThreadMutex));
		i++;
	}
	return wtp_num;
}

unsigned int Wid_Find_Running_Wtp(WID_WTP **WTP){
	int i = 0;
	unsigned int wtp_num = 0;
	while(i<WTP_NUM){
		CWThreadMutexLock(&(gWTPs[i].WTPThreadMutex));//fengwenchao add 20121123 for AXSSZFI-1050
		if((AC_WTP[i]!= NULL)
			&&(AC_WTP[i]->WTPID < WTP_NUM)
			&&(AC_WTP[i]->WTPStat ==5 )
			&&(AC_WTP[i]->WTPID > 0)){
			WTP[wtp_num]  = AC_WTP[i];
			wtp_num ++;
		}
		CWThreadMutexUnlock(&(gWTPs[i].WTPThreadMutex));
		i++;
	}
	return wtp_num;
}


unsigned int Wid_Find_ROUGE_Wtp(WID_WTP **WTP,unsigned int *wtp_num)
{
	int i = 0;
	*wtp_num = 0;
	unsigned int rouge_num = 0;
	
	while(i<WTP_NUM)
	{
		if(AC_WTP[i]!= NULL)
		{
			(*wtp_num) ++;
			if((AC_WTP[i]->NeighborAPInfos[0] != NULL)&&(AC_WTP[i]->NeighborAPInfos[0]->neighborapInfosCount != 0))
			{
				CWThreadMutexLock(&(gWTPs[i].RRMThreadMutex));

				if(AC_WTP[i]->rouge_ap_infos[0] == NULL)
				{
					AC_WTP[i]->rouge_ap_infos[0] = wid_check_rogue_ap_mac(i, 0);
					delete_rouge_ap_list_by_whitelist(&(AC_WTP[i]->rouge_ap_infos[0]));
				}
				
				else
				{
					if((AC_WTP[i]->rouge_ap_infos[0]) != NULL)
					{
						destroy_ap_info_list(&(AC_WTP[i]->rouge_ap_infos[0]));
					}
					AC_WTP[i]->rouge_ap_infos[0] = wid_check_rogue_ap_mac(i, 0);
					delete_rouge_ap_list_by_whitelist(&(AC_WTP[i]->rouge_ap_infos[0]));
				}

				if((AC_WTP[i]->rouge_ap_infos[0] != NULL)&&(AC_WTP[i]->rouge_ap_infos[0]->neighborapInfosCount != 0)){
					WTP[rouge_num]  = AC_WTP[i];
					rouge_num ++;
				}
				CWThreadMutexUnlock(&(gWTPs[i].RRMThreadMutex));
			}
		}
		i++;
	}
	return rouge_num;
}

/*fengwenchao add 20110401 for dot11WlanDataPktsTable*/
int WID_CHECK_SAME_ATH_OF_ALL_WTP(unsigned char wlanid,unsigned int *tx_pkt,unsigned long long *rx_bts,unsigned long long *tx_bts)
{
	int i = 0;
	int j = 0;
	int k = 0;
	int n = 0;   //fengwenchao add 20110426
	unsigned int wtp_num = 0;

	WID_WTP **WTP;
	WTP = malloc(WTP_NUM*(sizeof(WID_WTP *)));
	wtp_num = Wid_Find_Wtp(WTP);
	//WID_WTP_RADIO	**AC_RADIO_FOR_SEARCH;
	//AC_RADIO_FOR_SEARCH = malloc(G_RADIO_NUM*(sizeof(WID_WTP_RADIO *)));
	if(wtp_num != 0)
	{	for(i = 0; i < wtp_num; i++)
		{
			 for(j=0;j<L_RADIO_NUM;j++)
			 {
			 	if(WTP[i]->WTP_Radio[j] != NULL)
			 	{
			 		 for(k=0;k<L_BSS_NUM;k++)
			 		 {
			 		 	 if((WTP[i]->WTP_Radio[j]->BSS[k] != NULL)
									&&(WTP[i]->WTP_Radio[j]->BSS[k]->WlanID==wlanid)
									&&(WTP[i]->WTP_Radio[j]->BSS[k]->BSSID != NULL))
			 		 	 {
							for(n = 0; n < TOTAL_AP_IF_NUM;n++)     //fengwenchao add 20110426
				 		 	{ 	
								if((WTP[i]->apstatsinfo[n].radioId < TOTAL_AP_IF_NUM+1) && (wlanid == WTP[i]->apstatsinfo[n].wlanId)&&(WTP[i]->apstatsinfo[n].type == 0))   //fengwenchao modify 20110426
				 		 	 	{
				 		 	 		*tx_pkt += WTP[i]->apstatsinfo[n].tx_packets;
									*rx_bts += WTP[i]->apstatsinfo[n].rx_bytes;
									*tx_bts += WTP[i]->apstatsinfo[n].tx_bytes;
				 		 	 	}
							}
			 		 	 }
			 		 }
			 	}
				else
				{
					wid_syslog_debug_debug(WID_WTPINFO,"WID_CHECK_SAME_ATH_OF_ALL_WTP : WTP[%d]->WTP_Radio[%d] = NULL\n",i,j);
				}
			 }
		}
	}
	else
	{
		wid_syslog_debug_debug(WID_WTPINFO,"WID_CHECK_SAME_ATH_OF_ALL_WTP : wtp_num = 0\n");
	}
	if(WTP)
	{
		free(WTP);
		WTP = NULL;
	}
	return 0;
}
/*fengwenchao add end*/

unsigned char WID_WTP_FIND_RADIO(WID_WTP_RADIO	**AC_RADIO_FOR_SEARCH,WID_WTP *WTP){
	int i = 0;
	unsigned int g_radio_id = 0;
	unsigned char num_of_radio = 0;
	for(i = 0; i<L_RADIO_NUM; i++)
	{
		if(WTP->WTP_Radio[i] != NULL)
		{
			g_radio_id = WTP->WTP_Radio[i]->Radio_G_ID;
			AC_RADIO_FOR_SEARCH[num_of_radio] = AC_RADIO[g_radio_id];
			num_of_radio ++;
		}
	}
	return num_of_radio;
}

int WID_CHECK_WTP_ID(u_int32_t Id){
	int ret = 0;
	if(Id >= WTP_NUM)
		ret =  WTP_ID_LARGE_THAN_MAX;
	else if(AC_WTP[Id] == NULL)
		ret =  WTP_ID_NOT_EXIST;
	
	return ret ;
	
}

int WID_CHECK_WLAN_ID(u_int32_t Id){
	int ret = 0;
	if(Id >= WLAN_NUM)
		ret = WLAN_ID_LARGE_THAN_MAX;
	else if(AC_WLAN[Id] == NULL)
		ret = WLAN_ID_NOT_EXIST;
		
	return ret ;
	
}

int WID_CHECK_G_RADIO_ID(u_int32_t Id){
	int ret = 0;
	if(Id >= G_RADIO_NUM)
		ret = RADIO_ID_LARGE_THAN_MAX;
	else if(AC_RADIO[Id]== NULL)
		ret = RADIO_ID_NOT_EXIST;
	
	return ret ;
}

int WID_CHECK_ID(unsigned int TYPE,u_int32_t Id){
	int ret = 0;
	
	if(WID_WTP_CHECK == TYPE)
		ret = WID_CHECK_WTP_ID(Id);
	
	if(WID_WLAN_CHECK == TYPE)
		ret = WID_CHECK_WLAN_ID(Id);/*remember changing type from char to int*/

	if(WID_RADIO_CHECK == TYPE)
		ret = WID_CHECK_G_RADIO_ID(Id);

	return ret ;

}



CWBool check_ascii_32_to126(const char * str)
{
	if(str == NULL)
	{
		return CW_TRUE;
	}

	CWBool ret = CW_TRUE;
	const char *p = str;

	while(*p != '\0')
	{
		//printf("*p = %d\n",*p);
		if((*p < 32 )||(*p > 126))
		{
			ret = CW_FALSE;
			break;
		}
		p++;
	}
	//printf("ret = %d\n",ret);
	return ret;
}
void WID_CHECK_WLAN_APPLY_WTP_BSS_NAS_ID(unsigned char WlanID,unsigned short ifindex,unsigned int nas_id_len,char *nas_id){
	int i,j,BSSIndex;	
	for(i=0;i<WTP_NUM;i++)
		if((AC_WTP[i] != NULL)&&(AC_WTP[i]->BindingSystemIndex == ifindex)){
			for(j=0;j<AC_WTP[i]->RadioCount;j++){
				if(AC_WLAN[WlanID]->S_WTP_BSS_List[i][j] != 0){
					BSSIndex = AC_WLAN[WlanID]->S_WTP_BSS_List[i][j];
					if((check_bssid_func(BSSIndex))&&(AC_BSS[BSSIndex]!=NULL)){
						memset(AC_BSS[BSSIndex]->nas_id, 0, NAS_IDENTIFIER_NAME);
						AC_BSS[BSSIndex]->nas_id_len = nas_id_len;
						memcpy(AC_BSS[BSSIndex]->nas_id, nas_id, NAS_IDENTIFIER_NAME);
					}
				}
			}
		}
}
void wid_check_remove_wlan_bss_if_nasid(unsigned char WlanID,unsigned short ifindex)
{	
	int i,j,BSSIndex;	
	for(i=0;i<WTP_NUM;i++)
	{
		if((AC_WTP[i] != NULL)&&(AC_WTP[i]->BindingSystemIndex == ifindex))
		{
			for(j=0;j<AC_WTP[i]->RadioCount;j++)
			{
				if(AC_WLAN[WlanID]->S_WTP_BSS_List[i][j] != 0)
				{
					BSSIndex = AC_WLAN[WlanID]->S_WTP_BSS_List[i][j];
					if(AC_BSS[BSSIndex]!=NULL)
					{
						memset(AC_BSS[BSSIndex]->nas_id, 0, NAS_IDENTIFIER_NAME);
						AC_BSS[BSSIndex]->nas_id_len = 0;
					}
				}
			}
		}
	}
}

int WID_INTERFACE_SET_NASID(unsigned char WlanID,char* ifname,char* nas_id)
{
	if(AC_WLAN[WlanID]->Status == 0)
	{
		return WLAN_BE_ENABLE;
	}
//	if(AC_WLAN[WlanID]->SecurityID == 0)
//	{
//		return WLAN_APPLY_SECURITY_FIRST;
//	}
//	if((AC_WLAN[WlanID]->SecurityType != IEEE8021X)&&(AC_WLAN[WlanID]->SecurityType != WPA_E)&&(AC_WLAN[WlanID]->SecurityType != WPA2_E)){
//		return WLAN_NOT_NEED_NAS;
//	}
	int sockfd;
	struct ifreq	ifr;
	struct ifi *wif;
	struct ifi *wifnext;
	int ret = Check_And_Bind_Interface_For_WID(ifname);
	if(ret != 0)
		return ret;
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);

	strncpy(ifr.ifr_name,ifname, sizeof(ifr.ifr_name));
	
	if (ioctl(sockfd, SIOCGIFINDEX, &ifr) == -1){//bind to a interface 
		close(sockfd);
		return APPLY_IF_FAIL;
	}
	close(sockfd);
	wif = (struct ifi*)malloc(sizeof(struct ifi));
	memset(wif->ifi_name,0,ETH_IF_NAME_LEN);
	memcpy(wif->ifi_name,ifname,strlen(ifname));
	wif->ifi_index = ifr.ifr_ifindex;
	wif->nas_id_len = strlen(nas_id);
	memset(wif->nas_id,0,NAS_IDENTIFIER_NAME);
	memcpy(wif->nas_id,nas_id,strlen(nas_id));
	wif->ifi_next = NULL;
	
	if(AC_WLAN[WlanID]->Wlan_Ifi == NULL){
		
		wid_syslog_debug_debug(WID_DEFAULT,"** wlan binding if wlan id:%d ifname :%s sysindex:%d**\n",WlanID,ifname,wif->ifi_index);
		AC_WLAN[WlanID]->Wlan_Ifi = wif ;
		AC_WLAN[WlanID]->Wlan_Ifi->ifi_next = NULL;
	}else{

		wifnext = AC_WLAN[WlanID]->Wlan_Ifi;
		while(wifnext != NULL)
		{	
			if(wifnext->ifi_index == wif->ifi_index)
			{
				wifnext->nas_id_len = strlen(nas_id);
				memset(wifnext->nas_id,0,NAS_IDENTIFIER_NAME);
				memcpy(wifnext->nas_id,nas_id,strlen(nas_id));
				//printf("warnning you have binding this wlan eth ,please do not binding this again");
				wid_syslog_debug_debug(WID_DEFAULT,"warnning you have binding this wlan eth ,please do not binding this again");
				WID_CHECK_WLAN_APPLY_WTP_BSS_NAS_ID(WlanID, wif->ifi_index, wifnext->nas_id_len, nas_id);
				free(wif);
				wif = NULL;
				return 0;
			}
			wifnext = wifnext->ifi_next;
		}
		
		wid_syslog_debug_debug(WID_DEFAULT,"** wlan binding if wlan id:%d ifname :%s sysindex:%d**\n",WlanID,ifname,wif->ifi_index);
		wifnext = AC_WLAN[WlanID]->Wlan_Ifi;
		while(wifnext->ifi_next!= NULL)
		{	
			wifnext = wifnext->ifi_next;
		}
		
		wifnext->ifi_next= wif;		
		WID_CHECK_WLAN_APPLY_WTP_BSS_NAS_ID(WlanID, wif->ifi_index, wifnext->nas_id_len, nas_id);
		//wifnext->ifi_next = NULL;
	}
	AC_WLAN[WlanID]->ifcount++;
	return 0;
}
int wid_remove_wlan_interface_nasid(unsigned char WlanID,char* ifname)
{
	
	int sockfd;
	struct ifreq	ifr;
	int ifindex = 0;
	int isfind = 0;
	struct ifi *wif;
	
	
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);

	strncpy(ifr.ifr_name,ifname, sizeof(ifr.ifr_name));
	
	if (ioctl(sockfd, SIOCGIFINDEX, &ifr) == -1){//bind to a interface 
		close(sockfd);
		return APPLY_IF_FAIL;
	}
	close(sockfd);
	ifindex = ifr.ifr_ifindex;

	
	wif = AC_WLAN[WlanID]->Wlan_Ifi;
	while(wif != NULL)
	{
		if(wif->ifi_index == ifindex)/*this is the interface*/
		{
			isfind = 1;
			memset(wif->nas_id,0,NAS_IDENTIFIER_NAME);
			wif->nas_id_len = 0;
			wid_check_remove_wlan_bss_if_nasid(WlanID,ifindex);
			break;
		}

		wif = wif->ifi_next;
	}

	if(isfind == 0)
	{
		return WLAN_NOT_BINDING_IF;
	}
	return 0;
}
int wid_set_ap_statistics(int apstatics)
{
	int i = 0;
	msgq msg;
	for(i=0; i<WTP_NUM; i++)
	{
		if((AC_WTP[i] != NULL)&&(AC_WTP[i]->WTPStat == 5))
		{
//			printf("## wid_set_ap_statistics wtp id= %d##\n",i);
			
			AC_WTP[i]->WTP_Radio[0]->CMD |= 0x0100;
			AC_WTP[i]->CMD->radioid[0] += 1;
			AC_WTP[i]->CMD->setCMD = 1;	
			int WTPIndex = i;
			CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
			if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
			{
				
				memset((char*)&msg, 0, sizeof(msg));
				msg.mqid = WTPIndex%THREAD_NUM+1;
				msg.mqinfo.WTPID = WTPIndex;
				msg.mqinfo.type = CONTROL_TYPE;
				msg.mqinfo.subtype = WTP_S_TYPE;
				msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STATISTICS_REPORT;
				msg.mqinfo.u.WtpInfo.value2 = apstatics;
				if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
					wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
					perror("msgsnd");
				}
			}		
			CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
		}
	}

	return 0;

}


int wid_set_ap_statistics_interval(unsigned int wtpid,unsigned int apstatics_interval)
{
	int i = 0;
	msgq msg;
	struct msgqlist *elem;
	if(wtpid == 0){
		for(i=0; i<WTP_NUM; i++)
		{
			if((AC_WTP[i] != NULL)&&(AC_WTP[i]->apstatisticsinterval != apstatics_interval)){
				AC_WTP[i]->apstatisticsinterval = apstatics_interval;
			}
			if((AC_WTP[i] != NULL)&&(AC_WTP[i]->WTPStat == 5))
			{
				AC_WTP[i]->WTP_Radio[0]->CMD |= 0x0100;
				AC_WTP[i]->CMD->radioid[0] += 1;
				AC_WTP[i]->CMD->setCMD = 1;	
				int WTPIndex = i;
				CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
				if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
				{
					
					memset((char*)&msg, 0, sizeof(msg));
					msg.mqid = WTPIndex%THREAD_NUM+1;
					msg.mqinfo.WTPID = WTPIndex;
					msg.mqinfo.type = CONTROL_TYPE;
					msg.mqinfo.subtype = WTP_S_TYPE;
					msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STATISTICS_REPORT_INTERVAL;
					msg.mqinfo.u.WtpInfo.value2 = apstatics_interval;
					if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
						wid_syslog_info("%s msgsend %s",__func__,strerror(errno));
						perror("msgsnd");
					}
				}		
				CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
			}
		}
	}
	else{
		if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPStat == 5))
		{
			AC_WTP[wtpid]->WTP_Radio[0]->CMD |= 0x0100;
			AC_WTP[wtpid]->CMD->radioid[0] += 1;
			AC_WTP[wtpid]->CMD->setCMD = 1; 
			int WTPIndex = wtpid;
			CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
			if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
			{
				
				memset((char*)&msg, 0, sizeof(msg));
				msg.mqid = WTPIndex%THREAD_NUM+1;
				msg.mqinfo.WTPID = WTPIndex;
				msg.mqinfo.type = CONTROL_TYPE;
				msg.mqinfo.subtype = WTP_S_TYPE;
				msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STATISTICS_REPORT_INTERVAL;
				msg.mqinfo.u.WtpInfo.value2 = apstatics_interval;
				if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
					wid_syslog_info("%s msgsend %s",__func__,strerror(errno));
					perror("msgsnd");
				}
			}		
			CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
		}else if(AC_WTP[wtpid] != NULL){
				memset((char*)&msg, 0, sizeof(msg));
				msg.mqid = wtpid%THREAD_NUM+1;
				msg.mqinfo.WTPID = wtpid;
				msg.mqinfo.type = CONTROL_TYPE;
				msg.mqinfo.subtype = WTP_S_TYPE;
				msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STATISTICS_REPORT_INTERVAL;
				msg.mqinfo.u.WtpInfo.value2 = apstatics_interval;

				elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
				if(elem == NULL){
					wid_syslog_info("%s malloc %s",__func__,strerror(errno));
					perror("malloc");
					return 0;
				}
				memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
				elem->next = NULL;
				memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
				WID_INSERT_CONTROL_LIST(wtpid, elem);
			}
	}
	return 0;

}


//qos area
int WID_ADD_QOS_PROFILE(char *name,int ID){

	int i = 0;
	

	WID_QOS[ID] = (AC_QOS*)malloc(sizeof(AC_QOS));
	WID_QOS[ID]->QosID = ID;
	WID_QOS[ID]->name = (char *)malloc(strlen(name)+1);
	memset(WID_QOS[ID]->name, 0, strlen(name)+1);
	memcpy(WID_QOS[ID]->name, name, strlen(name));

	//set wireless qos info for mib
	WID_QOS[ID]->qos_total_bandwidth = 25;
	WID_QOS[ID]->qos_res_scale = 20;
	WID_QOS[ID]->qos_share_bandwidth = 10;
	WID_QOS[ID]->qos_res_share_scale = 20;
	WID_QOS[ID]->qos_use_res_grab = 0;
	WID_QOS[ID]->qos_use_res_shove = 0;
	
	memset(WID_QOS[ID]->qos_manage_arithmetic, 0, WID_QOS_ARITHMETIC_NAME_LEN);
	memcpy(WID_QOS[ID]->qos_manage_arithmetic, "ManagePolicy",12);
	memset(WID_QOS[ID]->qos_res_grab_arithmetic, 0, WID_QOS_ARITHMETIC_NAME_LEN);
	memcpy(WID_QOS[ID]->qos_res_grab_arithmetic, "GrabPolicy",10);
	memset(WID_QOS[ID]->qos_res_shove_arithmetic, 0, WID_QOS_ARITHMETIC_NAME_LEN);
	memcpy(WID_QOS[ID]->qos_res_shove_arithmetic, "ShovePolicy",11);
	for(i=0;i<4;i++)
	{
		WID_QOS[ID]->radio_qos[i] = (qos_profile*)malloc(sizeof(qos_profile));

		WID_QOS[ID]->radio_qos[i]->qos_average_rate = 5;
		WID_QOS[ID]->radio_qos[i]->qos_max_degree = 100;
		WID_QOS[ID]->radio_qos[i]->qos_policy_pri = 0;
		WID_QOS[ID]->radio_qos[i]->qos_res_shove_pri = 0;
		WID_QOS[ID]->radio_qos[i]->qos_res_grab_pri = 0;
		WID_QOS[ID]->radio_qos[i]->qos_max_parallel = 20;
		WID_QOS[ID]->radio_qos[i]->qos_bandwidth = 5;
		WID_QOS[ID]->radio_qos[i]->qos_bandwidth_scale = 20;
		WID_QOS[ID]->radio_qos[i]->qos_use_wred = 0;
		WID_QOS[ID]->radio_qos[i]->qos_use_traffic_shaping = 0;
		WID_QOS[ID]->radio_qos[i]->qos_use_flow_eq_queue = 0;
		WID_QOS[ID]->radio_qos[i]->qos_flow_max_queuedepth = 199;
		WID_QOS[ID]->radio_qos[i]->qos_flow_max_degree = 20;
		WID_QOS[ID]->radio_qos[i]->qos_flow_average_rate = 5;
	}
	//set wireless qos info for mib end
	for(i=0;i<4;i++)
	{
		//radio type
		
			
		WID_QOS[ID]->radio_qos[i]->QueueDepth = 199;
		/*
		WID_QOS[ID]->radio_qos[i]->CWMin = WID_QOS_CWMIN_DEFAULT;
		WID_QOS[ID]->radio_qos[i]->CWMax = WID_QOS_CWMAX_DEFAULT;
		WID_QOS[ID]->radio_qos[i]->AIFS = WID_QOS_AIFS_DEFAULT;
		
		WID_QOS[ID]->radio_qos[i]->TXOPlimit = 0;

		*/
		if(i == 0)//be
		{
			WID_QOS[ID]->radio_qos[i]->CWMin = 4;
			WID_QOS[ID]->radio_qos[i]->CWMax = 6;
			WID_QOS[ID]->radio_qos[i]->AIFS = 3;
			WID_QOS[ID]->radio_qos[i]->TXOPlimit = 0;
		}
		else if(i == 1)//ba
		{
			WID_QOS[ID]->radio_qos[i]->CWMin = 4;
			WID_QOS[ID]->radio_qos[i]->CWMax = 10;
			WID_QOS[ID]->radio_qos[i]->AIFS = 7;
			WID_QOS[ID]->radio_qos[i]->TXOPlimit = 0;
		}
		else if(i == 2)//vi
		{
			WID_QOS[ID]->radio_qos[i]->CWMin = 3;
			WID_QOS[ID]->radio_qos[i]->CWMax = 4;
			WID_QOS[ID]->radio_qos[i]->AIFS = 1;
			WID_QOS[ID]->radio_qos[i]->TXOPlimit = 3008;
		}
		else if(i == 3)//v0
		{
			WID_QOS[ID]->radio_qos[i]->CWMin = 2;
			WID_QOS[ID]->radio_qos[i]->CWMax = 3;
			WID_QOS[ID]->radio_qos[i]->AIFS = 1;
			WID_QOS[ID]->radio_qos[i]->TXOPlimit = 1504;
		}
		
		//WID_QOS[ID]->radio_qos[i]->Dot1PTag = 0;
		//WID_QOS[ID]->radio_qos[i]->DSCPTag = 0;
		WID_QOS[ID]->radio_qos[i]->ACK = 1;//default value is ack

		WID_QOS[ID]->radio_qos[i]->mapstate = 0;
		WID_QOS[ID]->radio_qos[i]->wmm_map_dot1p = 0;
		WID_QOS[ID]->radio_qos[i]->dot1p_map_wmm_num = 0;
		memset(WID_QOS[ID]->radio_qos[i]->dot1p_map_wmm,0,8);
		
		

		//client type
		WID_QOS[ID]->client_qos[i] = (qos_profile*)malloc(sizeof(qos_profile));
		WID_QOS[ID]->client_qos[i]->QueueDepth = 199;
		/*
		WID_QOS[ID]->client_qos[i]->CWMin = WID_QOS_CWMIN_DEFAULT;
		WID_QOS[ID]->client_qos[i]->CWMax = WID_QOS_CWMAX_DEFAULT;
		WID_QOS[ID]->client_qos[i]->AIFS = WID_QOS_AIFS_DEFAULT;
		
		WID_QOS[ID]->client_qos[i]->TXOPlimit = 0;

		*/
		if(i == 0)//be
		{
			WID_QOS[ID]->client_qos[i]->CWMin = 4;
			WID_QOS[ID]->client_qos[i]->CWMax = 10;
			WID_QOS[ID]->client_qos[i]->AIFS = 3;
			WID_QOS[ID]->client_qos[i]->TXOPlimit = 0;
		}
		else if(i == 1)//ba
		{
			WID_QOS[ID]->client_qos[i]->CWMin = 4;
			WID_QOS[ID]->client_qos[i]->CWMax = 10;
			WID_QOS[ID]->client_qos[i]->AIFS = 7;
			WID_QOS[ID]->client_qos[i]->TXOPlimit = 0;
		}
		else if(i == 2)//vi
		{
			WID_QOS[ID]->client_qos[i]->CWMin = 3;
			WID_QOS[ID]->client_qos[i]->CWMax = 4;
			WID_QOS[ID]->client_qos[i]->AIFS = 2;
			WID_QOS[ID]->client_qos[i]->TXOPlimit = 3008;
		}
		else if(i == 3)//v0
		{
			WID_QOS[ID]->client_qos[i]->CWMin = 2;
			WID_QOS[ID]->client_qos[i]->CWMax = 3;
			WID_QOS[ID]->client_qos[i]->AIFS = 2;
			WID_QOS[ID]->client_qos[i]->TXOPlimit = 1504;
		}
		//WID_QOS[ID]->client_qos[i]->Dot1PTag = 0;
		//WID_QOS[ID]->client_qos[i]->DSCPTag = 0;
		//WID_QOS[ID]->client_qos[i]->ACK = 0;//default value is noack
	}
	
	return WID_DBUS_SUCCESS;
}
int WID_DELETE_QOS_PROFILE(int ID){
	int i = 0;

	for(i=0;i<4;i++)
	{
		WID_QOS[ID]->radio_qos[i]->QueueDepth = UNUSED_QOS_VALUE;
		WID_QOS[ID]->radio_qos[i]->CWMin = UNUSED_QOS_VALUE;
		WID_QOS[ID]->radio_qos[i]->CWMax = UNUSED_QOS_VALUE;
		WID_QOS[ID]->radio_qos[i]->AIFS = UNUSED_QOS_VALUE;
		WID_QOS[ID]->radio_qos[i]->TXOPlimit = UNUSED_QOS_VALUE;
		WID_QOS[ID]->radio_qos[i]->Dot1PTag = UNUSED_QOS_VALUE;
		WID_QOS[ID]->radio_qos[i]->DSCPTag = UNUSED_QOS_VALUE;
		WID_QOS[ID]->radio_qos[i]->ACK = UNUSED_QOS_VALUE;


		WID_QOS[ID]->client_qos[i]->QueueDepth = UNUSED_QOS_VALUE;
		WID_QOS[ID]->client_qos[i]->CWMin = UNUSED_QOS_VALUE;
		WID_QOS[ID]->client_qos[i]->CWMax = UNUSED_QOS_VALUE;
		WID_QOS[ID]->client_qos[i]->AIFS = UNUSED_QOS_VALUE;
		WID_QOS[ID]->client_qos[i]->TXOPlimit = UNUSED_QOS_VALUE;
		WID_QOS[ID]->client_qos[i]->Dot1PTag = UNUSED_QOS_VALUE;
		WID_QOS[ID]->client_qos[i]->DSCPTag = UNUSED_QOS_VALUE;
		WID_QOS[ID]->client_qos[i]->ACK = UNUSED_QOS_VALUE;

		CW_FREE_OBJECT(WID_QOS[ID]->radio_qos[i]);
		CW_FREE_OBJECT(WID_QOS[ID]->client_qos[i]);
	}

	CW_FREE_OBJECT(WID_QOS[ID]->name);
	
	CW_FREE_OBJECT(WID_QOS[ID]);
	
	return WID_DBUS_SUCCESS;
}
int WID_QOS_SET_QOS_INFO(int ID,int qos_stream_id,unsigned short cwmin,unsigned short cwmax,unsigned char aifs,unsigned char ack,unsigned short txoplimit)
{
	

	WID_QOS[ID]->radio_qos[qos_stream_id]->CWMin = cwmin;
	WID_QOS[ID]->radio_qos[qos_stream_id]->CWMax = cwmax;
	WID_QOS[ID]->radio_qos[qos_stream_id]->AIFS = aifs;
	WID_QOS[ID]->radio_qos[qos_stream_id]->ACK = ack;
	WID_QOS[ID]->radio_qos[qos_stream_id]->TXOPlimit = txoplimit;
	return 0;
}
int WID_QOS_SET_QOS_INFO_CLIENT(int ID,int qos_stream_id,unsigned short cwmin,unsigned short cwmax,unsigned char aifs,unsigned short txoplimit)
{
	

	WID_QOS[ID]->client_qos[qos_stream_id]->CWMin = cwmin;
	WID_QOS[ID]->client_qos[qos_stream_id]->CWMax = cwmax;
	WID_QOS[ID]->client_qos[qos_stream_id]->AIFS = aifs;
	WID_QOS[ID]->client_qos[qos_stream_id]->TXOPlimit = txoplimit;
	return 0;
}
int WID_QOS_SET_QOS_WMM_MAP(int ID,int isadd)
{
	int i,j;

	if(isadd)
	{
		for(i=0;i<4;i++)
		{
			WID_QOS[ID]->radio_qos[i]->mapstate = 1;

			WID_QOS[ID]->radio_qos[i]->wmm_map_dot1p = 0;
			WID_QOS[ID]->radio_qos[i]->dot1p_map_wmm_num = 0;
			for(j=0;j<8;j++)
			{
				WID_QOS[ID]->radio_qos[i]->dot1p_map_wmm[j] = 0;
			}
		}
	}
	else
	{
		for(i=0;i<4;i++)
		{
			WID_QOS[ID]->radio_qos[i]->mapstate = 0;
			WID_QOS[ID]->radio_qos[i]->wmm_map_dot1p = 0;
			WID_QOS[ID]->radio_qos[i]->dot1p_map_wmm_num = 0;
			for(j=0;j<8;j++)
			{
				WID_QOS[ID]->radio_qos[i]->dot1p_map_wmm[j] = 0;
			}
		}
	}

	
	return 0;
}
int WID_QOS_SET_QOS_WMM_MAP_DOT1P(int ID,int wmm_order,unsigned char dot1p)
{
	

	WID_QOS[ID]->radio_qos[wmm_order]->wmm_map_dot1p = dot1p;

	return 0;
}
int WID_QOS_SET_QOS_DOT1P_MAP_WMM(int ID,int wmm_order,unsigned char num,unsigned char dot1p[])
{
	int i;
	//printf("num %d\n",num);
	WID_QOS[ID]->radio_qos[wmm_order]->dot1p_map_wmm_num = num;

	
	for(i=0;i<num;i++)
	{	//printf("i %d num %d\n",i,dot1p[i]);
		WID_QOS[ID]->radio_qos[wmm_order]->dot1p_map_wmm[i] = dot1p[i];

	}
	
	
	return 0;
}


int WID_ADD_RADIO_APPLY_QOS(unsigned int RadioID,int qosID,int qosstate)
{
	msgq msg;

	if((gWTPs[AC_RADIO[RadioID]->WTPID].currentState == CW_ENTER_RUN)&&(AC_RADIO[RadioID]->AdStat == 2))
	{
		return RADIO_IS_DISABLE;
	}
	
	int WTPIndex = AC_RADIO[RadioID]->WTPID;
	int l_radio_id = AC_RADIO[RadioID]->Radio_L_ID;
	AC_RADIO[RadioID]->QOSID = qosID;
	AC_RADIO[RadioID]->QOSstate = qosstate;
	
	//add to control list
	if((AC_WTP[WTPIndex] != NULL)&&(AC_WTP[WTPIndex]->WTPStat == WID_RUN))
	{
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WTPIndex%THREAD_NUM+1;
		msg.mqinfo.WTPID = WTPIndex;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = Radio_S_TYPE;
		msg.mqinfo.u.RadioInfo.Radio_Op = Radio_Qos;
		msg.mqinfo.u.RadioInfo.Radio_L_ID = l_radio_id;
		msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
		msg.mqinfo.u.RadioInfo.id1 = qosID;
		if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
		{
			wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
		}
	}
	
	return 0;
}
int wid_set_qos_flow_parameter_value(unsigned int qosid,unsigned char streamid,unsigned int type,unsigned int value)
{
	unsigned int stream_index = 4;
	wid_syslog_debug_debug(WID_DEFAULT,"qosid %d streamid %d type %d value %d \n",qosid,streamid,type,value);
	if((qosid < 1)||(qosid >15))
	{
		return WID_QOS_NOT_EXIST;
	}
	if(streamid >3)
	{
		return WID_QOS_STREAM_ERROR;
	}
	
	switch(streamid)
	{
		case WID_BESTEFFORT : stream_index= 0;
							break;
		case WID_BACKGTOUND: stream_index= 1;
							break;
		case WID_VIDEO: stream_index= 2;
						break;
		case WID_VOICE: stream_index= 3;
						break;
		default : break;
	}
	wid_syslog_debug_debug(WID_DEFAULT,"streamid %d stream_index %d value %d \n",streamid,stream_index,value);
	
	switch(type)
	{
		case averagerate_type : 
								WID_QOS[qosid]->radio_qos[stream_index]->qos_average_rate = value;
								break;

		case max_burstiness_type: 
			
								WID_QOS[qosid]->radio_qos[stream_index]->qos_max_degree = value;
								break;

		case manage_priority_type: 
	
								WID_QOS[qosid]->radio_qos[stream_index]->qos_policy_pri = value;
								break;

		case shove_priority_type: 
	
								WID_QOS[qosid]->radio_qos[stream_index]->qos_res_shove_pri = value;
								break;

		case grab_priority_type: 
	
								WID_QOS[qosid]->radio_qos[stream_index]->qos_res_grab_pri = value;
								break;

		case max_parallel_type:
			
								WID_QOS[qosid]->radio_qos[stream_index]->qos_max_parallel = value;
								break;
		case bandwidth_type:
			
								WID_QOS[qosid]->radio_qos[stream_index]->qos_bandwidth = value;
								break;
		case bandwidth_percentage_type:
			
								WID_QOS[qosid]->radio_qos[stream_index]->qos_bandwidth_scale = value;
								break;
		case flowqueuelenth_type:
			
								WID_QOS[qosid]->radio_qos[stream_index]->qos_flow_max_queuedepth= value;
								break;
		case flowaveragerate_type:
			
								WID_QOS[qosid]->radio_qos[stream_index]->qos_flow_average_rate = value;
								break;
		case flowmaxburstiness_type:
			
								WID_QOS[qosid]->radio_qos[stream_index]->qos_flow_max_degree= value;
								break;
		case unkonwn_type: break;

		default : break;
	}
	return WID_DBUS_SUCCESS;
}
int wid_set_qos_flow_able_value(unsigned int qosid,unsigned char streamid,unsigned int able_type,unsigned int flag)
{
	unsigned int stream_index = 4;
	wid_syslog_debug_debug(WID_DEFAULT,"qosid %d streamid %d abletype %d \n",qosid,streamid,able_type);
	if((qosid < 1)||(qosid >15))
	{
		return WID_QOS_NOT_EXIST;
	}
	if(streamid >3)
	{
		return WID_QOS_STREAM_ERROR;
	}
	
	switch(streamid)
	{
		case WID_BESTEFFORT : stream_index= 0;
							break;
		case WID_BACKGTOUND: stream_index= 1;
							break;
		case WID_VIDEO: stream_index= 2;
						break;
		case WID_VOICE: stream_index= 3;
						break;
		default : break;
	}
	wid_syslog_debug_debug(WID_DEFAULT,"streamid %d stream_index %d abletype %d \n",streamid,stream_index,able_type);

	if(flag == 1){
		WID_QOS[qosid]->radio_qos[stream_index]->qos_use_traffic_shaping = able_type;
	}
	else if(flag == 2){
		WID_QOS[qosid]->radio_qos[stream_index]->qos_use_flow_eq_queue = able_type;
	}else if(flag == 3){
		WID_QOS[qosid]->radio_qos[stream_index]->qos_use_wred = able_type;
	}else{}
	return WID_DBUS_SUCCESS;
}

int wid_set_qos_parameter_value(unsigned int qosid,unsigned int type,unsigned int value)
{
	
	wid_syslog_debug_debug(WID_DEFAULT,"qosid %d type %d value %d \n",qosid,type,value);
	if((qosid < 1)||(qosid >15))
	{
		return WID_QOS_NOT_EXIST;
	}
	
	switch(type)
	{
		case totalbandwidth_type : 
								WID_QOS[qosid]->qos_total_bandwidth = value;
								break;

		case resourcescale_type : 
			
								WID_QOS[qosid]->qos_res_scale = value;
								break;

		case sharebandwidth_type : 
	
								WID_QOS[qosid]->qos_share_bandwidth = value;
								break;

		case resourcesharescale_type : 
	
								WID_QOS[qosid]->qos_res_share_scale= value;
								break;

		case unkonwn_type: break;

		default : break;
	}
	return WID_DBUS_SUCCESS;
}

int wid_radio_set_throughout(int wtpid, unsigned char bandwidth)
{
	msgq msg;
	AC_WTP[wtpid]->WTP_Radio[0]->bandwidth = bandwidth;
	
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPStat == 5))
	{
		AC_WTP[wtpid]->WTP_Radio[0]->CMD |= 0x0800;
		AC_WTP[wtpid]->CMD->radioid[0] += 1;
		AC_WTP[wtpid]->CMD->setCMD = 1;	
		int WTPIndex = wtpid;
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_Throughput;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = 0;// waiting M-Radio
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
				perror("msgsnd");
			}

		}		
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}
	
	return 0;	

}
int wid_mul_radio_set_throughout(unsigned int radioid, unsigned char bandwidth)
{
	msgq msg;
	unsigned int wtpid = 0;
	unsigned int l_radioid = 0;
	wtpid = radioid/L_RADIO_NUM;
	l_radioid = radioid%L_RADIO_NUM;
	if(AC_WTP[wtpid] == NULL)
	{
		return WTP_ID_NOT_EXIST;
	}
	if(AC_WTP[wtpid]->WTP_Radio[l_radioid] == NULL)
	{
		return RADIO_ID_NOT_EXIST;
	}
	if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->bandwidth == bandwidth)
	{
		return 0;
	}
	AC_WTP[wtpid]->WTP_Radio[l_radioid]->bandwidth = bandwidth;
	
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPStat == 5))
	{
		AC_WTP[wtpid]->WTP_Radio[l_radioid]->CMD |= 0x0800;
		AC_WTP[wtpid]->CMD->radioid[l_radioid] += 1;
		AC_WTP[wtpid]->CMD->setCMD = 1;	
		int WTPIndex = wtpid;
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_Throughput;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = l_radioid;//M-Radio
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
				perror("msgsnd");
			}

		}		
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}
	
	return 0;	

}

int wid_update_ap_config(int wtpid,char *ip)
{
	char *command;
	command = (char *)malloc(sizeof(char)*50);
	memset(command,0,50);
	sprintf(command,"cd /jffs && tftp -g -r config.wtp %s",ip);
	wid_syslog_debug_debug(WID_DEFAULT,"command %s\n",command);
	//printf("command %s\n",command);
	wid_radio_set_extension_command(wtpid,command);
	CW_FREE_OBJECT(command);
	time(&AC_WTP[wtpid]->config_update_time);
	return 0;	

}

int wid_set_ap_timestamp(int timestamp)
{

	int i = 0;
	msgq msg;
	for(i=0; i<WTP_NUM; i++)
	{
		if((AC_WTP[i] != NULL)&&(AC_WTP[i]->WTPStat == 5))
		{
	//		printf("## wid_set_ap_timestamp wtp id= %d##\n",i);
			
			AC_WTP[i]->WTP_Radio[0]->CMD |= 0x2000;
			AC_WTP[i]->CMD->radioid[0] += 1;
			AC_WTP[i]->CMD->setCMD = 1;	
			int WTPIndex = i;
			CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
			if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
			{
				memset((char*)&msg, 0, sizeof(msg));
				msg.mqid = WTPIndex%THREAD_NUM+1;
				msg.mqinfo.WTPID = WTPIndex;
				msg.mqinfo.type = CONTROL_TYPE;
				msg.mqinfo.subtype = WTP_S_TYPE;
				msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_TIMESTAMP;
				
				if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
					wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
					perror("msgsnd");
				}
			}		
			CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));			
								
			//if(gtrapflag>=4){
			//	wid_dbus_trap_wtp_ap_ACTimeSynchroFailure(i);
			//}
		}
	
	}
	return 0;

}

int wid_radio_set_extension_command(int wtpid, char *command)
{
	msgq msg;
	struct msgqlist *elem = NULL;
	int WTPIndex = wtpid;
	
	CW_FREE_OBJECT(AC_WTP[wtpid]->WTP_Radio[0]->excommand);	
	AC_WTP[wtpid]->WTP_Radio[0]->excommand = (char*)malloc(strlen(command)+1);
	memset(AC_WTP[wtpid]->WTP_Radio[0]->excommand, 0, strlen(command)+1);
	memcpy(AC_WTP[wtpid]->WTP_Radio[0]->excommand, command, strlen(command));

	if((strlen(command) == 8)&&(strcmp(command, "poweroff") == 0))
	{
			
		if(gtrapflag>=1){
			#if NOSOFTAC
			wid_dbus_trap_wtp_ap_power_off(wtpid);
			#endif
		}
	}
	if((strlen(command) == 9)&&(strcmp(command, "sysreboot") == 0))
	{
		if(gtrapflag >= 1)
		{
		#if NOSOFTAC
			wid_dbus_trap_wtp_ap_reboot(wtpid);
		#endif
		}
	}
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPStat == WID_RUN))
	{
		AC_WTP[wtpid]->WTP_Radio[0]->CMD |= 0x0400;
		AC_WTP[wtpid]->CMD->radioid[0] += 1;
		AC_WTP[wtpid]->CMD->setCMD = 1;	
		int WTPIndex = wtpid;
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_EXTEND_CMD;
			memcpy(msg.mqinfo.u.WtpInfo.value, command, strlen(command));
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
				perror("msgsnd");
			}
		}		
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}
	else if((AC_WTP[wtpid] != NULL))
	{
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WTPIndex%THREAD_NUM+1;
		msg.mqinfo.WTPID = WTPIndex;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WTP_S_TYPE;
		msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_EXTEND_CMD;
		memcpy(msg.mqinfo.u.WtpInfo.value, command, strlen(command));

		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if(elem == NULL)
		{
			wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
			perror("malloc");
			return 0;
		}
		memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
		elem->next = NULL;
		memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
		WID_INSERT_CONTROL_LIST(wtpid, elem);
	}
	
	return 0;	
}

int wid_radio_set_option60_parameter(int wtpid, char * parameter)
{
	msgq msg;
	struct msgqlist *elem = NULL;
	int WTPIndex = wtpid;
	
	CW_FREE_OBJECT(AC_WTP[WTPIndex]->option60_param);
	AC_WTP[WTPIndex]->option60_param = (char *)malloc(strlen(parameter)+1);
	memset(AC_WTP[WTPIndex]->option60_param,0,(strlen(parameter)+1));
	memcpy(AC_WTP[WTPIndex]->option60_param,parameter,strlen(parameter));
	
	if((AC_WTP[WTPIndex] != NULL)&&(AC_WTP[WTPIndex]->WTPStat == WID_RUN))
	{
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_OPTION60_PARAM;
			memcpy(msg.mqinfo.u.WtpInfo.value, parameter, strlen(parameter));
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
				perror("msgsnd");
			}
		}		
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}
	else if((AC_WTP[wtpid] != NULL))
	{
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WTPIndex%THREAD_NUM+1;
		msg.mqinfo.WTPID = WTPIndex;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WTP_S_TYPE;
		msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_OPTION60_PARAM;
		memcpy(msg.mqinfo.u.WtpInfo.value, parameter, strlen(parameter));

		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if(elem == NULL){
			wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
			perror("malloc");
			return 0;
		}
		memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
		elem->next = NULL;
		memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
		WID_INSERT_CONTROL_LIST(wtpid, elem);
	}
	
	return 0;	
}

int wid_trap_remote_restart(unsigned int wtpid)
{
	if(AC_WTP[wtpid] == NULL)
	{
		return -1;
	}
	char *command = NULL;
	command = (char *)malloc(sizeof(char)*10);
	memset(command, 0, 10);
	strncpy(command, "sysreboot", 9);
	wid_syslog_debug_debug(WID_DEFAULT,"sysreboot %s\n",command);

	if(gtrapflag >= 4)
	{
#if NOSOFTAC
		wid_dbus_trap_set_wtp_remote_restart(wtpid);
#endif
	}
	wid_radio_set_extension_command(wtpid,command);
	
	CW_FREE_OBJECT(command);
	
	return 0;
}

int wid_trap_channel_disturb_enable(unsigned int wtpid)
{
	if(AC_WTP[wtpid] == NULL)
	{
		return -1;
	}
	char *command = NULL;
	command = (char *)malloc(sizeof(char)*27);
	memset(command,0,27);
	strncpy(command,"touch /tmp/disturb_warning",26);

	char *command2;
	command2 = (char *)malloc(sizeof(char)*30);
	memset(command2,0,30);
	strncpy(command2,"echo 1 > /tmp/disturb_warning",29);
	
	//wid_radio_set_extension_command(wtpid,command);
	wid_radio_set_extension_command(wtpid,command2);
	CW_FREE_OBJECT(command);
	CW_FREE_OBJECT(command2);
	
	return 0;
}

int wid_trap_channel_disturb_disable(unsigned int wtpid)
{
	if(AC_WTP[wtpid] == NULL)
	{
		return -1;
	}
	char *command = NULL;
	command = (char *)malloc(sizeof(char)*30);
	memset(command,0,30);
	strncpy(command,"echo 0 > /tmp/disturb_warning",29);
	wid_radio_set_extension_command(wtpid,command);
	CW_FREE_OBJECT(command);
	
	return 0;
}

int wid_set_ap_l2_isolation_enable(unsigned int wtpid,unsigned char wlanid)
{
	if(AC_WTP[wtpid] == NULL)
	{
		return -1;
	}
	int i = 0;
	int ret = 0;
	for (i = 0; i < L_BSS_NUM; i++)
	{
		if(AC_WTP[wtpid]->mib_info.wlan_l2isolation[i].wlanid == wlanid)
		{
			return -2;
		}
	}
	
	for (i = 0; i < L_BSS_NUM; i++)
	{
		if(AC_WTP[wtpid]->mib_info.wlan_l2isolation[i].wlanid == 0)
		{
			AC_WTP[wtpid]->mib_info.wlan_l2isolation[i].wlanid = wlanid;
			AC_WTP[wtpid]->mib_info.wlan_l2isolation[i].l2_isolation_switch = 1;
			ret = 1;
			break;
		}
	}
	if(ret == 0)
	{
		return -1;
	}
	char *command = NULL;
	command = (char *)malloc(sizeof(char)*25);
	memset(command, 0, 25);
	sprintf(command,"iwpriv ath%d ap_bridge 0",wlanid);//0 means open isolation,sta can not ping
	wid_syslog_debug_debug(WID_DEFAULT,"command %s\n",command);
	wid_radio_set_extension_command(wtpid,command);
	CW_FREE_OBJECT(command);
	
	return 0;
}

int wid_set_ap_l2_isolation_disable(unsigned int wtpid,unsigned char wlanid)
{
	if(AC_WTP[wtpid] == NULL)
	{
		return -1;
	}
	int i = 0;
	int ret = 0;
	
	for (i = 0; i < L_BSS_NUM; i++)
	{
		if(AC_WTP[wtpid]->mib_info.wlan_l2isolation[i].wlanid == wlanid)
		{
			AC_WTP[wtpid]->mib_info.wlan_l2isolation[i].wlanid = 0;
			AC_WTP[wtpid]->mib_info.wlan_l2isolation[i].l2_isolation_switch = 0;
			ret = 1;
			break;
		}
	}
	if(ret == 0)
	{
		return -2;									/*xiaodawei modify for l2 isolation disable already, 20101207*/
	}
	
	char *command = NULL;
	command = (char *)malloc(sizeof(char)*25);
	memset(command,0,25);
	sprintf(command,"iwpriv ath%d ap_bridge 1",wlanid);
	wid_syslog_debug_debug(WID_DEFAULT,"command %s\n",command);
	wid_radio_set_extension_command(wtpid,command);
	CW_FREE_OBJECT(command);
	
	return 0;
}

int wid_set_radio_l2_isolation_enable(unsigned int wtpid,unsigned int radioid,unsigned char wlanid)
{
	if(AC_WTP[wtpid] == NULL)
	{
		return -1;
	}
	int bssindex = 0;
	bssindex = AC_WLAN[wlanid]->S_WTP_BSS_List[wtpid][radioid];
	if((bssindex != 0)&&(check_bssid_func(bssindex)))
	{
		if(AC_BSS[bssindex]->ath_l2_isolation == 1)
		{
			return 0;
		}
		else
		{
			AC_BSS[bssindex]->ath_l2_isolation = 1;
		}
	}
	
	char *command = NULL;
	command = (char *)malloc(sizeof(char)*28);
	memset(command,0,28);
	sprintf(command,"iwpriv ath.%d-%d ap_bridge 0",radioid,wlanid);//0 means open isolation,sta can not ping
	wid_syslog_debug_debug(WID_DEFAULT,"command %s\n",command);
	wid_radio_set_extension_command(wtpid,command);
	CW_FREE_OBJECT(command);
	
	return 0;
}
int wid_set_radio_l2_isolation_disable(unsigned int wtpid,unsigned int radioid,unsigned char wlanid)
{
	if(AC_WTP[wtpid] == NULL)
	{
		return -1;
	}
	int bssindex = 0;
	bssindex = AC_WLAN[wlanid]->S_WTP_BSS_List[wtpid][radioid];
	if((bssindex != 0)&&(check_bssid_func(bssindex)))
	{
		if(AC_BSS[bssindex]->ath_l2_isolation == 0)
		{
			return 0;
		}
		else
		{
			AC_BSS[bssindex]->ath_l2_isolation = 0;
		}
	}
	
	char *command = NULL;
	command = (char *)malloc(sizeof(char)*28);
	memset(command,0,28);
	sprintf(command,"iwpriv ath.%d-%d ap_bridge 1",radioid,wlanid);
	wid_syslog_debug_debug(WID_DEFAULT,"command %s\n",command);
	wid_radio_set_extension_command(wtpid,command);
	CW_FREE_OBJECT(command);
	
	return 0;
}

int wid_set_radio_11n_cwmmode(unsigned int wtpid,unsigned int radioid,unsigned char wlanid,unsigned char policy)
{
	if(AC_WTP[wtpid] == NULL)
	{
		return -1;
	}
	int bssindex = 0;
	bssindex = AC_WLAN[wlanid]->S_WTP_BSS_List[wtpid][radioid];
	
	if(!check_bssid_func(bssindex))
	{
		wid_syslog_err("<error>%s\n",__func__);
		return BSS_NOT_EXIST;
	}
	
	if(AC_BSS[bssindex]->cwmmode == policy)
	{
		return 0;
	}
	char *command = NULL;
	command = (char *)malloc(sizeof(char)*32);
	memset(command,0,32);
	sprintf(command,"iwpriv ath.%d-%d cwmmode %d",radioid,wlanid,policy);//0 means 20 mode;1 means 20/40 mode
	wid_syslog_debug_debug(WID_DEFAULT,"command %s\n",command);
	wid_radio_set_extension_command(wtpid,command);
	CW_FREE_OBJECT(command);

	AC_BSS[bssindex]->cwmmode = policy;
	return 0;
}

int wid_set_ap_dos_def_enable(unsigned int wtpid)
{
	if(AC_WTP[wtpid] == NULL)
	{
		return -1;
	}
	AC_WTP[wtpid]->mib_info.dos_def_switch = 1;
	char *command;
	command = (char *)malloc(sizeof(char)*13);
	memset(command,0,13);
	strncpy(command,"dosdef start",12);
	wid_syslog_debug_debug(WID_DEFAULT,"command %s\n",command);
	wid_radio_set_extension_command(wtpid,command);
	CW_FREE_OBJECT(command);
	return 0;
}
int wid_set_ap_dos_def_disable(unsigned int wtpid)
{
	if(AC_WTP[wtpid] == NULL)
	{
		return -1;
	}
	AC_WTP[wtpid]->mib_info.dos_def_switch = 0;
	char *command = NULL;
	command = (char *)malloc(sizeof(char)*12);
	memset(command,0,12);
	strncpy(command,"dosdef stop",11);

	wid_radio_set_extension_command(wtpid,command);
	CW_FREE_OBJECT(command);
	return 0;
}
int wid_set_ap_igmp_snoop_enable(unsigned int wtpid)
{
	if(AC_WTP[wtpid] == NULL)
	{
		return -1;
	}
	AC_WTP[wtpid]->mib_info.igmp_snoop_switch = 1;
	char *command;
	command = (char *)malloc(sizeof(char)*17);
	memset(command,0,17);
	strncpy(command,"igmp_snoop start",16);
	wid_syslog_debug_debug(WID_DEFAULT,"command %s\n",command);
	wid_radio_set_extension_command(wtpid,command);
	CW_FREE_OBJECT(command);
	return 0;
}
int wid_set_ap_igmp_snoop_disable(unsigned int wtpid)
{
	if(AC_WTP[wtpid] == NULL)
	{
		return -1;
	}
	AC_WTP[wtpid]->mib_info.igmp_snoop_switch = 0;
	char *command;
	command = (char *)malloc(sizeof(char)*16);
	memset(command,0,16);
	strncpy(command,"igmp_snoop stop",15);
	wid_syslog_debug_debug(WID_DEFAULT,"command %s\n",command);
	wid_radio_set_extension_command(wtpid,command);
	CW_FREE_OBJECT(command);
	return 0;
}

void channel_interference_detected(int wtpid)
{
	unsigned char currentchannel = AC_WTP[wtpid]->WTP_Radio[0]->Radio_Chan;
	int i = 0;
	int channel_1 =0,channel_6 =0,channel_11 =0;
	int findrougeap = 0;
	unsigned char same_channel_flag = 0;
	unsigned char neighbor_channel_flag = 0;
	unsigned char mac[MAC_LEN] = {0};
	
	Neighbor_AP_INFOS *p_aplist =  AC_WTP[wtpid]->NeighborAPInfos[0];
	struct Neighbor_AP_ELE *phead = p_aplist->neighborapInfos;

	for(i=0; ((phead != NULL)||(i<p_aplist->neighborapInfosCount)); i++)
	{
		if(phead->Channel == currentchannel)
		{
			//trap APInterferenceDetected
			memset(mac,0,MAC_LEN);
			mac[0] = phead->BSSID[0];
			mac[1] = phead->BSSID[1];
			mac[2] = phead->BSSID[2];
			mac[3] = phead->BSSID[3];
			mac[4] = phead->BSSID[4];
			mac[5] = phead->BSSID[5];
			wid_syslog_debug_debug(WID_DEFAULT,"%02X-%02X-%02X-%02X-%02X-%02X\n",mac[0],mac[1],mac[2],mac[3],mac[4],mac[5]);
			if(gtrap_channel_device_interference_switch == 1)
			    if(gtrapflag >= 24)
    			{
    				if(AC_WTP[wtpid]->channel_device_interference_flag == 0)    //fengwenchao add 20110221
    				{
    					wid_dbus_trap_wtp_channel_device_interference(wtpid,currentchannel,mac);
    					AC_WTP[wtpid]->channel_device_interference_flag = 1;   //fengwenchao add 20110221
    				}
    			}
			
			if((phead->IEs_INFO != NULL)&&(strncmp(phead->IEs_INFO,"E",1)==0))
			{
				//trapAP  APInterferenceDetected
				/*zhaoruijia,20100825, ,start*/
				if(gtrap_channel_device_ap_switch == 1)
				{
					if(((phead->RSSI-95) - AC_WTP[wtpid]->samechannelrssithold)>0)
					{
					    if(gtrapflag >= 24)
					    {
						    if(AC_WTP[wtpid]->samechannel_trap_flag == 0)     //fengwenchao add 20110221
							{
							    wid_dbus_trap_wtp_channel_ap_interference(wtpid,currentchannel,mac);
							    AC_WTP[wtpid]->samechannel_trap_flag = 1;
							}
						}
						same_channel_flag = 1;
					}
				  /*zhaoruijia,20100825,,end*/
				}
				/*get neighbor ap sta info from asd*/
				if(phead->wtpid > 0)
				{
					wid_syslog_debug_debug(WID_DEFAULT,"rogue_terminal,phead->wtpid=%d,%s\n",phead->wtpid,__func__);
					Asd_neighbor_ap_sta_check_op(wtpid,phead->wtpid,mac,WTP_STA_CHECK);
				}
			}
			else if((phead->IEs_INFO != NULL)&&(strncmp(phead->IEs_INFO,"I",1)==0))
			{
				//trap  StaInterferenceDetected
				if(gtrapflag >= 24)
				{
					if((gtrap_channel_terminal_interference_switch == 1)&&(AC_WTP[wtpid]->wtp_rogue_terminal_threshold>=1))
						if(AC_WTP[wtpid]->wid_trap.rogue_terminal_trap_flag == 0)  //fengwenchao add 20110221
						{
							wid_dbus_trap_wtp_channel_terminal_interference(wtpid,0,currentchannel,mac);	
							AC_WTP[wtpid]->wid_trap.rogue_terminal_trap_flag = 1;   //fengwenchao add 20110221
						}
				}
			}
			else
			{
			}
			
		}
		else if((phead->Channel == (currentchannel-1))||(phead->Channel == (currentchannel+1)))
		{
			/*zhaoruijia,20100825,,start*/
			if(((phead->RSSI-95) - AC_WTP[wtpid]->neighborchannelrssithold )>0)
			{
				if(gtrapflag>=24)
				{
					if(AC_WTP[wtpid]->neighborchannel_trap_flag == 0)  //fengwenchao add 20110221
					{
						wid_dbus_trap_wtp_neighbor_channel_ap_interference(wtpid,currentchannel,mac,0);
						AC_WTP[wtpid]->neighborchannel_trap_flag = 1;
					}
				}
				neighbor_channel_flag = 1;
			}
			/*zhaoruijia,20100825,,end*/
		}

		if(phead->wtpid == 0)    
		{
			findrougeap = 1;
		}
		
		if(phead->Channel == 1)
		{
			channel_1 = 1;
		}
		else if(phead->Channel == 6)
		{
			channel_6 = 1;
		}
		else if(phead->Channel == 11)
		{
			channel_11= 1;
		}
		else
		{
		}
		
		phead = phead->next;
		
	}

	//printf("same_channel_flag %d\n",same_channel_flag);
	//printf("AC_WTP[%d]->samechannel_trap_flag %d\n",wtpid,AC_WTP[wtpid]->samechannel_trap_flag);
	//printf("neighbor_channel_flag %d\n",neighbor_channel_flag);
	//printf("AC_WTP[%d]->neighborchannel_trap_flag %d\n",wtpid,AC_WTP[wtpid]->neighborchannel_trap_flag);

	
		
		if(same_channel_flag == 0){
			if(AC_WTP[wtpid]->samechannel_trap_flag == 1){
				#if NOSOFTAC
				wid_dbus_trap_wtp_channel_ap_interference_clear(wtpid,currentchannel);
				#endif
				AC_WTP[wtpid]->samechannel_trap_flag = 0;
			}
		}
		if(neighbor_channel_flag == 0){
			if(AC_WTP[wtpid]->neighborchannel_trap_flag == 1){
				#if NOSOFTAC
				wid_dbus_trap_wtp_neighbor_channel_ap_interference(wtpid,currentchannel,mac,1);
				#endif
				AC_WTP[wtpid]->neighborchannel_trap_flag = 0;
			}
		}
	
		if((channel_1 == 1)&&(channel_6 == 1)&&(channel_11 == 1))
		{
			//  DFSFreeCountBelowThreshold 
			//trap
			if(gtrap_channel_count_minor_switch == 1)
				if(gtrapflag>=4){
					if(AC_WTP[wtpid]->channel_count_minor_flag == 0)    //fengwenchao add 20110221
					{
						#if NOSOFTAC
						wid_dbus_trap_wtp_channel_count_minor(wtpid);
						#endif
						AC_WTP[wtpid]->channel_count_minor_flag = 1;  //fengwenchao add 20110221
					}
				}
		}
		else
		{
			if(gtrapflag>=4){
				if(AC_WTP[wtpid]->channel_count_minor_flag == 1)    //fengwenchao add 20110221
				{
					#if NOSOFTAC
					wid_dbus_trap_wtp_channel_count_minor_clear(wtpid);
					#endif
					AC_WTP[wtpid]->channel_count_minor_flag = 0;  //fengwenchao add 20110221
				}
			}
		}
		unsigned char now_rssi = 0;           //fengwenchao add 20110507
		struct Neighbor_AP_ELE *p_head = p_aplist->neighborapInfos; //fengwenchao add 20110507
		struct Neighbor_AP_ELE * IGNORE_UBSV p_rssi = p_aplist->neighborapInfos;       //fengwenchao add 20110507
		if(findrougeap == 1)
		{
			if(gtrapflag>=4){
				if(AC_WTP[wtpid]->ac_discovery_danger_ap_flag == 1)   //fengwenchao add 20110221
					{
						/*fengwenchao add 20110507*/
						for(i=0; ((p_head != NULL)&&(i<p_aplist->neighborapInfosCount)); i++)
						{
							if(p_head->wtpid == 0)
							{
								if(p_head->RSSI   >  now_rssi)
								{
									now_rssi = p_head->RSSI;
									p_rssi = p_head;
								}
							}
							p_head = p_head->next;
						}
						/*fengwenchao add end*/
						#if NOSOFTAC
						wid_dbus_trap_wtp_ac_discovery_danger_ap(wtpid,p_rssi);   //fengwenchao modify 20110509
						#endif
						AC_WTP[wtpid]->ac_discovery_danger_ap_flag = 0;    //fengwenchao add 20110221
					}
				}
		}
	}

int wid_send_to_ap_extension_infomation(unsigned int wtpid)
{
	msgq msg;
	struct msgqlist *elem;
	//if(gWTPs[wtpid].currentState != CW_ENTER_RUN)
	{
		//return WTP_NOT_IN_RUN_STATE;
	}

		
	if(AC_WTP[wtpid]->WTPStat == WID_RUN)
	{
		AC_WTP[wtpid]->WTP_Radio[0]->CMD |= 0x4000;
		AC_WTP[wtpid]->CMD->radioid[0] += 1;
		AC_WTP[wtpid]->CMD->setCMD = 1;	
		
		CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));
		if(gWTPs[wtpid].isNotFree && (gWTPs[wtpid].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = wtpid%THREAD_NUM+1;
			msg.mqinfo.WTPID = wtpid;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_EXTEND_INFO_GET;
			
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}
		CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));
	}
	else if((AC_WTP[wtpid] != NULL)){
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = wtpid%THREAD_NUM+1;
			msg.mqinfo.WTPID = wtpid;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_EXTEND_INFO_GET;
			
			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if(elem == NULL){
				wid_syslog_info("%s malloc %s",__func__,strerror(errno));
				perror("malloc");
				return 0;
			}
			memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
			elem->next = NULL;
			memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
			WID_INSERT_CONTROL_LIST(wtpid, elem);
		}

	return 0;
	
}

int wid_send_to_ap_sta_deauth_report(unsigned int wtpid)
{
	wid_syslog_debug_debug(WID_DEFAULT,"in func %s :  set %d wtp deauth %s",__func__,wtpid,AC_WTP[wtpid]->sta_deauth_message_reportswitch?"enable":"disable");
	msgq msg;
	struct msgqlist *elem;	
	if(AC_WTP[wtpid]->WTPStat == WID_RUN)
	{		
		CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));
		if(gWTPs[wtpid].isNotFree && (gWTPs[wtpid].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = wtpid%THREAD_NUM+1;
			msg.mqinfo.WTPID = wtpid;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_DEAUTH_SWITCH;
			
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}
		CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));
	}
	else if((AC_WTP[wtpid] != NULL)){
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = wtpid%THREAD_NUM+1;
			msg.mqinfo.WTPID = wtpid;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_DEAUTH_SWITCH;
			
			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if(elem == NULL){
				wid_syslog_info("%s malloc %s",__func__,strerror(errno));
				perror("malloc");
				return 0;
			}
			memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
			elem->next = NULL;
			memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
			WID_INSERT_CONTROL_LIST(wtpid, elem);
		}

	return 0;
	
}
//
int wid_send_to_ap_sta_flow_information_report(unsigned int wtpid)
{
	wid_syslog_debug_debug(WID_DEFAULT,"in func %s :  set %d wtp flow information %s",__func__,wtpid,AC_WTP[wtpid]->sta_flow_information_reportswitch?"enable":"disable");
	msgq msg;
	struct msgqlist *elem;	
	if(AC_WTP[wtpid]->WTPStat == WID_RUN)
	{		
		CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));
		if(gWTPs[wtpid].isNotFree && (gWTPs[wtpid].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = wtpid%THREAD_NUM+1;
			msg.mqinfo.WTPID = wtpid;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_FLOW_INFORMATION_SWITCH;
			
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}
		CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));
	}
	else if((AC_WTP[wtpid] != NULL)){
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = wtpid%THREAD_NUM+1;
			msg.mqinfo.WTPID = wtpid;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_FLOW_INFORMATION_SWITCH;
			
			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if(elem == NULL){
				wid_syslog_info("%s malloc %s",__func__,strerror(errno));
				perror("malloc");
				return 0;
			}
			memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
			elem->next = NULL;
			memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
			WID_INSERT_CONTROL_LIST(wtpid, elem);
		}

	return 0;
	
}


int WID_RADIO_WLAN_PACKET_POWER(unsigned int wtpid, unsigned char radioid, unsigned char wlanid, unsigned char state)
{
	char buf[DEFAULT_LEN] = {0};
	
	memset(buf, 0, DEFAULT_LEN);
	snprintf(buf, DEFAULT_LEN, AP_EXT_CMD_SET_RADIO_WLAN_PKTPWR, radioid, wlanid, state);
	wid_syslog_debug_debug(WID_DEFAULT, "set wtp %d radio %d wlan %d packet power %s\n",
											wtpid,radioid,wlanid,state?"enable":"disable");
	wid_radio_set_extension_command(wtpid, buf);
	return 0;
}


/* zhangshu add for Terminal Disturb Info Report, 2010-10-08 */
int wid_send_to_ap_Terminal_Disturb_info(unsigned int wtpid)
{
	msgq msg;
	struct msgqlist *elem;
		
	if(AC_WTP[wtpid]->WTPStat == WID_RUN)
	{
		AC_WTP[wtpid]->WTP_Radio[0]->CMD |= 0x4000;
		AC_WTP[wtpid]->CMD->radioid[0] += 1;
		AC_WTP[wtpid]->CMD->setCMD = 1;	
		
		CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));
		if(gWTPs[wtpid].isNotFree && (gWTPs[wtpid].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = wtpid%THREAD_NUM+1;
			msg.mqinfo.WTPID = wtpid;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_TERMINAL_DISTRUB_INFO;
			
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
				wid_syslog_info("%s msgsend %s",__func__,strerror(errno));
			}
		}
		CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));
	}
	
	else if((AC_WTP[wtpid] != NULL)){
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = wtpid%THREAD_NUM+1;
			msg.mqinfo.WTPID = wtpid;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_TERMINAL_DISTRUB_INFO;
			
			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if(elem == NULL){
				wid_syslog_info("%s malloc %s",__func__,strerror(errno));
				perror("malloc");
				return 0;
			}
			memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
			elem->next = NULL;
			memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
			WID_INSERT_CONTROL_LIST(wtpid, elem);
		}

	return 0;
	
}


int setWtpNoRespToStaProReq(unsigned int wtpid,unsigned char l_radioid,unsigned char wlanid,unsigned int policy)
{
	msgq msg;
	struct msgqlist *elem;
	wid_syslog_debug_debug(WID_DBUS,"%s,%d,wtp %d l_radio %d wlan:%d,policy=%d.\n",__func__,__LINE__,wtpid,l_radioid,wlanid,policy);
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPStat == WID_RUN))
	{
		AC_WTP[wtpid]->WTP_Radio[0]->CMD |= 0x4000;
		AC_WTP[wtpid]->CMD->radioid[0] += 1;
		AC_WTP[wtpid]->CMD->setCMD = 1;	
		
		CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));
		if(gWTPs[wtpid].isNotFree && (gWTPs[wtpid].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = wtpid%THREAD_NUM+1;
			msg.mqinfo.WTPID = wtpid;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_NO_RESP_STA_PRO_REQ;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = l_radioid;
			msg.mqinfo.u.RadioInfo.id1 = policy;
			msg.mqinfo.u.RadioInfo.wlanid = wlanid;

			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
				wid_syslog_info("%s msgsend %s",__func__,strerror(errno));
			}
		}
		CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));
	}
	
	else if((AC_WTP[wtpid] != NULL)){
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = wtpid%THREAD_NUM+1;
			msg.mqinfo.WTPID = wtpid;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_NO_RESP_STA_PRO_REQ;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = l_radioid;
			msg.mqinfo.u.RadioInfo.id1 = policy;
			msg.mqinfo.u.RadioInfo.wlanid = wlanid;
			
			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if(elem == NULL){
				wid_syslog_info("%s malloc %s",__func__,strerror(errno));
				perror("malloc");
				return 0;
			}
			memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
			elem->next = NULL;
			memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
			WID_INSERT_CONTROL_LIST(wtpid, elem);
		}

	return 0;
	
}


int setWtpUniMutiBroCastIsolation(unsigned int wtpid,unsigned char radioid,unsigned char wlanid,unsigned char policy)
{
	msgq msg;
	struct msgqlist *elem;
	wid_syslog_debug_debug(WID_DBUS,"%s,%d,radio %d wlan:%d,policy=%d.\n",__func__,__LINE__,radioid,wlanid,policy);
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPStat == WID_RUN))
	{
		AC_WTP[wtpid]->WTP_Radio[0]->CMD |= 0x4000;
		AC_WTP[wtpid]->CMD->radioid[0] += 1;
		AC_WTP[wtpid]->CMD->setCMD = 1;	
		
		CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));
		if(gWTPs[wtpid].isNotFree && (gWTPs[wtpid].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = wtpid%THREAD_NUM+1;
			msg.mqinfo.WTPID = wtpid;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_UNI_MUTIBRO_CAST_ISO_SW;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = radioid;
			msg.mqinfo.u.RadioInfo.wlanid = wlanid;
			msg.mqinfo.u.RadioInfo.id_char = policy;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
				wid_syslog_info("%s msgsend %s",__func__,strerror(errno));
			}
		}
		CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));
	}
	
	else if((AC_WTP[wtpid] != NULL)){
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = wtpid%THREAD_NUM+1;
			msg.mqinfo.WTPID = wtpid;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_UNI_MUTIBRO_CAST_ISO_SW;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = radioid;
			msg.mqinfo.u.RadioInfo.wlanid = wlanid;
			msg.mqinfo.u.RadioInfo.id_char = policy;
			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if(elem == NULL){
				wid_syslog_info("%s malloc %s",__func__,strerror(errno));
				perror("malloc");
				return 0;
			}
			memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
			elem->next = NULL;
			memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
			WID_INSERT_CONTROL_LIST(wtpid, elem);
		}

	return 0;
	
}

int setWtpUniMutiBroCastRate(unsigned int wtpid,unsigned char radioid,unsigned char wlanid,unsigned int rate)
{
	msgq msg;
	struct msgqlist *elem;
	wid_syslog_debug_debug(WID_DBUS,"%s,%d,radio %d wlan:%d,rate=%d.\n",__func__,__LINE__,radioid,wlanid,rate);
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPStat == WID_RUN))
	{
		AC_WTP[wtpid]->WTP_Radio[0]->CMD |= 0x4000;
		AC_WTP[wtpid]->CMD->radioid[0] += 1;
		AC_WTP[wtpid]->CMD->setCMD = 1;	
		
		CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));
		if(gWTPs[wtpid].isNotFree && (gWTPs[wtpid].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = wtpid%THREAD_NUM+1;
			msg.mqinfo.WTPID = wtpid;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_UNI_MUTIBRO_CAST_TATE;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = radioid;
			msg.mqinfo.u.RadioInfo.wlanid = wlanid;
			msg.mqinfo.u.RadioInfo.id1 = rate;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
				wid_syslog_info("%s msgsend %s",__func__,strerror(errno));
			}
		}
		CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));
	}
	
	else if((AC_WTP[wtpid] != NULL)){
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = wtpid%THREAD_NUM+1;
			msg.mqinfo.WTPID = wtpid;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_UNI_MUTIBRO_CAST_TATE;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = radioid;
			msg.mqinfo.u.RadioInfo.wlanid = wlanid;
			msg.mqinfo.u.RadioInfo.id1 = rate;
			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if(elem == NULL){
				wid_syslog_info("%s malloc %s",__func__,strerror(errno));
				perror("malloc");
				return 0;
			}
			memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
			elem->next = NULL;
			memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
			WID_INSERT_CONTROL_LIST(wtpid, elem);
		}

	return 0;
	
}

int uni_muti_bro_cast_rate_check(unsigned int wtpindex,unsigned int radioid,unsigned int rate){
	/*
	11b rate set1000 2000 5500 11000
	11g rate set1000 2000 5500 11000 6000 9000 12000 18000 24000 36000
						48000 54000
	11nght20 rate set1000 2000 5500 11000 6000 9000 12000 18000 24000 36000
							48000 54000
	11nght40/11nght40plus/11nght40minus 
	rate set1000 2000 5500 11000 6000 9000 12000 18000 24000 36000 48000 54000
	
	11a rate set	  6000 9000 12000 18000 24000 36000 48000 54000
	11naht20 rate set6000 9000 12000 18000 24000 36000 48000 54000
	
	11naht40/11naht40plus/11naht40minus 
	rate set6000 9000 12000 18000 24000 36000 48000 54000
	*/
	int ret = 0;
	if(AC_WTP[wtpindex]->WTP_Radio[radioid]->Radio_Type == IEEE80211_11B){
		wid_syslog_debug_debug(WID_DBUS,"%s,%d,radio %d ,check rate:%d.\n",__func__,__LINE__,radioid,rate);
		if((10 == rate)||(20 == rate )||(55 == rate)||(110 == rate)){
			ret = 0;
		}else{
			ret = RADIO_SUPPORT_RATE_EXIST;
		}
	}else if(AC_WTP[wtpindex]->WTP_Radio[radioid]->Radio_Type & IEEE80211_11G){
		wid_syslog_debug_debug(WID_DBUS,"%s,%d,radio %d ,check rate:%d.\n",__func__,__LINE__,radioid,rate);
		if((10 == rate)||(20 == rate )||(55 == rate)||(110 == rate)||(60 == rate)||(90 == rate )||(120 == rate)||(180 == rate)\
			||(240 == rate)||(360 == rate)||(480 == rate)||(540 == rate)){
			ret = 0;
		}else{
			ret = RADIO_SUPPORT_RATE_EXIST;
		}
	}else if(AC_WTP[wtpindex]->WTP_Radio[radioid]->Radio_Type & IEEE80211_11A){
		wid_syslog_debug_debug(WID_DBUS,"%s,%d,radio %d ,check rate:%d.\n",__func__,__LINE__,radioid,rate);
		if((60 == rate)||(90 == rate )||(120 == rate)||(180 == rate)\
			||(240 == rate)||(360 == rate)||(480 == rate)||(540 == rate)){
			ret = 0;
		}else{
			ret = RADIO_SUPPORT_RATE_EXIST;
		}
	}else{
		wid_syslog_warning("%s,%d,unknow radio type:%d.\n",__func__,__LINE__,AC_WTP[wtpindex]->WTP_Radio[radioid]->Radio_Type);
		ret = RADIO_SUPPORT_RATE_EXIST;
	}
	wid_syslog_debug_debug(WID_DBUS,"%s,%d,radio %d ,check rate:%d,ret=%d.\n",__func__,__LINE__,radioid,rate,ret);
	return ret;
}
int set_wid_sample_enable()
{
	int i = 0;
	msgq msg;
	for(i=0; i<WTP_NUM; i++)
	{
		if((AC_WTP[i] != NULL)&&(AC_WTP[i]->WTPStat == WID_RUN))
		{
			wid_syslog_debug_debug(WID_DEFAULT,"## set_wid_sample_enable wtp id= %d##\n",i);
			
			AC_WTP[i]->WTP_Radio[0]->CMD |= 0x8000;
			AC_WTP[i]->CMD->radioid[0] += 1;
			AC_WTP[i]->CMD->setCMD = 1;	
			int WTPIndex = i;
			CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
			if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
			{
				memset((char*)&msg, 0, sizeof(msg));
				msg.mqid = WTPIndex%THREAD_NUM+1;
				msg.mqinfo.WTPID = WTPIndex;
				msg.mqinfo.type = CONTROL_TYPE;
				msg.mqinfo.subtype = WTP_S_TYPE;
				msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_SAMPLE_INFO_SET;
				
				if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
					wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
				}

			}		
			CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
		}
	}
	
	return 0;
}
int wid_radio_bss_set_max_throughput(unsigned int wtp_id,unsigned int l_radio_id,unsigned int l_bss_id,unsigned int throughput)
{
	msgq msg;
	if(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[l_bss_id]->band_width == throughput)
	{
		return 0;
	}
	else
	{
		AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[l_bss_id]->band_width = throughput;
	}
	if((AC_WTP[wtp_id] != NULL)&&(AC_WTP[wtp_id]->WTPStat == WID_RUN))
	{
		AC_WTP[wtp_id]->WTP_Radio[0]->CMD |= 0x0800;
		AC_WTP[wtp_id]->CMD->radioid[0] += 1;
		AC_WTP[wtp_id]->CMD->setCMD = 1;	
		int WTPIndex = wtp_id;
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_BSS_Throughput;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = l_radio_id;
			msg.mqinfo.u.RadioInfo.BSS_L_ID = l_bss_id;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}

		}		
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}
	
	return 0;	
}
int wid_set_wlan_vlanid(unsigned char Wlanid,unsigned int vlanid)
{
	if (AC_WLAN[Wlanid]->vlanid == vlanid)
	{
		return WID_DBUS_SUCCESS;
	}
	
	AC_WLAN[Wlanid]->vlanid = vlanid;
	
	{
		int i,j;
		for(i=0; i<WTP_NUM; i++)
		{
			/*if((AC_WTP[i]!=NULL)&&(AC_WTP[i]->isused == 1))*/
			if(AC_WTP[i]!=NULL)
			{
				for(j=0; j<AC_WTP[i]->RadioCount; j++)//zhanglei change L_RADIO_NUM to AC_WTP[i]->RadioCount
				{
					if(AC_WLAN[Wlanid]->S_WTP_BSS_List[i][j] != 0)
					{
						int bssindex = AC_WLAN[Wlanid]->S_WTP_BSS_List[i][j];
						if(!check_bssid_func(bssindex)){
							wid_syslog_err("<error>%s\n",__func__);
							//return BSS_NOT_EXIST;
						}else{						
							AC_BSS[bssindex]->wlan_vlanid = vlanid;
						}
					}
				}
			}
		}
	}
	return WID_DBUS_SUCCESS;
}
int wid_set_wlan_vlan_priority(unsigned char Wlanid,unsigned int priority)
{
	if (AC_WLAN[Wlanid]->wlan_1p_priority == priority)
	{
		return WID_DBUS_SUCCESS;
	}
	
	AC_WLAN[Wlanid]->wlan_1p_priority = priority;
	
	return WID_DBUS_SUCCESS;
}

int CHECK_AND_UPDATE_IF_POLICY(char* ifname,int *wtpid1,int *radioid1,int *wlanid1,int isadd)
{
//	int ret = 0;
	unsigned int vrrid_t = 0;
	/* coverity-CID:10960 Uninitialized scalar variable */
	int wtpid = 0;
	/* coverity-CID:10959 Uninitialized scalar variable */
	int radioid = 0;
	/* coverity-CID:10961 Uninitialized scalar variable */
	int wlanid = 0;
	
	if(!strncasecmp(ifname,"r",1)){
		char *id = (char *)malloc(sizeof(char)*25);
		memset(id,0,25);
		if(id == NULL)
		{
			wid_syslog_err("malloc error,%s",__func__);
			return MALLOC_ERROR;
		}
		memcpy(id,ifname+1,(strlen(ifname)-1));
		if(parse_radio_ifname(id,&wtpid,&radioid,&wlanid)==0)
		{
			wid_syslog_debug_debug(WID_DBUS,"ifname %s,wtpid %d,radioid %d wlanid2 %d",ifname,wtpid,radioid,wlanid);
		}else if(parse_radio_ifname_v2(id, &wtpid,&radioid,&wlanid,&vrrid_t)==0){

		}else{
			wid_syslog_warning("parse radio interface %s error",ifname);;
			if(id != NULL){
				free(id);
				id = NULL;
			}
			return -1;
		}
		if(id != NULL){
			free(id);
			id = NULL;
		}
	}else{
		wid_syslog_debug_debug(WID_DBUS,"%s,%s",__func__,ifname);
	}
	
	*wtpid1 = wtpid;
	*radioid1 = radioid;
	*wlanid1 = wlanid;
	if((AC_WLAN[wlanid])&&(AC_WLAN[wlanid]->S_WTP_BSS_List[wtpid][radioid] != 0))
	{
		int bssindex = AC_WLAN[wlanid]->S_WTP_BSS_List[wtpid][radioid];
		if(!check_bssid_func(bssindex)){
			wid_syslog_err("\n");
			//return ;							
		}else if(isadd){						
			if(AC_BSS[bssindex]->BSS_IF_POLICY == NO_INTERFACE)
			{
				wid_syslog_warning("<warning>bss %d policy is NO_INTERFACE->WLAN_INTERFACE\n",bssindex);
				AC_BSS[bssindex]->BSS_IF_POLICY = WLAN_INTERFACE;
				AC_BSS[bssindex]->BSS_TUNNEL_POLICY = CW_802_DOT_11_TUNNEL;
			}
			else if(AC_BSS[bssindex]->BSS_IF_POLICY == BSS_INTERFACE)
			{
				wid_syslog_debug_debug(WID_DEFAULT,"bss %d policy is BSS_INTERFACE->WLAN_INTERFACE\n",bssindex);
				AC_BSS[bssindex]->BSS_IF_POLICY = WLAN_INTERFACE;
				AC_BSS[bssindex]->BSS_TUNNEL_POLICY = CW_802_DOT_11_TUNNEL;
			}
			else
			{
			}
		}else{						
			if(AC_BSS[bssindex]->BSS_IF_POLICY == NO_INTERFACE)
			{
				wid_syslog_warning("<warning>bss %d policy is NO_INTERFACE->BSS_INTERFACE\n",bssindex);
				AC_BSS[bssindex]->BSS_IF_POLICY = BSS_INTERFACE;
				AC_BSS[bssindex]->BSS_TUNNEL_POLICY = 0;
			}
			else if(AC_BSS[bssindex]->BSS_IF_POLICY == WLAN_INTERFACE)
			{
				wid_syslog_debug_debug(WID_DEFAULT,"bss %d policy is WLAN_INTERFACE->BSS_INTERFACE\n",bssindex);
				AC_BSS[bssindex]->BSS_IF_POLICY = BSS_INTERFACE;
				AC_BSS[bssindex]->BSS_TUNNEL_POLICY = 0;
			}
			else
			{
			}
		}
	}
	return 0;
}

int wid_set_tunnel_wlan_vlan(unsigned char wlanid,char * ifname)
{
//	printf("input wlanid %d ifname %s\n",wlanid,ifname);

	int ret = 0;
	int reason = 0;
	char brname[ETH_IF_NAME_LEN];
	char syscmd[WID_SYSTEM_CMD_LENTH];
	WTPQUITREASON quitreason = WTP_INIT;
	int wtpid = 0;
	int wlanid2 = 0;
	int radioid = 0;
		
	memset(brname,0,ETH_IF_NAME_LEN);
	memset(syscmd,0,WID_SYSTEM_CMD_LENTH);
	if(local)
		sprintf(brname,"wlanl%d-%d-%d",slotid,vrrid,wlanid);
	else
		sprintf(brname,"wlan%d-%d-%d",slotid,vrrid,wlanid);
		
	ret = Check_Interface_Config(brname,&quitreason);
	if(ret != WID_DBUS_SUCCESS)
	{
		return ret;
	}
	sprintf(syscmd,"brctl addif %s %s",brname,ifname);
//	printf("syscmd %s\n",syscmd);

	ret = system(syscmd);
	reason = WEXITSTATUS(ret);
	//if(ret == WID_DBUS_SUCCESS)
	if(reason == WID_DBUS_SUCCESS)
	{
		if(CHECK_AND_UPDATE_IF_POLICY(ifname,&wtpid,&radioid,&wlanid2,1) == 0){
			wid_syslog_debug_debug(WID_DBUS,"ifname %s CHECK_AND_UPDATE_IF_POLICY successfull",ifname);
		}else{
			wid_syslog_debug_debug(WID_DBUS,"ifname %s,line %d",ifname,__LINE__);
		}
		struct WID_TUNNEL_WLAN_VLAN *wif;
		struct WID_TUNNEL_WLAN_VLAN *wifnext;
		
		wif = (struct WID_TUNNEL_WLAN_VLAN*)malloc(sizeof(struct WID_TUNNEL_WLAN_VLAN));
		memset(wif->ifname,0,ETH_IF_NAME_LEN);
		memcpy(wif->ifname,ifname,strlen(ifname));
		wif->ifnext = NULL;
		
		if(AC_WLAN[wlanid]->tunnel_wlan_vlan == NULL)
		{
//			printf("wlan id:%d ifname :%s\n",wlanid,ifname);
			AC_WLAN[wlanid]->tunnel_wlan_vlan = wif ;
			AC_WLAN[wlanid]->tunnel_wlan_vlan->ifnext = NULL;
		}
		else
		{
			wifnext = AC_WLAN[wlanid]->tunnel_wlan_vlan;
			while(wifnext != NULL)
			{	
				if(strncmp(wifnext->ifname,ifname,strlen(ifname)) == 0)
				{
//					printf("already in the list\n");
					free(wif);
					wif = NULL;
					return 0;
				}
				wifnext = wifnext->ifnext;
			}
			
//			printf("wlan id:%d ifname :%s\n",wlanid,ifname);
			wifnext = AC_WLAN[wlanid]->tunnel_wlan_vlan;
			while(wifnext->ifnext != NULL)
			{	
				wifnext = wifnext->ifnext;
			}
			
			wifnext->ifnext = wif;
			
		}
		return 0;
	}
	else
	{
		return SYSTEM_CMD_ERROR;
	}
	
}
int wid_undo_tunnel_wlan_vlan(unsigned char wlanid,char * ifname)
{
//	printf("input wlanid %d ifname %s\n",wlanid,ifname);

	int ret = 0;
	int reason = 0;
	int wtpid = 0;
	int wlanid2 = 0;
	int radioid = 0;
	char brname[ETH_IF_NAME_LEN];
	char syscmd[WID_SYSTEM_CMD_LENTH];
	WTPQUITREASON quitreason = WTP_INIT;
		
	memset(brname,0,ETH_IF_NAME_LEN);
	memset(syscmd,0,WID_SYSTEM_CMD_LENTH);
	if(local)
		sprintf(brname,"wlanl%d-%d-%d",slotid,vrrid,wlanid);
	else
		sprintf(brname,"wlan%d-%d-%d",slotid,vrrid,wlanid);
	ret = Check_Interface_Config(brname,&quitreason);
	if(ret != WID_DBUS_SUCCESS)
	{
		return ret;
	}

	sprintf(syscmd,"brctl delif %s %s",brname,ifname);
//	printf("syscmd %s\n",syscmd);

	ret = system(syscmd);
	reason = WEXITSTATUS(ret);
	//if(ret == WID_DBUS_SUCCESS)
	if(reason == WID_DBUS_SUCCESS)
	{

		if(CHECK_AND_UPDATE_IF_POLICY(ifname,&wtpid,&radioid,&wlanid2,0) == 0){
			wid_syslog_debug_debug(WID_DBUS,"ifname %s,wtpid %d,radioid %d wlanid2 %d",ifname,wtpid,radioid,wlanid2);
		}else{
			wid_syslog_debug_debug(WID_DBUS,"ifname %s,line %d",ifname,__LINE__);
		}
	
		struct WID_TUNNEL_WLAN_VLAN *wif;
		struct WID_TUNNEL_WLAN_VLAN *wifnext;

		wifnext = AC_WLAN[wlanid]->tunnel_wlan_vlan;
		
		if(AC_WLAN[wlanid]->tunnel_wlan_vlan != NULL)
		{
			if(strncmp(wifnext->ifname,ifname,strlen(ifname)) == 0)
			{
				AC_WLAN[wlanid]->tunnel_wlan_vlan = wifnext->ifnext;
				free(wifnext);
				wifnext = NULL;		
//				printf("delete ifname %s from list\n",ifname);
			}
			else
			{
				while(wifnext->ifnext != NULL)
				{	
					if(strncmp(wifnext->ifnext->ifname,ifname,strlen(ifname)) == 0)
					{
						wif = wifnext->ifnext;
						wifnext->ifnext = wifnext->ifnext->ifnext;
						free(wif);
						wif = NULL;				
//						printf("delete ifname %s from list\n",ifname);
						return 0;
					}
					wifnext = wifnext->ifnext;
				}
			}
		}
		return 0;
	}
	else
	{
		return SYSTEM_CMD_ERROR;
	}
}

//xm add
static int get_oui_node(unsigned char oui[],struct oui_node **od,struct oui_node **cr){

	if(0==g_oui_list.list_len)
		return -1;

	if(od!=NULL&&cr!=NULL){
		*od = *cr = g_oui_list.oui_list;
		
		while(*cr!=NULL){
			if(0!=memcmp((*cr)->oui,oui,3)){
				*od=*cr;
				*cr=(*cr)->next;
			}else
				return 0;
		}
		
		return -1;
	}else if(od==NULL&&cr==NULL){
	
		struct oui_node *crt;
		
		crt = g_oui_list.oui_list;
		while(crt!=NULL){
			if(0!=memcmp(crt->oui,oui,3)){
				crt=crt->next;
			}else
				return 0;
		}
		
		return -1;		
	}
	return -1;	
}


static int get_essid_node(char *essid,struct essid_node **od,struct essid_node **cr)
{
	if(0 == g_essid_list.list_len)
	{
		return ESSID_LIST_IS_NULL;
	}
	
	if(od != NULL && cr != NULL)
	{
		*od = *cr = g_essid_list.essid_list;
		
		while(*cr != NULL)
		{
			if(0 != strcmp((*cr)->essid, essid))
			{
				*od = *cr;
				*cr = (*cr)->next;
			}
			else
			{
				return 0;
			}
		}
			
		return ESSID_NOT_EXIST;
	}
	else if(od == NULL && cr == NULL)
	{
		struct essid_node *crt = NULL;
		crt = g_essid_list.essid_list;
		while(crt != NULL)
		{
			if(0 != strcmp(crt->essid, essid))
			{
				crt = crt->next;
			}
			else
			{
				return 0;
			}
		}
			
		return ESSID_NOT_EXIST;		
	}
	return -1;
}

static int get_mac_node(unsigned char mac[],struct attack_mac_node **od, struct attack_mac_node **cr)
{
    if(0 == g_attack_mac_list.list_len)
	{
	    return -1;
    }
	if(od != NULL && cr != NULL)
	{
		*od = *cr = g_attack_mac_list.attack_mac_list;
		
		while(*cr != NULL)
		{
			if(0 != memcmp((*cr)->mac,mac,6))
			{
				*od=*cr;
				*cr=(*cr)->next;
			}
			else
			{
			    return 0;
			}
		}
		
		return -1;
	}
	else if(od == NULL && cr == NULL)
	{
		struct attack_mac_node *crt = NULL;
		crt = g_attack_mac_list.attack_mac_list;
		while(crt != NULL)
		{
			if(0 != memcmp(crt->mac,mac,6))
			{
				crt=crt->next;
			}
			else
			{
			    return 0;
			}
		}
		
		return -1;		
	}
	return -1;
}

int wid_add_manufacturer_oui(unsigned char oui[]){

	int ret;
	struct oui_node *node=NULL;

	if(oui==NULL)
		return -1;

	if(0==g_oui_list.list_len){
		CW_CREATE_OBJECT_ERR(node, struct oui_node, return -1;);
		node->oui[0]=oui[0];
		node->oui[1]=oui[1];
		node->oui[2]=oui[2];
		node->next=NULL;

		g_oui_list.list_len++;
		g_oui_list.oui_list=node;

	}else{
		ret=get_oui_node(oui,NULL,NULL);
		if(0==ret)
			return 0;
		else{
			CW_CREATE_OBJECT_ERR(node, struct oui_node, return -1;);
			node->oui[0]=oui[0];
			node->oui[1]=oui[1];
			node->oui[2]=oui[2];

			node->next=g_oui_list.oui_list;
			g_oui_list.oui_list=node;
			
			g_oui_list.list_len++;
			
		}

	}

	return 0;
}



int wid_add_legal_essid(char *essid)
{
	int ret = 0;
	struct essid_node *node = NULL;

	if(essid == NULL)
	{
		return WID_DBUS_ERROR;
	}
	if (ESSID_LENGTH < strlen(essid))
	{		
		wid_syslog_debug_debug(WID_DEFAULT,"%% Essid too long, should be 1 to %d\n", ESSID_LENGTH);
		return WID_DBUS_ERROR;
	}
	
	if(0 == g_essid_list.list_len)
	{
		CW_CREATE_OBJECT_ERR(node, struct essid_node, return MALLOC_ERROR;);

		node->essid = (char *)malloc(ESSID_LENGTH+1);
		if(NULL == node->essid)
		{
			CW_FREE_OBJECT(node);
			return MALLOC_ERROR;
		}
		memset(node->essid, 0, ESSID_LENGTH+1);
		strncpy(node->essid, essid, ESSID_LENGTH);
		node->len = strlen(essid);
		node->next = NULL;
		
		g_essid_list.essid_list = node;
		g_essid_list.list_len++;
	}
	else
	{
		ret = get_essid_node(essid, NULL, NULL);
		if(0 == ret)
		{
			return ESSID_IS_EXIST;
		}

		CW_CREATE_OBJECT_ERR(node, struct essid_node, return MALLOC_ERROR;);
		
		node->essid = (char *)malloc(ESSID_LENGTH+1);
		if(NULL == node->essid)
		{
			CW_FREE_OBJECT(node);
			return MALLOC_ERROR;
		}
		memset(node->essid, 0, ESSID_LENGTH+1);
		strncpy(node->essid, essid, ESSID_LENGTH);		
		node->len = strlen(essid);
		node->next = g_essid_list.essid_list;
		
		g_essid_list.essid_list = node;			
		g_essid_list.list_len++;		
	}
	wid_syslog_debug_debug(WID_DBUS,"add legal essid %s successfully, len=%d\n",essid,node->len);
	
	return 0;
}


int wid_modify_legal_essid(char *essid,char *essid_new)
{
	struct essid_node *od = NULL, *cr = NULL;
	int ret = WID_DBUS_ERROR;

	if((NULL == essid) || (NULL == essid_new))
	{
		return WID_DBUS_ERROR;
	}
	
	if ((ESSID_LENGTH < strlen(essid)) || (ESSID_LENGTH < strlen(essid_new)))
	{		
		wid_syslog_debug_debug(WID_DEFAULT,"%% Essid too long, should be 1 to %d\n", ESSID_LENGTH);
		return WID_DBUS_ERROR;
	}
	
	ret = get_essid_node(essid, &od, &cr);
	if(0 != ret)
	{
		return ret;
	}
	
	ret = get_essid_node(essid_new, NULL, NULL);
	if(0 == ret)
	{
		return ESSID_IS_EXIST;
	}

	memset(cr->essid, 0, ESSID_LENGTH+1);
	strncpy(cr->essid, essid_new, ESSID_LENGTH);
	cr->len = strlen(essid_new);

	wid_syslog_debug_debug(WID_DEFAULT,"modify legal essid %s to %s successfully, len=%d\n",essid,essid_new,cr->len);
	return 0;
}


int wid_del_legal_essid(char *essid)
{
	struct essid_node *od = NULL, *cr = NULL;
	int ret = 0;

	if(essid == NULL)
	{
		return WID_DBUS_ERROR;
	}

	if (ESSID_LENGTH < strlen(essid))
	{		
		wid_syslog_debug_debug(WID_DEFAULT,"%% Essid too long, should be 1 to %d\n", ESSID_LENGTH);
	}
	
	ret = get_essid_node(essid,&od,&cr);
	if(0 != ret)
	{
		return ESSID_NOT_EXIST;
	}
	
	if(od == cr)
	{
		g_essid_list.essid_list = cr->next;

	}
	else
	{
		od->next = cr->next;
	}
	cr->next = NULL;

	free(cr->essid);
	cr->essid = NULL;
	free(cr);
	cr = NULL;
	g_essid_list.list_len--;

	wid_syslog_debug_debug(WID_DBUS,"del legal essid %s successfully\n",essid);
	return 0;
}


int wid_add_attack_ap_mac(unsigned char mac[])
{
	int ret = 0;
	struct attack_mac_node *node=NULL;

	if(mac == NULL)
	{
	    return -1;
    }
	if(0 == g_attack_mac_list.list_len)
	{
		CW_CREATE_OBJECT_ERR(node, struct attack_mac_node, return -1;);

		memset(node->mac,0,6);
		memcpy(node->mac,mac,6);
		
		node->next = NULL;
		g_attack_mac_list.attack_mac_list = node;
		g_attack_mac_list.list_len++;
	}
	else
	{
		ret = get_mac_node(mac,NULL,NULL);
		if(0 == ret)
		{
		    return 0;
		}
		else
		{
			CW_CREATE_OBJECT_ERR(node, struct attack_mac_node, return -1;);
			
			memset(node->mac,0,6);
			memcpy(node->mac,mac,6);

			node->next = g_attack_mac_list.attack_mac_list;
			g_attack_mac_list.attack_mac_list = node;
			g_attack_mac_list.list_len++;
		}
	}

	return 0;
}


int wid_del_manufacturer_oui(unsigned char oui[])
{
	struct oui_node *od = NULL, *cr = NULL;
	int ret = 0;
	ret = get_oui_node(oui,&od,&cr);

	if(0 == ret)
	{
		if(od == cr)
		{
			g_oui_list.oui_list=cr->next;

		}
		else
		{
			od->next=cr->next;
		}
		cr->next=NULL;
		free(cr);
		cr=NULL;
		g_oui_list.list_len--;
	}
	else
		return 0;
	return 0;
}

int wid_del_attack_ap_mac(unsigned char mac[])
{
	struct attack_mac_node *od = NULL, *cr = NULL;
	int ret = 0;
	ret = get_mac_node(mac,&od,&cr);
	
	if(0 == ret)
	{
		if(od == cr)
		{
			g_attack_mac_list.attack_mac_list = cr->next;
		}
		else
		{
			od->next = cr->next;
		}
		
		cr->next = NULL;
		free(cr);
		cr = NULL;
		g_attack_mac_list.list_len--;
	}
	else
		return 0;
	return 0;
}
int wid_set_wlan_br_isolation(unsigned char wlanid,unsigned char state)
{
	int ret = 0;
	int reason = 0;
	WTPQUITREASON quitreason = WTP_INIT;
	char brcmd[WID_SYSTEM_CMD_LENTH];
	memset(brcmd,0,WID_SYSTEM_CMD_LENTH);
	
	
	char brname[ETH_IF_NAME_LEN];
	memset(brname,0,ETH_IF_NAME_LEN);
	if(local)
		sprintf(brname,"wlanl%d-%d-%d",slotid,vrrid,wlanid);
	else
		sprintf(brname,"wlan%d-%d-%d",slotid,vrrid,wlanid);		
//	printf("brname:wlan%d\n",wlanid);
	wid_syslog_debug_debug(WID_DEFAULT,"wid_set_wlan_br_isolation ifname:%s\n",brname);

	//check br if validity
	ret = Check_Interface_Exist(brname,&quitreason);
	if(ret != 0)
	{
		return WLAN_CREATE_BR_FAIL;
	}

	//set br isolation
	if(state == 0)
	{
		sprintf(brcmd,"brctl isolation %s off\n",brname);
	}
	else if(state == 1)
	{
		sprintf(brcmd,"brctl isolation %s on\n",brname);
	}
	wid_syslog_debug_debug(WID_DEFAULT,"set bridge-isolation cmd:%s\n",brcmd);
	
	ret = system(brcmd);
	reason = WEXITSTATUS(ret);
	if(reason != 0)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"system cmd error,error code %d\n",reason);
		return SYSTEM_CMD_ERROR;
	}
	wid_syslog_debug_debug(WID_DEFAULT,"ret:%d(0 success)\n",ret);

	if(ret != 0)
	{
		return SYSTEM_CMD_ERROR;//set failure
	}
	else
	{
		AC_WLAN[wlanid]->isolation_policy = state;
		return 0;//set success
	}
	
}
int wid_set_wlan_br_multicast_isolation(unsigned char wlanid,unsigned char state)
{
	int ret = 0;
	int reason = 0;
	WTPQUITREASON quitreason = WTP_INIT;
	char brcmd[WID_SYSTEM_CMD_LENTH];
	memset(brcmd,0,WID_SYSTEM_CMD_LENTH);
	
	
	char brname[ETH_IF_NAME_LEN];
	memset(brname,0,ETH_IF_NAME_LEN);
	if(local)
		sprintf(brname,"wlanl%d-%d-%d",slotid,vrrid,wlanid);
	else
		sprintf(brname,"wlan%d-%d-%d",slotid,vrrid,wlanid);		
//	printf("brname:wlan%d\n",wlanid);
	wid_syslog_debug_debug(WID_DEFAULT,"wid_set_wlan_br_multicast_isolation ifname:%s\n",brname);

	//check br if validity
	ret = Check_Interface_Exist(brname,&quitreason);
	if(ret != 0)
	{
		return WLAN_CREATE_BR_FAIL;
	}

	//set br isolation
	if(state == 0)
	{
		sprintf(brcmd,"brctl multicastisolation %s off\n",brname);
	}
	else if(state == 1)
	{
		sprintf(brcmd,"brctl multicastisolation %s on\n",brname);
	}
	wid_syslog_debug_debug(WID_DEFAULT,"set bridge-multicast isolation cmd:%s\n",brcmd);
	
	ret = system(brcmd);
	reason = WEXITSTATUS(ret);
	if(reason != 0)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"system cmd error,error code %d\n",reason);
		return SYSTEM_CMD_ERROR;
	}
	wid_syslog_debug_debug(WID_DEFAULT,"ret:%d(0 success)\n",ret);

	if(ret != 0)
	{
		return SYSTEM_CMD_ERROR;//set failure
	}
	else
	{
		AC_WLAN[wlanid]->multicast_isolation_policy = state;
		return 0;//set success
	}
	
}











/*
  *****************************************************************************
  *  
  * NOTES:	 
  * INPUT:	   
  * OUTPUT:	  
  * return:	  
  *  
  * author: 		Huang Leilei 
  * begin time:	2012-11-12 9:00  
  * finish time:		2012-11-15 11:00 
  * history:	
  * 
  **************************************************************************** 
  */
int 
wid_set_wlan_ebr_br_ucast_solicit(unsigned char Wlan_Ebr_ID, unsigned char state, unsigned char Wlan_Ebr_flag)
{
	int ret = 0;
	WTPQUITREASON quitreason = WTP_INIT;
	char Wlan_Ebr_File[PATH_MAX + NAME_MAX];
	memset(Wlan_Ebr_File, 0, sizeof(Wlan_Ebr_File));
	
	char Wlan_Ebr_Name[ETH_IF_NAME_LEN];
	memset(Wlan_Ebr_Name,0,ETH_IF_NAME_LEN);

	int ucast_fd = 0;

	if (Wlan_Ebr_flag == 0)
	{
		if (local)
		{
			sprintf(Wlan_Ebr_Name, "wlanl%d-%d-%d", slotid, vrrid, Wlan_Ebr_ID);
		}
		else
		{
			sprintf(Wlan_Ebr_Name, "wlan%d-%d-%d", slotid, vrrid, Wlan_Ebr_ID);
		}
		
		wid_syslog_debug_debug(WID_DBUS, "wid_set_wlan_ebr_br_ucast_solicit ifname:%s\n",Wlan_Ebr_Name);

		//check br if validity
		ret = Check_Interface_Exist(Wlan_Ebr_Name, &quitreason);
		if(ret != 0)
		{
			wid_syslog_err("%s: interface %s not exist\n", __func__, Wlan_Ebr_Name);
			return WLAN_CREATE_BR_FAIL;
		}

		sprintf(Wlan_Ebr_File, "/proc/sys/net/ipv4/neigh/%s/ucast_solicit", Wlan_Ebr_Name);
		
		wid_syslog_debug_debug(WID_DBUS, "wid_set_wlan_ebr_br_ucast_solicit ifname:%s\n",Wlan_Ebr_File);

	}
	else if (Wlan_Ebr_flag == 1)
	{
		if (local)
		{
			sprintf(Wlan_Ebr_Name, "ebrl%d-%d-%d", slotid, vrrid, Wlan_Ebr_ID);
		}
		else
		{
			sprintf(Wlan_Ebr_Name, "ebr%d-%d-%d", slotid, vrrid, Wlan_Ebr_ID);
		}

		//check br if validity
		ret = Check_Interface_Exist(Wlan_Ebr_Name,&quitreason);
		if(ret != 0)
		{
			wid_syslog_err("%s: interface %s not exist\n", __func__, Wlan_Ebr_Name);
			return WLAN_CREATE_BR_FAIL;
		}

		sprintf(Wlan_Ebr_File, "/proc/sys/net/ipv4/neigh/%s/ucast_solicit", Wlan_Ebr_Name);
		
		wid_syslog_debug_debug(WID_DBUS, "wid_set_wlan_ebr_br_ucast_solicit ifname:%s\n",Wlan_Ebr_File);

	}
	else
	{
		wid_syslog_err("%s: <error> Wlan_Ebr_flag:%d\n", __func__, Wlan_Ebr_flag);
	}
		
	//
	ucast_fd = open(Wlan_Ebr_File, O_RDWR);
	if(ucast_fd< 0)
	{
		wid_syslog_err("%s: open file %s error, return vlaue is:%d\n", __func__, Wlan_Ebr_File, ucast_fd);
		return WID_DBUS_ERROR;
	}
	if(state == 0)
	{
		if (write(ucast_fd, "0", 1) != 1)
		{
			wid_syslog_err("%s: write \"0\" to file:%s error\n", __func__, Wlan_Ebr_File);
			close(ucast_fd);
			return WID_DBUS_ERROR;
		}
		else
		{
			if (Wlan_Ebr_flag == 1)			/* ebr config mode */
			{
				WID_EBR[Wlan_Ebr_ID]->bridge_ucast_solicit_stat = 0;
			}
			else if (Wlan_Ebr_flag == 0)	/* wlan config mode */
			{
				AC_WLAN[Wlan_Ebr_ID]->bridge_ucast_solicit_stat = 0;
			}
		}
	}
	else if(state == 1)
	{
		
		if (write(ucast_fd, "5", 1) != 1)
		{
			wid_syslog_err("%s: write \"5\" to file:%s error\n", __func__, Wlan_Ebr_File);
			close(ucast_fd);
			return WID_DBUS_ERROR;
		}
		else
		{
			if (Wlan_Ebr_flag == 1)			/* ebr config mode */
			{
				WID_EBR[Wlan_Ebr_ID]->bridge_ucast_solicit_stat = 1;
			}
			else if (Wlan_Ebr_flag == 0)	/* wlan config mode */
			{
				AC_WLAN[Wlan_Ebr_ID]->bridge_ucast_solicit_stat = 1;
			}
		}
	}
	else
	{
		wid_syslog_err("%s: <error> state:%d\n", __func__, state);
	}
	
	close(ucast_fd);
	
	return WID_DBUS_SUCCESS;
}


/*
  *****************************************************************************
  *  
  * NOTES:	 
  * INPUT:	   
  * OUTPUT:	  
  * return:	  
  *  
  * author: 		Huang Leilei 
  * begin time:	2012-11-12 9:00  
  * finish time:		2012-11-15 11:00 
  * history:	
  * 
  **************************************************************************** 
  */
int 
wid_set_wlan_ebr_br_mcast_solicit(unsigned char Wlan_Ebr_ID, unsigned char state, unsigned char Wlan_Ebr_flag)
{
	int ret = 0;
	WTPQUITREASON quitreason = WTP_INIT;
	char Wlan_Ebr_File[PATH_MAX + NAME_MAX];
	memset(Wlan_Ebr_File, 0, sizeof(Wlan_Ebr_File));
	
	char Wlan_Ebr_Name[ETH_IF_NAME_LEN];
	memset(Wlan_Ebr_Name,0,ETH_IF_NAME_LEN);

	int mcast_fd = 0;

	if (Wlan_Ebr_flag == 0)
	{
		if (local)
		{
			sprintf(Wlan_Ebr_Name, "wlanl%d-%d-%d", slotid, vrrid, Wlan_Ebr_ID);
		}
		else
		{
			sprintf(Wlan_Ebr_Name, "wlan%d-%d-%d", slotid, vrrid, Wlan_Ebr_ID);
		}

		//check br if validity
		ret = Check_Interface_Exist(Wlan_Ebr_Name, &quitreason);
		if(ret != 0)
		{
			wid_syslog_err("%s: interface %s not exist\n", __func__, Wlan_Ebr_Name);
			return WLAN_CREATE_BR_FAIL;
		}

		sprintf(Wlan_Ebr_File, "/proc/sys/net/ipv4/neigh/%s/mcast_solicit", Wlan_Ebr_Name);
		
		wid_syslog_debug_debug(WID_DBUS, "wid_set_wlan_ebr_br_mcast_solicit ifname:%s\n",Wlan_Ebr_File);

	}
	else if (Wlan_Ebr_flag == 1)
	{
		if (local)
		{
			sprintf(Wlan_Ebr_Name, "ebrl%d-%d-%d", slotid, vrrid, Wlan_Ebr_ID);
		}
		else
		{
			sprintf(Wlan_Ebr_Name, "ebr%d-%d-%d", slotid, vrrid, Wlan_Ebr_ID);
		}

		//check br if validity
		ret = Check_Interface_Exist(Wlan_Ebr_Name,&quitreason);
		if(ret != 0)
		{
			wid_syslog_err("%s: interface %s not exist\n", __func__, Wlan_Ebr_Name);
			return WLAN_CREATE_BR_FAIL;
		}

		sprintf(Wlan_Ebr_File, "/proc/sys/net/ipv4/neigh/%s/mcast_solicit", Wlan_Ebr_Name);

		wid_syslog_debug_debug(WID_DBUS, "wid_set_wlan_ebr_br_mcast_solicit ifname:%s\n",Wlan_Ebr_File);

	}
	else
	{
		wid_syslog_err("%s: <error> Wlan_Ebr_flag:%d\n", __func__, Wlan_Ebr_flag);
	}
	
	//
	mcast_fd = open(Wlan_Ebr_File, O_RDWR);
	if(mcast_fd< 0)
	{
		wid_syslog_err("%s: open file %s error, return vlaue is:%d\n", __func__, Wlan_Ebr_File, mcast_fd);
		return WID_DBUS_ERROR;
	}
	if(state == 0)
	{
		if (write(mcast_fd, "0", 1) != 1)
		{
			wid_syslog_err("%s: write \"0\" to file:%s error\n", __func__, Wlan_Ebr_File);
			close(mcast_fd);
			return WID_DBUS_ERROR;
		}
		else
		{
			if (Wlan_Ebr_flag == 1)			/* ebr config mode */
			{
				WID_EBR[Wlan_Ebr_ID]->bridge_mcast_solicit_stat = 0;
			}
			else if (Wlan_Ebr_flag == 0)	/* wlan config mode */
			{
				AC_WLAN[Wlan_Ebr_ID]->bridge_mcast_solicit_stat = 0;
			}
		}
	}
	else if(state == 1)
	{
		if (write(mcast_fd, "1", 1) != 1)
		{
			wid_syslog_err("%s: write \"1\" to file:%s error\n", __func__, Wlan_Ebr_File);
			close(mcast_fd);
			return WID_DBUS_ERROR;
		}
		else
		{
			if (Wlan_Ebr_flag == 1)			/* ebr config mode */
			{
				WID_EBR[Wlan_Ebr_ID]->bridge_mcast_solicit_stat = 1;
			}
			else if (Wlan_Ebr_flag == 0)	/* wlan config mode */
			{
				AC_WLAN[Wlan_Ebr_ID]->bridge_mcast_solicit_stat = 1;
			}
		}
	}
	else
	{
		wid_syslog_err("%s: <error> state:%d\n", __func__, state);
	}
		
	close(mcast_fd);
						
	return WID_DBUS_SUCCESS;
}



































int wid_set_wlan_br_sameportswitch(unsigned char wlanid,unsigned char state)
{
	int ret = 0;
	int reason = 0;
	WTPQUITREASON quitreason = WTP_INIT;
	char brcmd[WID_SYSTEM_CMD_LENTH];
	memset(brcmd,0,WID_SYSTEM_CMD_LENTH);
	
	
	char brname[ETH_IF_NAME_LEN];
	memset(brname,0,ETH_IF_NAME_LEN);
	if(local)
		sprintf(brname,"wlanl%d-%d-%d",slotid,vrrid,wlanid);
	else
		sprintf(brname,"wlan%d-%d-%d",slotid,vrrid,wlanid);		
//	printf("brname:wlan%d\n",wlanid);
	wid_syslog_debug_debug(WID_DEFAULT,"wid_set_wlan_br_sameportswitch ifname:%s\n",brname);

	//check br if validity
	ret = Check_Interface_Config(brname,&quitreason);
	if(ret != 0)
	{
		return WLAN_CREATE_BR_FAIL;
	}

	//set br isolation
	if(state == 0)
	{
		sprintf(brcmd,"brctl sameportswitching %s off\n",brname);
	}
	else if(state == 1)
	{
		sprintf(brcmd,"brctl sameportswitching %s on\n",brname);
	}
	wid_syslog_debug_debug(WID_DEFAULT,"set bridge sameportswitch cmd:%s\n",brcmd);
	
	ret = system(brcmd);
	reason = WEXITSTATUS(ret);
	if(reason != 0)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"system cmd error,error code %d\n",reason);
		return SYSTEM_CMD_ERROR;
	}
	wid_syslog_debug_debug(WID_DEFAULT,"ret:%d(0 success)\n",ret);

	if(ret != 0)
	{
		return SYSTEM_CMD_ERROR;//set failure
	}
	else
	{
		AC_WLAN[wlanid]->sameportswitch = state;
		return 0;//set success
	}
	
}

//ethereal bridge area
int Check_Interface_Exist(char * ifname,WTPQUITREASON *quitreason)
{
	wid_syslog_debug_debug(WID_DEFAULT,"Check_Interface_Config:%s\n",ifname);
	int sockfd;
	struct ifreq	ifr;
	
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	
	strncpy(ifr.ifr_name,ifname, sizeof(ifr.ifr_name));	
	
	if(ioctl(sockfd, SIOCGIFINDEX, &ifr) == -1)    //bind to a interface
	{
		wid_syslog_debug_debug(WID_DEFAULT,"SIOCGIFINDEX error\n");
		*quitreason = IF_NOINDEX;
		wid_syslog_debug_debug(WID_DEFAULT,"wtp quit reason is IF_NOINDEX error");
		close(sockfd);
		return APPLY_IF_FAIL;
	 }
	if (ioctl(sockfd, SIOCGIFFLAGS, &ifr) == -1)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"SIOCGIFFLAGS error\n");
		*quitreason = IF_NOFLAGS;
		wid_syslog_debug_debug(WID_DEFAULT,"wtp quit reason is IF_NOFLAGS error");
		close(sockfd);
		return APPLY_IF_FAIL;
	}
	
	close(sockfd);
	wid_syslog_debug_debug(WID_DEFAULT,"Check_Interface_Exist ifname:%s quitreason:%d\n",ifname,*quitreason);
	return 0;
}

int WID_ADD_ETHEREAL_BRIDGE(char *name,unsigned int ID)
{
	int ret = 0;
	int reason = 0;
	WTPQUITREASON quitreason = WTP_INIT;
	char brname[ETH_IF_NAME_LEN];
	char systemcmd[WID_SYSTEM_CMD_LENTH];
	memset(brname,0,ETH_IF_NAME_LEN);
	memset(systemcmd,0,WID_SYSTEM_CMD_LENTH);
	
	//check br 
	if(local)
		sprintf(brname,"ebrl%d-%d-%d",slotid,vrrid,ID);
	else
		sprintf(brname,"ebr%d-%d-%d",slotid,vrrid,ID);		
	//printf("brname:%s\n",brname);
	
	ret = Check_Interface_Exist(brname,&quitreason);
	if(ret == 0)
	{
#if 0
		memset(systemcmd,0,WID_SYSTEM_CMD_LENTH);
		if(local)
			sprintf(systemcmd,"ifconfig ebrl%d-%d-%d down",slotid,vrrid,ID);
		else
			sprintf(systemcmd,"ifconfig ebr%d-%d-%d down",slotid,vrrid,ID); 	
		ret = system(systemcmd);
		reason = WEXITSTATUS(ret);
		if(reason != 0)
		{
			wid_syslog_debug_debug(WID_DEFAULT,"system cmd error,error code %d\n",reason);
			return SYSTEM_CMD_ERROR;
		}
		if(ret != 0)
		{
			return SYSTEM_CMD_ERROR;
		}
		
		memset(systemcmd,0,WID_SYSTEM_CMD_LENTH);
		if(local)
			sprintf(systemcmd,"brctl delbr ebrl%d-%d-%d",slotid,vrrid,ID);
		else
			sprintf(systemcmd,"brctl delbr ebr%d-%d-%d",slotid,vrrid,ID);
		//printf("systemcmd:%s\n",systemcmd);
		ret = system(systemcmd);
		reason = WEXITSTATUS(ret);
		if(reason != 0)
		{
			wid_syslog_debug_debug(WID_DEFAULT,"system cmd %s error,error code %d\n",systemcmd,reason);
			return SYSTEM_CMD_ERROR;
		}
		if(ret != 0)
		{
			return SYSTEM_CMD_ERROR;
		}
#endif
	}
	else{
		memset(systemcmd,0,WID_SYSTEM_CMD_LENTH);	
		if(local)
			sprintf(systemcmd,"brctl addbr ebrl%d-%d-%d",slotid,vrrid,ID);
		else
			sprintf(systemcmd,"brctl addbr ebr%d-%d-%d",slotid,vrrid,ID);		
		//printf("systemcmd:%s\n",systemcmd);
		ret = system(systemcmd);
		reason = WEXITSTATUS(ret);
		if(reason != 0)
		{
			wid_syslog_debug_debug(WID_DEFAULT,"system cmd %s error,error code %d\n",systemcmd,reason);
			return SYSTEM_CMD_ERROR;
		}
		if(ret != 0)
		{
			return SYSTEM_CMD_ERROR;
		}
		/*set isolation default value*/
		memset(systemcmd,0,WID_SYSTEM_CMD_LENTH);
		if(local)
			sprintf(systemcmd,"brctl isolation ebrl%d-%d-%d on",slotid,vrrid,ID);
		else
			sprintf(systemcmd,"brctl isolation ebr%d-%d-%d on",slotid,vrrid,ID);		
		ret = system(systemcmd);
		reason = WEXITSTATUS(ret);
		if(reason != 0)
		{
			wid_syslog_debug_debug(WID_DEFAULT,"system cmd %s error,error code %d\n",systemcmd,reason);
			return SYSTEM_CMD_ERROR;
		}

		memset(systemcmd,0,WID_SYSTEM_CMD_LENTH);
		if(local)
			sprintf(systemcmd,"brctl multicastisolation ebrl%d-%d-%d on",slotid,vrrid,ID);
		else
			sprintf(systemcmd,"brctl multicastisolation ebr%d-%d-%d on",slotid,vrrid,ID);		
		ret = system(systemcmd);
		reason = WEXITSTATUS(ret);
		if(reason != 0)
		{
			wid_syslog_debug_debug(WID_DEFAULT,"system cmd %s error,error code %d\n",systemcmd,reason);
			return SYSTEM_CMD_ERROR;
		}
	}
	WID_EBR[ID] = (ETHEREAL_BRIDGE *)malloc(sizeof(ETHEREAL_BRIDGE));
	WID_EBR[ID]->EBRID = ID;
	WID_EBR[ID]->name = (char *)malloc(strlen(name)+1);
	memset(WID_EBR[ID]->name, 0, strlen(name)+1);
	memcpy(WID_EBR[ID]->name, name, strlen(name));
	WID_EBR[ID]->state = 0;
	WID_EBR[ID]->isolation_policy = 1;/*sz change default value from 0 to 1 090723*/
	WID_EBR[ID]->multicast_isolation_policy = 1;/*sz change default value from 0 to 1 090723*/
	WID_EBR[ID]->bridge_mcast_solicit_stat = 1;
	WID_EBR[ID]->bridge_ucast_solicit_stat = 1;
	WID_EBR[ID]->sameportswitch = 0;
	WID_EBR[ID]->iflist = NULL;
	WID_EBR[ID]->uplinklist = NULL;
	WID_EBR[ID]->r_num = 0;
	WID_EBR[ID]->eth_num = 0;
	WID_EBR[ID]->multicast_fdb_learn = 1;

	wid_set_ebr_isolation(ID,1);
	wid_set_ebr_multcast_isolation(ID,1);
	wid_set_ebr_multicast_fdb_learn(ID,1);
	
	return WID_DBUS_SUCCESS;
}
int WID_DELETE_ETHEREAL_BRIDGE(unsigned int ID)
{
	int ret = 0;
	int reason = 0;
	//WTPQUITREASON *quitreason = WTP_INIT;
	char systemcmd[WID_SYSTEM_CMD_LENTH];
	memset(systemcmd,0,WID_SYSTEM_CMD_LENTH);
	if(local)
		sprintf(systemcmd,"ifconfig ebrl%d-%d-%d down",slotid,vrrid,ID);
	else
		sprintf(systemcmd,"ifconfig ebr%d-%d-%d down",slotid,vrrid,ID);		
	//printf("systemcmd:%s\n",systemcmd);
	ret = system(systemcmd);
	reason = WEXITSTATUS(ret);
	if(reason != 0)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"system cmd error,error code %d\n",reason);
		return SYSTEM_CMD_ERROR;
	}
	if(ret != 0)
	{
		return SYSTEM_CMD_ERROR;
	}
	
	memset(systemcmd,0,WID_SYSTEM_CMD_LENTH);
	if(local)
		sprintf(systemcmd,"brctl delbr ebrl%d-%d-%d",slotid,vrrid,ID);
	else
		sprintf(systemcmd,"brctl delbr ebr%d-%d-%d",slotid,vrrid,ID);
	//printf("systemcmd:%s\n",systemcmd);
	ret = system(systemcmd);
	reason = WEXITSTATUS(ret);
	if(reason != 0)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"system cmd error,error code %d\n",reason);
		return SYSTEM_CMD_ERROR;
	}
	if(ret != 0)
	{
		return SYSTEM_CMD_ERROR;
	}
	// delete iflist
	EBR_IF_LIST *iflist = WID_EBR[ID]->iflist;
	while(iflist != NULL)
	{
		WID_EBR[ID]->iflist = iflist->ifnext;
		free(iflist);
		iflist = NULL;
		iflist = WID_EBR[ID]->iflist;
	}
	
	iflist = WID_EBR[ID]->uplinklist;
	while(iflist != NULL)
	{
		WID_EBR[ID]->uplinklist = iflist->ifnext;
		free(iflist);
		iflist = NULL;
		iflist = WID_EBR[ID]->uplinklist;
	}	
	
	CW_FREE_OBJECT(WID_EBR[ID]->name);
	CW_FREE_OBJECT(WID_EBR[ID]);
	
	return WID_DBUS_SUCCESS;
}
int WID_SET_ETHEREAL_BRIDGE_ENABLE(unsigned int ID)
{
	int ret = 0;
	int reason = 0;
	WTPQUITREASON quitreason = WTP_INIT;
	char brname[ETH_IF_NAME_LEN];
	char systemcmd[WID_SYSTEM_CMD_LENTH];
	memset(brname,0,ETH_IF_NAME_LEN);
	memset(systemcmd,0,WID_SYSTEM_CMD_LENTH);
	
	//check br 
	if(local)
		sprintf(brname,"ebrl%d-%d-%d",slotid,vrrid,ID);
	else
		sprintf(brname,"ebr%d-%d-%d",slotid,vrrid,ID);		
	//printf("brname:%s\n",brname);
	ret = Check_Interface_Exist(brname,&quitreason);
	if(ret != 0)
	{
		return WID_EBR_ERROR;
	}
	if(local)
		sprintf(systemcmd,"ifconfig ebrl%d-%d-%d up",slotid,vrrid,ID);
	else
		sprintf(systemcmd,"ifconfig ebr%d-%d-%d up",slotid,vrrid,ID);
	//printf("systemcmd:%s\n",systemcmd);
	ret = system(systemcmd);
	reason = WEXITSTATUS(ret);
	if(reason != 0)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"system cmd error,error code %d\n",reason);
		return SYSTEM_CMD_ERROR;
	}
	if(ret != 0)
	{
		return SYSTEM_CMD_ERROR;
	}
	WID_EBR[ID]->state = 1;
	
	return WID_DBUS_SUCCESS;
}
int WID_SET_ETHEREAL_BRIDGE_DISABLE(unsigned int ID)
{
	int ret = 0;
	int reason = 0;
	WTPQUITREASON quitreason = WTP_INIT;
	char brname[ETH_IF_NAME_LEN];
	char systemcmd[WID_SYSTEM_CMD_LENTH];
	memset(brname,0,ETH_IF_NAME_LEN);
	memset(systemcmd,0,WID_SYSTEM_CMD_LENTH);
	
	//check br 
	if(local)
		sprintf(brname,"ebrl%d-%d-%d",slotid,vrrid,ID);
	else
		sprintf(brname,"ebr%d-%d-%d",slotid,vrrid,ID);
	//printf("brname:%s\n",brname);
	ret = Check_Interface_Exist(brname,&quitreason);
	if(ret != 0)
	{
		return WID_EBR_ERROR;
	}
	if(local)
		sprintf(systemcmd,"ifconfig ebrl%d-%d-%d down",slotid,vrrid,ID);
	else
		sprintf(systemcmd,"ifconfig ebr%d-%d-%d down",slotid,vrrid,ID);
	//printf("systemcmd:%s\n",systemcmd);
	ret = system(systemcmd);
	reason = WEXITSTATUS(ret);
	if(reason != 0)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"system cmd error,error code %d\n",reason);
		return SYSTEM_CMD_ERROR;
	}
	if(ret != 0)
	{
		return SYSTEM_CMD_ERROR;
	}
	WID_EBR[ID]->state = 0;
	return WID_DBUS_SUCCESS;
}
int wid_set_ebr_isolation(unsigned int ID,unsigned char state)
{
	int ret = 0;
	int reason = 0;
	WTPQUITREASON quitreason = WTP_INIT;
	char brname[ETH_IF_NAME_LEN];
	char systemcmd[WID_SYSTEM_CMD_LENTH];
	memset(brname,0,ETH_IF_NAME_LEN);
	memset(systemcmd,0,WID_SYSTEM_CMD_LENTH);
	
	//check br 
	if(local)
		sprintf(brname,"ebrl%d-%d-%d",slotid,vrrid,ID);
	else
		sprintf(brname,"ebr%d-%d-%d",slotid,vrrid,ID);		
	//printf("brname:%s\n",brname);
	ret = Check_Interface_Exist(brname,&quitreason);
	if(ret != 0)
	{
		return WID_EBR_ERROR;
	}
	if(state == 1)
	{
		if(local)
			sprintf(systemcmd,"brctl isolation ebrl%d-%d-%d on\n",slotid,vrrid,ID);
		else
			sprintf(systemcmd,"brctl isolation ebr%d-%d-%d on\n",slotid,vrrid,ID);			
	}
	else 
	{
		if(local)
			sprintf(systemcmd,"brctl isolation ebrl%d-%d-%d off\n",slotid,vrrid,ID);
		else
			sprintf(systemcmd,"brctl isolation ebr%d-%d-%d off\n",slotid,vrrid,ID);			
	}
	//printf("systemcmd:%s\n",systemcmd);
	ret = system(systemcmd);
	reason = WEXITSTATUS(ret);
	if(reason != 0)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"system cmd error,error code %d\n",reason);
		return SYSTEM_CMD_ERROR;
	}
	if(ret != 0)
	{
		return SYSTEM_CMD_ERROR;
	}
	WID_EBR[ID]->isolation_policy = state;
	return WID_DBUS_SUCCESS;
}
int wid_set_ebr_multcast_isolation(unsigned int ID,unsigned char state)
{
	int ret = 0;
	int reason = 0;
	WTPQUITREASON quitreason = WTP_INIT;
	char brname[ETH_IF_NAME_LEN];
	char systemcmd[WID_SYSTEM_CMD_LENTH];
	memset(brname,0,ETH_IF_NAME_LEN);
	memset(systemcmd,0,WID_SYSTEM_CMD_LENTH);
	
	//check br 
	if(local)
		sprintf(brname,"ebrl%d-%d-%d",slotid,vrrid,ID);
	else
		sprintf(brname,"ebr%d-%d-%d",slotid,vrrid,ID);		
	//printf("brname:%s\n",brname);
	ret = Check_Interface_Exist(brname,&quitreason);
	if(ret != 0)
	{
		return WID_EBR_ERROR;
	}
	if(state == 1)
	{
		if(local)
			sprintf(systemcmd,"brctl multicastisolation ebrl%d-%d-%d on\n",slotid,vrrid,ID);
		else
			sprintf(systemcmd,"brctl multicastisolation ebr%d-%d-%d on\n",slotid,vrrid,ID);
	}
	else 
	{
		if(local)
			sprintf(systemcmd,"brctl multicastisolation ebrl%d-%d-%d off\n",slotid,vrrid,ID);
		else
			sprintf(systemcmd,"brctl multicastisolation ebr%d-%d-%d off\n",slotid,vrrid,ID);
	}
	//printf("systemcmd:%s\n",systemcmd);
	ret = system(systemcmd);
	reason = WEXITSTATUS(ret);
	if(reason != 0)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"system cmd error,error code %d\n",reason);
		return SYSTEM_CMD_ERROR;
	}
	if(ret != 0)
	{
		return SYSTEM_CMD_ERROR;
	}
	WID_EBR[ID]->multicast_isolation_policy = state;
	return WID_DBUS_SUCCESS;
}
int wid_set_ebr_sameportswitch(unsigned int ID,unsigned char state)
{
	int ret = 0;
	int reason = 0;
	WTPQUITREASON quitreason = WTP_INIT;
	char brname[ETH_IF_NAME_LEN];
	char systemcmd[WID_SYSTEM_CMD_LENTH];
	memset(brname,0,ETH_IF_NAME_LEN);
	memset(systemcmd,0,WID_SYSTEM_CMD_LENTH);
	
	//check br 
	if(local)
		sprintf(brname,"ebrl%d-%d-%d",slotid,vrrid,ID);
	else
		sprintf(brname,"ebr%d-%d-%d",slotid,vrrid,ID);		
	//printf("brname:%s\n",brname);
	ret = Check_Interface_Exist(brname,&quitreason);
	if(ret != 0)
	{
		return WID_EBR_ERROR;
	}
	if(state == 1)
	{
		if(local)
			sprintf(systemcmd,"brctl sameportswitching ebrl%d-%d-%d on\n",slotid,vrrid,ID);
		else
			sprintf(systemcmd,"brctl sameportswitching ebr%d-%d-%d on\n",slotid,vrrid,ID);
	}
	else 
	{
		if(local)
			sprintf(systemcmd,"brctl sameportswitching ebrl%d-%d-%d off\n",slotid,vrrid,ID);
		else
			sprintf(systemcmd,"brctl sameportswitching ebr%d-%d-%d off\n",slotid,vrrid,ID);
	}
	//printf("systemcmd:%s\n",systemcmd);
	ret = system(systemcmd);
	reason = WEXITSTATUS(ret);
	if(reason != 0)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"system cmd error,error code %d\n",reason);
		return SYSTEM_CMD_ERROR;
	}
	if(ret != 0)
	{
		return SYSTEM_CMD_ERROR;
	}
	WID_EBR[ID]->sameportswitch = state;
	return WID_DBUS_SUCCESS;
}

int wid_set_ebr_multicast_fdb_learn(unsigned int ID,unsigned char state)
{
	int ret = 0;
	int reason = 0;
	WTPQUITREASON quitreason = WTP_INIT;
	char brname[ETH_IF_NAME_LEN];
	char systemcmd[WID_SYSTEM_CMD_LENTH];
	memset(brname,0,ETH_IF_NAME_LEN);
	memset(systemcmd,0,WID_SYSTEM_CMD_LENTH);
	
	//check br 
	if(local)
		sprintf(brname,"ebrl%d-%d-%d",slotid,vrrid,ID);
	else
		sprintf(brname,"ebr%d-%d-%d",slotid,vrrid,ID);		
	//printf("brname:%s\n",brname);
	ret = Check_Interface_Exist(brname,&quitreason);
	if(ret != 0)
	{
		return WID_EBR_ERROR;
	}
	if(state == 1)
	{
		if(local)
			sprintf(systemcmd,"sudo echo 1 > /sys/class/net/ebrl%d-%d-%d/bridge/fdb_multicast_update_state\n",slotid,vrrid,ID);
		else
			sprintf(systemcmd,"sudo echo 1 > /sys/class/net/ebr%d-%d-%d/bridge/fdb_multicast_update_state\n",slotid,vrrid,ID);
	}
	else 
	{
		if(local)
			sprintf(systemcmd,"sudo echo 0 > /sys/class/net/ebrl%d-%d-%d/bridge/fdb_multicast_update_state\n",slotid,vrrid,ID);
		else
			sprintf(systemcmd,"sudo echo 0 > /sys/class/net/ebr%d-%d-%d/bridge/fdb_multicast_update_state\n",slotid,vrrid,ID);
	}
	//printf("systemcmd:%s\n",systemcmd);
	ret = system(systemcmd);
	reason = WEXITSTATUS(ret);
	if(reason != 0)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"system cmd error,error code %d\n",reason);
		return SYSTEM_CMD_ERROR;
	}
	if(ret != 0)
	{
		return SYSTEM_CMD_ERROR;
	}
	WID_EBR[ID]->multicast_fdb_learn = state;
	return WID_DBUS_SUCCESS;
}

int WID_SET_ETHEREAL_BRIDGE_IF_UPLINK(unsigned int ID,char *ifname,int is_radio,int g_radioid,int wlanid)
{
	//printf("input ebrid %d ifname %s\n",ID,ifname);

	int ret = 0;
	int reason = 0;
	char ebrname[ETH_IF_NAME_LEN];
	char syscmd[WID_SYSTEM_CMD_LENTH];
	char ifcheck[WID_SYSTEM_CMD_LENTH];
	WTPQUITREASON quitreason = WTP_INIT;
	int need_set_mtu = 0;	
	memset(ebrname,0,ETH_IF_NAME_LEN);
	memset(syscmd,0,WID_SYSTEM_CMD_LENTH);
	memset(ifcheck,0,WID_SYSTEM_CMD_LENTH);
	if(local)
		sprintf(ebrname,"ebrl%d-%d-%d",slotid,vrrid,ID);
	else
		sprintf(ebrname,"ebr%d-%d-%d",slotid,vrrid,ID);		
	ret = Check_Interface_Exist(ebrname,&quitreason);
	if(ret != WID_DBUS_SUCCESS)
	{
		return WID_EBR_ERROR;
	}
	if(local)
		sprintf(ifcheck,"/sys/class/net/ebrl%d-%d-%d/brif/%s/port_id",slotid,vrrid,ID,ifname);
	else
		sprintf(ifcheck,"/sys/class/net/ebr%d-%d-%d/brif/%s/port_id",slotid,vrrid,ID,ifname);		
	ret = file_check(ifcheck);
	if(ret == 1)
	{
		wid_syslog_debug_debug(WID_DBUS,"%s: %s already in %s\n", __func__, ifname, ebrname);
		ret = 0;
		reason = 0;
	}
	else
	{
		sprintf(syscmd,"brctl addif %s %s",ebrname,ifname);
		//printf("syscmd %s\n",syscmd);

		ret = system(syscmd);
		reason = WEXITSTATUS(ret);
	}
	//if(ret == WID_DBUS_SUCCESS)
	if(reason == WID_DBUS_SUCCESS)
	{	
		if(is_radio)
		{
		    /*coverity-CID: 10831, Out-of-bounds read*/
			if((g_radioid>0)&&(g_radioid <= WTP_NUM*L_RADIO_NUM)&&(wlanid > 0)&&(wlanid < WLAN_NUM))
			{
				if((AC_RADIO[g_radioid] != NULL)&&(wlanid < WLAN_NUM))
				{
				    wid_syslog_debug_debug(WID_DEFAULT,"%s:AC_RADIO[%d]->br_ifname[%d] %s.\n",
				                    __func__,g_radioid,wlanid,AC_RADIO[g_radioid]->br_ifname[wlanid]);
				    memset(AC_RADIO[g_radioid]->br_ifname[wlanid],0,IF_NAME_MAX);
					memcpy(AC_RADIO[g_radioid]->br_ifname[wlanid],ebrname,strlen(ebrname));//for advise to asd
				}
				wid_syslog_debug_debug(WID_DEFAULT,"%s:AC_RADIO[%d]->br_ifname[%d] %s.\n",
				                   __func__,g_radioid,wlanid,AC_RADIO[g_radioid]->br_ifname[wlanid]);
			}
		}
		EBR_IF_LIST *wif = NULL;
		EBR_IF_LIST *wifnext = NULL;
		
		wif = (EBR_IF_LIST *)malloc(sizeof(EBR_IF_LIST));
		memset(wif,0,sizeof(EBR_IF_LIST));
		wif->ifname = (char *)malloc(ETH_IF_NAME_LEN);
		memset(wif->ifname,0,ETH_IF_NAME_LEN);
		memcpy(wif->ifname,ifname,strlen(ifname));
		wif->ifnext = NULL;
		
		if(WID_EBR[ID]->iflist == NULL)
		{
			//printf("ebr id:%d ifname :%s\n",ID,ifname);
			WID_EBR[ID]->iflist = wif ;
			WID_EBR[ID]->iflist->ifnext = NULL;			
		}
		else
		{
			
			wifnext = WID_EBR[ID]->iflist;
			while(wifnext != NULL)
			{	
				if((strlen(ifname) == strlen(wifnext->ifname))&&(strncmp(wifnext->ifname,ifname,strlen(ifname)) == 0))
				{
					//printf("already in the list\n");
					free(wif->ifname);
					wif->ifname = NULL;
					free(wif);
					wif = NULL;
					return 0;
				}
				wifnext = wifnext->ifnext;
			}
			if(is_radio&&(WID_EBR[ID]->r_num == 0)&&(WID_EBR[ID]->eth_num > 0)){
				need_set_mtu = 1;
			}else if((!is_radio)&&(WID_EBR[ID]->r_num > 0)){
				memset(syscmd,0,WID_SYSTEM_CMD_LENTH);				
				sprintf(syscmd,"ifconfig %s mtu 1416",ifname);
				printf("%s %s\n",__func__,syscmd);
				system(syscmd);
			}
			
			//printf("ebr id:%d ifname :%s\n",ID,ifname);
			wifnext = WID_EBR[ID]->iflist;
			while(wifnext->ifnext != NULL)
			{	
				if(need_set_mtu){
//					if(strncasecmp(wifnext->ifname,"radio",5)){												
					if(strncasecmp(wifnext->ifname,"r",1)){ 											
						memset(syscmd,0,WID_SYSTEM_CMD_LENTH);				
						sprintf(syscmd,"ifconfig %s mtu 1416",wifnext->ifname);
						printf("%s2 %s\n",__func__,syscmd);
						system(syscmd);
					}
				}
				wifnext = wifnext->ifnext;
			}
			if(need_set_mtu){
				//if(strncasecmp(wifnext->ifname,"radio",5)){ 	
				if(strncasecmp(wifnext->ifname,"r",1)){ 	
					memset(syscmd,0,WID_SYSTEM_CMD_LENTH);				
					sprintf(syscmd,"ifconfig %s mtu 1416",wifnext->ifname);
					printf("%s2 %s\n",__func__,syscmd);
					system(syscmd);
				}
			}
			
			wifnext->ifnext = wif;
		}		
		if(is_radio){
			WID_EBR[ID]->r_num++;
		}else{
			WID_EBR[ID]->eth_num++;
		}
		return 0;
	}
	else
	{
		return SYSTEM_CMD_ERROR;
	}
	
}
int WID_SET_ETHEREAL_BRIDGE_IF_DOWNLINK(unsigned int ID,char *ifname,int is_radio,int g_radioid,int wlanid)
{
	//printf("input ebrid %d ifname %s\n",ID,ifname);

	int ret = 0;
	int reason = 0;
	char ebrname[ETH_IF_NAME_LEN];
	char syscmd[WID_SYSTEM_CMD_LENTH];
	WTPQUITREASON quitreason = WTP_INIT;
	int need_set_mtu = 0;	
	memset(ebrname,0,ETH_IF_NAME_LEN);
	memset(syscmd,0,WID_SYSTEM_CMD_LENTH);
	//delete uplink first if exists
	wid_set_ethereal_bridge_del_uplink(ID,ifname);
	
	if(local)
		sprintf(ebrname,"ebrl%d-%d-%d",slotid,vrrid,ID);
	else
		sprintf(ebrname,"ebr%d-%d-%d",slotid,vrrid,ID);
	ret = Check_Interface_Exist(ebrname,&quitreason);
	if(ret != WID_DBUS_SUCCESS)
	{
		return ret;
	}

	sprintf(syscmd,"brctl delif %s %s",ebrname,ifname);
	//printf("syscmd %s\n",syscmd);

	ret = system(syscmd);
	reason = WEXITSTATUS(ret);
	//if(ret == WID_DBUS_SUCCESS)
	if(reason == WID_DBUS_SUCCESS)
	{
		if(is_radio){
            /* coverity-CID: 10830 Out-of-bounds read */
			if((g_radioid>0)&&(g_radioid < WTP_NUM*L_RADIO_NUM)&&(wlanid > 0)&&(wlanid < WLAN_NUM)){
				if(AC_RADIO[g_radioid] != NULL){
					memset(AC_RADIO[g_radioid]->br_ifname[wlanid],0,IF_NAME_MAX);//for advise to asd
				}
				wid_syslog_debug_debug(WID_DEFAULT,"del AC_RADIO[%d]->br_ifname[%d] %s\n",g_radioid,wlanid,AC_RADIO[g_radioid]->br_ifname[wlanid]);
			}
		}
		EBR_IF_LIST *wif = NULL;
		EBR_IF_LIST *wifnext = NULL;

		wifnext = WID_EBR[ID]->iflist;
		
		if(WID_EBR[ID]->iflist != NULL)
		{

			if(is_radio&&(WID_EBR[ID]->r_num == 1)&&(WID_EBR[ID]->eth_num > 0)){
				need_set_mtu = 1;
			}else if((!is_radio)&&(WID_EBR[ID]->r_num > 0)){
				memset(syscmd,0,WID_SYSTEM_CMD_LENTH);				
				sprintf(syscmd,"ifconfig %s mtu 1500",ifname);				
				printf("%s %s\n",__func__,syscmd);
				system(syscmd);
			}

			if((strlen(ifname) == strlen(wifnext->ifname))&&(strncmp(wifnext->ifname,ifname,strlen(ifname)) == 0))
			{
				WID_EBR[ID]->iflist = wifnext->ifnext;
				CW_FREE_OBJECT(wifnext->ifname);
				CW_FREE_OBJECT(wifnext);	
				//printf("delete ifname %s from list\n",ifname);				
				wifnext = WID_EBR[ID]->iflist;
				if(need_set_mtu)
					while(wifnext->ifnext != NULL)
					{	
						//if(strncasecmp(wifnext->ifname,"radio",5)){ 											
						if(strncasecmp(wifnext->ifname,"r",1)){ 
							memset(syscmd,0,WID_SYSTEM_CMD_LENTH);				
							sprintf(syscmd,"ifconfig %s mtu 1500",wifnext->ifname);							
							printf("%s2 %s\n",__func__,syscmd);
							system(syscmd);
						}
						wifnext = wifnext->ifnext;
					}
				
				if(is_radio){
					WID_EBR[ID]->r_num--;
				}else{
					WID_EBR[ID]->eth_num--;
				}
			}
			else
			{
								
				while(wifnext->ifnext != NULL)
				{	
					if((strlen(ifname) == strlen(wifnext->ifnext->ifname))&&(strncmp(wifnext->ifnext->ifname,ifname,strlen(ifname)) == 0))
					{
						wif = wifnext->ifnext;
						wifnext->ifnext = wifnext->ifnext->ifnext;
						CW_FREE_OBJECT(wif->ifname);
						CW_FREE_OBJECT(wif);			
						//printf("delete ifname %s from list\n",ifname);
						if(is_radio){
							WID_EBR[ID]->r_num--;
						}else{
							WID_EBR[ID]->eth_num--;
						}
						if(!need_set_mtu){							
							return 0;
						}else
							continue;
					}					
					if(need_set_mtu){
						//if(strncasecmp(wifnext->ifname,"radio",5)){ 	
						if(strncasecmp(wifnext->ifname,"r",1)){ 	
							memset(syscmd,0,WID_SYSTEM_CMD_LENTH);				
							sprintf(syscmd,"ifconfig %s mtu 1500",wifnext->ifname);							
							printf("%s3 %s\n",__func__,syscmd);
							system(syscmd);
						}
					}
					wifnext = wifnext->ifnext;
				}				
				if(need_set_mtu){
					//if(strncasecmp(wifnext->ifname,"radio",5)){ 
					if(strncasecmp(wifnext->ifname,"r",1)){
						memset(syscmd,0,WID_SYSTEM_CMD_LENTH);				
						sprintf(syscmd,"ifconfig %s mtu 1500",wifnext->ifname);						
						printf("%s4 %s\n",__func__,syscmd);
						system(syscmd);
					}
				}
			}
		}
		
		return 0;
	}
	else
	{
		return SYSTEM_CMD_ERROR;
	}
}
int wid_add_cpu_value_for_accounting_average(unsigned int wtpid,unsigned int cpu_value){
	struct ap_cpu_info  *cpu_node = NULL;
	if((cpu_node = (struct ap_cpu_info*)malloc(sizeof(struct ap_cpu_info))) == NULL){
		wid_syslog_debug_debug(WID_DEFAULT,"malloc fail in wid_add_cpu_value_for_accounting_average. \n");
		return -1;
	}
	else{
		cpu_node->value = cpu_value;
		cpu_node->next = NULL;
		if(AC_WTP[wtpid]->apcminfo.ap_cpu_info_head == NULL){
			AC_WTP[wtpid]->apcminfo.ap_cpu_info_head = cpu_node;
			AC_WTP[wtpid]->apcminfo.ap_cpu_info_length++;
		}
		else{
			cpu_node->next = AC_WTP[wtpid]->apcminfo.ap_cpu_info_head;
			AC_WTP[wtpid]->apcminfo.ap_cpu_info_head = cpu_node;
			AC_WTP[wtpid]->apcminfo.ap_cpu_info_length++;
		}
 		return 0;
	}
}

int wid_add_mem_value_for_accounting_average(unsigned int wtpid,unsigned int mem_value){
	wid_syslog_debug_debug(WID_DEFAULT,"mem value : %d \n", AC_WTP[wtpid]->wifi_extension_info.memoryuse );
	struct ap_cpu_info  *mem_node = NULL;
	if((mem_node = (struct ap_cpu_info*)malloc(sizeof(struct ap_cpu_info))) == NULL){
		wid_syslog_debug_debug(WID_DEFAULT,"malloc fail in %s. \n",__func__);
		return -1;
	}
	else{
		mem_node->value = mem_value;
		mem_node->next = NULL;
		if(AC_WTP[wtpid]->apcminfo.ap_mem_info_head == NULL){
			AC_WTP[wtpid]->apcminfo.ap_mem_info_head = mem_node;
			AC_WTP[wtpid]->apcminfo.ap_mem_info_length++;
		}
		else{
			mem_node->next = AC_WTP[wtpid]->apcminfo.ap_mem_info_head;
			AC_WTP[wtpid]->apcminfo.ap_mem_info_head = mem_node;
			AC_WTP[wtpid]->apcminfo.ap_mem_info_length++;
		}
 		return 0;
	}
}



int wid_del_cpu_value_for_accounting_average(unsigned int wtpid,unsigned int total_node_num){
	struct ap_cpu_info  *p = AC_WTP[wtpid]->apcminfo.ap_cpu_info_head ;
	struct ap_cpu_info  *tmp = NULL;
	int i=0;
	
	for(i=0;i<total_node_num;i++){
		if (p!= NULL){
			tmp = p;
			p = p->next;
		}
	}
	if(tmp)
	{
		tmp->next = NULL;
	}
	
	while(p!=NULL){
		tmp = p;
		p = p->next;
		tmp->next = NULL;
		free(tmp);
		tmp = NULL;
		AC_WTP[wtpid]->apcminfo.ap_cpu_info_length--;
 	}
	
	wid_syslog_debug_debug(WID_DEFAULT,"AC_WTP[%d]->ap_cpu_info_length = %d\n",\
							wtpid,AC_WTP[wtpid]->apcminfo.ap_cpu_info_length);
	return 0;
}
int wid_del_mem_value_for_accounting_average(unsigned int wtpid,unsigned int total_node_num){
	struct ap_cpu_info  *p = AC_WTP[wtpid]->apcminfo.ap_mem_info_head ;
	struct ap_cpu_info  *tmp = NULL;
	int i=0;
	
	for(i=0;i<total_node_num;i++){
		if (p!= NULL){
			tmp = p;
			p = p->next;
		}
	}
	tmp->next = NULL;
	
	while(p!=NULL){
		tmp = p;
		p = p->next;
		tmp->next = NULL;
		free(tmp);
		tmp = NULL;
		AC_WTP[wtpid]->apcminfo.ap_mem_info_length--;
 	}
	
	wid_syslog_debug_debug(WID_DEFAULT,"AC_WTP[%d]->ap_mem_info_length = %d\n",\
							wtpid,AC_WTP[wtpid]->apcminfo.ap_mem_info_length);
	
	return 0;
}

int wid_accouting_cpu_average(unsigned int wtpid){
	unsigned int sum_cpu_value = 0;
	struct ap_cpu_info  *Node_cpu = AC_WTP[wtpid]->apcminfo.ap_cpu_info_head;
	AC_WTP[wtpid]->apcminfo.cpu_peak_value = Node_cpu->value;
	
	while(Node_cpu != NULL){
		if(AC_WTP[wtpid]->apcminfo.cpu_peak_value < Node_cpu->value) {
			AC_WTP[wtpid]->apcminfo.cpu_peak_value = Node_cpu->value;
		}
		sum_cpu_value += Node_cpu->value;
		Node_cpu = Node_cpu->next;
	}
	AC_WTP[wtpid]->wifi_extension_info.cpu_collect_average = 
						sum_cpu_value / AC_WTP[wtpid]->apcminfo.ap_cpu_info_length ;
	
	AC_WTP[wtpid]->apcminfo.cpu_average = AC_WTP[wtpid]->wifi_extension_info.cpu_collect_average;

	return 0 ;
}

int wid_accouting_mem_average(unsigned int wtpid){
	unsigned int sum_mem_value = 0;
	struct ap_cpu_info  *Node_mem = AC_WTP[wtpid]->apcminfo.ap_mem_info_head;
	AC_WTP[wtpid]->apcminfo.mem_peak_value = Node_mem->value;
	
	while(Node_mem != NULL){
		if(AC_WTP[wtpid]->apcminfo.mem_peak_value < Node_mem->value) {
			AC_WTP[wtpid]->apcminfo.mem_peak_value = Node_mem->value;
		}
		sum_mem_value += Node_mem->value;
		Node_mem = Node_mem->next;
	}
	AC_WTP[wtpid]->wifi_extension_info.mem_collect_average = 
						sum_mem_value / AC_WTP[wtpid]->apcminfo.ap_mem_info_length ;
	
	AC_WTP[wtpid]->apcminfo.mem_average = AC_WTP[wtpid]->wifi_extension_info.mem_collect_average;

	return 0 ;
}

/*for sample cpu value  by nl  2010-08-26*/
int wid_accouting_cpu_sample_average_and_peak(unsigned int wtpid){
	unsigned int i_sample = 0;/**/
	unsigned int j = 0, k = 0;/*j k */
	unsigned int i_node = 0;/**/
	unsigned int D_value = 0;/**/
	unsigned int sum_cpu_value = 0;/*cpu */
	unsigned int sample_times = 0;/**/
	unsigned int total_sample_time = 0;/**/
	int ret = 0;

	ret = WID_CHECK_ID(WID_WTP_CHECK,wtpid);

	if(ret != 0){
		wid_syslog_info("wtpid error = %d at %s\n",\
							wtpid, __func__);
		return -1 ;
	}
	
	if(sample_infor_interval <= 0){
		wid_syslog_info("sample_infor_interval = %d at %s\n",\
							sample_infor_interval,__func__);
		return -1 ;
	}
	
	total_sample_time = (AC_WTP[wtpid]->apcminfo.ap_cpu_info_length) 
						* (unsigned int) AC_WTP[wtpid]->wifi_extension_reportinterval;
	if(total_sample_time <= 0){
		wid_syslog_info("total_sample_time = %d at %s\n",\
									total_sample_time,__func__);
		return -1 ;
	}
	
	sample_times = total_sample_time/sample_infor_interval;
	
	if(sample_times <= 0){
		wid_syslog_info("sample_times = %d at %s\n",\
							sample_infor_interval,__func__);
		return -1 ;
	}
	
	struct ap_cpu_info  *Node_cpu = AC_WTP[wtpid]->apcminfo.ap_cpu_info_head;
	AC_WTP[wtpid]->apcminfo.cpu_peak_value = Node_cpu->value;

	for(i_sample=0;i_sample<sample_times;i_sample++){
		if(0 == i_sample ){
			sum_cpu_value = Node_cpu->value;
		}
		else{
			k = (((i_sample * sample_infor_interval)+(unsigned int) AC_WTP[wtpid]->wifi_extension_reportinterval))
				/(unsigned int) AC_WTP[wtpid]->wifi_extension_reportinterval;
			j = ((((i_sample-1) * sample_infor_interval)+(unsigned int) AC_WTP[wtpid]->wifi_extension_reportinterval))
				/(unsigned int) AC_WTP[wtpid]->wifi_extension_reportinterval;
			D_value = k - j;
			for(i_node = 0;i_node < D_value;i_node++){
				if(Node_cpu!= NULL&&Node_cpu->next != NULL){
					Node_cpu = Node_cpu->next;
				}
			}
			sum_cpu_value += Node_cpu->value;
			if(AC_WTP[wtpid]->apcminfo.cpu_peak_value < Node_cpu->value){
				AC_WTP[wtpid]->apcminfo.cpu_peak_value = Node_cpu->value;
			}
		}
	}

	AC_WTP[wtpid]->wifi_extension_info.cpu_collect_average = 
						sum_cpu_value / sample_times ;

	AC_WTP[wtpid]->apcminfo.cpu_average = AC_WTP[wtpid]->wifi_extension_info.cpu_collect_average;


	return 0 ;
}

/*for sample mem value  by nl  2010-08-26*/
int wid_accouting_mem_sample_average_and_peak(unsigned int wtpid){
	unsigned int i_sample = 0;/**/
	unsigned int j = 0, k = 0;/*j k */
	unsigned int i_node = 0;/**/
	unsigned int D_value = 0;/**/
	unsigned int sum_mem_value = 0;/*cpu */
	unsigned int sample_times = 0;/**/
	unsigned int total_sample_time = 0;/**/
	int ret = 0 ;
	
	if(sample_infor_interval <= 0){
		wid_syslog_info("sample_infor_interval = %d at %s\n",\
							sample_infor_interval,__func__);
		return -1 ;
	}
	
	ret = WID_CHECK_ID(WID_WTP_CHECK,wtpid);

	if(ret != 0){
		wid_syslog_info("wtpid error = %d at %s\n",\
							wtpid, __func__);
		return -1 ;
	}
	
	total_sample_time = (AC_WTP[wtpid]->apcminfo.ap_mem_info_length) 
						* (unsigned int) AC_WTP[wtpid]->wifi_extension_reportinterval;

	if(total_sample_time <= 0){
		wid_syslog_info("total_sample_time = %d at %s\n",\
									total_sample_time,__func__);
		return -1 ;
	}
	
	sample_times = total_sample_time/sample_infor_interval;
	
	if(sample_times <= 0){
		wid_syslog_info("sample_times = %d at %s\n",\
							sample_infor_interval,__func__);
		return -1 ;
	}
	
	struct ap_cpu_info  *Node_mem = AC_WTP[wtpid]->apcminfo.ap_mem_info_head;
	AC_WTP[wtpid]->apcminfo.mem_peak_value = Node_mem->value;

	for(i_sample=0;i_sample<sample_times;i_sample++){
		if(0 == i_sample ){
			sum_mem_value = Node_mem->value;
		}
		else{
			k = (((i_sample * sample_infor_interval)+(unsigned int) AC_WTP[wtpid]->wifi_extension_reportinterval))
				/(unsigned int) AC_WTP[wtpid]->wifi_extension_reportinterval;
			j = ((((i_sample-1) * sample_infor_interval)+(unsigned int) AC_WTP[wtpid]->wifi_extension_reportinterval))
				/(unsigned int) AC_WTP[wtpid]->wifi_extension_reportinterval;
			D_value = k - j;
			for(i_node = 0;i_node < D_value;i_node++){
				if(Node_mem!= NULL&&Node_mem->next != NULL){
					Node_mem = Node_mem->next;
				}
			}
			sum_mem_value += Node_mem->value;
			if(AC_WTP[wtpid]->apcminfo.cpu_peak_value < Node_mem->value){
				AC_WTP[wtpid]->apcminfo.cpu_peak_value = Node_mem->value;
			}
		}
	}
	
	AC_WTP[wtpid]->wifi_extension_info.mem_collect_average = 
						sum_mem_value / sample_times ;

	AC_WTP[wtpid]->apcminfo.mem_average = AC_WTP[wtpid]->wifi_extension_info.mem_collect_average;
	/*printf("sample_times %d\n",sample_times);
	printf("mem_average %d\n",AC_WTP[wtpid]->apcminfo.mem_average );*/
	
	return 0 ;
}

int accounting_snr_math_average(unsigned int wtpid,int average_num){
	int i = 0;
	int sum = 0;
	double pi = 0;
	double sum1 = 0;
	
	for(i=0;i<average_num;i++){
		sum = sum + AC_WTP[wtpid]->wtp_wifi_snr_stats.snr[i];
		pi = pow(10,(double)(AC_WTP[wtpid]->wtp_wifi_snr_stats.snr[i]/10.00));
		sum1 = sum1 +pi;
		/*printf(" AC_WTP[wtpid]->wtp_wifi_snr_stats.snr[i] %d\n", AC_WTP[wtpid]->wtp_wifi_snr_stats.snr[i]);
		printf("pi %g\n",pi);
		printf("sum1 %g\n",sum1);*/
	}
	AC_WTP[wtpid]->wtp_wifi_snr_stats.snr_average = sum/average_num;
	AC_WTP[wtpid]->wtp_wifi_snr_stats.snr_math_average = 10*log10(sum1/average_num);

	return 0;
}
/*for sample snr value  by nl  2010-09-07*/
struct ap_snr_info  * find_next_sample_node(unsigned int wtpid,unsigned int i_sample,struct ap_snr_info  *Node_snr){
	unsigned int j =0 ;			/*j */
	unsigned int k = 0; 		/*k */
	unsigned int D_value;		/**/
	unsigned int i_node = 0;	/**/
	int ret = WID_DBUS_SUCCESS;
	struct ap_snr_info  *search_node = Node_snr;

	ret = WID_CHECK_ID(WID_WTP_CHECK,wtpid);

	if(ret != WID_DBUS_SUCCESS ){
		wid_syslog_info("wtpid error = %d at %s\n",\
						wtpid, __func__);
		return NULL ;
	}
	
	if(AC_WTP[wtpid]->wifi_extension_reportinterval <= 0){
		wid_syslog_debug_debug(WID_DEFAULT,"reportinterval <= 0 in func %s \n",__func__);
		return NULL;
	}
	
	k = (((i_sample * sample_infor_interval)+(unsigned int) AC_WTP[wtpid]->wifi_extension_reportinterval))
					/(unsigned int) AC_WTP[wtpid]->wifi_extension_reportinterval;
	
	j = ((((i_sample-1) * sample_infor_interval)+(unsigned int) AC_WTP[wtpid]->wifi_extension_reportinterval))
		/(unsigned int) AC_WTP[wtpid]->wifi_extension_reportinterval;
	
	D_value = k - j;
	
	for(i_node = 0;i_node < D_value;i_node++){
		if(search_node!= NULL&&search_node->next != NULL){
			search_node = search_node->next;
		}
	}
	
	return search_node;
}
int wid_add_snr_value_for_accounting_average(unsigned int wtpid,unsigned char snr_value,unsigned int l_radioid){ //fengwenchao modify 20120314 for onlinebug-162//qiuchen copy from v1.3
	wid_syslog_debug_debug(WID_DEFAULT,"snr value : %d \n", snr_value);

	struct ap_snr_info  *snr_node = NULL;
	if((snr_node = (struct ap_snr_info*)malloc(sizeof(struct ap_snr_info))) == NULL){
		wid_syslog_debug_debug(WID_DEFAULT,"malloc fail in %s. \n",__func__);
		return -1;
	}
	else{
		snr_node->value = snr_value;
		snr_node->next = NULL;
		if(AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].ap_snr_info_head == NULL){
			AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].ap_snr_info_head = snr_node;
			AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].ap_snr_info_length++;
		}
		else{
			snr_node->next = AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].ap_snr_info_head;
			AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].ap_snr_info_head = snr_node;
			AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].ap_snr_info_length++;
		}
 		return 0;
	}
}

int wid_del_snr_value_for_accounting_average(unsigned int wtpid,unsigned int total_node_num,unsigned int l_radioid){ //fengwenchao add 20120314 for onlinebug-162//qiuchen copy from v1.3
	struct ap_snr_info  *p = AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].ap_snr_info_head ;

	struct ap_snr_info  *tmp = NULL;
	int i=0;
	
	for(i=0;i<total_node_num;i++){
		if (p!= NULL){
			tmp = p;
			p = p->next;
		}
	}
	tmp->next = NULL;
	
	while(p!=NULL){
		tmp = p;
		p = p->next;
		tmp->next = NULL;
		free(tmp);
		tmp = NULL;
		AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].ap_snr_info_length--;
 	}
	
	wid_syslog_debug_debug(WID_DEFAULT,"AC_WTP[%d]->ap_snr_info_length = %d\n",\
							wtpid,AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].ap_snr_info_length);
	
	return 0;
}

/*for sample snr value  by nl  2010-09-09*/
struct ap_cpu_info  * find_next_sample_node2(unsigned int wtpid,unsigned int i_sample,struct ap_cpu_info  *Node_snr){
	unsigned int j =0 ;				/*j */
	unsigned int k = 0;				/*k */
	unsigned int D_value;			/**/
	unsigned int i_node = 0;		/**/
	int ret = WID_DBUS_SUCCESS;
	
	struct ap_cpu_info  *search_node = Node_snr;

	ret = WID_CHECK_ID(WID_WTP_CHECK,wtpid);

	if(ret != WID_DBUS_SUCCESS ){
		wid_syslog_info("wtpid error = %d at %s\n",\
						wtpid, __func__);
		return NULL ;
	}

	if(AC_WTP[wtpid]->wifi_extension_reportinterval <= 0){
		wid_syslog_debug_debug(WID_DEFAULT,"reportinterval <= 0 in func %s \n",__func__);
		return NULL;
	}
	
	k = (((i_sample * sample_infor_interval)+(unsigned int) AC_WTP[wtpid]->wifi_extension_reportinterval))
					/(unsigned int) AC_WTP[wtpid]->wifi_extension_reportinterval;
	
	j = ((((i_sample-1) * sample_infor_interval)+(unsigned int) AC_WTP[wtpid]->wifi_extension_reportinterval))
		/(unsigned int) AC_WTP[wtpid]->wifi_extension_reportinterval;
	
	D_value = k - j;
	
	for(i_node = 0;i_node < D_value;i_node++){
		if(search_node!= NULL&&search_node->next != NULL){
			search_node = search_node->next;
		}
	}
	
	return search_node;
}
/*for sample snr value  by nl  2010-09-08*/
int wid_accouting_snr_average(unsigned int wtpid,unsigned int l_radioid){ //fengwenchao modify 20120314 for onlinebug-162//qiuchen copy from v1.3

	unsigned int sum_snr_value = 0;
	int valued_num = 0;				/*accounting for the not zero value number */
	int ret = WID_DBUS_SUCCESS;

	ret = WID_CHECK_ID(WID_WTP_CHECK,wtpid);

	if(ret != 0){
		wid_syslog_info("wtpid error = %d at %s\n",\
							wtpid, __func__);
		return -1 ;
	}
	
	struct ap_snr_info  *Node_snr = AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].ap_snr_info_head;
	AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].snr_max_value = Node_snr->value;
	
	while(Node_snr != NULL){
		if(Node_snr->value != 0){
			valued_num ++;
			if(valued_num > AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].ap_snr_info_length){
				wid_syslog_info("vlued_num  > ap_snr_info_length at %s\n",__func__);
				return -1;
			}
			if(AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].snr_max_value < Node_snr->value) {
				AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].snr_max_value = Node_snr->value;
			}
			if(AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].snr_min_value > Node_snr->value){
				AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].snr_min_value = Node_snr->value;
			}
			
			sum_snr_value += Node_snr->value;
			Node_snr = Node_snr->next;
		}
	}
	
	/*AC_WTP[wtpid]->wifi_extension_info.snr_collect_average = 
						sum_snr_value / AC_WTP[wtpid]->apcminfo.ap_snr_info_length ;
	AC_WTP[wtpid]->apcminfo.snr_average = AC_WTP[wtpid]->wifi_extension_info.snr_collect_average;*/
	
	/*if the omc requir not accounting the 0 node, use the valued num ,else use the AC_WTP[wtpid]->apcminfo.ap_snr_info_length*/
#if 0
	AC_WTP[wtpid]->apcminfo.snr_average = sum_snr_value / AC_WTP[wtpid]->apcminfo.ap_snr_info_length ;*/
#endif

	AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].snr_average = sum_snr_value / valued_num ;

	return WID_DBUS_SUCCESS ;
}

/*for sample snr value  by nl  2010-09-07*/
int wid_accouting_snr_sample_average_and_peak(unsigned int wtpid,unsigned int l_radioid){ //fengwenchao add 20120314 for onlinebug-162//qiuchen copy from v1.3

	//printf("#########wid_accouting_snr_sample_average_and_peak#######\n");
	unsigned int i_sample = 0;				/**/
	//unsigned int i_node = 0;					/**/
	//unsigned int D_value = 0;					/**/
	unsigned int sum_snr_value = 0;			/*snr */
	unsigned int sample_times = 0;			/**/
	unsigned int total_sample_time = 0;		/**/
	int ret = WID_DBUS_SUCCESS ;
	int valued_num = 0;						/**/
	double pi = 0;							/*10 */
	double double_sum = 0;					/*pi  */
	struct ap_snr_info  *sample_node= NULL;
	
	if(sample_infor_interval <= 0){
		wid_syslog_info("sample_infor_interval = %d at %s\n",\
							sample_infor_interval,__func__);
		return -1 ;
	}
	
	ret = WID_CHECK_ID(WID_WTP_CHECK,wtpid);

	if(ret != WID_DBUS_SUCCESS){
		wid_syslog_info("wtpid error = %d at %s\n",\
							wtpid, __func__);
		return -1 ;
	}
	
	total_sample_time = (AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].ap_snr_info_length) 
						* (unsigned int) AC_WTP[wtpid]->wifi_extension_reportinterval;

	if(total_sample_time <= 0){
		wid_syslog_info("total_sample_time = %d at %s\n",\
									total_sample_time,__func__);
		return -1 ;
	}
	
	sample_times = total_sample_time/sample_infor_interval;
	
	if(sample_times <= 0){
		wid_syslog_info("sample_times = %d at %s\n",\
							sample_infor_interval,__func__);
		return -1 ;
	}
	
	struct ap_snr_info  *Node_snr = AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].ap_snr_info_head;
	AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].snr_max_value = Node_snr->value;
	AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].snr_min_value = Node_snr->value;

	for(i_sample=0;i_sample<sample_times;i_sample++){
		if(0 == i_sample ){
			if(0==Node_snr->value){
				sum_snr_value = 0;
				double_sum = 0;
				wid_syslog_debug_debug(WID_DEFAULT,"i_sample ==0 at %s\n",\
							 __func__);
			}
			else{
				sum_snr_value = Node_snr->value;
				pi = pow(10,( Node_snr->value/10.00));
				double_sum += pi;	
				valued_num++;
			}
		}
		else{
			/*
			k = (((i_sample * sample_infor_interval)+(unsigned int) AC_WTP[wtpid]->reportinterval))
				/(unsigned int) AC_WTP[wtpid]->reportinterval;
			j = ((((i_sample-1) * sample_infor_interval)+(unsigned int) AC_WTP[wtpid]->reportinterval))
				/(unsigned int) AC_WTP[wtpid]->reportinterval;
			D_value = k - j;
			for(i_node = 0;i_node < D_value;i_node++){
				if(Node_snr!= NULL&&Node_snr->next != NULL){
					Node_snr = Node_snr->next;
				}
			}*/

			sample_node = find_next_sample_node(wtpid,i_sample,Node_snr);
			Node_snr = sample_node ; 

			if(sample_node == NULL){
				wid_syslog_info(" wtp %d sample_node == NULL at %s\n",\
										wtpid, __func__);
			}
			
			if(sample_node->value !=0){
				valued_num ++;
				sum_snr_value += sample_node->value;
				pi = pow(10,( sample_node->value/10.00));
				double_sum = double_sum +pi;

				//AC_WTP[wtpid]->wtp_wifi_snr_stats.snr_average = sum/average_num;
				
				/*printf("### sample_node->value ###%d\n", sample_node->value);
				printf(" sample_node->snr_max_value %d\n", AC_WTP[wtpid]->apcminfo.snr_max_value);
				printf(" sample_node->snr_min_value %d\n", AC_WTP[wtpid]->apcminfo.snr_min_value);*/
				
				if(AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].snr_max_value < sample_node->value){
					AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].snr_max_value = sample_node->value;
				}
				if(AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].snr_min_value > sample_node->value){
					AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].snr_min_value = sample_node->value;
				}
			  /*printf("111 sample_node->snr_max_value %d\n", AC_WTP[wtpid]->apcminfo.snr_max_value);
				printf("111 sample_node->snr_min_value %d\n", AC_WTP[wtpid]->apcminfo.snr_min_value);*/
			}
		}
	}
	
	if(valued_num != 0){
		AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].snr_average = (unsigned char)(sum_snr_value /valued_num) ;
		/*snr_math_average */
		AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].snr_math_average = 10*log10(double_sum/valued_num);	
		//printf("  math_average %g \n",AC_WTP[wtpid]->apcminfo.snr_math_average);
	}
	else{
		AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].snr_average = 0;
		AC_WTP[wtpid]->apcminfo.wifi_snr[l_radioid].snr_math_average = 0 ;
	}
	
	return WID_DBUS_SUCCESS ;
}

int wid_ap_cpu_mem_statistics(unsigned int wtpid)
{
	//struct ap_cpu_info  *cpu_node = NULL;
	//struct ap_cpu_info  *mem_node = NULL;
	unsigned int total_node_num = 0 ;
	unsigned int reportinterval = 0;
	int ret = WID_DBUS_SUCCESS;int ret2 = WID_DBUS_SUCCESS;int ret3 = WID_DBUS_SUCCESS;
	int i = 0;
	
	ret = WID_CHECK_ID(WID_WTP_CHECK,wtpid);

	if(ret != WID_DBUS_SUCCESS){
		wid_syslog_debug_debug(WID_DEFAULT," wtpid %d error in func %s",wtpid,__func__);
		return -1;
	}

	if(AC_WTP[wtpid] == NULL)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"input wtpid %d error",wtpid);
		return -1;
	}

	reportinterval = (unsigned int) AC_WTP[wtpid]->wifi_extension_reportinterval;
	if(reportinterval <= 0){
		wid_syslog_debug_debug(WID_DEFAULT,"reportinterval <= 0 \n");
		return -1;
	}
	total_node_num = (AC_WTP[wtpid]->collect_time + reportinterval - 1)/reportinterval;
	if(total_node_num == 0){
		wid_syslog_debug_debug(WID_DEFAULT,"total_node_num == 0 \n");
		return -1;
	}

	//cpu
	{
		AC_WTP[wtpid]->apcminfo.cpu_times++;
 		ret = wid_add_cpu_value_for_accounting_average(wtpid,AC_WTP[wtpid]->wifi_extension_info.cpu);
		
 		if(ret == WID_DBUS_SUCCESS){
 			if(AC_WTP[wtpid]->apcminfo.ap_cpu_info_length > total_node_num){
				ret2 = wid_del_cpu_value_for_accounting_average(wtpid,total_node_num);
				if(ret2 != WID_DBUS_SUCCESS){
					wid_syslog_debug_debug(WID_DEFAULT,"wid_del_cpu_value_for_accounting_average error\n");
					return -1;
				}
			}
 			if((AC_WTP[wtpid]->apcminfo.ap_cpu_info_length != 0) && 
				(AC_WTP[wtpid]->apcminfo.ap_cpu_info_head!=NULL)){
				if(sample_infor_interval == 0){
					ret3 = wid_accouting_cpu_average(wtpid);
				}
				else{
					ret3 = wid_accouting_cpu_sample_average_and_peak(wtpid);
				}
				if(ret3 != WID_DBUS_SUCCESS){
					wid_syslog_debug_debug(WID_DEFAULT,"wid_accouting_cpu_sample_average_and_peak error\n");
					return -1;
				}
			}
		}
		else
			return -1;
 	}
	//memory usage
	{
		AC_WTP[wtpid]->apcminfo.mem_times++;
 		ret = wid_add_mem_value_for_accounting_average(wtpid,AC_WTP[wtpid]->wifi_extension_info.memoryuse);
 		if(ret == WID_DBUS_SUCCESS){
 			if(AC_WTP[wtpid]->apcminfo.ap_mem_info_length > total_node_num){
				ret2 = wid_del_mem_value_for_accounting_average(wtpid,total_node_num);
				if(ret2 != WID_DBUS_SUCCESS){
					wid_syslog_debug_debug(WID_DEFAULT,"wid_del_mem_value_for_accounting_average error\n");
					return -1;
				}
			}
 			if((AC_WTP[wtpid]->apcminfo.ap_mem_info_length != 0) && 
				(AC_WTP[wtpid]->apcminfo.ap_mem_info_head!=NULL)){
				if(sample_infor_interval == 0){
					ret3 = wid_accouting_mem_average(wtpid);
				}
				else{
					ret3 = wid_accouting_mem_sample_average_and_peak(wtpid);
				}
				if(ret3 != WID_DBUS_SUCCESS){
					wid_syslog_debug_debug(WID_DEFAULT,"wid_accouting_mem_sample_average_and_peak error\n");
					return -1;
				}
			}
		}
		else
			return -1;
 	}
	
#if 0	
	{
		AC_WTP[wtpid]->apcminfo.mem_times++;
		if((mem_node = (struct ap_cpu_info*)malloc(sizeof(struct ap_cpu_info))) == NULL){
			wid_syslog_debug_debug(WID_DEFAULT,"malloc fail in %s \n",__func__);
		}else{ 
			mem_node->value = AC_WTP[wtpid]->wifi_extension_info.memoryuse;
			mem_node->next = NULL;
			
			if(AC_WTP[wtpid]->apcminfo.ap_mem_info_head == NULL){
				AC_WTP[wtpid]->apcminfo.ap_mem_info_head = mem_node;
				AC_WTP[wtpid]->apcminfo.ap_mem_info_length++;
			}
			else{
				mem_node->next = AC_WTP[wtpid]->apcminfo.ap_mem_info_head;
				AC_WTP[wtpid]->apcminfo.ap_mem_info_head = mem_node;
				AC_WTP[wtpid]->apcminfo.ap_mem_info_length++;
			}
		}
		
		if(AC_WTP[wtpid]->apcminfo.ap_mem_info_length > total_node_num){
			struct ap_cpu_info	*p = AC_WTP[wtpid]->apcminfo.ap_mem_info_head ;
			struct ap_cpu_info	*tmp = NULL;
			
			for(i=0;i<total_node_num;i++){
				if (p!= NULL){
					tmp = p;
					p = p->next;
				}
			}
			tmp->next = NULL;
			
			while(p!=NULL){
				tmp = p;
				p = p->next;
				tmp->next = NULL;
				free(tmp);
				tmp = NULL;
				AC_WTP[wtpid]->apcminfo.ap_mem_info_length--;
			}

		}

		wid_syslog_debug_debug(WID_DEFAULT,"AC_WTP[%d]->ap_mem_info_length = %d\n",wtpid,AC_WTP[wtpid]->apcminfo.ap_mem_info_length);
		if((AC_WTP[wtpid]->apcminfo.ap_mem_info_length != 0) && (AC_WTP[wtpid]->apcminfo.ap_mem_info_head!=NULL)) {
			unsigned int sum_mem_value;
			struct ap_cpu_info	*Node_cpu = AC_WTP[wtpid]->apcminfo.ap_mem_info_head;
			AC_WTP[wtpid]->apcminfo.mem_peak_value = Node_cpu->value;
			for(; Node_cpu; Node_cpu=Node_cpu->next){
				if(AC_WTP[wtpid]->apcminfo.mem_peak_value < Node_cpu->value) {
					AC_WTP[wtpid]->apcminfo.mem_peak_value = Node_cpu->value;
				}
				sum_mem_value += Node_cpu->value;
			}
			AC_WTP[wtpid]->apcminfo.mem_average = sum_mem_value/AC_WTP[wtpid]->apcminfo.ap_mem_info_length ;
		}
	}
#endif
	
	/*accounting snr math average and sample average*/
	for(i =0;i < AC_WTP[wtpid]->wifi_extension_info.wifi_count;i++)
	{
		AC_WTP[wtpid]->apcminfo.wifi_snr[i].snr_times++;
		ret = wid_add_snr_value_for_accounting_average(wtpid,AC_WTP[wtpid]->wifi_extension_info.wifi_snr_new[i],i);
		if(ret == WID_DBUS_SUCCESS){
			if(AC_WTP[wtpid]->apcminfo.wifi_snr[i].ap_snr_info_length > total_node_num){
				ret2 = wid_del_snr_value_for_accounting_average(wtpid,total_node_num,i);
				if(ret2 != WID_DBUS_SUCCESS){
					wid_syslog_debug_debug(WID_DEFAULT,"wid_del_snr_value_for_accounting_average error\n");
					return -1;
				}
			}
			if((AC_WTP[wtpid]->apcminfo.wifi_snr[i].ap_snr_info_length != 0) && 
				(AC_WTP[wtpid]->apcminfo.wifi_snr[i].ap_snr_info_head!=NULL)){
				if(sample_infor_interval == 0){
					ret3 = wid_accouting_snr_average(wtpid,i);
				}
				else{
					ret3 = wid_accouting_snr_sample_average_and_peak(wtpid,i);
				}
				if(ret3 != WID_DBUS_SUCCESS){
					wid_syslog_debug_debug(WID_DEFAULT,"wid_accouting_snr_sample_average_and_peak error\n");
					return -1;
				}
			}
		}
		else
			return -1;
	}
#if 0 
	//wifi snr stat
	{
		if(AC_WTP[wtpid]->wtp_wifi_snr_stats.snr_max < AC_WTP[wtpid]->wifi_extension_info.wifi_snr)
		{
			AC_WTP[wtpid]->wtp_wifi_snr_stats.snr_max = AC_WTP[wtpid]->wifi_extension_info.wifi_snr;
		}
		if(AC_WTP[wtpid]->wifi_extension_info.wifi_snr != 0)
		{
			if(AC_WTP[wtpid]->wtp_wifi_snr_stats.snr_min > AC_WTP[wtpid]->wifi_extension_info.wifi_snr)
			{
				AC_WTP[wtpid]->wtp_wifi_snr_stats.snr_min = AC_WTP[wtpid]->wifi_extension_info.wifi_snr;
			}
		}
		i =  (AC_WTP[wtpid]->apcminfo.mem_times)%10;
		AC_WTP[wtpid]->wtp_wifi_snr_stats.snr[i] = AC_WTP[wtpid]->wifi_extension_info.wifi_snr;

		if((AC_WTP[wtpid]->apcminfo.mem_times) < 10 && (AC_WTP[wtpid]->apcminfo.mem_times > 0)){
			snr_ret= accounting_snr_math_average(wtpid,AC_WTP[wtpid]->apcminfo.mem_times);
		}
		else if(AC_WTP[wtpid]->apcminfo.mem_times >= 10){
			snr_ret = accounting_snr_math_average(wtpid,10);
		}
	}
	return 0;
	
#endif
	return 0;
}

int wid_parse_wtp_cpu_mem_trap_info(unsigned int wtpid)
{
	unsigned char IGNORE_UBSV flag = 0;
	int i = 0;
	int m = 0;
	unsigned int times = 0;
	unsigned int interval = 0;
	
	//cpu mem statistics
	wid_ap_cpu_mem_statistics(wtpid);
		
	if(AC_WTP[wtpid] == NULL)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"input wtpid %d error",wtpid);
		return -1;
	}
	m = AC_WTP[wtpid]->trap_collect_time%AC_WTP[wtpid]->wifi_extension_reportinterval;
	interval = AC_WTP[wtpid]->wifi_extension_reportinterval;
	if(interval != 0){
		if(m == 0){
			times = AC_WTP[wtpid]->trap_collect_time/interval;
		}else{
			times = AC_WTP[wtpid]->trap_collect_time/interval + 1;
		}
	}
	
	//cpu
	//- if((AC_WTP[wtpid]->wifi_extension_info.cpu)/100 > g_ap_cpu_threshold)
	if((AC_WTP[wtpid]->wifi_extension_info.cpu)/100 > AC_WTP[wtpid]->wtp_cpu_use_threshold)
	{
		if(AC_WTP[wtpid]->wifi_extension_info.cpu_trap_flag == 0)    //fengwenchao add 20110221 
		{
			AC_WTP[wtpid]->cpu_resend_times ++;
			flag = 1;

			if(gtrapflag>=4){
				//-if((gtrap_ap_cpu_trap_switch == 1)&&(AC_WTP[wtpid]->wtp_cpu_use_threshold < ((AC_WTP[wtpid]->wifi_extension_info.cpu)/100)))
				if((gtrap_ap_cpu_trap_switch == 1)&&(AC_WTP[wtpid]->wtp_cpu_use_threshold < ((AC_WTP[wtpid]->apcminfo.cpu_average)/100)))
					if(AC_WTP[wtpid]->cpu_resend_times >= times){
							AC_WTP[wtpid]->wifi_extension_info.cpu_trap_flag = 1;
							#if NOSOFTAC
							wid_dbus_trap_ap_cpu_threshold(wtpid,flag);							
							#endif
						AC_WTP[wtpid]->cpu_resend_times = 0;
					}
				}
		}
	}
	else
	{
		if(AC_WTP[wtpid]->wifi_extension_info.cpu_trap_flag == 1)
		{
			flag = 0;
			AC_WTP[wtpid]->cpu_clear_resend_times ++;
			if(gtrapflag>=4){
				//--if((gtrap_ap_cpu_trap_switch == 1)&&(AC_WTP[wtpid]->wtp_cpu_use_threshold > ((AC_WTP[wtpid]->wifi_extension_info.cpu)/100)))
				if((gtrap_ap_cpu_trap_switch == 1)&&(AC_WTP[wtpid]->wtp_cpu_use_threshold > ((AC_WTP[wtpid]->apcminfo.cpu_average)/100)))
					if(AC_WTP[wtpid]->cpu_clear_resend_times >= times){
						AC_WTP[wtpid]->wifi_extension_info.cpu_trap_flag = 0;
						#if NOSOFTAC
						wid_dbus_trap_ap_cpu_threshold(wtpid,flag);
						#endif
						AC_WTP[wtpid]->cpu_clear_resend_times = 0;
					}
				}
		}
		else
		{
			
		}
	}
	//mem
	//--if(AC_WTP[wtpid]->wifi_extension_info.memoryuse > g_ap_memuse_threshold)
	if(AC_WTP[wtpid]->wifi_extension_info.memoryuse > AC_WTP[wtpid]->wtp_mem_use_threshold)
	{
		if(AC_WTP[wtpid]->wifi_extension_info.mem_trap_flag == 0)     //fengwenchao add 20110221
		{
			flag = 1;
			AC_WTP[wtpid]->memtrap_resend_times ++;
			if(gtrapflag>=4){
				//if((gtrap_ap_mem_trap_switch == 1)&&(AC_WTP[wtpid]->wtp_mem_use_threshold < AC_WTP[wtpid]->wifi_extension_info.memoryuse))
				if((gtrap_ap_mem_trap_switch == 1)&&(AC_WTP[wtpid]->wtp_mem_use_threshold < AC_WTP[wtpid]->apcminfo.mem_average))
					if(AC_WTP[wtpid]->memtrap_resend_times >= times){
						AC_WTP[wtpid]->wifi_extension_info.mem_trap_flag = 1;
							#if NOSOFTAC
							wid_dbus_trap_ap_mem_threshold(wtpid,flag);
							#endif
							AC_WTP[wtpid]->memtrap_resend_times = 0;
					}
				}
		}
	}
	else
	{
		if(AC_WTP[wtpid]->wifi_extension_info.mem_trap_flag == 1)
		{
			flag = 0;
			AC_WTP[wtpid]->memtrap_clear_resend_times ++;
			if(gtrapflag>=4){
				//--if((gtrap_ap_mem_trap_switch  == 1)&&(AC_WTP[wtpid]->wtp_mem_use_threshold > AC_WTP[wtpid]->wifi_extension_info.memoryuse)){
				if((gtrap_ap_mem_trap_switch  == 1)&&(AC_WTP[wtpid]->wtp_mem_use_threshold > AC_WTP[wtpid]->apcminfo.mem_average)){
					wid_syslog_debug_debug(WID_DBUS,"wtpid:%d,memtrap_clear_resend_times %d\n",wtpid,AC_WTP[wtpid]->memtrap_clear_resend_times);
					if(AC_WTP[wtpid]->memtrap_clear_resend_times >= times){
						AC_WTP[wtpid]->wifi_extension_info.mem_trap_flag = 0;
						#if NOSOFTAC
						wid_dbus_trap_ap_mem_threshold(wtpid,flag);
						#endif
						AC_WTP[wtpid]->memtrap_clear_resend_times = 0;
					}
				}
			}
		}
		else
		{
			
		}
	}
	//temp
	if(AC_WTP[wtpid]->wifi_extension_info.temperature > g_ap_temp_threshold)
	{
		if(AC_WTP[wtpid]->wifi_extension_info.temp_trap_flag == 0)     //fengwenchao add 20110221
		{
			flag = 1;
			AC_WTP[wtpid]->ap_temp_resend_times ++;
			if(gtrapflag>=4){
				wid_syslog_debug_debug(WID_DBUS,"wtpid:%d,ap_temp_resend_times %d\n",wtpid,AC_WTP[wtpid]->ap_temp_resend_times);
				if(AC_WTP[wtpid]->ap_temp_resend_times >= times){
					AC_WTP[wtpid]->wifi_extension_info.temp_trap_flag = 1;
						#if NOSOFTAC
						wid_dbus_trap_ap_temp_threshold(wtpid,flag);
						#endif
						AC_WTP[wtpid]->ap_temp_resend_times = 0;
				}
			}
		}
	}
	else
	{
		if(AC_WTP[wtpid]->wifi_extension_info.temp_trap_flag == 1)
		{
			flag = 0;
			AC_WTP[wtpid]->ap_temp_clear_resend_times ++;
			if(gtrapflag>=4){
				wid_syslog_debug_debug(WID_DBUS,"wtpid:%d,ap_temp_clear_resend_times %d\n",wtpid,AC_WTP[wtpid]->ap_temp_clear_resend_times);
				if(AC_WTP[wtpid]->ap_temp_clear_resend_times >= times){
					#if NOSOFTAC
					wid_dbus_trap_ap_temp_threshold(wtpid,flag);
					#endif
					AC_WTP[wtpid]->wifi_extension_info.temp_trap_flag = 0;
					AC_WTP[wtpid]->ap_temp_clear_resend_times = 0;
				}
			}
		}
		else
		{
			
		}
	}
	
	//wifi interface state trap
	if(AC_WTP[wtpid]->wifi_extension_info.wifi_count != 0)
	{
		for(i=0;i<AC_WTP[wtpid]->wifi_extension_info.wifi_count;i++)
		{
			if(AC_WTP[wtpid]->wifi_extension_info.wifi_state[i] == 3)
			{
				AC_WTP[wtpid]->wifi_extension_info.wifi_trap_flag[i] = 1;
				flag = 1;

				if(gtrapflag>=4){
					#if NOSOFTAC
					wid_dbus_trap_ap_wifi_if_error(wtpid,i,flag);
					#endif
				}
			}
			else if((AC_WTP[wtpid]->wifi_extension_info.wifi_state[i] == 1)||(AC_WTP[wtpid]->wifi_extension_info.wifi_state[i] == 2))
			{
				if(AC_WTP[wtpid]->wifi_extension_info.wifi_trap_flag[i] == 1)
				{
					flag = 0;

					if(gtrapflag>=4){
						#if NOSOFTAC
						wid_dbus_trap_ap_wifi_if_error(wtpid,i,flag);
						#endif
						AC_WTP[wtpid]->wifi_extension_info.wifi_trap_flag[i] = 0;  //fengwenchao add 20110302
						}
				}
				else
				{
					
				}
				//AC_WTP[wtpid]->wifi_extension_info.wifi_trap_flag[i] = 0;   //fengwenchao modify 20110302
			}
		}
	}
	
	return 0;
}
int wid_set_ap_sta_infomation_report(unsigned int wtpid)
{
	msgq msg;
	struct msgqlist *elem;
		
	if(AC_WTP[wtpid]->WTPStat == WID_RUN)
	{
		
		CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));
		if(gWTPs[wtpid].isNotFree && (gWTPs[wtpid].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = wtpid%THREAD_NUM+1;
			msg.mqinfo.WTPID = wtpid;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_INFO_SET;
			
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}
		CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));
	}
	else if((AC_WTP[wtpid] != NULL)){
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = wtpid%THREAD_NUM+1;
		msg.mqinfo.WTPID = wtpid;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WTP_S_TYPE;
		msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_INFO_SET;
		
		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if(elem == NULL){
			wid_syslog_info("%s malloc %s",__func__,strerror(errno));
			perror("malloc");
			return 0;
		}
		memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
		elem->next = NULL;
		memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
		WID_INSERT_CONTROL_LIST(wtpid, elem);
	}

	return 0;
	
}

int  wtp_set_sta_info_report(unsigned int wtpid,int policy)
{	
	msgq msg;
	struct msgqlist *elem;
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->sta_ip_report != policy))
	{
		printf("%s AC_WTP[%d]->sta_ip_report %d\n",__func__,wtpid,AC_WTP[wtpid]->sta_ip_report);
		AC_WTP[wtpid]->sta_ip_report = policy;
		
		if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPStat == WID_RUN))
		{
			CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));
			if(gWTPs[wtpid].isNotFree && (gWTPs[wtpid].currentState == CW_ENTER_RUN))
			{
				memset((char*)&msg, 0, sizeof(msg));
				msg.mqid = wtpid%THREAD_NUM+1;
				msg.mqinfo.WTPID = wtpid;
				msg.mqinfo.type = CONTROL_TYPE;
				msg.mqinfo.subtype = WTP_S_TYPE;
				msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_INFO_REPORT;
				msg.mqinfo.u.WtpInfo.value2 = policy;
				if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
					wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
				}
			}		
			CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));
		}else if((AC_WTP[wtpid] != NULL)){
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = wtpid%THREAD_NUM+1;
			msg.mqinfo.WTPID = wtpid;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_INFO_REPORT;
			msg.mqinfo.u.WtpInfo.value2 = policy;
		
			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if(elem == NULL){
				wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
				perror("malloc");
				return 0;
			}
			memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
			elem->next = NULL;
			memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
			WID_INSERT_CONTROL_LIST(wtpid, elem);
			elem = NULL;
		}
	}
	return 0;
}

/*wcl add for globle variable*/

int  wtp_set_wtp_dhcp_snooping(unsigned int wtpid,int policy)
{	
	msgq msg;
	struct msgqlist *elem;
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->dhcp_snooping != policy))
	{
		printf("%s AC_WTP[%d]->dhcp_snooping %d\n",__func__,wtpid,AC_WTP[wtpid]->dhcp_snooping);
		AC_WTP[wtpid]->dhcp_snooping = policy;
		
		if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPStat == WID_RUN))
		{
			CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));
			if(gWTPs[wtpid].isNotFree && (gWTPs[wtpid].currentState == CW_ENTER_RUN))
			{
				memset((char*)&msg, 0, sizeof(msg));
				msg.mqid = wtpid%THREAD_NUM+1;
				msg.mqinfo.WTPID = wtpid;
				msg.mqinfo.type = CONTROL_TYPE;
				msg.mqinfo.subtype = WTP_S_TYPE;
				msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_DHCP_SNOOPING;
				msg.mqinfo.u.WtpInfo.value2 = policy;
				if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
					wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
				}
			}		
			CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));
		}else if((AC_WTP[wtpid] != NULL)){
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = wtpid%THREAD_NUM+1;
			msg.mqinfo.WTPID = wtpid;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_DHCP_SNOOPING;
			msg.mqinfo.u.WtpInfo.value2 = policy;
		
			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if(elem == NULL){
				wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
				perror("malloc");
				return 0;
			}
			memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
			elem->next = NULL;
			memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
			WID_INSERT_CONTROL_LIST(wtpid, elem);
			elem = NULL;
		}
	}
	return 0;
}
/*end*/
int wid_set_ap_sta_wapi_info_report(unsigned int wtpid)
{
	msgq msg;
	struct msgqlist *elem;
		
	if(AC_WTP[wtpid]->WTPStat == WID_RUN)
	{
		
		CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));
		if(gWTPs[wtpid].isNotFree && (gWTPs[wtpid].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = wtpid%THREAD_NUM+1;
			msg.mqinfo.WTPID = wtpid;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_WAPI_INFO_SET;
			
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
				wid_syslog_info("%s msgsend %s",__func__,strerror(errno));
			}
		}
		CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));
	}
	else if((AC_WTP[wtpid] != NULL)){
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = wtpid%THREAD_NUM+1;
		msg.mqinfo.WTPID = wtpid;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WTP_S_TYPE;
		msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_WAPI_INFO_SET;
					
		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if(elem == NULL){
			wid_syslog_info("%s malloc %s",__func__,strerror(errno));
			perror("malloc");
			return 0;
		}
		memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
		elem->next = NULL;
		memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
		WID_INSERT_CONTROL_LIST(wtpid, elem);
	}

	return 0;
	
}

int wid_set_ap_if_info_report(unsigned int wtpid)
{
	msgq msg;
	struct msgqlist *elem;
		
	if(AC_WTP[wtpid]->WTPStat == WID_RUN)
	{
		
		CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));
		if(gWTPs[wtpid].isNotFree && (gWTPs[wtpid].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = wtpid%THREAD_NUM+1;
			msg.mqinfo.WTPID = wtpid;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_IF_INFO_SET;
			
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}
		CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));
	}
	else if((AC_WTP[wtpid] != NULL)){
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = wtpid%THREAD_NUM+1;
		msg.mqinfo.WTPID = wtpid;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WTP_S_TYPE;
		msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_IF_INFO_SET;

		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if(elem == NULL){
			wid_syslog_info("%s malloc %s",__func__,strerror(errno));
			perror("malloc");
			return 0;
		}
		memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
		elem->next = NULL;
		memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
		WID_INSERT_CONTROL_LIST(wtpid, elem);
	}

	return 0;
	
}
int wid_set_ap_wids_set(unsigned int wtpid)
{
	msgq msg;
		
	if(AC_WTP[wtpid]->WTPStat == WID_RUN)
	{
		
		CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));
		if(gWTPs[wtpid].isNotFree && (gWTPs[wtpid].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = wtpid%THREAD_NUM+1;
			msg.mqinfo.WTPID = wtpid;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_WIDS_SET;
			
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}
		CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));
	}

	return 0;
	
}
int wid_set_ap_if_updown(unsigned int wtpid,unsigned char type,unsigned char ifindex,unsigned char policy)
{
	int IGNORE_UBSV ret = 0;
	wid_syslog_debug_debug(WID_DEFAULT,"wid_set_ap_if_updown wtpid %d,type %d,ifindex %d,policy %d\n",wtpid,type,ifindex,policy);
	char iftype[2][5] = {"eth","wifi"};
	char ifpolicy[2][5] = {"down","up"};
	time_t t;			//xiaodawei add for state time, 20110114
	time(&t);

	if(type == 0)//eth
	{
		if(policy == 0)//down
		{
			if(AC_WTP[wtpid]->apifinfo.eth[ifindex].state == 2)//state down
			{
				return 0;
			}
			else
			{
				AC_WTP[wtpid]->apifinfo.eth[ifindex].state = 2;
				AC_WTP[wtpid]->apifinfo.eth[ifindex].state_time = t;
			}
		}
		else if(policy == 1)//up
		{
			if(AC_WTP[wtpid]->apifinfo.eth[ifindex].state == 1)//state up
			{
				return 0;
			}
			else
			{
				AC_WTP[wtpid]->apifinfo.eth[ifindex].state = 1;
				AC_WTP[wtpid]->apifinfo.eth[ifindex].state_time = t;
			}
		}
	}
	else if(type == 1)//wifi
	{
		if(policy == 0)//down
		{
			if(AC_WTP[wtpid]->apifinfo.wifi[ifindex].state == 2)//state down
			{
				return 0;
			}
			else
			{
				AC_WTP[wtpid]->apifinfo.wifi[ifindex].state = 2;
				AC_WTP[wtpid]->apifinfo.wifi[ifindex].state_time = t;
			}
		}
		else if(policy == 1)//up
		{
			if(AC_WTP[wtpid]->apifinfo.wifi[ifindex].state == 1)//state up
			{
				return 0;
			}
			else
			{
				AC_WTP[wtpid]->apifinfo.wifi[ifindex].state = 1;
				AC_WTP[wtpid]->apifinfo.wifi[ifindex].state_time = t;
			}
		}
	}
	char apcmd[WID_SYSTEM_CMD_LENTH];
	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);

	sprintf(apcmd,"ifconfig %s%d %s",iftype[type],ifindex,ifpolicy[policy]);
	//printf("apcmd %s\n",apcmd);

	ret = wid_radio_set_extension_command(wtpid,apcmd);

	return 0;
}
int wid_set_wtp_ntp(unsigned int wtpid)
{
	wid_syslog_debug_debug(WID_DEFAULT,"wid_set_wtp_ntp wtpid %d\n",wtpid);
/*
	char *addr;
	char *ifname;
	
	ifname = (char *)malloc(ETH_IF_NAME_LEN+1);
	if(ifname == NULL)
	{
		wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
		perror("malloc");
		return MALLOC_ERROR;
	}
	memset(ifname,0,ETH_IF_NAME_LEN+1);
	memcpy(ifname,AC_WTP[wtpid]->BindingIFName,strlen(AC_WTP[wtpid]->BindingIFName));
	//printf("ifname %s\n",ifname);
	
	struct ifi_info *ifi = (struct ifi_info*)calloc(1, sizeof(struct ifi_info));
	memset(ifi->ifi_name,0,sizeof(ifi->ifi_name));
	strncpy(ifi->ifi_name,ifname,sizeof(ifi->ifi_name));
	ret = Get_Interface_Info(ifname,ifi);
	if(ret != 0){
		if(ifi->ifi_addr != NULL){
			free(ifi->ifi_addr);
			ifi->ifi_addr = NULL;
		}		
		if(ifi->ifi_brdaddr != NULL){
			free(ifi->ifi_brdaddr);
			ifi->ifi_brdaddr = NULL;
		}
		free(ifi);
		ifi = NULL;
		CW_FREE_OBJECT(ifname);
		return WID_DBUS_ERROR;		
	}
	addr = (char *)malloc(ETH_IF_NAME_LEN+1);
	if(addr == NULL)
	{
		wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
		perror("malloc");
		return MALLOC_ERROR;
	}
	memset(addr,0,ETH_IF_NAME_LEN+1);
	sprintf(addr,"%s",inet_ntoa(((struct sockaddr_in*)(ifi->ifi_addr))->sin_addr));
	//printf("addr %s\n",addr);
	
	char apcmd[WID_SYSTEM_CMD_LENTH];
	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);

	sprintf(apcmd,"ntpclient -h %s -s",addr);
	wid_syslog_debug_debug(WID_DEFAULT,"apcmd %s\n",apcmd);

	ret = wid_radio_set_extension_command(wtpid,apcmd);

	CW_FREE_OBJECT(ifname);
	CW_FREE_OBJECT(addr);
*/
    {
		msgq msg;	
		struct msgqlist *elem = NULL;
		
		if(AC_WTP[wtpid]->WTPStat == WID_RUN)
		{
			CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));
			if(gWTPs[wtpid].isNotFree && (gWTPs[wtpid].currentState == CW_ENTER_RUN))
			{
				memset((char*)&msg, 0, sizeof(msg));
				msg.mqid = wtpid%THREAD_NUM+1;
				msg.mqinfo.WTPID = wtpid;
				msg.mqinfo.type = CONTROL_TYPE;
				msg.mqinfo.subtype = WTP_S_TYPE;
				msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_NTP_SET;
				
				if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
				{
					wid_syslog_info("%s msgsend %s",__func__,strerror(errno));
				}
			}
			CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));
		}
		else if((AC_WTP[wtpid] != NULL))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = wtpid%THREAD_NUM+1;
			msg.mqinfo.WTPID = wtpid;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_NTP_SET;
	
			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if(elem == NULL)
			{
				wid_syslog_info("%s malloc %s",__func__,strerror(errno));
				perror("malloc");
				return 0;
			}
			memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
			elem->next = NULL;
			memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
			WID_INSERT_CONTROL_LIST(wtpid, elem);
		}	
	}
	
	return 0;
}

//auto ap area
int wid_auto_ap_login_insert_iflist(char *ifname)
{
	//get if index
	unsigned int ifindex = 0;
	int sockfd = -1;
	struct ifreq ifr;
      
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if(sockfd < 0)
	{
		return WID_DBUS_ERROR;
	}

	strncpy(ifr.ifr_name,ifname, sizeof(ifr.ifr_name));
    
	if (ioctl(sockfd, SIOCGIFINDEX, &ifr) == -1)
	{
		wid_syslog_err(WAI_FUNC_LINE_FMT"add auto login interface%s get gindex error(%d) %s\n", \
					WAI_FUNC_LINE_LITERAL, ifname, errno, strerror(errno));
		close(sockfd);
		return APPLY_IF_FAIL;
	}
	close(sockfd);
	
	ifindex = ifr.ifr_ifindex;
	//insert to the list
	wid_auto_ap_if *wif = NULL;
	wid_auto_ap_if *wifnext = NULL;
	
	wif = (wid_auto_ap_if *)malloc(sizeof(wid_auto_ap_if));
	wif->ifindex = ifindex;
	wif->wlannum = 0;
	memset(wif->wlanid,0,L_BSS_NUM);
	memset(wif->ifname,0,ETH_IF_NAME_LEN);
	memcpy(wif->ifname,ifname,strlen(ifname));
	wif->ifnext = NULL;
	
	if(g_auto_ap_login.auto_ap_if == NULL)
	{
		g_auto_ap_login.auto_ap_if = wif ;
		g_auto_ap_login.auto_ap_if->ifnext = NULL;
		g_auto_ap_login.ifnum = 1;
	}
	else
	{
		wifnext = g_auto_ap_login.auto_ap_if;
		while(wifnext != NULL)
		{	
			if(strcmp(wifnext->ifname,ifname) == 0)
			{
				//printf("already in the list\n");
				CW_FREE_OBJECT(wif);
				return 0;
			}
			wifnext = wifnext->ifnext;
		}
		
		wifnext = g_auto_ap_login.auto_ap_if;
		while(wifnext->ifnext != NULL)
		{	
			wifnext = wifnext->ifnext;
		}
		
		wifnext->ifnext = wif;
		g_auto_ap_login.ifnum++;
	}
	wid_syslog_debug(WAI_FUNC_LINE_FMT"add auto login interface %s ifindex %#x got count %u\n", \
				WAI_FUNC_LINE_LITERAL, ifname, ifindex, g_auto_ap_login.ifnum);
	
	return 0;
}

int wid_auto_ap_login_remove_iflist(char *ifname)
{
	wid_auto_ap_if *wif = NULL;
	wid_auto_ap_if *wifnext = NULL;

	wifnext = g_auto_ap_login.auto_ap_if;
	
	if(g_auto_ap_login.auto_ap_if != NULL)
	{
		if(strcmp(wifnext->ifname,ifname) == 0)  //fengwenchao modify 20110414
		{
			g_auto_ap_login.auto_ap_if = wifnext->ifnext;
			g_auto_ap_login.ifnum--;
			wid_syslog_debug(WAI_FUNC_LINE_FMT"remove auto login interface %s ifindex %#x got count %u first node\n", \
						WAI_FUNC_LINE_LITERAL, ifname, wifnext->ifindex, g_auto_ap_login.ifnum);
			free(wifnext);
			wifnext = NULL;		
		}
		else
		{
			while(wifnext->ifnext != NULL)
			{	
				if(strcmp(wifnext->ifnext->ifname,ifname) == 0)  //fengwenchao modify 20110414
				{
					wif = wifnext->ifnext;
					wifnext->ifnext = wifnext->ifnext->ifnext;
					g_auto_ap_login.ifnum--;
					wid_syslog_debug(WAI_FUNC_LINE_FMT"remove auto login interface %s ifindex %#x got count %u\n", \
								WAI_FUNC_LINE_LITERAL, ifname, wif->ifindex, g_auto_ap_login.ifnum);
					free(wif);
					wif = NULL;				
					return 0;
				}
				wifnext = wifnext->ifnext;
			}
		}
	}
	return 0;	
}

int WID_WDS_BSSID_OP(unsigned int RadioID, unsigned char WlanID, unsigned char *MAC, unsigned char OP)
{
	char buf[DEFAULT_LEN];
	//int ret = -1;
	//int k1 = 0;	
	int i = 0;
	int WtpID = RadioID/L_RADIO_NUM;
	int localradio_id = RadioID%L_RADIO_NUM;	
	/* coverity-CID: 10887 Uninitialized scalar variable */
	WID_BSS * BSS = NULL;
	struct wds_bssid *wds = NULL;
	struct wds_bssid *wds_next = NULL;
	unsigned char oper = 0;
	oper = OP&0x03;
	
	if(AC_WLAN[WlanID] == NULL)
	{
		return WLAN_ID_NOT_EXIST;
	}
	if(AC_RADIO[RadioID]->Wlan_Id == NULL)
	{
		return RADIO_NO_BINDING_WLAN;
	}
	else
	{	
		while(i < L_BSS_NUM)
		{	
			if(AC_RADIO[RadioID]->BSS[i] == NULL){
				i++;
				continue;
			}
			if(AC_RADIO[RadioID]->BSS[i]->WlanID == WlanID)
			{
				BSS = AC_RADIO[RadioID]->BSS[i]; 
				break;
			}
			i++;
		}
		
		if(NULL == BSS)
		{
			return BSS_NOT_EXIST;
		}

		if(i == L_BSS_NUM)
			return RADIO_NO_BINDING_WLAN;
		
		if(BSS->WDSStat == WDS_ANY)
			return WDS_MODE_BE_USED;

		if(oper == 1){//add
			BSS->WDSStat = WDS_SOME;
			if(BSS->wds_bss_list == NULL){
				wds = malloc(sizeof(struct wds_bssid));
				if(wds == NULL){
					return WID_DBUS_ERROR;
				}
				memset(wds, 0, sizeof(struct wds_bssid));
				memcpy(wds->BSSID, MAC, MAC_LEN);
				wds->next = NULL;
				BSS->wds_bss_list = wds;
				if((OP&0x04) == 0){
					AC_RADIO[RadioID]->BSS[i]->wblwm = 0;
				}
				else{
					AC_RADIO[RadioID]->BSS[i]->wblwm = 1;
				}
				if((AC_WTP[WtpID]!=NULL) && (AC_WTP[WtpID]->isused == 1)){
					memset(buf,0,DEFAULT_LEN);
					sprintf(buf,"/usr/sbin/wds_add ath.%d-%d %02X:%02X:%02X:%02X:%02X:%02X\n",localradio_id,WlanID,MAC[0],MAC[1],MAC[2],MAC[3],MAC[4],MAC[5]);
//					printf("/usr/sbin/wds_add ath.%d-%d %02X:%02X:%02X:%02X:%02X:%02X\n",localradio_id,WlanID,MAC[0],MAC[1],MAC[2],MAC[3],MAC[4],MAC[5]);
					wid_radio_set_extension_command(WtpID,buf);
				}
			}else{
				wds_next = BSS->wds_bss_list;
				while(wds_next != NULL){
					if(memcmp(wds_next->BSSID, MAC, MAC_LEN) == 0)
						return WID_DBUS_SUCCESS;
					wds_next = wds_next->next;
				}
				wds = malloc(sizeof(struct wds_bssid));
				if(wds == NULL){
					return WID_DBUS_ERROR;
				}
				memset(wds, 0, sizeof(struct wds_bssid));
				memcpy(wds->BSSID, MAC, MAC_LEN);
				wds->next = NULL;
				wds->next = BSS->wds_bss_list;
				BSS->wds_bss_list = wds;
				if((OP&0x04) == 0){
					AC_RADIO[RadioID]->BSS[i]->wblwm = 0;
				}
				else{
					AC_RADIO[RadioID]->BSS[i]->wblwm = 1;
				}
				if((AC_WTP[WtpID]!=NULL) && (AC_WTP[WtpID]->isused == 1)){
					memset(buf,0,DEFAULT_LEN);
					sprintf(buf,"/usr/sbin/wds_add ath.%d-%d %02X:%02X:%02X:%02X:%02X:%02X\n",localradio_id,WlanID,MAC[0],MAC[1],MAC[2],MAC[3],MAC[4],MAC[5]);
//					printf("/usr/sbin/wds_add ath.%d-%d %02X:%02X:%02X:%02X:%02X:%02X\n",localradio_id,WlanID,MAC[0],MAC[1],MAC[2],MAC[3],MAC[4],MAC[5]);
					wid_radio_set_extension_command(WtpID,buf);
				}
			}
		}
		else if(oper == 2){//delete
			if(BSS->wds_bss_list == NULL){
				return WID_DBUS_SUCCESS;
			}else{
				wds_next = BSS->wds_bss_list;
				if(memcmp(wds_next->BSSID, MAC, MAC_LEN) == 0){
					BSS->wds_bss_list = wds_next->next;
					wds_next->next = NULL;
					free(wds_next);
					wds_next = NULL;	
					if((OP&0x04) == 0){
						AC_RADIO[RadioID]->BSS[i]->wblwm = 0;
					}
					else{
						AC_RADIO[RadioID]->BSS[i]->wblwm = 1;
					}
					if(BSS->State == 1){
						memset(buf,0,DEFAULT_LEN);
						sprintf(buf,"/usr/sbin/wds_del %02X:%02X:%02X:%02X:%02X:%02X\n",MAC[0],MAC[1],MAC[2],MAC[3],MAC[4],MAC[5]);
//						printf("/usr/sbin/wds_del %02X:%02X:%02X:%02X:%02X:%02X\n",MAC[0],MAC[1],MAC[2],MAC[3],MAC[4],MAC[5]);
						wid_radio_set_extension_command(WtpID,buf);
					}
					if(BSS->wds_bss_list == NULL){
						BSS->WDSStat = DISABLE;
//						printf("wds bssid disable\n");
					}
					return WID_DBUS_SUCCESS;
				}
				while(wds_next->next != NULL){
					if(memcmp(wds_next->next->BSSID, MAC, MAC_LEN) == 0){
						wds = wds_next->next;
						wds_next->next = wds->next;
						wds->next = NULL;
						free(wds);
						wds = NULL;
						if((OP&0x04) == 0){
							AC_RADIO[RadioID]->BSS[i]->wblwm = 0;
						}
						else{
							AC_RADIO[RadioID]->BSS[i]->wblwm = 1;
						}
						if(BSS->State == 1){
							memset(buf,0,DEFAULT_LEN);
							sprintf(buf,"/usr/sbin/wds_del %02X:%02X:%02X:%02X:%02X:%02X\n",MAC[0],MAC[1],MAC[2],MAC[3],MAC[4],MAC[5]);
//							printf("/usr/sbin/wds_del %02X:%02X:%02X:%02X:%02X:%02X\n",MAC[0],MAC[1],MAC[2],MAC[3],MAC[4],MAC[5]);
							wid_radio_set_extension_command(WtpID,buf);
						}
						if(BSS->wds_bss_list == NULL){
							BSS->WDSStat = DISABLE;
//							printf("wds bssid disable\n");
						}
						return WID_DBUS_SUCCESS;
					}
					wds_next = wds_next->next;
				}
				return WID_DBUS_SUCCESS;				
			}
		}
	}
			
	return 0;

}

int WID_RADIO_SET_WDS_STATUS(unsigned int RadioID, unsigned char WLANID,unsigned char status)
{

	int k = 0;
	unsigned char wds_mesh = status&0x02;
	status = status&(0x01);
	int wtpid = RadioID/L_RADIO_NUM;
	int local_radioid = RadioID%L_RADIO_NUM;
	msgq msg;
	struct msgqlist *elem;
	k = WLANID;
	
	if((AC_WLAN[k] != NULL))
	{				

		if(AC_WLAN[k]->S_WTP_BSS_List[wtpid][local_radioid] != 0)
		{	
			unsigned int BSSIndex = AC_WLAN[k]->S_WTP_BSS_List[wtpid][local_radioid];
			if(!check_bssid_func(BSSIndex)){
				wid_syslog_err("<error>%s\n",__func__);
				return BSS_NOT_EXIST;
			}else{						
			}
			if(AC_BSS[BSSIndex]->WDSStat == status)
			{
				return 0;
			}
			else
			{
				if(AC_BSS[BSSIndex]->WDSStat == WDS_SOME)
					return WDS_MODE_BE_USED;
				AC_BSS[BSSIndex]->WDSStat = status;
				if(wds_mesh!=0){
					AC_BSS[BSSIndex]->wds_mesh = 1;
				}
				else {
					AC_BSS[BSSIndex]->wds_mesh = 0;
				}

			}
			if((AC_BSS[BSSIndex] != NULL)&&(AC_WTP[wtpid] != NULL))
			{
				//if(AC_WTP[wtpid]->CMD->radiowlanid[local_radioid][k] != 0)	//run state
				{					
					msg.mqid = wtpid%THREAD_NUM+1;
					msg.mqinfo.WTPID = wtpid;
					msg.mqinfo.type = CONTROL_TYPE;
					msg.mqinfo.subtype = WDS_S_TYPE;
					if(wds_mesh == 1)
					{
						msg.mqinfo.u.WlanInfo.Wlan_Op = WLAN_WDS_ENABLE;
					}
					else
					{
						msg.mqinfo.u.WlanInfo.Wlan_Op = WLAN_WDS_DISABLE;
					}
					
					msg.mqinfo.u.WlanInfo.WLANID = k;
					msg.mqinfo.u.WlanInfo.Radio_L_ID = local_radioid;
					if(AC_WTP[wtpid]->WTPStat == 5)
					{	
						if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
						{
							wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
							perror("msgsnd");
						}
					}
					else
					{
						elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
						if(elem == NULL)
						{
							wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
							perror("malloc");
							return 0;
						}
						memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
						elem->next = NULL;
						memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
						WID_INSERT_CONTROL_LIST(wtpid, elem);						
					}
				}
			}
			else
			{
				return RADIO_NO_BINDING_WLAN;	
			}
		
		}
		else
		{
			return RADIO_NO_BINDING_WLAN;	
		}
	}
	else
	{
		return WLAN_ID_NOT_EXIST;
	}
	
	return 0;	
}

void wid_set_wds_state(unsigned int wtpid, unsigned char radioid, unsigned char wlanid, unsigned char state)
{
	int IGNORE_UBSV ret = 0;
	
	char apcmd[WID_SYSTEM_CMD_LENTH];
	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);
	char apcmd2[WID_SYSTEM_CMD_LENTH];
	memset(apcmd2,0,WID_SYSTEM_CMD_LENTH);

	if(state == WLAN_WDS_ENABLE)
	{
		sprintf(apcmd,"iwpriv ath.%d-%d wds 1",radioid,wlanid);
		sprintf(apcmd2,"iwpriv ath.%d-%d ap_bridge 0",radioid,wlanid);
	}
	else if(state == WLAN_WDS_DISABLE)
	{
		sprintf(apcmd,"iwpriv ath.%d-%d wds 0",radioid,wlanid);
	}
	else
	{
		return;
	}

	ret = wid_radio_set_extension_command(wtpid,apcmd);

	if(state == WLAN_WDS_ENABLE)
	{
		ret = wid_radio_set_extension_command(wtpid,apcmd2);
	}

	return;

}

int CWWIDReInit(){
	int i = 0;
	int flag = 0;
	int m = 0;
	char buf_base[DEFAULT_LEN];
	char strdir[DEFAULT_LEN];
	
	if(g_wtp_binding_count == NULL){
		g_wtp_binding_count = malloc((glicensecount+1)*sizeof(LICENSE_TYPE *));
		memset(g_wtp_binding_count,0,(glicensecount+1)*sizeof(LICENSE_TYPE *));
		for(i=0; i<glicensecount+1; i++){
			g_wtp_binding_count[i] = NULL;
		}
	}else{
		for(i=0; i<glicensecount+1; i++){
			if(g_wtp_binding_count[i]){
				memset(g_wtp_binding_count[i],0,sizeof(LICENSE_TYPE));
			}
		}
	}

	if(g_wtp_count == NULL){
		g_wtp_count = malloc(glicensecount*(sizeof(LICENSE_TYPE *)));
		memset(g_wtp_count,0,sizeof(LICENSE_TYPE *));
	}
	
	for(i=0; i<glicensecount; i++)
	{
		if(g_wtp_count[i] == NULL){
			g_wtp_count[i] = malloc(sizeof(LICENSE_TYPE));
			memset(g_wtp_count[i],0,sizeof(LICENSE_TYPE));
		}
		//g_wtp_count[i]->gcurrent_wtp_count = 0;
		//g_wtp_count[i]->flag = 0;
		g_wtp_count[i]->isShm = 0;
		memset(strdir,0,DEFAULT_LEN);
		memset(buf_base,0,DEFAULT_LEN);	
		sprintf(strdir,AFC_RUN_PAH"/wtplicense%d-%d-%d",local,vrrid,i+1);
		if(read_ac_info(strdir,buf_base) == 0)
		{
			if(parse_int_ID(buf_base, &g_wtp_count[i]->gmax_wtp_count)==-1)
			g_wtp_count[i]->gmax_wtp_count = WTP_DEFAULT_NUM_OEM;
		}
		else
		{
			g_wtp_count[i]->gmax_wtp_count = WTP_DEFAULT_NUM_OEM;
		}
		g_wtp_count[i]->gmax_wtp_count_assign = g_wtp_count[i]->gmax_wtp_count;
		flag = g_wtp_count[i]->flag;
		if(flag > 0){
			g_wtp_binding_count[flag]->gcurrent_wtp_count+=g_wtp_count[i]->gcurrent_wtp_count;
			g_wtp_binding_count[flag]->gmax_wtp_count+=g_wtp_count[i]->gmax_wtp_count;
		}
		wid_syslog_info("########CWWIDReInit######## maxwtp[%d] = %d\n",i,g_wtp_count[i]->gmax_wtp_count);
	}
	
	for(m=1;m<glicensecount;m++){
		if((g_wtp_binding_count)&&(g_wtp_binding_count[m])){
			wid_syslog_info("g_wtp_binding_count[%d]->gcurrent_wtp_count=%d,max=%d.\n",m,g_wtp_binding_count[m]->gcurrent_wtp_count,g_wtp_binding_count[m]->gmax_wtp_count);
		}
		if((g_wtp_count)&&(g_wtp_count[m])){
			wid_syslog_info("g_wtp_count[%d]->gcurrent_wtp_count=%d,max=%d.\n",m,g_wtp_count[m]->gcurrent_wtp_count,g_wtp_count[m]->gmax_wtp_count);
		}
	}
	//license_binding_Reinit("2,3");
	//license_binding_Reinit("5,6");

	wid_syslog_info("########CWWIDReInit##lic bind reinit###### glicensecount = %d.\n",glicensecount);
	return 0;
}

void wid_parse_legal_essid_list(unsigned int wtpindex,char *name)
{
	int ret = 0;
	int len1 = 0;
	int len2 = 0;
	len1 = strlen(name);
	struct essid_node *list;
	list = g_essid_list.essid_list;
	while(list != NULL)
	{
		len2 = strlen(list->essid);
		if((len1 == len2)&&(memcmp(name,list->essid,len1) == 0))
		{
//			printf("name %s in the list\n",name);
			ret = 1;
		}
		list = list->next;
	}
	if(ret == 0)
	{
		if(gtrapflag>=4){
			#if NOSOFTAC
			wid_dbus_trap_wtp_find_unsafe_essid(wtpindex,name);
			#endif
		}

		return;
	}
}
void wid_parse_neighbor_ap_list(unsigned int wtpindex)
{
	if((AC_WTP[wtpindex] == NULL)||(AC_WTP[wtpindex]->NeighborAPInfos[0] == NULL))
	{
		return;
	}
	int count = AC_WTP[wtpindex]->NeighborAPInfos[0]->neighborapInfosCount;
	int i = 0;
	if(count == 0)
	{
		return;
	}
	struct Neighbor_AP_ELE *list = NULL;
	list = AC_WTP[wtpindex]->NeighborAPInfos[0]->neighborapInfos;

	char *essid = NULL;

	for(i=0;i<count;i++)
	{
		essid = (char *)list->ESSID;
		if(essid != NULL)
		{
			if((g_essid_list.essid_list == NULL)||(g_essid_list.list_len == 0))
			{
				if(gtrapflag>=4){
					#if NOSOFTAC
					wid_dbus_trap_wtp_find_unsafe_essid(wtpindex,essid);
					#endif
				}
			}
			else
			{
				wid_parse_legal_essid_list(wtpindex,essid);
			}
		}
		list = list->next;
	}
}
void wid_init_wtp_info_in_create(unsigned int WTPID)
{
	int i;
	//wtp wifi snr stats
	{
		AC_WTP[WTPID]->wtp_wifi_snr_stats.ifindex = 0;
		AC_WTP[WTPID]->wtp_wifi_snr_stats.snr_max = 0;
		AC_WTP[WTPID]->wtp_wifi_snr_stats.snr_min = 100;
		AC_WTP[WTPID]->wtp_wifi_snr_stats.snr_average = 0;
		AC_WTP[WTPID]->wtp_wifi_snr_stats.snr_math_average = 0;
		memset(AC_WTP[WTPID]->wtp_wifi_snr_stats.snr,0,10);
	}
	//ap sta info report area
	{
		AC_WTP[WTPID]->ap_sta_report_switch = gSTAREPORTSWITCH; /*wcl modify for globle variable*/
		AC_WTP[WTPID]->ap_sta_report_interval = gSTAREPORTINTERVAL;/*wcl modify for globle variable*/
	}
	wid_apstatsinfo_init(WTPID);	//xiaodawei modify for apstatsinfo init, 20110107

	/*fengwenchao add 20111117 for GM-3*/
	{
		AC_WTP[WTPID]->heart_time.heart_statistics_switch = 0;
		AC_WTP[WTPID]->heart_time.heart_statistics_collect = 300;
		AC_WTP[WTPID]->heart_time.heart_time_delay = 0;
		AC_WTP[WTPID]->heart_time.heart_lose_pkt = 0;
		AC_WTP[WTPID]->heart_time.heart_transfer_pkt = 0;
		AC_WTP[WTPID]->heart_time.heart_time_value_length = 0;
		AC_WTP[WTPID]->heart_time.heart_time_avarge = 0;
		AC_WTP[WTPID]->heart_time.heart_time_value_head = NULL;
	}
	/*fengwenchao add end*/
#if 0
	for(i=0; i<TOTAL_AP_IF_NUM; i++)
	{
		AC_WTP[WTPID]->apstatsinfo[i].radioId = TOTAL_AP_IF_NUM+1;
		AC_WTP[WTPID]->apstatsinfo[i].type = TOTAL_AP_IF_NUM+1;
		AC_WTP[WTPID]->apstatsinfo[i].wlanId = 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_bytes = 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_bytes = 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_drop = 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_drop = 0;

		
		AC_WTP[WTPID]->apstatsinfo[i].rx_packets = 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_packets = 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_errors = 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_errors = 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_rate = 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_rate = 0;
		AC_WTP[WTPID]->apstatsinfo[i].ast_rx_crcerr = 0;
		AC_WTP[WTPID]->apstatsinfo[i].ast_rx_badcrypt = 0;
		AC_WTP[WTPID]->apstatsinfo[i].ast_rx_badmic = 0;
		AC_WTP[WTPID]->apstatsinfo[i].ast_rx_phyerr = 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_frame = 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_frame = 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_error_frame = 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_error_frame = 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_drop_frame = 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_drop_frame = 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_band= 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_band= 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_unicast= 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_unicast= 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_broadcast= 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_broadcast= 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_multicast= 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_multicast= 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_pkt_unicast= 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_pkt_unicast = 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_pkt_broadcast= 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_pkt_broadcast = 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_pkt_multicast= 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_pkt_multicast = 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_pkt_retry = 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_pkt_retry = 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_retry = 0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_retry = 0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_pkt_mgmt =0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_pkt_mgmt =0;
		AC_WTP[WTPID]->apstatsinfo[i].rx_mgmt =0;
		AC_WTP[WTPID]->apstatsinfo[i].tx_mgmt =0;

	}
	#endif
	AC_WTP[WTPID]->rx_bytes = 0;
	AC_WTP[WTPID]->tx_bytes = 0;
	AC_WTP[WTPID]->rx_bytes_before = 0;
	AC_WTP[WTPID]->tx_bytes_before = 0;

	//set wifi_info 0
	{
		AC_WTP[WTPID]->wifi_extension_info.cpu_trap_flag = 0;
		AC_WTP[WTPID]->wifi_extension_info.mem_trap_flag = 0;
		AC_WTP[WTPID]->wifi_extension_info.temp_trap_flag = 0;
		memset(AC_WTP[WTPID]->wifi_extension_info.wifi_trap_flag,0,AP_WIFI_IF_NUM);
		
		//AC_WTP[WTPID]->wifi_extension_reportswitch = 0; /*wcl modify for globle variable*/
		AC_WTP[WTPID]->wifi_extension_reportinterval = gWIFIEXTENSIONREPORTINTERVAL;//sz change 1 to 3 0630 /*wcl modify for globle variable*/
		//AC_WTP[WTPID]->wifi_extension_info.reportswitch = 0;
		//AC_WTP[WTPID]->wifi_extension_info.reportinterval = 3;//sz change 1 to 3 0630
		AC_WTP[WTPID]->wifi_extension_info.cpu = 0;
		AC_WTP[WTPID]->collect_time= cpu_mem_collect_time;			//xiaodawei change 3500 to 300, 20101211	/*wcl modify for globle variable*/			
		AC_WTP[WTPID]->wifi_extension_info.tx_mgmt = 0;
		AC_WTP[WTPID]->wifi_extension_info.rx_mgmt = 0;
		AC_WTP[WTPID]->wifi_extension_info.tx_packets = 0;
		AC_WTP[WTPID]->wifi_extension_info.tx_errors = 0;
		AC_WTP[WTPID]->wifi_extension_info.tx_retry = 0;
		AC_WTP[WTPID]->wifi_extension_info.ipmode = 1;
		AC_WTP[WTPID]->wifi_extension_info.memoryall = 0;
		AC_WTP[WTPID]->wifi_extension_info.memoryuse = 0;
		AC_WTP[WTPID]->wifi_extension_info.flashall = 0;
		AC_WTP[WTPID]->wifi_extension_info.wifi_snr = 0;
		/*fengwenchao add 20120314 for onlinebug-162*///qiuchen copy from v1.3
		memset(AC_WTP[WTPID]->wifi_extension_info.wifi_snr_new,0,L_RADIO_NUM);
		memset(AC_WTP[WTPID]->wifi_extension_info.wifi_noise_new,0,L_RADIO_NUM);
		/*fengwenchao add end*/
		AC_WTP[WTPID]->wifi_extension_info.flashempty = 0;
		AC_WTP[WTPID]->wifi_extension_info.eth_count = 0;
		AC_WTP[WTPID]->wifi_extension_info.ath_count = 0;
		AC_WTP[WTPID]->wifi_extension_info.temperature = 0;
		AC_WTP[WTPID]->wifi_extension_info.wifi_count = 0;
		AC_WTP[WTPID]->wifi_extension_info.tx_unicast = 0;
		AC_WTP[WTPID]->wifi_extension_info.tx_broadcast = 0;
		AC_WTP[WTPID]->wifi_extension_info.tx_multicast = 0;
		AC_WTP[WTPID]->wifi_extension_info.tx_drop = 0;
		AC_WTP[WTPID]->wifi_extension_info.rx_unicast = 0;
		AC_WTP[WTPID]->wifi_extension_info.rx_broadcast = 0;
		AC_WTP[WTPID]->wifi_extension_info.rx_multicast = 0;
		AC_WTP[WTPID]->wifi_extension_info.rx_drop = 0;
		AC_WTP[WTPID]->wifi_extension_info.wpi_replay_error = 0;
		AC_WTP[WTPID]->wifi_extension_info.wpi_decryptable_error = 0;
		AC_WTP[WTPID]->wifi_extension_info.wpi_mic_error = 0;
		AC_WTP[WTPID]->wifi_extension_info.disassoc_unnormal = 0;
		AC_WTP[WTPID]->wifi_extension_info.rx_assoc_norate = 0;
		AC_WTP[WTPID]->wifi_extension_info.rx_assoc_capmismatch = 0;
		AC_WTP[WTPID]->wifi_extension_info.assoc_invaild = 0;
		AC_WTP[WTPID]->wifi_extension_info.reassoc_deny = 0;
		memset(AC_WTP[WTPID]->wifi_extension_info.wifi_state,0,AP_WIFI_IF_NUM);
		memset(AC_WTP[WTPID]->wifi_extension_info.eth_updown_time,0,AP_ETH_IF_NUM);
		//memset(AC_WTP[WTPID]->wifi_extension_info.ath_updown_time,0,AP_ATH_IF_NUM);
		memset(AC_WTP[WTPID]->wifi_extension_info.ath_if_info,0,sizeof(wid_ap_ath_info));
	}
	//ap interface info
	{
		AC_WTP[WTPID]->apifinfo.report_switch = gINFOREPORTSWITCH; /*wcl modify  for globle variable*/
		AC_WTP[WTPID]->apifinfo.report_interval = gINFOREPORTINTERVAL;//sz change 1 to 3 0630 /*wcl modify for globle variable*/
		//AC_WTP[WTPID]->apifinfo.eth_num = 1;    //fengwenchao modify 20110325
		AC_WTP[WTPID]->apifinfo.wifi_num = 1;
		memset(AC_WTP[WTPID]->apifinfo.eth,0,AP_ETH_IF_NUM);
		memset(AC_WTP[WTPID]->apifinfo.wifi,0,AP_WIFI_IF_NUM);
		unsigned char jj=0;
		for(jj = 0;jj<AP_ETH_IF_NUM;jj++){
			AC_WTP[WTPID]->apifinfo.eth[jj].eth_rate = gAPIFINFOETH_RATE[jj]; /*wcl modify for globle variable*/
			AC_WTP[WTPID]->apifinfo.eth[jj].eth_mtu = gAPIFINFOETH_MTU[jj];   //fengwenchao add 20110127 for XJDEV-32 from 2.0 /*wcl modify for globle variable*/
		}
	}
	//ap cpu mem statistics
	memset(AC_WTP[WTPID]->apcminfo.cpu_value,0,10);
	memset(AC_WTP[WTPID]->apcminfo.mem_value,0,10);
	AC_WTP[WTPID]->apcminfo.cpu_average = 0;
	AC_WTP[WTPID]->apcminfo.cpu_times = 0;
	AC_WTP[WTPID]->apcminfo.cpu_peak_value = 0;
	AC_WTP[WTPID]->apcminfo.mem_average = 0;
	AC_WTP[WTPID]->apcminfo.mem_times = 0;
	AC_WTP[WTPID]->apcminfo.mem_peak_value = 0;
	/*fengwenchao add 20120314 for onlinebug-162*///qiuchen copy from v1.3
	memset(AC_WTP[WTPID]->apcminfo.wifi_snr,0,L_RADIO_NUM);
	/*fengwenchao add end*/
	//for mib info
	AC_WTP[WTPID]->mib_info.dos_def_switch = 0;
	AC_WTP[WTPID]->mib_info.igmp_snoop_switch = 0;
	for(i=0;i<L_BSS_NUM;i++)
	{
		AC_WTP[WTPID]->mib_info.wlan_l2isolation[i].wlanid = 0;
		AC_WTP[WTPID]->mib_info.wlan_l2isolation[i].l2_isolation_switch = 0;
	}
	AC_WTP[WTPID]->wid_sample_throughput.past_uplink_throughput = 0;
	AC_WTP[WTPID]->wid_sample_throughput.current_uplink_throughput = 0;
	AC_WTP[WTPID]->wid_sample_throughput.past_downlink_throughput = 0;
	AC_WTP[WTPID]->wid_sample_throughput.current_downlink_throughput = 0;
	AC_WTP[WTPID]->wid_sample_throughput.uplink_rate = 0;
	AC_WTP[WTPID]->wid_sample_throughput.downlink_rate = 0;
	AC_WTP[WTPID]->wifi_extension_reportswitch = g_AC_ALL_EXTENTION_INFORMATION_SWITCH;//nl
	
	AC_WTP[WTPID]->trap_collect_time = 3500;
	AC_WTP[WTPID]->cputrap_resend_times = 0;
	AC_WTP[WTPID]->memtrap_resend_times = 0;
	AC_WTP[WTPID]->rogueaptrap_resend_times = 0;
	AC_WTP[WTPID]->rogueteminaltap_resend_times = 0;
	AC_WTP[WTPID]->cpu_resend_times = 0;
	AC_WTP[WTPID]->cpu_clear_resend_times = 0;
	AC_WTP[WTPID]->memtrap_clear_resend_times = 0;
	AC_WTP[WTPID]->ap_temp_resend_times = 0;
	AC_WTP[WTPID]->ap_temp_clear_resend_times = 0;
}

void merge_wids_list(wid_wids_device *pdestlist, wid_wids_device **psrclist,int wtpid)
{
	if((pdestlist == NULL)||(pdestlist->wids_device_info == NULL)||(pdestlist->count == 0))
	{
//		printf("merge_wids_list dest parameter error\n");
		wid_syslog_debug_debug(WID_DEFAULT,"merge_wids_list dest parameter error\n");
		return ;
	}	
	
	if(((*psrclist) == NULL)||((*psrclist)->wids_device_info == NULL)||((*psrclist)->count== 0))
	{
//		printf("merge_wids_list src parameter error\n");
		wid_syslog_debug_debug(WID_DEFAULT,"merge_wids_list src parameter error\n");
		CW_FREE_OBJECT(*psrclist);
		return;
	}	
	int now_rssi = 0;   //fengwenchao add 20110507
	int i = 0;       //fengwenchao add 20110507
	struct tag_wids_device_ele *phead_trap = pdestlist->wids_device_info;     //fengwenchao add 20110507
	struct tag_wids_device_ele * IGNORE_UBSV pnode_trap = pdestlist->wids_device_info;     //fengwenchao add 20110507
	if(pdestlist->wids_device_info->bssid!=NULL){
		unsigned char *name = NULL;
		name= (unsigned char *)malloc(MAC_LEN+1);
		if(name!=NULL){
			memset(name,0,MAC_LEN+1);
			memcpy(name,pdestlist->wids_device_info->bssid,MAC_LEN);  

			time_t now;
			time(&now);
			wid_syslog_warning("<warning>wtp[%d] find attack from %02x:%02x:%02x:%02x:%02x:%02x\n",wtpid,name[0],name[1],name[2],name[3],name[4],name[5]);
			syslog(LOG_WARNING|LOG_LOCAL7, "WTP %d,WTP MAC:"MACSTR",WTP IP:%s,find attack from MAC:"MACSTR", at Time:%s\n",\
				wtpid,MAC2STR(AC_WTP[wtpid]->WTPMAC),AC_WTP[wtpid]->WTPIP,MAC2STR(name),ctime(&now));
			if(gtrapflag>=25){
				if(AC_WTP[wtpid]->find_wids_attack_flag == 1)  //fengwenchao add 20110221
					{
						/*fengwenchao add 20110507*/
						for(i = 0; ((phead_trap != NULL)||(i < pdestlist->count));i++)
						{
							if(phead_trap->rssi > now_rssi)
							{
								now_rssi = phead_trap->rssi;
								pnode_trap = phead_trap;
							}
							phead_trap = phead_trap->next;
						}
						/*fengwenchao add end*/
						#if NOSOFTAC
						wid_dbus_trap_wtp_find_wids_attack(wtpid,pnode_trap);	   //fengwenchao modify 20110509
						#endif
						AC_WTP[wtpid]->find_wids_attack_flag = 0;   //fengwenchao add 20110221
					}
			}
			CW_FREE_OBJECT(name);

		}
	}
	else 
	{
		return;
	}
	struct tag_wids_device_ele  *pnode = (*psrclist)->wids_device_info;
	struct tag_wids_device_ele  *pnext = pnode->next;
	CWBool isfind = CW_FALSE;
	
	isfind = find_elem_in_wids_list(pdestlist,pnode);

	if(isfind == 0) //add element
	{
		insert_elem_into_wids_list(pdestlist,pnode);
		
	}
	else 
	{
		update_elem_in_wids_list(pdestlist,pnode);

		CW_FREE_OBJECT(pnode);

	}

	while(pnext != NULL)
	{
		pnode = pnext ->next;

		isfind = find_elem_in_wids_list(pdestlist,pnext);
			
		if(isfind == 0) //add element
		{
			insert_elem_into_wids_list(pdestlist,pnext);
			
		}
		else 
		{
			update_elem_in_wids_list(pdestlist,pnext);
		
			CW_FREE_OBJECT(pnext);
		
		}

		pnext = pnode;
		
	}

	CW_FREE_OBJECT(*psrclist);
	
	//printf("merge_ap_list to end\n");
	
	
	return ;
}

CWBool find_elem_in_wids_list(wid_wids_device  *paplist,struct tag_wids_device_ele *elem)
{
	if((elem == NULL)||((paplist) == NULL)||((paplist)->wids_device_info == NULL)||((paplist)->count== 0))
	{
//		printf("find_elem_in_wids_list parameter error\n");
		wid_syslog_debug_debug(WID_DEFAULT,"find_elem_in_wids_list parameter error\n");
		return CW_FALSE;
	}	


	
	struct tag_wids_device_ele *pnode = paplist->wids_device_info;
	struct tag_wids_device_ele *pnext = pnode->next;

	if(memcmp((pnode->bssid),elem->bssid,6) == 0)
	{
		
		return CW_TRUE;

	}

	while(pnext != NULL)
	{
		if(memcmp((pnext->bssid),elem->bssid,6) == 0)
		{

			return CW_TRUE;

		}	

		pnode = pnode->next;
		pnext = pnext->next;
	}

	return CW_FALSE;//insert success

}

CWBool update_elem_in_wids_list(wid_wids_device  *paplist,struct tag_wids_device_ele *elem)
{
//	printf("update_elem_in_wids_list\n");

	if((elem == NULL)||((paplist) == NULL)||((paplist)->wids_device_info == NULL)||((paplist)->count== 0))
	{
//		printf("update_elem_in_wids_list parameter error\n");
		wid_syslog_debug_debug(WID_DEFAULT,"update_elem_in_wids_list parameter error\n");
		return CW_FALSE;
	}	


	
	struct tag_wids_device_ele *pnode = paplist->wids_device_info;
	struct tag_wids_device_ele *pnext = pnode->next;

	if(memcmp((pnode->bssid),elem->bssid,6) == 0)
	{
		pnode->attackcount++;
		pnode->attacktype = elem->attacktype;
		pnode->frametype = elem->frametype;

		pnode->lst_attack = elem->fst_attack;
		
			
		return CW_TRUE;

	}

	while(pnext != NULL)
	{
		if(memcmp((pnext->bssid),elem->bssid,6) == 0)
		{
			pnext->attackcount++;
			pnext->attacktype= elem->attacktype;
			pnext->frametype = elem->frametype;
			
			pnext->lst_attack = elem->fst_attack;

			return CW_TRUE;

		}	

		pnode = pnode->next;
		pnext = pnext->next;
	}

	return CW_FALSE;//insert success

}
CWBool insert_elem_into_wids_list(wid_wids_device *paplist,struct tag_wids_device_ele *elem)
{
	wid_syslog_debug_debug(WID_DEFAULT,"insert_elem_into_wids_list\n");
	
	if((elem == NULL)||(paplist == NULL))
	{
		wid_syslog_debug_debug(WID_DEFAULT,"insert_elem_into_ap_list parameter error\n");
		return CW_FALSE;
	}	

	if(paplist->count== 0)
	{
		paplist->wids_device_info = elem;
		elem->next = NULL;
		paplist->count++;	
		return CW_TRUE;
	}


	elem->next = paplist->wids_device_info;
	paplist->wids_device_info= elem;
	paplist->count++;	

	return CW_TRUE;//insert success
	
}
void delete_wids_list(wid_wids_device **paplist)
{
	if(((*paplist) == NULL)||((*paplist)->count == 0))
	{
		CW_FREE_OBJECT(*paplist);
		return;
	}

	struct tag_wids_device_ele *phead = NULL;
	struct tag_wids_device_ele *pnext = NULL;
	phead = (*paplist)->wids_device_info;
	(*paplist)->wids_device_info = NULL;

	while(phead != NULL)
	{	
		
		pnext = phead->next;

		CW_FREE_OBJECT(phead);

		phead = pnext;

	}

	(*paplist)->count = 0;
	
	CW_FREE_OBJECT(*paplist);

}

wid_wids_device * wid_check_wids_device_all()
{
	wid_wids_device * wids_list = wid_get_wids_device_list();
	//printf("wid_check_wids_device_all\n");
	//display_wids_info_list(wids_list);
	if(wids_list == NULL)
	{
		return NULL;
	}
	
	return wids_list;	

}

wid_wids_device * wid_get_wids_device_list()
{
	int i = 0;
	CWBool ret = CW_FALSE;
	struct tag_wids_device_ele *phead = NULL;
	struct tag_wids_device_ele *Pnode = NULL;
	
	wid_wids_device *create_wids_info;
	CW_CREATE_OBJECT_ERR(create_wids_info, wid_wids_device, return NULL;);		
	create_wids_info->count = 0;
	create_wids_info->wids_device_info = NULL;

	for(i=0; i<WTP_NUM; i++)
	{
		
		if ((AC_WTP[i] != NULL))
		{
			
			if(AC_WTP[i]->wids_device_list != NULL)
			{
				CWThreadMutexLock(&(gWTPs[i].WIDSThreadMutex));
				
				phead = AC_WTP[i]->wids_device_list->wids_device_info;

				while(phead != NULL)
				{
					ret = check_elem_in_wids_list(create_wids_info,phead);
					if(ret == CW_FALSE)
					{
						if(find_elem_in_wids_list(wids_ignore_list,phead) == CW_FALSE)
						{
							Pnode = create_wids_elem(phead);
							if(Pnode != NULL)
							{
								if(insert_elem_into_wids_list_head(create_wids_info,Pnode) == CW_FALSE)
								{

									CW_FREE_OBJECT(Pnode);
								}
							}
						}
						
					}
					phead = phead->next;
				}
				CWThreadMutexUnlock(&(gWTPs[i].WIDSThreadMutex));
			}		
			
		}		
	}


	if((create_wids_info->wids_device_info == NULL)||(create_wids_info->count == 0))
	{
		CW_FREE_OBJECT(create_wids_info);
		return NULL;
	}

	
	return create_wids_info;

}

CWBool check_elem_in_wids_list(wid_wids_device *paplist,struct tag_wids_device_ele *elem)
{
	if((elem == NULL)||((paplist) == NULL)||((paplist)->wids_device_info == NULL)||((paplist)->count == 0))
	{
		wid_syslog_debug_debug(WID_DEFAULT,"check_elem_in_wids_list parameter error\n");
		return CW_FALSE;
	}	

	
	struct tag_wids_device_ele *pnode = (paplist)->wids_device_info;
	struct tag_wids_device_ele *pnext = pnode->next;

	if(memcmp((pnode->bssid),elem->bssid,6) == 0)
	{

		return CW_TRUE;

	}

	while(pnext != NULL)
	{
		if(memcmp((pnext->bssid),elem->bssid,6) == 0)
		{
			return CW_TRUE;
		}	

		pnode = pnode->next;
		pnext = pnext->next;
	}

	return CW_FALSE;

}

struct tag_wids_device_ele * create_wids_elem(struct tag_wids_device_ele *apelem)
{
	struct tag_wids_device_ele *neighborapelem = NULL;
	
	CW_CREATE_OBJECT_SIZE_ERR(neighborapelem, sizeof(struct tag_wids_device_ele), return NULL;);

	
	memcpy(neighborapelem->bssid,apelem->bssid, 6);
	
	neighborapelem->attacktype = apelem->attacktype;

	neighborapelem->frametype = apelem->frametype;
	neighborapelem->attackcount = apelem->attackcount;
	neighborapelem->fst_attack = apelem->fst_attack;
	neighborapelem->lst_attack = apelem->lst_attack;

	neighborapelem->channel = apelem->channel;
	neighborapelem->rssi = apelem->rssi ;
	memcpy(neighborapelem->vapbssid,apelem->vapbssid,6);

	neighborapelem->next = NULL;	

	return neighborapelem;
	
}
CWBool insert_elem_into_wids_list_head(wid_wids_device *paplist,struct tag_wids_device_ele *elem)
{
	if((elem == NULL)||(paplist == NULL))
	{
		wid_syslog_debug_debug(WID_DEFAULT,"insert_elem_into_wids_list_head parameter error\n");
		return CW_FALSE;
	}	

	if(paplist->count == 0)
	{
		paplist->wids_device_info = elem;
		paplist->count++;	
		return CW_TRUE;
	}
	
	struct tag_wids_device_ele *pnode = paplist->wids_device_info;

	paplist->wids_device_info= elem;
	elem->next = pnode;
	paplist->count++;	

	return CW_TRUE;


}

wid_wids_device * create_wids_info_list(int count)
{
	wid_wids_device *create_wids_info = NULL;
	int i = 0;
	CW_CREATE_OBJECT_ERR(create_wids_info, wid_wids_device, return NULL;);	
				
	create_wids_info->count = count;
	create_wids_info->wids_device_info = NULL;
	
	struct tag_wids_device_ele *neighborapelem = NULL;
	struct tag_wids_device_ele *phead = NULL;

	for(i=0; i<create_wids_info->count; i++)
	{
	    /*coverity-CID: 10852, Resource leaks*/
		CW_CREATE_OBJECT_SIZE_ERR(neighborapelem, sizeof(struct tag_wids_device_ele), {delete_wids_list(&(create_wids_info)); return NULL;});		
		
		char str[3][6] = {{"111111"},{"222222"},{"333333"}};
		memcpy(neighborapelem->bssid,str[i], 6);

		neighborapelem->bssid[0] = 1;
		neighborapelem->bssid[1] = 1;
		neighborapelem->bssid[2] = 1;
		neighborapelem->bssid[3] = 1;
		neighborapelem->bssid[4] = 1;
		neighborapelem->bssid[5] = 1;
		
		neighborapelem->attackcount = 110;

		neighborapelem->frametype = 1;
		neighborapelem->attacktype = 1;
		time(&neighborapelem->fst_attack);
		time(&neighborapelem->fst_attack);

		neighborapelem->next = NULL;

		if(i== 0)
		{
			//printf("parse first ap info\n");
			create_wids_info->wids_device_info = neighborapelem;
			phead = neighborapelem;
			neighborapelem = NULL;
		}
		else
		{
			//printf("parse more ap info\n");
			phead->next = neighborapelem;
			phead = neighborapelem;
			neighborapelem = NULL;
		}
		//printf("######002####\n");
	}	

	return create_wids_info;
	//display_ap_info_list(create_ap_info);


}

void display_wids_info_list(wid_wids_device *paplist)
{

	if((paplist == NULL)||(paplist->wids_device_info== NULL)||(paplist->count== 0))
	{
		printf("display_ap_info_list parameter error\n");
		return;
	}
	
	int i = 0;
	int j = 0;

	struct tag_wids_device_ele *phead = paplist->wids_device_info;
		
	printf("## display_wids_info_list count is = %d: ##\n",paplist->count);
	for(i=0; i<paplist->count; i++)
	{
		printf("## the count i = %d##\n",i);
		printf("mac = ");
		for(j=0; j<6; j++)
		{
			printf("%02x", phead->bssid[j]);
		}
		printf("\n");

		phead = phead->next;
	}
}

int add_ipip_tunnel(unsigned int BSSIndex)
{
	
	ex_ip_info iptunnelinfo;
	iptunnelinfo.sip = 0;
	iptunnelinfo.dip = 0;
	
	int wtpid = 0;
	int l_radioid = 0;
	int wlanid = 0;
	//int reason = 0;
	
	memset(iptunnelinfo.if_name,0,ETH_IF_NAME_LEN);
	memset(iptunnelinfo.wtpmac,0,MAC_LEN);


	wtpid = BSSIndex/(L_BSS_NUM*L_RADIO_NUM);
	l_radioid = AC_BSS[BSSIndex]->Radio_L_ID;
	wlanid = AC_BSS[BSSIndex]->WlanID;
	
//	printf(" add_ipip_tunnel radio%d-%d.%d\n",wtpid,l_radioid,wlanid);
	
//	snprintf(iptunnelinfo.if_name,ETH_IF_NAME_LEN-1,"radio%d-%d-%d.%d",vrrid,wtpid,l_radioid,wlanid);
	if(local)
		snprintf((char*)iptunnelinfo.if_name,ETH_IF_NAME_LEN,"r%d-%d-%d.%d",vrrid,wtpid,l_radioid,wlanid);
	else
		snprintf((char*)iptunnelinfo.if_name,ETH_IF_NAME_LEN,"r%d-%d-%d-%d.%d",slotid,vrrid,wtpid,l_radioid,wlanid);
	memcpy(iptunnelinfo.wtpmac, AC_WTP[wtpid]->WTPMAC, MAC_LEN);
	
	//make sip and dip
	/*fengwenchao modify begin 20110525*/
	if((gWTPs[wtpid].interfaceIndex < gMaxInterfacesCount)&&(gWTPs[wtpid].interfaceIndex >= 0))
	{
		struct sockaddr_in	*sin = (struct sockaddr_in *)((struct sockaddr*) &(gInterfaces[gWTPs[wtpid].interfaceIndex].addr));
		iptunnelinfo.dip = sin->sin_addr.s_addr;
	}
	else
	{
		wid_syslog_err(" gWTPs[%d].interfaceIndex = %d , is not  legal !\n",wtpid,gWTPs[wtpid].interfaceIndex);
		return -1;
	}
	/*fengwenchao add end*/

	char apip[WID_SYSTEM_CMD_LENTH];
	char *delim=":";
	char *papip = NULL;
	strcpy(apip,AC_WTP[wtpid]->WTPIP);
	papip = strtok(apip,delim);

//	printf("ip :%s \n",papip);

	
	iptunnelinfo.sip = inet_addr(papip);	

//	printf("ifname:%s dip:%d sip:%d\n",iptunnelinfo.if_name,iptunnelinfo.dip,iptunnelinfo.sip);
//	printf("mac:%02x:%02x:%02x:%02x:%02x:%02x\n",iptunnelinfo.wtpmac[0],iptunnelinfo.wtpmac[1],iptunnelinfo.wtpmac[2],iptunnelinfo.wtpmac[3],iptunnelinfo.wtpmac[4],iptunnelinfo.wtpmac[5]);

	int ret = -1;
	
	int fd = open("/dev/wifi0", O_RDWR);

	if(fd < 0)
	{
		return -1;//create failure
	}

	
	ret = ioctl(fd, WIFI_IOC_IP_ADD, &iptunnelinfo);

	close(fd);
	
	if(ret < 0)
	{
		return -1;
	}
	
	return 0;

}

int delete_ipip_tunnel(unsigned int BSSIndex)
{
	
	ex_ip_info iptunnelinfo;
	iptunnelinfo.sip = 0;
	iptunnelinfo.dip = 0;
	
	int wtpid = 0;
	int l_radioid = 0;
	int wlanid = 0;
	//int reason = 0;
	
	memset(iptunnelinfo.if_name,0,ETH_IF_NAME_LEN);
	memset(iptunnelinfo.wtpmac,0,MAC_LEN);


	wtpid = BSSIndex/(L_BSS_NUM*L_RADIO_NUM);
	l_radioid = AC_BSS[BSSIndex]->Radio_L_ID;
	wlanid = AC_BSS[BSSIndex]->WlanID;
	
//	printf(" delete_ipip_tunnel radio%d-%d.%d\n",wtpid,l_radioid,wlanid);
	
	//snprintf(iptunnelinfo.if_name,ETH_IF_NAME_LEN-1,"radio%d-%d-%d.%d",vrrid,wtpid,l_radioid,wlanid);
	if(local)
		snprintf((char*)iptunnelinfo.if_name,ETH_IF_NAME_LEN,"r%d-%d-%d.%d",vrrid,wtpid,l_radioid,wlanid);
	else
		snprintf((char*)iptunnelinfo.if_name,ETH_IF_NAME_LEN,"r%d-%d-%d-%d.%d",slotid,vrrid,wtpid,l_radioid,wlanid);
	memcpy(iptunnelinfo.wtpmac, AC_WTP[wtpid]->WTPMAC, MAC_LEN);
	
	//make sip and dip
	/*fengwenchao modify begin 20110525*/
	if((gWTPs[wtpid].interfaceIndex < gMaxInterfacesCount)&&(gWTPs[wtpid].interfaceIndex >= 0))
	{
		struct sockaddr_in	*sin = (struct sockaddr_in *)((struct sockaddr*) &(gInterfaces[gWTPs[wtpid].interfaceIndex].addr));
		iptunnelinfo.dip = sin->sin_addr.s_addr;
	}
	else
	{
		wid_syslog_err(" gWTPs[%d].interfaceIndex = %d , is not  legal !\n",wtpid,gWTPs[wtpid].interfaceIndex);
	}
	/*fengwenchao add end*/
	
	char apip[WID_SYSTEM_CMD_LENTH];
	char *delim=":";
	char *papip = NULL;
	strcpy(apip,AC_WTP[wtpid]->WTPIP);
	papip = strtok(apip,delim);

//	printf("ip :%s \n",papip);

	
	iptunnelinfo.sip = inet_addr(papip);	

//	printf("ifname:%s dip:%d sip:%d\n",iptunnelinfo.if_name,iptunnelinfo.dip,iptunnelinfo.sip);
//	printf("mac:%02x:%02x:%02x:%02x:%02x:%02x\n",iptunnelinfo.wtpmac[0],iptunnelinfo.wtpmac[1],iptunnelinfo.wtpmac[2],iptunnelinfo.wtpmac[3],iptunnelinfo.wtpmac[4],iptunnelinfo.wtpmac[5]);
	
	int ret = -1;
	
	int fd = open("/dev/wifi0", O_RDWR);

	if(fd < 0)
	{
		return -1;//create failure
	}

	
	ret = ioctl(fd, WIFI_IOC_IP_DEL, &iptunnelinfo);

	close(fd);
	
	if(ret < 0)
	{
		return -1;
	}
	
	return 0;

}

int wid_set_neighbordead_intervalt(unsigned int wtpid, int neighbordead_interval)
{
	msgq msg;	
	struct msgqlist *elem;

	memset((char*)&msg, 0, sizeof(msg));
	msg.mqid = wtpid%THREAD_NUM+1;
	msg.mqinfo.WTPID = wtpid;
	msg.mqinfo.type = CONTROL_TYPE;
	msg.mqinfo.subtype = WTP_S_TYPE;
	msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_NEIGHBORDEAD_INTERVAL;
	

	if(AC_WTP[wtpid]->WTPStat == WID_RUN)
	{	
		if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
			wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
		}
	}
	else
	{
		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if(elem == NULL){
			wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
			perror("malloc");
			return 0;
		}
		memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
		elem->next = NULL;
		memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
		
		WID_INSERT_CONTROL_LIST(wtpid, elem);		
	}

	return 0;
	
}
int wid_set_radio_auto_channel_able(unsigned int wtpid,unsigned int l_radioid,unsigned int able)
{
	int IGNORE_UBSV ret = 0;
	
	char apcmd[WID_SYSTEM_CMD_LENTH];
	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);
	if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->auto_channel == able)
	{
		return 0;
	}
	else
	{
		sprintf(apcmd,"echo %d > /proc/sys/dev/wifi%d/nonoverlapping",able,l_radioid);
		//printf("apcmd %s\n",apcmd);
		wid_syslog_debug_debug(WID_DEFAULT,"apcmd %s\n",apcmd);

		ret = wid_radio_set_extension_command(wtpid,apcmd);
		AC_WTP[wtpid]->WTP_Radio[l_radioid]->auto_channel = able;
		return 0;
	}
	
}
//enter run state,process radio diversity&txantenna
int wid_set_radio_diversity(unsigned int wtpid,unsigned int l_radioid,unsigned int able)
{
	int IGNORE_UBSV ret = 0;
	
	char apcmd[WID_SYSTEM_CMD_LENTH];
	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);

	sprintf(apcmd,"echo %d > /proc/sys/dev/wifi%d/diversity",able,l_radioid);
	//printf("wid_set_radio_diversity apcmd %s\n",apcmd);
	wid_syslog_debug_debug(WID_DEFAULT,"wid_set_radio_diversity apcmd %s\n",apcmd);

	ret = wid_radio_set_extension_command(wtpid,apcmd);
	return 0;
}
int wid_set_radio_txantenna(unsigned int wtpid,unsigned int l_radioid,unsigned int able)
{
	int IGNORE_UBSV ret = 0;
	
	char apcmd[WID_SYSTEM_CMD_LENTH];
	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);

	sprintf(apcmd,"echo %d > /proc/sys/dev/wifi%d/txantenna",able,l_radioid);
	//printf("wid_set_radio_txantenna apcmd %s\n",apcmd);
	wid_syslog_debug_debug(WID_DEFAULT,"wid_set_radio_txantenna apcmd %s\n",apcmd);

	ret = wid_radio_set_extension_command(wtpid,apcmd);
	return 0;
}

int wid_set_radio_diversity_txantenna_after_run(unsigned int wtpid,unsigned int l_radioid)
{
	if(AC_WTP[wtpid] == NULL)
	{
		return -1;
	}
	if(AC_WTP[wtpid]->WTP_Radio[l_radioid] == NULL)
	{
		return -1;
	}
	
	int diversity = 0;
	int txantenna = 0;
	diversity = AC_WTP[wtpid]->WTP_Radio[l_radioid]->diversity;
	txantenna = AC_WTP[wtpid]->WTP_Radio[l_radioid]->txantenna;
	int code_result = wid_parse_wtp_code_for_radio_set(wtpid);
	/*1 means hardware right; 2 means the second wifi need to be changed;0 means all wifi need to be changed*/
	/*this will be change after ap hardware changed soon  sz 09-07-17*/
	if(code_result == 0)
	{
		if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->txantenna == 1)
		{
			txantenna = 2;//change hardware mistake
			wid_set_radio_txantenna(wtpid,l_radioid,txantenna);
		}
		else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->txantenna == 2)
		{
			txantenna = 1;//change hardware mistake
			wid_set_radio_txantenna(wtpid,l_radioid,txantenna);
		}
		else
		{
			txantenna = 0;
			wid_set_radio_txantenna(wtpid,l_radioid,txantenna);
		}	
	}
	else if(code_result == 1)
	{
		wid_set_radio_txantenna(wtpid,l_radioid,txantenna);
	}
	else if(code_result == 2)
	{
		if(l_radioid == 1)
		{
			if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->txantenna == 1)
			{
				txantenna = 2;//change hardware mistake
				wid_set_radio_txantenna(wtpid,l_radioid,txantenna);
			}
			else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->txantenna == 2)
			{
				txantenna = 1;//change hardware mistake
				wid_set_radio_txantenna(wtpid,l_radioid,txantenna);
			}
			else
			{
				wid_set_radio_txantenna(wtpid,l_radioid,txantenna);
			}
		}
		else
		{
			wid_set_radio_txantenna(wtpid,l_radioid,txantenna);
		}
	}

	if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->diversity != 1)
	{
		wid_set_radio_diversity(wtpid,l_radioid,diversity);
	}
	
	return 0;	
}
int wid_set_radio_diversity_txantenna_after_run_new(unsigned int wtpid,unsigned int l_radioid)
{
	if(AC_WTP[wtpid] == NULL)
	{
		return -1;
	}
	if(AC_WTP[wtpid]->WTP_Radio[l_radioid] == NULL)
	{
		return -1;
	}
	
	int diversity = 0;
	int txantenna = 0;
	diversity = AC_WTP[wtpid]->WTP_Radio[l_radioid]->diversity;
	txantenna = AC_WTP[wtpid]->WTP_Radio[l_radioid]->txantenna;
	
	int IGNORE_UBSV ret = 0;
	
	char apcmd[WID_SYSTEM_CMD_LENTH];
	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);

	sprintf(apcmd,"cd / && setantenna wifi%d diversity %d",l_radioid,diversity);
	wid_syslog_debug(WAI_FUNC_LINE_FMT""WAI_AFI_FMT"radio %u command '%s'\n", \
						WAI_FUNC_LINE_LITERAL, wtpid,AC_WTP[wtpid]->WTPNAME, l_radioid,apcmd);

	ret = wid_radio_set_extension_command(wtpid,apcmd);

	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);

	sprintf(apcmd,"cd / && setantenna wifi%d tx %d",l_radioid,txantenna);
	wid_syslog_debug(WAI_FUNC_LINE_FMT""WAI_AFI_FMT"radio %u command '%s'\n", \
						WAI_FUNC_LINE_LITERAL, wtpid,AC_WTP[wtpid]->WTPNAME, l_radioid,apcmd);

	ret = wid_radio_set_extension_command(wtpid,apcmd);

	return 0;	
}

int wid_parse_wtp_code_for_radio_set(unsigned int wtpid)
{
	int code_result = 0;
	
	if(AC_WTP[wtpid] == NULL)
	{
		return -1;
	}
	else if(AC_WTP[wtpid]->APCode == NULL)
	{
		return -1;
	}
	else
	{
		int codelen = strlen(AC_WTP[wtpid]->APCode);
		
		if(AC_WTP[wtpid]->APCode[codelen-1] == 'N')
		{
			code_result = 1;
			return code_result;
		}
		else
		{
			if(codelen == 4)
			{
				if((memcmp(AC_WTP[wtpid]->APCode,"2010",4) == 0)||(memcmp(AC_WTP[wtpid]->APCode,"1010",4) == 0))
				{
					code_result = 1;
					return code_result;
				}
			}
			else if(codelen == 6)
			{
				if(memcmp(AC_WTP[wtpid]->APCode,"2010V2",6) == 0)
				{
					code_result = 1;
					return code_result;
				}
			}
			
			if((AC_WTP[wtpid]->APCode[codelen-1] == 'H')||(AC_RADIO[wtpid*L_RADIO_NUM]->ishighpower == 1))
			{
				code_result = 2;
				return code_result;
			}
			else
			{
				code_result = 1;        //zhangshu change code_result from 0 to 1,2010-10-29
				return code_result;
			}
		}
	}
	//printf("ap code %s ;result %d\n",AC_WTP[wtpid]->APCode,code_result);
	return code_result;
}

int wid_set_ap_reboot(unsigned int WtpID)
{
	wid_syslog_debug_debug(WID_DEFAULT,"%s:%d AC_WTP[%d]->WTPStat= %d\n",__func__,__LINE__,WtpID);
	if(AC_WTP[WtpID]->WTPStat == WID_OFFLINE)
	{
	    return WTP_IN_OFFLINE_STATE;
	}
	
	wid_trap_remote_restart(WtpID);
	WID_SUSPEND_WTP(WtpID);
	AC_WTP[WtpID]->quitreason = WTP_UNUSED;
	return 0;
}

int wid_set_bss_traffic_limit(unsigned int wtpid,unsigned int l_radioid,unsigned char wlanid,unsigned char able)
{
	int IGNORE_UBSV ret = 0;
	
	char apcmd[WID_SYSTEM_CMD_LENTH];
	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);

	if(able == 1)
		sprintf(apcmd,"autelan traffic_limit ath.%d-%d set_every_node_flag %d",l_radioid,wlanid,able);
	else if(able == 0)
	{
		sprintf(apcmd,"autelan traffic_limit ath.%d-%d set_vap_flag %d;"
		"autelan traffic_limit ath.%d-%d set_every_node_flag %d;",
		l_radioid,wlanid,able,\
		l_radioid,wlanid,able);
		/*
		sprintf(apcmd,"autelan traffic_limit ath.%d-%d set_every_node_flag %d;"
		"autelan traffic_limit ath.%d-%d set_every_node %d;"
		"autelan traffic_limit ath.%d-%d set_every_node_send %d;"
		"autelan traffic_limit ath.%d-%d set_vap %d;"
		"autelan traffic_limit ath.%d-%d set_vap_send %d;",
		l_radioid,wlanid,able,\
		l_radioid,wlanid,STA_DEFAULT_TRAFFIC_LIMIT,\
		l_radioid,wlanid,STA_DEFAULT_TRAFFIC_LIMIT,\
		l_radioid,wlanid,STA_DEFAULT_TRAFFIC_LIMIT,\
		l_radioid,wlanid,STA_DEFAULT_TRAFFIC_LIMIT);
		*/
	}
	
	wid_syslog_debug_debug(WID_DEFAULT,"wid_set_bss_traffic_limit apcmd %s\n",apcmd);

	ret = wid_radio_set_extension_command(wtpid,apcmd);
	return 0;
}
int wid_set_bss_traffic_limit_value(unsigned int wtpid,unsigned int l_radioid,unsigned char wlanid,unsigned int value,unsigned char issend)
{
	int IGNORE_UBSV ret = 0;
	
	char apcmd[WID_SYSTEM_CMD_LENTH];
	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);

	if(value == 0)
	{
		sprintf(apcmd,"autelan traffic_limit ath.%d-%d set_vap_flag 0",l_radioid,wlanid);
	}
	else
	{
		if(issend == 1)
		{
			sprintf(apcmd,"autelan traffic_limit ath.%d-%d set_vap_flag 1;autelan traffic_limit ath.%d-%d set_vap_send %d",l_radioid,wlanid,l_radioid,wlanid,value);
		}
		else if(issend == 0)
		{		
			sprintf(apcmd,"autelan traffic_limit ath.%d-%d set_vap_flag 1;autelan traffic_limit ath.%d-%d set_vap %d",l_radioid,wlanid,l_radioid,wlanid,value);
		}
		else
		{
			wid_syslog_debug_debug(WID_DEFAULT,"wid_set_bss_traffic_limit_value error\n");
		}
	}
	wid_syslog_debug_debug(WID_DEFAULT,"wid_set_bss_traffic_limit_value apcmd %s\n",apcmd);

	ret = wid_radio_set_extension_command(wtpid,apcmd);
	
	return 0;
}

int wid_set_bss_traffic_limit_average_value(unsigned int wtpid,unsigned int l_radioid,unsigned char wlanid,unsigned int value,unsigned char issend)
{
	int IGNORE_UBSV ret = 0;
	char apcmd[WID_SYSTEM_CMD_LENTH];
	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);

	if(value == 0)
	{
		sprintf(apcmd,"autelan traffic_limit ath.%d-%d set_every_node_flag 0", l_radioid, wlanid);
	}
	else
	{
		if(issend == 1)
		{
			sprintf(apcmd,"autelan traffic_limit ath.%d-%d set_every_node_flag 1;autelan traffic_limit ath.%d-%d set_every_node_send %d",l_radioid,wlanid,l_radioid,wlanid,value);
		}
		else if(issend == 0)
		{		
			sprintf(apcmd,"autelan traffic_limit ath.%d-%d set_every_node_flag 1;autelan traffic_limit ath.%d-%d set_every_node %d",l_radioid,wlanid,l_radioid,wlanid,value);
		}
		else
		{
			wid_syslog_debug_debug(WID_DEFAULT,"wid_set_bss_traffic_limit_average_value error\n");
		}
	}
	wid_syslog_debug_debug(WID_DEFAULT,"wid_set_bss_traffic_limit_average_value apcmd %s\n",apcmd);

	ret = wid_radio_set_extension_command(wtpid,apcmd);
	
	return 0;
}

int wid_set_bss_traffic_limit_sta_value(unsigned int wtpid,
												unsigned int l_radioid,
												unsigned char wlanid,
												unsigned char mac0,
												unsigned char mac1,
												unsigned char mac2,
												unsigned char mac3,
												unsigned char mac4,
												unsigned char mac5,
												unsigned int value,
												unsigned char issend)
{
	int IGNORE_UBSV ret = 0;
	char apcmd[WID_SYSTEM_CMD_LENTH];
	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);

	if(value == 0)
		value = STA_DEFAULT_TRAFFIC_LIMIT;
	if(issend == 1)
	{
		sprintf(apcmd,"autelan traffic_limit ath.%d-%d set_specific_node_flag %02X:%02X:%02X:%02X:%02X:%02X 1;autelan traffic_limit ath.%d-%d set_specific_node_send %02X:%02X:%02X:%02X:%02X:%02X %d",l_radioid,wlanid,mac0,mac1,mac2,mac3,mac4,mac5,l_radioid,wlanid,mac0,mac1,mac2,mac3,mac4,mac5,value);
	}
	else if(issend == 0)
	{		
		sprintf(apcmd,"autelan traffic_limit ath.%d-%d set_specific_node_flag %02X:%02X:%02X:%02X:%02X:%02X 1;autelan traffic_limit ath.%d-%d set_specific_node %02X:%02X:%02X:%02X:%02X:%02X %d",l_radioid,wlanid,mac0,mac1,mac2,mac3,mac4,mac5,l_radioid,wlanid,mac0,mac1,mac2,mac3,mac4,mac5,value);
	}
	else
	{
		wid_syslog_debug_debug(WID_DEFAULT,"wid_set_bss_traffic_limit_sta_value error\n");
	}

	wid_syslog_debug_debug(WID_DEFAULT,"wid_set_bss_traffic_limit_sta_value apcmd %s\n",apcmd);
    
	ret = wid_radio_set_extension_command(wtpid,apcmd);
	
	return 0;
}

int wid_set_sta_traffic_limit
(	
	unsigned int wtpid,
	unsigned char l_radioid,
	unsigned char wlanid,
	unsigned char *haddr,
	unsigned int traffic_limit,
	unsigned int traffic_limit_send
)
{
	int IGNORE_UBSV ret = 0;	
	char apcmd[WID_SYSTEM_CMD_LENTH];

	memset(apcmd, 0, WID_SYSTEM_CMD_LENTH);
	snprintf(apcmd, sizeof(apcmd), 
		"autelan traffic_limit ath.%d-%d set_specific_node_flag %02X:%02X:%02X:%02X:%02X:%02X 1;"
		"autelan traffic_limit ath.%d-%d set_specific_node_send %02X:%02X:%02X:%02X:%02X:%02X %d",
		l_radioid, wlanid, haddr[0], haddr[1], haddr[2], haddr[3], haddr[4], haddr[5],
		l_radioid, wlanid, haddr[0], haddr[1], haddr[2], haddr[3], haddr[4], haddr[5], traffic_limit_send);

	wid_syslog_debug_debug(WID_DEFAULT,"downlink: %s\n",apcmd);
	ret = wid_radio_set_extension_command(wtpid,apcmd);
		
	sprintf(apcmd,
		"autelan traffic_limit ath.%d-%d set_specific_node_flag %02X:%02X:%02X:%02X:%02X:%02X 1;"
		"autelan traffic_limit ath.%d-%d set_specific_node %02X:%02X:%02X:%02X:%02X:%02X %d",
		l_radioid, wlanid, haddr[0], haddr[1], haddr[2], haddr[3], haddr[4], haddr[5],
		l_radioid, wlanid, haddr[0], haddr[1], haddr[2], haddr[3], haddr[4], haddr[5], traffic_limit);
	
	wid_syslog_debug_debug(WID_DEFAULT,"uplink %s\n",apcmd);
	
	ret = wid_radio_set_extension_command(wtpid,apcmd);
	
	return 0;
}
int wid_cancel_bss_traffic_limit_sta_value(unsigned int wtpid,
												unsigned int l_radioid,
												unsigned char wlanid,
												unsigned char mac0,
												unsigned char mac1,
												unsigned char mac2,
												unsigned char mac3,
												unsigned char mac4,
												unsigned char mac5,
												unsigned int value,
												unsigned char flag,
												unsigned char issend)
{
	int IGNORE_UBSV ret = 0;
	
	char apcmd[WID_SYSTEM_CMD_LENTH];
	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);

	if(flag == 2)
	{
		sprintf(apcmd,"autelan traffic_limit ath.%d-%d set_specific_node_flag %02X:%02X:%02X:%02X:%02X:%02X 0;"
			"autelan traffic_limit ath.%d-%d set_specific_node %02X:%02X:%02X:%02X:%02X:%02X %d;"
			"autelan traffic_limit ath.%d-%d set_specific_node_send %02X:%02X:%02X:%02X:%02X:%02X %d",
			l_radioid,wlanid,mac0,mac1,mac2,mac3,mac4,mac5,
			l_radioid,wlanid,mac0,mac1,mac2,mac3,mac4,mac5,STA_DEFAULT_TRAFFIC_LIMIT,
			l_radioid,wlanid,mac0,mac1,mac2,mac3,mac4,mac5,STA_DEFAULT_TRAFFIC_LIMIT);
	}
	else if(issend == 1)
	{
		sprintf(apcmd,"autelan traffic_limit ath.%d-%d set_specific_node_flag %02X:%02X:%02X:%02X:%02X:%02X 1;autelan traffic_limit ath.%d-%d set_specific_node_send %02X:%02X:%02X:%02X:%02X:%02X %d",l_radioid,wlanid,mac0,mac1,mac2,mac3,mac4,mac5,l_radioid,wlanid,mac0,mac1,mac2,mac3,mac4,mac5,value);
	}
	else if(issend == 0)
	{		
		sprintf(apcmd,"autelan traffic_limit ath.%d-%d set_specific_node_flag %02X:%02X:%02X:%02X:%02X:%02X 1;autelan traffic_limit ath.%d-%d set_specific_node %02X:%02X:%02X:%02X:%02X:%02X %d",l_radioid,wlanid,mac0,mac1,mac2,mac3,mac4,mac5,l_radioid,wlanid,mac0,mac1,mac2,mac3,mac4,mac5,value);
	}
	else
	{
		wid_syslog_debug_debug(WID_DEFAULT,"wid_set_bss_traffic_limit_sta_value error\n");
	}
//	printf("wid_set_bss_traffic_limit_sta_value apcmd %s\n",apcmd);
	wid_syslog_debug_debug(WID_DEFAULT,"wid_set_bss_traffic_limit_sta_value apcmd %s\n",apcmd);

	ret = wid_radio_set_extension_command(wtpid,apcmd);
	return 0;
}
/*nl add 20100317*/
int wid_radio_set_whole_wlan_traffic_limit_value(unsigned char wlanid,unsigned int value,unsigned char issend)
{
	int i = 0;
	int l_radio_num = 0;
	int k = 0;
	unsigned int IGNORE_UBSV bssindex = 0;
	unsigned char bssid = 0;
	int wtp_num;

	
	for(i=0;i<G_RADIO_NUM;i++){

		wtp_num = i/L_RADIO_NUM;
		l_radio_num = i % L_RADIO_NUM;
				
		if((AC_WTP[wtp_num] == NULL)||(AC_WTP[wtp_num]->WTP_Radio[l_radio_num] == NULL))
			{	
				continue;
			}

		else{
			if(AC_WTP[wtp_num]->WTP_Radio[l_radio_num]->isBinddingWlan == 0)
				{	
					continue;
				}
			
			else{
				for(k=0;k<L_BSS_NUM;k++){
					
					if(AC_WTP[wtp_num]->WTP_Radio[l_radio_num]->BSS[k] != NULL){
						if(AC_WTP[wtp_num]->WTP_Radio[l_radio_num]->BSS[k]->WlanID == wlanid){
							
							bssindex = AC_WTP[wtp_num]->WTP_Radio[l_radio_num]->BSS[k]->BSSIndex;
							bssid = k;
							
							if(issend == 1){/*down*/
								if(AC_WTP[wtp_num]->WTP_Radio[l_radio_num]->BSS[bssid]->send_traffic_limit == value)
								{
									continue;
								}
							}
							else if(issend == 0){/*up*/
								if(AC_WTP[wtp_num]->WTP_Radio[l_radio_num]->BSS[bssid]->traffic_limit == value)
								{
									continue;
								}
							} 
							
							wid_set_bss_traffic_limit_value(wtp_num,l_radio_num,wlanid,value,issend);
							AC_WTP[wtp_num]->WTP_Radio[l_radio_num]->BSS[bssid]->traffic_limit_able = 1;
							
							if(issend == 1)
							{
								AC_WTP[wtp_num]->WTP_Radio[l_radio_num]->BSS[bssid]->send_traffic_limit = value;
							}
							else if(issend == 0)
							{
								AC_WTP[wtp_num]->WTP_Radio[l_radio_num]->BSS[bssid]->traffic_limit = value;
							}
				#if NOSOFTAC
							wid_asd_bss_traffic_limit(bssindex);
				#endif
						}
					}
				}
			}
		}
	}
	
	return WID_DBUS_SUCCESS;
	
}
/*nl add 20100401*/
int wid_radio_set_whole_wlan_station_average_traffic_limit_value(unsigned char wlanid,unsigned int value,unsigned char issend)
{
	int i = 0;
	int l_radio_num = 0;
	int k = 0;
	unsigned int IGNORE_UBSV bssindex = 0;
	unsigned char bssid = 0;
	int wtp_num;

	
	for(i=0;i<G_RADIO_NUM;i++){

		wtp_num = i/L_RADIO_NUM;
		l_radio_num = i % L_RADIO_NUM;
				
		if((AC_WTP[wtp_num] == NULL)||(AC_WTP[wtp_num]->WTP_Radio[l_radio_num] == NULL))
			{	
				continue;
			}

		else{
			if(AC_WTP[wtp_num]->WTP_Radio[l_radio_num]->isBinddingWlan == 0)
				{	
					continue;
				}
			
			else{
				for(k=0;k<L_BSS_NUM;k++){
					
					if(AC_WTP[wtp_num]->WTP_Radio[l_radio_num]->BSS[k] != NULL){
						if(AC_WTP[wtp_num]->WTP_Radio[l_radio_num]->BSS[k]->WlanID == wlanid){
							
							bssindex = AC_WTP[wtp_num]->WTP_Radio[l_radio_num]->BSS[k]->BSSIndex;
							bssid = k;
							
							if(issend == 1){/*down*/
								if(AC_WTP[wtp_num]->WTP_Radio[l_radio_num]->BSS[bssid]->send_average_rate == value)
								{
									continue;
								}
							}
							else if(issend == 0){/*up*/
								if(AC_WTP[wtp_num]->WTP_Radio[l_radio_num]->BSS[bssid]->average_rate == value)
								{
									continue;
								}
							} 
							
							wid_set_bss_traffic_limit_average_value(wtp_num,l_radio_num,wlanid,value,issend);
							
							//wid_set_bss_traffic_limit_value(wtp_num,l_radio_num,wlanid,value,issend);
							AC_WTP[wtp_num]->WTP_Radio[l_radio_num]->BSS[bssid]->traffic_limit_able = 1;
							
							if(issend == 1)
							{
								AC_WTP[wtp_num]->WTP_Radio[l_radio_num]->BSS[bssid]->send_average_rate = value;
							}
							else if(issend == 0)
							{
								AC_WTP[wtp_num]->WTP_Radio[l_radio_num]->BSS[bssid]->average_rate = value;
							}
					#if NOSOFTAC		
							wid_asd_bss_traffic_limit(bssindex);
					#endif
						}
					}
				}
			}
		}
	}
	
	return WID_DBUS_SUCCESS;
	
}


/*nl add 20100120*/
int wid_radio_set_inter_vap_forwarding_able(unsigned int wtpid,unsigned int l_radioid,unsigned char policy)
{
	if(AC_WTP[wtpid] == NULL)
	{
		return -1;
	}
	int IGNORE_UBSV ret = 0;
	char apcmd[WID_SYSTEM_CMD_LENTH];
	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);
	if(policy == 0){
		sprintf(apcmd,"set interVF diable");
	}
	else if(policy == 1){
		sprintf(apcmd,"set interVF enable");
	}
	//sprintf(apcmd,"set interVF policy %d",policy);
	
	wid_syslog_debug_debug(WID_DEFAULT,"set_inter_VAP_forwarding: %s\n",apcmd);
	printf("set_inter_VAP_forwarding: %s\n",apcmd);
	
	ret = wid_radio_set_extension_command(wtpid,apcmd);
	return 0;
}
/*nl add 20100121*/
int wid_radio_set_intra_vap_forwarding_able(unsigned int wtpid,unsigned int l_radioid,unsigned char policy)
{
	if(AC_WTP[wtpid] == NULL)
	{
		return -1;
	}
	int IGNORE_UBSV ret = 0;
	char apcmd[WID_SYSTEM_CMD_LENTH];
	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);

	if(policy == 0){
		sprintf(apcmd,"set intraVF diable");
	}
	else if(policy == 1){
		sprintf(apcmd,"set intraVF enable");
	}	
	wid_syslog_debug_debug(WID_DEFAULT,"set_intra_VAP_forwarding: %s\n",apcmd);

	
	ret = wid_radio_set_extension_command(wtpid,apcmd);
	return 0;
}
/*nl add 20100128*/
int wid_radio_set_keep_alive_period_value(unsigned int wtpid,unsigned int l_radioid,unsigned int idle_period)
{
	if(AC_WTP[wtpid] == NULL)
	{
		return -1;
	}
	int IGNORE_UBSV ret = 0;
	char apcmd[WID_SYSTEM_CMD_LENTH];
	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);

	sprintf(apcmd,"set keepaliveperiod %d",idle_period);
	
	wid_syslog_debug_debug(WID_DEFAULT,"set_keep_alive_period: %s\n",apcmd);

	
	ret = wid_radio_set_extension_command(wtpid,apcmd);
	return 0;
}


/*nl add 20100129*/
int wid_radio_set_keep_alive_idle_time_value(unsigned int wtpid,unsigned int l_radioid,unsigned int idle_time)
{
	if(AC_WTP[wtpid] == NULL)
	{
		return -1;
	}
	int IGNORE_UBSV ret = 0;
	char apcmd[WID_SYSTEM_CMD_LENTH];
	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);

	sprintf(apcmd,"set keepaliveidletime %d",idle_time);
	
	wid_syslog_debug_debug(WID_DEFAULT,"set_keep_alive_idle_time %s\n",apcmd);

	
	ret = wid_radio_set_extension_command(wtpid,apcmd);
	return 0;
}
/*nl add 20100130*/
int wid_radio_set_congestion_avoid_state(unsigned int wtpid,unsigned int l_radioid,unsigned int congestion_av_state)
{
	if(AC_WTP[wtpid] == NULL)
	{
		return -1;
	}
	int IGNORE_UBSV ret = 0;
	char apcmd[WID_SYSTEM_CMD_LENTH];
	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);

	if(0 == congestion_av_state)
		sprintf(apcmd,"set caScheme disable");
	else if(1 == congestion_av_state)
		sprintf(apcmd,"set caScheme tail-drop");
	else if(2 == congestion_av_state)
		sprintf(apcmd,"set caScheme RED");
	else if(3== congestion_av_state)
		sprintf(apcmd,"set caScheme FWRED");
	
	wid_syslog_debug_debug(WID_DEFAULT,"set_congestion_avoid_state %s\n",apcmd);

	
	ret = wid_radio_set_extension_command(wtpid,apcmd);
	return 0;
}

int wid_radio_set_wlan_traffic_limit_able(unsigned int wtpid,unsigned int l_radioid,unsigned char wlanid,unsigned char policy)
{
	if((AC_WTP[wtpid] == NULL)||(AC_WLAN[wlanid] == NULL)||(AC_WTP[wtpid]->WTP_Radio[l_radioid] == NULL))
	{
		return -1;
	}

	int i = 0;
	unsigned int IGNORE_UBSV bssindex = 0;
	unsigned char bssid = 0;
	for(i=0;i<L_BSS_NUM;i++)
	{
		if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[i] != NULL)
		{
			if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[i]->WlanID == wlanid)
			{
				bssindex = AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[i]->BSSIndex;
				bssid = i;
				break;
			}
		}
	}

	if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->traffic_limit_able == policy)
	{
		return 0;
	}

	wid_set_bss_traffic_limit(wtpid,l_radioid,wlanid,policy);
	AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->traffic_limit_able = policy;
	/*
	if(policy == 0)
	{
		//AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->traffic_limit = 0;
		AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->average_rate = 0;
		//AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->send_traffic_limit = 0;
		AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->send_average_rate = 0;
	}
	*/
#if NOSOFTAC
	wid_asd_bss_traffic_limit(bssindex);
#endif

	return 0;
}
int wid_radio_set_wlan_traffic_limit_value(unsigned int wtpid,unsigned int l_radioid,unsigned char wlanid,unsigned int value,unsigned char issend)
{
	if((AC_WTP[wtpid] == NULL)||(AC_WLAN[wlanid] == NULL)||(AC_WTP[wtpid]->WTP_Radio[l_radioid] == NULL))
	{
		return -1;
	}

	int i = 0;
	unsigned int IGNORE_UBSV bssindex = 0;
	unsigned char bssid = 0;
	for(i=0;i<L_BSS_NUM;i++)
	{
		if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[i] != NULL)
		{
			if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[i]->WlanID == wlanid)
			{
				bssindex = AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[i]->BSSIndex;
				bssid = i;
				break;
			}
		}
	}
	if(issend == 1)//
	{
	/*	if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->send_traffic_limit == value)
		{
			return 0;
		}*/
	}
	else if(issend == 0)//
	{
		/*if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->traffic_limit == value)
		{
			return 0;
		}*/
	}
	else
	{
		return WID_DBUS_ERROR;
	}
	

	wid_set_bss_traffic_limit_value(wtpid,l_radioid,wlanid,value,issend);
	AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->traffic_limit_able = 1;
	if(issend == 1)
	{
		AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->send_traffic_limit = value;
	}
	else if(issend == 0)
	{
		AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->traffic_limit = value;
	}
	else
	{
		return WID_DBUS_ERROR;
	}
#if NOSOFTAC
	wid_asd_bss_traffic_limit(bssindex);
#endif
	return 0;
}
int wid_radio_set_wlan_traffic_limit_average_value(unsigned int wtpid,unsigned int l_radioid,unsigned char wlanid,unsigned int value,unsigned char issend)
{
	if((AC_WTP[wtpid] == NULL)||(AC_WLAN[wlanid] == NULL)||(AC_WTP[wtpid]->WTP_Radio[l_radioid] == NULL))
	{
		return -1;
	}

	int i = 0;
	unsigned int IGNORE_UBSV bssindex = 0;
	unsigned char bssid = 0;
	for(i=0;i<L_BSS_NUM;i++)
	{
		if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[i] != NULL)
		{
			if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[i]->WlanID == wlanid)
			{
				bssindex = AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[i]->BSSIndex;
				bssid = i;
				break;
			}
		}
	}


	
	if(issend == 1)//
	{
		if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->send_traffic_limit != 0)
		{
			if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->send_traffic_limit < value)
			{
				return IF_POLICY_CONFLICT;
			}
		}
		
/*		if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->send_average_rate == value)
		{
			return 0;
		}*/
	}
	else if(issend == 0)//
	{
		if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->traffic_limit != 0)
		{
			if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->traffic_limit < value)
			{
				return IF_POLICY_CONFLICT;
			}
		}
		
/*		if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->average_rate == value)
		{
			return 0;
		}*/
	}
	else
	{
		return WID_DBUS_ERROR;
	}
	
	wid_set_bss_traffic_limit_average_value(wtpid,l_radioid,wlanid,value,issend);
	AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->traffic_limit_able = 1;
	if(issend == 1)
	{
		AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->send_average_rate = value;
	}
	else if(issend == 0)
	{
		AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->average_rate = value;
	}
	else
	{
		return WID_DBUS_ERROR;
	}
#if NOSOFTAC	
	wid_asd_bss_traffic_limit(bssindex);
#endif
	return 0;
}
int wid_radio_set_wlan_traffic_limit_sta_value(unsigned int wtpid
														,unsigned int l_radioid
														,unsigned char wlanid
														,unsigned char mac0
														,unsigned char mac1
														,unsigned char mac2
														,unsigned char mac3
														,unsigned char mac4
														,unsigned char mac5
														,unsigned int value
														,unsigned char issend)
{
	if((AC_WTP[wtpid] == NULL)||(AC_WLAN[wlanid] == NULL)||(AC_WTP[wtpid]->WTP_Radio[l_radioid] == NULL))
	{
		return -1;
	}

	int i = 0;
	unsigned int IGNORE_UBSV bssindex = 0;
	unsigned char bssid = 0;
	for(i=0;i<L_BSS_NUM;i++)
	{
		if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[i] != NULL)
		{
			if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[i]->WlanID == wlanid)
			{
				bssindex = AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[i]->BSSIndex;
				bssid = i;
				break;
			}
		}
	}

	if(issend == 1)//
	{
		if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->send_traffic_limit != 0)
		{
			if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->send_traffic_limit < value)
			{
				return IF_POLICY_CONFLICT;
			}
		}
	}
	else if(issend == 0)//
	{
		if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->traffic_limit != 0)
		{
			if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->traffic_limit < value)
			{
				return IF_POLICY_CONFLICT;
			}
		}
	}
	else
	{
		return WID_DBUS_ERROR;
	}
	
	wid_set_bss_traffic_limit_sta_value(wtpid,l_radioid,wlanid,mac0,mac1,mac2,mac3,mac4,mac5,value,issend);
	if(value != 0)
		AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->traffic_limit_able = 1;
	return 0;
}
int wid_radio_set_wlan_traffic_limit_cancel_sta_value(unsigned int wtpid
														,unsigned int l_radioid
														,unsigned char wlanid
														,unsigned char mac0
														,unsigned char mac1
														,unsigned char mac2
														,unsigned char mac3
														,unsigned char mac4
														,unsigned char mac5
														,unsigned char flag
														,unsigned char issend)
{
	if((AC_WTP[wtpid] == NULL)||(AC_WLAN[wlanid] == NULL)||(AC_WTP[wtpid]->WTP_Radio[l_radioid] == NULL))
	{
		return -1;
	}

	int i = 0;
	unsigned int IGNORE_UBSV bssindex = 0;
	unsigned int value = 0;
	unsigned char bssid = 0;
	for(i=0;i<L_BSS_NUM;i++)
	{
		if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[i] != NULL)
		{
			if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[i]->WlanID == wlanid)
			{
				bssindex = AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[i]->BSSIndex;
				bssid = i;
				break;
			}
		}
	}

	if((issend == 1) && (flag == 1))//
	{
		value = AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->send_average_rate;
		if(value == 0)
			value = STA_DEFAULT_TRAFFIC_LIMIT;
	}
	else if((issend == 0) && (flag == 1))//
	{
		value = AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->average_rate;
		if(value == 0)
			value = STA_DEFAULT_TRAFFIC_LIMIT;
	}
	else if( flag == 2)
	{
		value = STA_DEFAULT_TRAFFIC_LIMIT;
	}
	else
	{
		return WID_DBUS_ERROR;
	}

	wid_cancel_bss_traffic_limit_sta_value(wtpid,l_radioid,wlanid,mac0,mac1,mac2,mac3,mac4,mac5,value,flag,issend);
	/*AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->traffic_limit_able = 1;*/
	return 0;
}

int wid_set_sta_ip_mac_binding(unsigned int wtpid,	unsigned int l_radioid,unsigned char wlanid,
					unsigned int value)
{
	int IGNORE_UBSV ret = 0;
	int i = 0;
	unsigned int	IGNORE_UBSV  bssindex = 0;
	unsigned char	bssid = 0;
	
	char apcmd[WID_SYSTEM_CMD_LENTH];
	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);

	for(i=0;i<L_BSS_NUM;i++)
	{
		if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[i] != NULL)
		{
			if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[i]->WlanID == wlanid)
			{
				bssindex = AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[i]->BSSIndex;
				bssid = i;
				break;
			}
		}
	}

	if((value == 0) || (value == 1))
	{		
		sprintf(apcmd,"/usr/sbin/set_ip_enable ath.%d-%d %d",l_radioid,wlanid,value);
		AC_WTP[wtpid]->WTP_Radio[l_radioid]->BSS[bssid]->ip_mac_binding = value;
	}
	else
	{
		wid_syslog_info("wid_set_sta_ip_mac_binding error\n");
	}
	printf("wid_set_sta_ip_mac_binding apcmd %s\n",apcmd);
	wid_syslog_debug_debug(WID_DEFAULT,"wid_set_sta_ip_mac_binding apcmd %s\n",apcmd);

	ret = wid_radio_set_extension_command(wtpid,apcmd);
	return 0;
}

int wid_set_radio_sector_value(unsigned int wtpid,	unsigned int l_radioid,unsigned short value,unsigned int policy)
{
	int send_flag = 0;
	char apcmd[WID_SYSTEM_CMD_LENTH];
	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);
	//CW_CREATE_OBJECT_ERR(AC_WTP[wtpid]->WTP_Radio[l_radioid]->sector[value],WID_oem_sector,return NULL;);
	/*for(i=0;i<SECTOR_NUM;i++)
	{	
		CW_CREATE_OBJECT_ERR(AC_WTP[wtpid]->WTP_Radio[l_radioid]->sector[i],WID_oem_sector,return NULL;);
	}*/
	if((policy == 1)&&((AC_WTP[wtpid]->WTP_Radio[l_radioid]->sector_state_value & value) != value)){
		if(value&0x1)
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->sector[0]->state = 1;
		if(value&0x2)
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->sector[1]->state = 1;
		if(value&0x4)
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->sector[2]->state = 1;
		if(value&0x8)
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->sector[3]->state = 1;
		AC_WTP[wtpid]->WTP_Radio[l_radioid]->sector_state_value	= value;
		send_flag = 1;
	}
	else if((policy == 0)&&((AC_WTP[wtpid]->WTP_Radio[l_radioid]->sector_state_value & (~value)) != AC_WTP[wtpid]->WTP_Radio[l_radioid]->sector_state_value)){
		if(value&0x1)
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->sector[0]->state = 0;
		if(value&0x2)
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->sector[1]->state = 0;
		if(value&0x4)
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->sector[2]->state = 0;
		if(value&0x8)
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->sector[3]->state = 0;

		AC_WTP[wtpid]->WTP_Radio[l_radioid]->sector_state_value = (AC_WTP[wtpid]->WTP_Radio[l_radioid]->sector_state_value)&(~value);
		send_flag = 1;
	}
	else{}
	if(send_flag == 1){
		sprintf(apcmd,"set sector %u",AC_WTP[wtpid]->WTP_Radio[l_radioid]->sector_state_value);
	wid_syslog_debug_debug(WID_DEFAULT,"wid_set_sector apcmd %s\n",apcmd);
		wid_radio_set_extension_command(wtpid,apcmd);
	}
	return 0;
}
int wid_set_radio_tx_chainmask_value(unsigned int wtpid,	unsigned int l_radioid,unsigned char value,unsigned int policy)
{
	int send_flag = 0;
	char apcmd[WID_SYSTEM_CMD_LENTH];
	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);
	/*
	wid_syslog_debug_debug(WID_DEFAULT,"5555555555555555\n");

	wid_syslog_debug_debug(WID_DEFAULT,"5555555555555555policy:%d\n",policy);
	
	wid_syslog_debug_debug(WID_DEFAULT,"5555555555555555 tx_mask value:%d\n",AC_WTP[wtpid]->WTP_Radio[l_radioid]->tx_chainmask_state_value);
	wid_syslog_debug_debug(WID_DEFAULT,"value:%d\n",value);*/
	

	if((policy == 1)&&((AC_WTP[wtpid]->WTP_Radio[l_radioid]->tx_chainmask_state_value & value)!= value)){
		
		if(value&0x1)
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->tx_chainmask[0]->state = 1;
		if(value&0x2)
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->tx_chainmask[1]->state = 1;
		if(value&0x4)
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->tx_chainmask[2]->state = 1;
				
		AC_WTP[wtpid]->WTP_Radio[l_radioid]->tx_chainmask_state_value	= value;
		send_flag = 1;
	}
	else if((policy == 0)&&((AC_WTP[wtpid]->WTP_Radio[l_radioid]->tx_chainmask_state_value & (~value)) != AC_WTP[wtpid]->WTP_Radio[l_radioid]->tx_chainmask_state_value)){
		if(value&0x1)
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->tx_chainmask[0]->state = 0;
		if(value&0x2)
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->tx_chainmask[1]->state = 0;
		if(value&0x4)
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->tx_chainmask[2]->state = 0;
		
		AC_WTP[wtpid]->WTP_Radio[l_radioid]->tx_chainmask_state_value = (AC_WTP[wtpid]->WTP_Radio[l_radioid]->tx_chainmask_state_value)&(~value);
		send_flag = 1;
		
	}
	else{}
	if(send_flag == 1){
		sprintf(apcmd,"set tx_chainmask %u",AC_WTP[wtpid]->WTP_Radio[l_radioid]->tx_chainmask_state_value);
	wid_syslog_debug_debug(WID_DEFAULT,"wid_tx_chainmask apcmd %s\n",apcmd);
		wid_radio_set_extension_command(wtpid,apcmd);
	}
	return 0;
}

int radio_sectorid_parse_func(unsigned short int sectorid,char* str){
	unsigned int ret = 0;
	//char str[4];
//	str = NULL;
	if (sectorid == 0)
	{
		memcpy(str, "0",1);
	}		
	else if (sectorid == 1)
	{
		memcpy(str, "1",1);
	}
	else if (sectorid == 2)
	{
		memcpy(str, "2",1);
	}
	else if (sectorid == 3)
	{
		memcpy(str, "3",1);
	}
	else if (sectorid == 4)
	{
		memcpy(str, "all",3);
	}
	else
	{
		ret = -1;
	}
	return ret ;
}
int wid_set_radio_sector_tx_power_value(unsigned int wtpid,	unsigned int l_radioid,unsigned short sectorid,unsigned int value)
{
	int j = 0;
	int send_flag = 0;
	char* Sector = NULL;
	Sector = (char*)malloc(3+1);
	memset(Sector,0,3+1);
	radio_sectorid_parse_func(sectorid,Sector);
	char apcmd[WID_SYSTEM_CMD_LENTH];
	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);

	//if((sectorid == 0x1) || (sectorid == 0x2)||(sectorid == 0x4) || (sectorid == 0x8)||(sectorid == 0xF))
	if(sectorid<=4)
	{		
		if(sectorid == 4){
			for(j=0;j<SECTOR_NUM;j++){
				if((AC_WTP[wtpid]->WTP_Radio[l_radioid]->sector[j]->state == 1)&&(AC_WTP[wtpid]->WTP_Radio[l_radioid]->sector[j]->tx_power != value)){
						AC_WTP[wtpid]->WTP_Radio[l_radioid]->sector[j]->tx_power = value;
						send_flag = 1;
				}
			}
		}else if(sectorid<4){
			if((AC_WTP[wtpid]->WTP_Radio[l_radioid]->sector[sectorid]->state == 1)&&(AC_WTP[wtpid]->WTP_Radio[l_radioid]->sector[sectorid]->tx_power != value)){
				AC_WTP[wtpid]->WTP_Radio[l_radioid]->sector[sectorid]->tx_power = value;
				send_flag = 1;
			}
		}

		if(send_flag == 1){
			sprintf(apcmd,"set power %s %d",Sector,value);
			wid_radio_set_extension_command(wtpid,apcmd);

			printf("wid_set_sector apcmd %s\n",apcmd);
			wid_syslog_debug_debug(WID_DEFAULT,"wid_set_sector apcmd %s\n",apcmd);
		}
	}
	else
	{
		wid_syslog_info("wid_set_sector error\n");
	}

	if(Sector){
		free(Sector);
		Sector = NULL;
	}
	return 0;
}

int wid_set_radio_netgear_supper_g_technology_state(unsigned int wtpid,	unsigned int l_radioid,unsigned short supper_g_type,unsigned int supper_g_state)
{
	int ret = 0;
	
	char apcmd[WID_SYSTEM_CMD_LENTH];
	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);
	if(supper_g_state == 1){
		if(supper_g_type == 1)
		{		
			sprintf(apcmd,"set bursting enable");
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->supper_g.supper_g_type |= 0x1;
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->supper_g.supper_g_state = 1;
		}
		else if(supper_g_type == 2)
		{		
			sprintf(apcmd,"set fastFrame enable");
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->supper_g.supper_g_type |= 0x2;
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->supper_g.supper_g_state = 1;
		}
		else if(supper_g_type == 3)
		{		
			sprintf(apcmd,"set compression enable ");
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->supper_g.supper_g_type |= 0x4;
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->supper_g.supper_g_state = 1;
		}
	}
	else if(supper_g_state == 0){
		if(supper_g_type == 1)
		{		
			sprintf(apcmd,"set bursting disable");
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->supper_g.supper_g_type &= ~0x1;
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->supper_g.supper_g_state = 0;
		}
		else if(supper_g_type == 2)
		{		
			sprintf(apcmd,"set fastFrame disable");
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->supper_g.supper_g_type &= ~0x2;
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->supper_g.supper_g_state = 0;
		}
		else if(supper_g_type == 3)
		{		
			sprintf(apcmd,"set compression disable ");
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->supper_g.supper_g_type &= ~0x4;
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->supper_g.supper_g_state = 0;
		}

	}
	else
	{
		wid_syslog_info("set (bursting|fastFrame|compression) (enable|disable) error\n");
	}
	
	printf("set (bursting|fastFrame|compression) (enable|disable) apcmd %s\n",apcmd);
	wid_syslog_debug_debug(WID_DEFAULT,"set (bursting|fastFrame|compression) (enable|disable) apcmd %s\n",apcmd);
	ret = wid_radio_set_extension_command(wtpid,apcmd);
	return ret;
}
int wid_set_dhcp_before_autherized(unsigned int wtpid,	unsigned int l_radioid,unsigned char wlanid,
					unsigned int value)
{
	int IGNORE_UBSV ret = 0;
	
	char apcmd[WID_SYSTEM_CMD_LENTH];
	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);

	if((value == 0) || (value == 1))
	{		
		sprintf(apcmd,"/usr/sbin/set_dhcp ath.%d-%d %d",l_radioid,wlanid,value);
	}
	else
	{
		wid_syslog_info("wid_set_dhcp_before_autherized error\n");
	}
	printf("wid_set_dhcp_before_autherized apcmd %s\n",apcmd);
	wid_syslog_debug_debug(WID_DEFAULT,"wid_set_dhcp_before_autherized apcmd %s\n",apcmd);

	ret = wid_radio_set_extension_command(wtpid,apcmd);
	return 0;
}

int wid_set_sta_vlan_id(unsigned int wtpid,	unsigned int l_radioid,unsigned char wlanid,
					unsigned char *mac,unsigned int value)
{
	int IGNORE_UBSV ret = 0;
	
	char apcmd[WID_SYSTEM_CMD_LENTH];
	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);

	if((value >= 0) && (value <= 4095))
	{		
		sprintf(apcmd,"/usr/sbin/set_mac_vlan ath.%d-%d %02X:%02X:%02X:%02X:%02X:%02X %d",l_radioid,wlanid,mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],value);
	}
	else
	{
		wid_syslog_info("wid_set_sta_vlan_id error\n");
	}
	printf("wid_set_sta_vlan_id apcmd %s\n",apcmd);
	wid_syslog_debug_debug(WID_DEFAULT,"wid_set_sta_vlan_id apcmd %s\n",apcmd);

	ret = wid_radio_set_extension_command(wtpid,apcmd);
	return 0;
}

void update_next_wtp()
{
	//printf("update_next_wtp %d\n",checkwtpcount);
	int i = 0, j = 0, result = 0;
	CWBool bMatchCode = CW_FALSE;
	CWBool bMatchVersion = CW_FALSE;
	
	if(checkwtpcount < WTP_NUM)
	{
		checkwtpcount++;
	}
	//printf("update_next_wtp %d\n",checkwtpcount);
	for(i = checkwtpcount; i < WTP_NUM; i++)
	{
		for(j = 0; j < BATCH_UPGRADE_AP_NUM; j++)
		{
			if((AC_WTP[i] != NULL)&&(AC_WTP[i]->WTPStat == WID_RUN)&&(AC_WTP[i]->updateversion == NULL))//run state
			{
				if((gConfigVersionUpdateInfo[j] != NULL)
				    &&(strcmp(AC_WTP[i]->WTPModel,gConfigVersionUpdateInfo[j]->str_ap_model) == 0))
				{
					CWConfigVersionInfo *tmpnode = gConfigVersionUpdateInfo[j];
					while(tmpnode != NULL)
					{
						wid_syslog_debug_debug(WID_WTPINFO,"%s, wtp%d code %s update node code %s\n",
									            __func__, i, AC_WTP[i]->APCode, tmpnode->str_ap_code);
								            
						if(strcmp(tmpnode->str_ap_code,AC_WTP[i]->APCode) == 0)
						{
						    bMatchCode = CW_TRUE;
                            wid_syslog_debug_debug(WID_WTPINFO,"%s, wtp%d bMatchCode successfully\n", __func__, i);

							if((AC_WTP[i]->codever == NULL)&&(strcmp(AC_WTP[i]->ver,tmpnode->str_ap_version_name) == 0))				
							{
								wid_syslog_debug_debug(WID_WTPINFO,"%s, wtp%d ver %s update node version %s\n",
														__func__, i, AC_WTP[i]->ver, tmpnode->str_ap_version_name);
								bMatchVersion = CW_TRUE;
							}
							else if((AC_WTP[i]->codever != NULL)&&(strcmp(tmpnode->str_ap_version_name,AC_WTP[i]->codever) == 0))
							{								
								wid_syslog_debug_debug(WID_WTPINFO,"%s, wtp%d codever %s update node version %s\n",
														__func__, i, AC_WTP[i]->codever, tmpnode->str_ap_version_name);
								bMatchVersion = CW_TRUE;
							}
							break;
						}
						tmpnode = tmpnode->next;
					}

					if((CW_TRUE == bMatchCode) && (CW_FALSE == bMatchVersion))
					{
                        wid_syslog_info("%s, wtp%d bMatchCode TRUE MatchVersion FALSE\n", __func__, i);

						insert_wtp_list(i);
						wid_set_ap_reboot(i);
						AC_WTP[i]->updateStat = 0;
						AC_WTP[i]->updatefailcount = 0;
						time(&AC_WTP[i]->manual_update_time);
						if(updatewtplist->count >= gupdateCountOneTime)
						{
							checkwtpcount = i;
							result = 1;
						}
					}
					break;
				}
			}
		}
		checkwtpcount = i;
		if(result == 1)
		{
			break;
		}
	}
}

void update_current_wtp()
{
	//printf("update_current_wtp %d\n",checkwtpcount);
	int i = 0, j = 0, result = 0;
	CWBool bMatchCode = CW_FALSE;
	CWBool bMatchVersion = CW_FALSE;
	
	for(i = 0; i < WTP_NUM; i++)
	{
		for(j = 0; j < BATCH_UPGRADE_AP_NUM; j++)
		{
			if((AC_WTP[i] != NULL)&&(AC_WTP[i]->WTPStat == WID_RUN)&&(AC_WTP[i]->updateversion == NULL))//run state
			{
				if((gConfigVersionUpdateInfo[j] != NULL)
					&&(strcmp(AC_WTP[i]->WTPModel,gConfigVersionUpdateInfo[j]->str_ap_model) == 0))
				{
					CWConfigVersionInfo *tmpnode = gConfigVersionUpdateInfo[j];
					while(tmpnode != NULL)
					{
						wid_syslog_debug_debug(WID_WTPINFO,"%s, wtp%d code %s update node code %s\n",
															__func__, i, AC_WTP[i]->APCode, tmpnode->str_ap_code);
						
						if(strcmp(tmpnode->str_ap_code,AC_WTP[i]->APCode) == 0)
						{
						    bMatchCode = CW_TRUE;
                            wid_syslog_debug_debug(WID_WTPINFO,"%s, wtp%d bMatchCode successfully\n", __func__, i);
                            
							if((AC_WTP[i]->codever == NULL)&&(strcmp(AC_WTP[i]->ver,tmpnode->str_ap_version_name) == 0))				
							{
								wid_syslog_debug_debug(WID_WTPINFO,"%s, wtp%d ver %s update node version %s\n",
																	__func__, i, AC_WTP[i]->ver, tmpnode->str_ap_version_name);
								bMatchVersion = CW_TRUE;
							}
							else if((AC_WTP[i]->codever != NULL)&&(strcmp(tmpnode->str_ap_version_name,AC_WTP[i]->codever) == 0))
							{
								wid_syslog_debug_debug(WID_WTPINFO,"%s, wtp%d codever %s update node version %s\n",
																	__func__, i, AC_WTP[i]->codever, tmpnode->str_ap_version_name);
								bMatchVersion = CW_TRUE;
							}
							break;
						}
						tmpnode = tmpnode->next;
					}
				
					if((CW_TRUE == bMatchCode) && (CW_FALSE == bMatchVersion))
					{				
                        wid_syslog_info("%s, wtp%d bMatchCode TRUE MatchVersion FALSE\n", __func__, i);
                        
						insert_wtp_list(i);
						wid_set_ap_reboot(i);
						AC_WTP[i]->updateStat = 0;
						AC_WTP[i]->updatefailcount = 0;
						time(&AC_WTP[i]->manual_update_time);
						if(updatewtplist->count >= gupdateCountOneTime)
						{
							checkwtpcount = i;
							result = 1;
						}
					}
					break;
				}
			}
		}
		checkwtpcount = i;
		if(result == 1)
		{
            wid_syslog_info("%s, checkwtpcount %d, result = %d\n",__func__,checkwtpcount,result);
			break;
		}
	}	
}


CWBool insert_wtp_list(int id)
{
	//printf("insert_wtp_list\n");
	struct tag_wtpid *wtp_id = NULL;
	struct tag_wtpid *wtp_id_next = NULL;
	
	wtp_id = (struct tag_wtpid*)malloc(sizeof(struct tag_wtpid));	
	wtp_id->wtpid = id;
	wtp_id->next = NULL;
	//printf("*** insert_wtp_list is %d*\n", wtp_id->wtpid);
	
	if(updatewtplist == NULL)
	{
		updatewtplist = (struct tag_wtpid_list*)malloc(sizeof(struct tag_wtpid_list));
		updatewtplist->wtpidlist = wtp_id ;		
		updatewtplist->count = 1;
		//printf("*** wtp id:%d insert first  \n",id);
	}
	else
	{
		wtp_id_next = updatewtplist->wtpidlist;
		while(wtp_id_next->next != NULL)
		{	
			wtp_id_next = wtp_id_next->next;//insert element int tail
		}
		
		wtp_id_next->next = wtp_id;
		updatewtplist->count++;
		
		//printf("*** wtp id:%d insert more  \n",id);
	}
	return CW_TRUE;

}
CWBool delete_wtp_list(int id)
{
	//printf("delete_wtp_list\n");
	if(updatewtplist == NULL)
	{
		return CW_FALSE;
	}

	struct tag_wtpid *wtp_id = NULL;
	struct tag_wtpid *wtp_id_next = NULL;

	wtp_id = updatewtplist->wtpidlist;
	wtp_id_next = updatewtplist->wtpidlist;

	if(updatewtplist->count == 0)
	{
		return CW_FALSE;
	}
	else if(wtp_id_next->wtpid == id)
	{

		updatewtplist->wtpidlist = wtp_id_next->next;
		free(wtp_id_next);
		wtp_id_next = NULL;
		
		updatewtplist->count--;
		
		if(updatewtplist->wtpidlist == NULL)
		{
			free(updatewtplist);
			updatewtplist = NULL;
		}
		return CW_TRUE;
	}
	else
	{
		while(wtp_id_next->next != NULL)
		{	
			if(wtp_id_next->next->wtpid== id)
			{

				wtp_id = wtp_id_next->next;
				wtp_id_next->next = wtp_id_next->next->next;
				free(wtp_id);
				wtp_id = NULL;
				updatewtplist->count--;
				return CW_TRUE;
			}
			wtp_id_next = wtp_id_next->next;
		}
	}

	return CW_FALSE;

}
CWBool find_in_wtp_list(int id)
{
	//printf("find_in_wtp_list\n");
	if (updatewtplist == NULL)
	{
		return CW_FALSE;
	}
	
	struct tag_wtpid *wtp_id_next = NULL;
	
	wtp_id_next = updatewtplist->wtpidlist;
	while (wtp_id_next != NULL)
	{	
		if (wtp_id_next->wtpid == id)
		{
			return CW_TRUE;
		}
		wtp_id_next = wtp_id_next->next;
	}

	return CW_FALSE;
}

void destroy_wtp_list()
{
	if (updatewtplist == NULL)
	{
		return;
	}

	struct tag_wtpid *phead = NULL;
	struct tag_wtpid *pnext = NULL;
	phead = updatewtplist->wtpidlist;
	
	free(updatewtplist);
	updatewtplist = NULL;
	
	while (phead != NULL)
	{	
		pnext = phead->next;
	
		CW_FREE_OBJECT(phead);

		phead = pnext;
	}	
}

/*mahz add for ap upgrade automatically*/
int WIDCheckFreeMem(unsigned int fileLen, char *filePath)
{
    FILE *fp = NULL;
    char buf[1024] = {0};
    unsigned int freeMem = 0;
    unsigned int minMem = 0;
    wid_syslog_debug_debug(WID_DEFAULT, "filepath = %s\n",(char*)filePath);
    if(0 == memcmp(filePath, "/blk", 4)){
        system("sudo mount /blk");
        fp = popen("df -l /blk |grep blk |awk '{ print $4 }'","r");
        minMem = CFDISK_MIN_MEM;
    }
    else{
        fp = popen("free | grep + | awk '{ print $4 }'","r");
        minMem = SYSTEM_MIN_MEM;
    }
    if(!fp){
        wid_syslog_err("failed to get memery information\n");
        return -1;
    }
    
    if (fread(buf, sizeof(char), sizeof(buf), fp) == 0)
    {
        wid_syslog_err("%s read fail %s\n", __func__, strerror(errno));
		pclose(fp);
		
        return -1;
	}
    pclose(fp);

    if(-1 == parse_int_ID((char*)buf, &freeMem)){
        wid_syslog_err("Error : get free memery failed.\n");
    }
    wid_syslog_debug_debug(WID_DEFAULT, "freemem = %d, minMem = %d, filelen = %d\n",freeMem,minMem,fileLen/1000);
    if(freeMem > (minMem + (fileLen/1000)))
        return 0;
    else
        return -1;
}

unsigned int getfilesize(char *file_path){
    unsigned int file_len = 0;
    FILE *fp = NULL;
    
	fp = fopen(file_path, "rb");
    if(!fp){
        wid_syslog_err("failed to open file %s\n",file_path);
    	wid_syslog_debug_debug(WID_DBUS, "open file %s to read failed\n", file_path);
	    return -1;
    }
	fseek(fp, 0, SEEK_END);
    file_len = ftell(fp);
    fseek(fp, 0, SEEK_SET);

    fclose(fp);
	fp = NULL;
	
	return file_len;
}

int create_ac_ip_list_group(unsigned char ID,char *IFNAME){
	int ret = 0;
	int i;
	for(i = 1; i < ACIPLIST_NUM; i++){
		if((AC_IP_GROUP[i] != NULL)&&(strcmp((char*)AC_IP_GROUP[i]->ifname,IFNAME) == 0)){
			return AC_IP_BIND_IF_EXIST;
		}
	}
	ret = Check_And_Bind_Interface_For_WID(IFNAME);
	if(ret != 0)
		return ret;
	AC_IP_GROUP[ID] = (wid_ac_ip_group*)malloc(sizeof(wid_ac_ip_group));
	memset(AC_IP_GROUP[ID], 0, sizeof(wid_ac_ip_group));
	AC_IP_GROUP[ID]->GroupID = ID;
	AC_IP_GROUP[ID]->load_banlance = 0;
	AC_IP_GROUP[ID]->diff_count = 0;
	AC_IP_GROUP[ID]->ifname = (unsigned char*)malloc(strlen(IFNAME)+1);
	memset(AC_IP_GROUP[ID]->ifname, 0, strlen(IFNAME)+1);
	memcpy(AC_IP_GROUP[ID]->ifname, IFNAME, strlen(IFNAME));

	AC_IP_GROUP[ID]->isock = init_client_socket();
	
	if(get_ipv4addr_by_ifname(ID) == INTERFACE_HAVE_NO_IP_ADDR){	//xiaodawei add, 20110324
		if(AC_IP_GROUP[ID]->ifname){
			free(AC_IP_GROUP[ID]->ifname);
			AC_IP_GROUP[ID]->ifname = NULL;
		}
		if(AC_IP_GROUP[ID]){
			free(AC_IP_GROUP[ID]);
			AC_IP_GROUP[ID] = NULL;
		}
		return INTERFACE_HAVE_NO_IP_ADDR;
	}
	
	return ret;
}

int delete_ac_ip_list_group(unsigned char ID){
	int ret = 0;
	struct wid_ac_ip *tmp;
	struct wid_ac_ip *tmp1;
	if(AC_IP_GROUP[ID] == NULL)
		return ret;
	tmp = AC_IP_GROUP[ID]->ip_list;	
	AC_IP_GROUP[ID]->ipnum = 0;
	while(tmp != NULL){
		tmp1 = tmp->next;
		free(tmp->ip);
		tmp->ip = NULL;
		free(tmp);
		tmp = NULL;
		tmp = tmp1;
	}
	AC_IP_GROUP[ID]->ip_list = NULL;
	free(AC_IP_GROUP[ID]->ifname);
	AC_IP_GROUP[ID]->ifname = NULL;
	free(AC_IP_GROUP[ID]->ipaddr);
	AC_IP_GROUP[ID]->ipaddr = NULL;
	close(AC_IP_GROUP[ID]->isock);
	free(AC_IP_GROUP[ID]);
	AC_IP_GROUP[ID] = NULL;
	return ret;
}

int add_ac_ip(unsigned char ID, char * ip, unsigned char priority){
	struct wid_ac_ip *tmp = NULL;
	struct wid_ac_ip *tmp1 = NULL;
	printf("1\n");
	if(AC_IP_GROUP[ID] == NULL)
		return WLAN_ID_NOT_EXIST;
	printf("2\n");
	if(AC_IP_GROUP[ID]->ip_list == NULL){
		printf("3\n");
		tmp = (struct wid_ac_ip *)malloc(sizeof(struct wid_ac_ip));
		memset(tmp, 0, sizeof(struct wid_ac_ip));
		tmp->priority = priority;
		tmp->ip = malloc(strlen(ip)+1);
		tmp->wtpcount = 0;
		tmp->threshold = 0;
		memset(tmp->ip, 0, strlen(ip)+1);
		memcpy(tmp->ip, ip, strlen(ip));
		tmp->next = NULL;
		AC_IP_GROUP[ID]->ip_list = tmp;
		AC_IP_GROUP[ID]->ipnum += 1;
		return WID_DBUS_SUCCESS;
	}else{
		printf("4\n");
		tmp1 = AC_IP_GROUP[ID]->ip_list;
		while(tmp1 != NULL){
			if((strcmp(tmp1->ip, ip)==0)){
				return AC_IP_EXIST;
			}
			tmp1 = tmp1->next;
		}		
		tmp1 = AC_IP_GROUP[ID]->ip_list;
		if((tmp1->priority < priority)){
			printf("5\n");
			tmp = (struct wid_ac_ip *)malloc(sizeof(struct wid_ac_ip));
			memset(tmp, 0, sizeof(struct wid_ac_ip));
			tmp->priority = priority;
			tmp->wtpcount = 0;
			tmp->threshold = 0;
			tmp->ip = malloc(strlen(ip)+1);
			memset(tmp->ip, 0, strlen(ip)+1);
			memcpy(tmp->ip, ip, strlen(ip));
			tmp->next = NULL;
			tmp->next = AC_IP_GROUP[ID]->ip_list;
			AC_IP_GROUP[ID]->ip_list = tmp;			
			AC_IP_GROUP[ID]->ipnum += 1;
			return WID_DBUS_SUCCESS;
		}
		while(tmp1->next != NULL){
			printf("6\n");
			if((tmp1->next->priority < priority)){
				printf("8\n");
				tmp = (struct wid_ac_ip *)malloc(sizeof(struct wid_ac_ip));
				memset(tmp, 0, sizeof(struct wid_ac_ip));
				tmp->priority = priority;
				tmp->wtpcount = 0;
				tmp->threshold = 0;
				tmp->ip = malloc(strlen(ip)+1);
				memset(tmp->ip, 0, strlen(ip)+1);
				memcpy(tmp->ip, ip, strlen(ip));
				tmp->next = NULL;
				tmp->next = tmp1->next;
				tmp1->next = tmp;				
				AC_IP_GROUP[ID]->ipnum += 1;
				return WID_DBUS_SUCCESS;				
			}
			tmp1 = tmp1->next;
			tmp = NULL;
		}
		printf("9\n");
		tmp = (struct wid_ac_ip *)malloc(sizeof(struct wid_ac_ip));
		memset(tmp, 0, sizeof(struct wid_ac_ip));
		tmp->priority = priority;
		tmp->wtpcount = 0;
		tmp->threshold = 0;
		tmp->ip = malloc(strlen(ip)+1);
		memset(tmp->ip, 0, strlen(ip)+1);
		memcpy(tmp->ip, ip, strlen(ip));
		tmp->next = NULL;
		tmp1->next = tmp;				
		AC_IP_GROUP[ID]->ipnum += 1;
		return WID_DBUS_SUCCESS;				
		
	}
	printf("10\n");
	
	return WID_DBUS_SUCCESS;
}

int delete_ac_ip(unsigned char ID,char *ip){
	int ret = 0;	
	struct wid_ac_ip *tmp;
	struct wid_ac_ip *tmp1;
	
	if(AC_IP_GROUP[ID] == NULL)
		return WLAN_ID_NOT_EXIST;
	if(AC_IP_GROUP[ID]->ip_list == NULL){
		return AC_IP_NOT_EXIST;
	}

	tmp = AC_IP_GROUP[ID]->ip_list;
	if(strcmp(tmp->ip,ip)==0){
		AC_IP_GROUP[ID]->ip_list = tmp->next;
		tmp->next = NULL;
		free(tmp->ip);
		tmp->ip = NULL;
		free(tmp);
		tmp = NULL;
		AC_IP_GROUP[ID]->ipnum -= 1;
		return ret;
	}
	while(tmp->next != NULL){
		tmp1 = tmp->next;
		if(strcmp(tmp1->ip,ip)==0){
			tmp->next = tmp1->next;
			tmp1->next = NULL;
			free(tmp1->ip);
			tmp1->ip = NULL;
			free(tmp1);
			tmp1 = NULL;			
			AC_IP_GROUP[ID]->ipnum -= 1;
			return ret;
		}
		tmp = tmp1;
	}
	return AC_IP_NOT_EXIST;
}

int set_ac_ip_priority(unsigned char ID, char * ip, unsigned char priority){
	struct wid_ac_ip *tmp;
	struct wid_ac_ip *tmp1;
	struct wid_ac_ip *node = NULL;
	printf("1\n");
	if(AC_IP_GROUP[ID] == NULL)
		return WLAN_ID_NOT_EXIST;
	
	if(AC_IP_GROUP[ID]->ip_list == NULL){
		return AC_IP_NOT_EXIST;
	}

	tmp = AC_IP_GROUP[ID]->ip_list;
	if(strcmp(tmp->ip,ip)==0){
		if(tmp->priority == priority)
			return WID_DBUS_SUCCESS;
		AC_IP_GROUP[ID]->ip_list = tmp->next;
		tmp->next = NULL;
		node = tmp;
		node->priority = priority;
	}else{
		while(tmp->next != NULL){
			tmp1 = tmp->next;
			if(strcmp(tmp1->ip,ip)==0){				
				if(tmp1->priority == priority)
					return WID_DBUS_SUCCESS;
				tmp->next = tmp1->next;
				tmp1->next = NULL;
				node = tmp1;
				node->priority = priority;
				break;
			}
			tmp = tmp1;
		}
	}
	if(node == NULL){
		return AC_IP_NOT_EXIST;
	}
	printf("2\n");
	if(AC_IP_GROUP[ID]->ip_list == NULL){
		printf("3\n");
		AC_IP_GROUP[ID]->ip_list = node;
		return WID_DBUS_SUCCESS;
	}else{
		printf("4\n");
		tmp1 = AC_IP_GROUP[ID]->ip_list;
		while(tmp1 != NULL){
			if((strcmp(tmp1->ip, ip)==0)){
				return AC_IP_EXIST;
			}
			tmp1 = tmp1->next;
		}		
		tmp1 = AC_IP_GROUP[ID]->ip_list;
		if((tmp1->priority < priority)){
			printf("5\n");
			node->next = AC_IP_GROUP[ID]->ip_list;
			AC_IP_GROUP[ID]->ip_list = node;			
			return WID_DBUS_SUCCESS;
		}
		while(tmp1->next != NULL){
			printf("6\n");
			if((tmp1->next->priority < priority)){
				printf("8\n");
				node->next = tmp1->next;
				tmp1->next = node;				
				return WID_DBUS_SUCCESS;				
			}
			tmp1 = tmp1->next;
			tmp = NULL;
		}
		printf("9\n");
		tmp1->next = node;				
		return WID_DBUS_SUCCESS;				
		
	}
	printf("10\n");
	
	return WID_DBUS_SUCCESS;
}

int set_ac_ip_load_banlance(unsigned char ID, unsigned char load_banlance)
{
	if(AC_IP_GROUP[ID] == NULL)
	{
		return WLAN_ID_NOT_EXIST;
	}

	if(AC_IP_GROUP[ID]->load_banlance == load_banlance)
	{
		return WID_DBUS_SUCCESS;
	}

	CWThread loadbanlancethread;
	
	if(load_banlance == 1)
	{
		//create socket listen interface
		if(havecreatethread == 0)
		{
			if(!CWErr(CWCreateThread(&loadbanlancethread, CWLoadbanlanceThread, &ID,0)))
			{
				wid_syslog_crit("Error starting loadbanlancethread Thread");
				return WID_DBUS_ERROR;
			}
			havecreatethread = 1;
		}
		
		gloadbanlance++;
		//just test 
		
	}
	else if(load_banlance == 0)
	{
		//destroy socket listen interface
		gloadbanlance--;
		make_link_sequence_by_priority(ID);
	}


	AC_IP_GROUP[ID]->load_banlance = load_banlance;

	//printf("send count 7\n");
	//test
	//SendActiveWTPCount(7);
	//make_link_sequence_by_wtpcount(ID);
	
	return WID_DBUS_SUCCESS;
}
int  set_ac_ip_diff_banlance(unsigned char ID, unsigned int diff_banlance)
{
	if(AC_IP_GROUP[ID] == NULL)
	{
		return WLAN_ID_NOT_EXIST;
	}

	if(AC_IP_GROUP[ID]->diff_count == diff_banlance)
	{
		return WID_DBUS_SUCCESS;
	}


	AC_IP_GROUP[ID]->diff_count = diff_banlance;
	
	return WID_DBUS_SUCCESS;
}
int set_ac_ip_diffcount(unsigned char ID, char * ip, unsigned int diffcount){
	struct wid_ac_ip *tmp;
	struct wid_ac_ip *tmp1;
	if(AC_IP_GROUP[ID] == NULL)
		return WLAN_ID_NOT_EXIST;
	
	if(AC_IP_GROUP[ID]->ip_list == NULL){
		return AC_IP_NOT_EXIST;
	}

	tmp = AC_IP_GROUP[ID]->ip_list;
	
	if(strcmp(tmp->ip,ip)==0)
	{
		tmp->threshold = diffcount;
		return WID_DBUS_SUCCESS;
	}
	else
	{
		while(tmp->next != NULL)
		{
			tmp1 = tmp->next;
			if(strcmp(tmp1->ip,ip)==0)
			{				
				tmp1->threshold = diffcount;
				return WID_DBUS_SUCCESS;

			}
			tmp = tmp1;
		}
	}
	
	return AC_IP_NOT_EXIST;

}


//save sample throughput info
void save_sample_throughput_info(int WTPIndex, wid_sample_rate_info sample_throughput)
{
	unsigned int uplink = 0;
	unsigned int downlink = 0;
	if(sample_throughput.current_uplink_throughput == 0)
	{
		uplink = AC_WTP[WTPIndex]->wid_sample_throughput.current_uplink_throughput;
	}
	else
	{
		uplink = sample_throughput.current_uplink_throughput - AC_WTP[WTPIndex]->wid_sample_throughput.current_uplink_throughput;
	}
	if(sample_throughput.current_downlink_throughput == 0)
	{
		downlink = AC_WTP[WTPIndex]->wid_sample_throughput.current_downlink_throughput;
	}
	else
	{
		downlink = sample_throughput.current_downlink_throughput - AC_WTP[WTPIndex]->wid_sample_throughput.current_downlink_throughput;
	}
	
	AC_WTP[WTPIndex]->wid_sample_throughput.uplink_rate = uplink;
	AC_WTP[WTPIndex]->wid_sample_throughput.downlink_rate = downlink;

	AC_WTP[WTPIndex]->wid_sample_throughput.past_uplink_throughput = AC_WTP[WTPIndex]->wid_sample_throughput.current_uplink_throughput;
	AC_WTP[WTPIndex]->wid_sample_throughput.past_downlink_throughput = AC_WTP[WTPIndex]->wid_sample_throughput.current_downlink_throughput;

	AC_WTP[WTPIndex]->wid_sample_throughput.current_uplink_throughput = sample_throughput.current_uplink_throughput;
	AC_WTP[WTPIndex]->wid_sample_throughput.current_downlink_throughput = sample_throughput.current_downlink_throughput;
}

//save extension info
CWBool CWSaveWTPExtensionInfo2(wid_wifi_info ap_wifi_info, unsigned int WTPIndex)
{
	if(AC_WTP[WTPIndex] == NULL) return CWErrorRaise(CW_ERROR_WRONG_ARG, NULL);
	int i = 0;
	AC_WTP[WTPIndex]->wifi_extension_info.cpu = ap_wifi_info.cpu;

	AC_WTP[WTPIndex]->wifi_extension_info.tx_mgmt = ap_wifi_info.tx_mgmt;
	AC_WTP[WTPIndex]->wifi_extension_info.rx_mgmt = ap_wifi_info.rx_mgmt;
	AC_WTP[WTPIndex]->wifi_extension_info.tx_packets = ap_wifi_info.tx_packets;
	AC_WTP[WTPIndex]->wifi_extension_info.tx_errors = ap_wifi_info.tx_errors;
	AC_WTP[WTPIndex]->wifi_extension_info.tx_retry = ap_wifi_info.tx_retry;

	AC_WTP[WTPIndex]->wifi_extension_info.tx_unicast = ap_wifi_info.tx_unicast;
	AC_WTP[WTPIndex]->wifi_extension_info.tx_broadcast = ap_wifi_info.tx_broadcast;
	AC_WTP[WTPIndex]->wifi_extension_info.tx_multicast = ap_wifi_info.tx_multicast;
	AC_WTP[WTPIndex]->wifi_extension_info.tx_drop = ap_wifi_info.tx_drop;
	AC_WTP[WTPIndex]->wifi_extension_info.rx_unicast = ap_wifi_info.rx_unicast;
	AC_WTP[WTPIndex]->wifi_extension_info.rx_broadcast = ap_wifi_info.rx_broadcast;
	AC_WTP[WTPIndex]->wifi_extension_info.rx_multicast = ap_wifi_info.rx_multicast;
	AC_WTP[WTPIndex]->wifi_extension_info.rx_drop = ap_wifi_info.rx_drop;

	/* zhangshu add for save, 2010-09-25 */
	AC_WTP[WTPIndex]->wifi_extension_info.wpi_replay_error = ap_wifi_info.wpi_replay_error;
	AC_WTP[WTPIndex]->wifi_extension_info.wpi_decryptable_error = ap_wifi_info.wpi_decryptable_error;
	AC_WTP[WTPIndex]->wifi_extension_info.wpi_mic_error = ap_wifi_info.wpi_mic_error;
	AC_WTP[WTPIndex]->wifi_extension_info.disassoc_unnormal = ap_wifi_info.disassoc_unnormal;
	AC_WTP[WTPIndex]->wifi_extension_info.rx_assoc_norate = ap_wifi_info.rx_assoc_norate;
	AC_WTP[WTPIndex]->wifi_extension_info.rx_assoc_capmismatch = ap_wifi_info.rx_assoc_capmismatch;
	AC_WTP[WTPIndex]->wifi_extension_info.assoc_invaild = ap_wifi_info.assoc_invaild;
	AC_WTP[WTPIndex]->wifi_extension_info.reassoc_deny = ap_wifi_info.reassoc_deny;
	
	AC_WTP[WTPIndex]->wifi_extension_info.ipmode = ap_wifi_info.ipmode;
	AC_WTP[WTPIndex]->wifi_extension_info.memoryall = ap_wifi_info.memoryall;
	AC_WTP[WTPIndex]->wifi_extension_info.memoryuse = ap_wifi_info.memoryuse;
	AC_WTP[WTPIndex]->wifi_extension_info.flashall = ap_wifi_info.flashall;
	AC_WTP[WTPIndex]->wifi_extension_info.flashempty = ap_wifi_info.flashempty;
	AC_WTP[WTPIndex]->wifi_extension_info.wifi_snr = ap_wifi_info.wifi_snr;
	AC_WTP[WTPIndex]->wifi_extension_info.eth_count = ap_wifi_info.eth_count;
	if(ap_wifi_info.ath_count <= AP_ATH_IF_NUM)
		AC_WTP[WTPIndex]->wifi_extension_info.ath_count = ap_wifi_info.ath_count;
	else{	
		wid_syslog_debug_debug(WID_DBUS,"%s something wrong ap_wifi_info.ath_count %d\n",ap_wifi_info.ath_count);
		AC_WTP[WTPIndex]->wifi_extension_info.ath_count = 1;
	}
	AC_WTP[WTPIndex]->wifi_extension_info.temperature = ap_wifi_info.temperature;
	AC_WTP[WTPIndex]->wifi_extension_info.wifi_count = ap_wifi_info.wifi_count;
		

	for(i=0;i<AP_ETH_IF_NUM;i++)
	{
		
		AC_WTP[WTPIndex]->wifi_extension_info.eth_updown_time[i] = ap_wifi_info.eth_updown_time[i];
	}
	for(i=0;i<AP_WIFI_IF_NUM;i++)
	{
		
		AC_WTP[WTPIndex]->wifi_extension_info.wifi_state[i] = ap_wifi_info.wifi_state[i];
	}
	for(i=0;i<AC_WTP[WTPIndex]->wifi_extension_info.ath_count;i++)
	{
		
		AC_WTP[WTPIndex]->wifi_extension_info.ath_if_info[i].radioid = ap_wifi_info.ath_if_info[i].radioid;
		AC_WTP[WTPIndex]->wifi_extension_info.ath_if_info[i].wlanid = ap_wifi_info.ath_if_info[i].wlanid;
		AC_WTP[WTPIndex]->wifi_extension_info.ath_if_info[i].ath_updown_times = ap_wifi_info.ath_if_info[i].ath_updown_times;
	}
	/*fengwenchao add 20120314 for onlinebug-162*///qiuchen copy from v1.3
	for(i =0;i < AC_WTP[WTPIndex]->wifi_extension_info.wifi_count;i++)
	{
		AC_WTP[WTPIndex]->wifi_extension_info.wifi_snr_new[i] = ap_wifi_info.wifi_snr_new[i];
		AC_WTP[WTPIndex]->wifi_extension_info.wifi_noise_new[i] = ap_wifi_info.wifi_noise_new[i];
	}
	/*fengwenchao add end*/
	return CW_TRUE;
}

void save_extension_info(int WTPIndex, wid_wifi_info ap_wifi_info)
{
	CWSaveWTPExtensionInfo2(ap_wifi_info,WTPIndex);	
	AsdWsm_WTPOp(WTPIndex, WID_WIFI_INFO);
	wid_parse_wtp_cpu_mem_trap_info(WTPIndex);
}

int wid_radio_set_ip_gateway(int wtpid,unsigned int ip,unsigned int gateway,unsigned char mask)
{
	msgq msg;
	AC_WTP[wtpid]->ap_ipadd = ip;
	AC_WTP[wtpid]->ap_gateway = gateway;
	AC_WTP[wtpid]->resetflag = 1;
	AC_WTP[wtpid]->ap_mask = mask;
	
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPStat == WID_RUN))
	{
		AC_WTP[wtpid]->WTP_Radio[0]->CMD |= 0x1000;
		AC_WTP[wtpid]->CMD->radioid[0] += 1;
		AC_WTP[wtpid]->CMD->setCMD = 1;	
		int WTPIndex = wtpid;
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_SET_IP;
			
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
				perror("msgsnd");
			}
		}		
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}
	
	if(gtrapflag >= 4)
	{
#if NOSOFTAC
		wid_dbus_trap_wtp_ip_change_alarm(wtpid);
#endif
	}

	return 0;
}

int wid_radio_set_ip_gateway_dns
(
    int wtpid,
    unsigned int ip,
    unsigned int gateway,
    unsigned int mask,
    unsigned int fstdns,
    unsigned int snddns
)
{
	msgq msg;
	
	AC_WTP[wtpid]->ap_ipadd = ip;
	AC_WTP[wtpid]->ap_gateway = gateway;
	AC_WTP[wtpid]->resetflag = 1;
	AC_WTP[wtpid]->ap_mask_new = mask;
	AC_WTP[wtpid]->ap_dnsfirst = fstdns;
	AC_WTP[wtpid]->ap_dnssecend = snddns;
	
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPStat == WID_RUN))
	{
		AC_WTP[wtpid]->WTP_Radio[0]->CMD |= 0x1000;
		AC_WTP[wtpid]->CMD->radioid[0] += 1;
		AC_WTP[wtpid]->CMD->setCMD = 1;	
		int WTPIndex = wtpid;
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_SET_IP_DNS;
			
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
				perror("msgsnd");
			}

		}		
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}
	
	if(gtrapflag >= 4)
	{
#if NOSOFTAC
		wid_dbus_trap_wtp_ip_change_alarm(wtpid);
#endif
	}

	return 0;
}

int wid_set_ap_hotreboot(int hotreboot)
{
	int i = 0;
	char command[DEFAULT_LEN] = {0};
	memset(command,0,DEFAULT_LEN);
	sprintf(command,"/usr/sbin/set_ap_reboot_flag %d",hotreboot);
	
	wid_syslog_debug_debug(WID_DEFAULT,"command %s\n",command);
	
	for(i=0; i<WTP_NUM; i++)
	{
		if((AC_WTP[i] != NULL)&&(AC_WTP[i]->WTPStat == 5))
		{
			wid_radio_set_extension_command(i,command);
		}
	}

	return 0;

}
CWBool delete_elem_into_wids_list(wid_wids_device  *paplist,struct tag_wids_device_ele *elem)
{
	if ((elem == NULL)||((paplist) == NULL)||((paplist)->wids_device_info == NULL)||((paplist)->count == 0))
	{
		wid_syslog_debug_debug(WID_DEFAULT,"delete_elem_into_wids_list parameter error\n");
		return CW_FALSE;
	}
	
	struct tag_wids_device_ele *pnode = paplist->wids_device_info;
	struct tag_wids_device_ele *pnext = pnode->next;

	if (memcmp((pnode->bssid), elem->bssid, MAC_LEN) == 0)
	{
		CW_FREE_OBJECT(pnode);
		paplist->wids_device_info = pnext;
		paplist->count--;
			
		return CW_TRUE;
	}

	while (pnext != NULL)
	{
		if (memcmp((pnext->bssid), elem->bssid, MAC_LEN) == 0)
		{
			pnode->next = pnext->next;
			
			CW_FREE_OBJECT(pnext);
			paplist->count--;
			
			return CW_TRUE;
		}	

		pnode = pnode->next;
		pnext = pnext->next;
	}

	return CW_FALSE;//insert success
}

int wid_add_del_wids_mac(unsigned char mac[],int isadd)
{
	if (wids_ignore_list == NULL)
	{
		CW_CREATE_OBJECT_ERR(wids_ignore_list, wid_wids_device, return CWErrorRaise(CW_ERROR_OUT_OF_MEMORY, NULL););	
					
		wids_ignore_list->count = 0;
		wids_ignore_list->wids_device_info = NULL;
	}

	struct tag_wids_device_ele *wids_device_ele = NULL;
	CW_CREATE_OBJECT_SIZE_ERR(wids_device_ele, sizeof(struct tag_wids_device_ele), return CWErrorRaise(CW_ERROR_OUT_OF_MEMORY, NULL););	
	memcpy(wids_device_ele->bssid, mac, MAC_LEN);
	
	int isfind = find_elem_in_wids_list(wids_ignore_list,wids_device_ele);

	if (isfind == CW_FALSE) //add element
	{
		if (isadd == CW_TRUE)
		{
			insert_elem_into_wids_list(wids_ignore_list,wids_device_ele);
		}
		else
		{
			CW_FREE_OBJECT(wids_device_ele);
		}
	}
	else 
	{
		if (isadd == CW_FALSE)
		{
			delete_elem_into_wids_list(wids_ignore_list,wids_device_ele);
			CW_FREE_OBJECT(wids_device_ele);
		}
		/* Coverity: CID: 10192  Error-Type: Resource leak */
		else /* found when add */ 
		{
			CW_FREE_OBJECT(wids_device_ele);
		}
	}

	return 0;
}

int wid_count_countermeasure_rogue_ap(Neighbor_AP_INFOS *paplist,int wtpid)
{
	unsigned int count = 0;
	unsigned int RadioID = wtpid*L_RADIO_NUM;
	unsigned short RadioTxp = 20;    //fengwenchao modify 20110505
	CWBool flag = CW_FALSE;
	//fengwenchao add 20110505
	if (AC_RADIO[RadioID]->ishighpower == 1)
	{		
		RadioTxp = 27;
	}
	//fengwenchao add end
	
	if ((paplist == NULL) || (paplist->neighborapInfos == NULL) || (paplist->neighborapInfosCount == 0))
	{
		return 0;
	}	
	struct Neighbor_AP_ELE *phead = paplist->neighborapInfos;

	while (phead != NULL)
	{
		if (phead->status == 1)
		{
			count ++;
			break;
		}

		phead = phead->next;
	}

	wid_syslog_debug_debug(WID_DEFAULT," wid_count_countermeasure_rogue_ap is %d\n",count);
	//fengwenchao add 20110325
	if (count == 0)
	{
		AC_RADIO[RadioID]->radio_countermeasures_flag = 0;  //AP
	}
	//fengwenchao add end
	//countermeasure rouge ap added by weianying 2009/12/28
	if((gapscanset.countermeasures_switch == 1)&&(count >0))
	{
		//maybe add condition like rssi strength or check count
		//if((countermeasurecount==0)||(countermeasurecount%COUNTERMEASURE_DEFAULT_COUNT == 0))
		{
			//fengwenchao modify 20110325
			if(AC_RADIO[RadioID]->radio_countermeasures_flag == 0)   
			{
				WID_RADIO_SET_TXP(RadioID, RadioTxp,flag);
				AC_RADIO[RadioID]->radio_countermeasures_flag = 1;
			}
			//fengwenchao modify end
		}
		//countermeasurecount++;
	}	

	return 1;
}

int wid_disturb_countermeasure_rogue_ap(int wtpid, int rid, int rougeop)
{
	msgq msg;
	struct msgqlist *elem = NULL;
	unsigned char localradio_id = 0;
	
	WID_CHECK_WTP_STANDARD_RET(wtpid,WTP_ID_NOT_EXIST);
	localradio_id = rid;
	
	wid_syslog_debug_debug(WID_DEFAULT,"%s: wtp%d radioid %d rougeop %d\n",
	                        __func__, wtpid, localradio_id, rougeop);
		
	if ((AC_WTP[wtpid] != NULL) && (AC_WTP[wtpid]->WTPStat == WID_RUN))
	{
		//CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));
		if (gWTPs[wtpid].isNotFree && (CW_ENTER_RUN == gWTPs[wtpid].currentState))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = wtpid%THREAD_NUM+1;
			msg.mqinfo.WTPID = wtpid;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_ROGUEAP_BLACK_LIST;
			msg.mqinfo.u.WtpInfo.i1 = rougeop;
			msg.mqinfo.u.WtpInfo.c1 = localradio_id;

			if (-1 == msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg), 0))
			{
				wid_syslog_info("%s msgsend %s", __func__, strerror(errno));
			}
		}		
		//CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));
	}
	else if (NULL != AC_WTP[wtpid])
	{		
		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if (elem == NULL)
		{
			WID_MALLOC_ERR();
			return MALLOC_ERROR;
		}
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = wtpid%THREAD_NUM+1;
		msg.mqinfo.WTPID = wtpid;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WTP_S_TYPE;
		msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_ROGUEAP_BLACK_LIST;
		msg.mqinfo.u.WtpInfo.i1 = rougeop;
		msg.mqinfo.u.WtpInfo.c1 = localradio_id;

		memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
		elem->next = NULL;
		memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
		WID_INSERT_CONTROL_LIST(wtpid, elem);		
		elem = NULL;
	}
	
	return 	0;
}


CWBool wid_check_rogue_ap_increase_state(int wtpid, int rid)
{
    struct Neighbor_AP_ELE *phead = NULL;

    WID_CHECK_WTP_STANDARD_RET(wtpid, CW_FALSE);
    WID_CHECK_L_RADIOID_STANDARD_RET(rid,CW_FALSE);

    if ((AC_WTP[wtpid]->rouge_ap_infos[rid] == NULL)||(AC_WTP[wtpid]->rouge_ap_infos[rid]->neighborapInfosCount == 0))
    {
        return CW_FALSE;
    }

    phead = AC_WTP[wtpid]->rouge_ap_infos[rid]->neighborapInfos;    
 	while (phead != NULL)
	{
        if ((0 == phead->agingstatus)||(2 == phead->agingstatus))
		{
            return 1;
		}

		phead = phead->next;
	}
		
	return 0;
}


void delsame_rogue_ap_from_list(Neighbor_AP_INFOS **paplist)
{
	struct Neighbor_AP_ELE *p = NULL;
	struct Neighbor_AP_ELE *q = NULL;
	struct Neighbor_AP_ELE *temp1 = NULL;
	struct Neighbor_AP_ELE *temp2 = NULL;

	if (((*paplist) == NULL)||((*paplist)->neighborapInfos == NULL)||((*paplist)->neighborapInfosCount == 0))
	{
		return ;
	}
	
	p = (*paplist)->neighborapInfos;
	if ((p == NULL) || (p->next == NULL))
	{
		return;
	}	
	
	while ((p != NULL) && (p->next != NULL))
	{
		temp1 = p;
		q = p->next;  
		
		while (q)
		{
			if ((0 == memcmp(p->BSSID, q->BSSID, MAC_LEN)) && (p->Channel == q->Channel))
			{
				temp2 = q;
				q = q->next;
				temp1->next = q;
				CW_FREE_OBJECT(temp2->IEs_INFO);
        		CW_FREE_OBJECT(temp2);
				(*paplist)->neighborapInfosCount--;
			}
			else
			{
				q = q->next;
				temp1 = temp1->next;
			}
		}
		p = p->next;
	}
}

/* wcl add for RDIR-33 */
int wid_radio_set_acktimeout_distance(unsigned int RadioID)
{
	msgq msg;
	struct msgqlist *elem = NULL;

	int WTPIndex = RadioID/L_RADIO_NUM;
	if ((AC_WTP[WTPIndex] != NULL)&&(AC_WTP[AC_RADIO[RadioID]->WTPID]->WTPStat == WID_RUN))
	{
		AC_RADIO[RadioID]->CMD |= 0x20;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->radioid[AC_RADIO[RadioID]->Radio_L_ID] += 1;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->setCMD = 1;	
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if (gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
		    msg.mqinfo.u.RadioInfo.Radio_Op = Radio_acktimeout_distance;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
			msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}

		}
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}
	else if ((AC_WTP[WTPIndex] != NULL))
	{
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WTPIndex%THREAD_NUM+1;
		msg.mqinfo.WTPID = WTPIndex;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = Radio_S_TYPE;
		msg.mqinfo.u.RadioInfo.Radio_Op = Radio_acktimeout_distance;
		msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
		msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
	
		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if (elem == NULL)
		{
			wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
			perror("malloc");
			return 0;
		}
		memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
		elem->next = NULL;
		memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
		WID_INSERT_CONTROL_LIST(WTPIndex, elem);
		elem = NULL;
	}
	
	return 0;
}

int wid_radio_set_guard_interval(unsigned int RadioID)
{
	msgq msg;
	//if((gWTPs[AC_RADIO[RadioID]->WTPID].currentState == CW_ENTER_RUN)&&(AC_RADIO[RadioID]->AdStat == 2))
	{
		//return RADIO_IS_DISABLE;
	}

	int WTPIndex = AC_RADIO[RadioID]->WTPID;
	wid_syslog_debug_debug(WID_DEFAULT,"set radio %d guardinterval %d", RadioID, AC_RADIO[RadioID]->guardinterval);
	
	if (AC_WTP[AC_RADIO[RadioID]->WTPID]->WTPStat == WID_RUN)
	{
		AC_RADIO[RadioID]->CMD |= 0x20;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->radioid[AC_RADIO[RadioID]->Radio_L_ID] += 1;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->setCMD = 1;	
		//int WTPIndex = AC_RADIO[RadioID]->WTPID;
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if (gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_11N_GI_MCS_CMMODE;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
			msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}

		}
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}
	else if ((AC_WTP[WTPIndex] != NULL))
	{
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WTPIndex%THREAD_NUM+1;
		msg.mqinfo.WTPID = WTPIndex;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = Radio_S_TYPE;
		msg.mqinfo.u.RadioInfo.Radio_Op = Radio_11N_GI_MCS_CMMODE;
		msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
		msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
		struct msgqlist *elem = NULL;
		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if (elem == NULL)
		{
			wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
			perror("malloc");
			return 0;
		}
		memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
		elem->next = NULL;
		memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
		WID_INSERT_CONTROL_LIST(WTPIndex, elem);
		elem = NULL;
	}

	return 0;
}

/* zhangshu add for set 11n para, 2010-10-09 */
int wid_radio_set_ampdu_able(unsigned int RadioID, unsigned char type)
{
	msgq msg;
	struct msgqlist *elem = NULL;
	//if((gWTPs[AC_RADIO[RadioID]->WTPID].currentState == CW_ENTER_RUN)&&(AC_RADIO[RadioID]->AdStat == 2))
	{
		//return RADIO_IS_DISABLE;
	}

	int WTPIndex = RadioID/L_RADIO_NUM;
	if ((AC_WTP[WTPIndex] != NULL)&&(AC_WTP[AC_RADIO[RadioID]->WTPID]->WTPStat == WID_RUN))
	{
		AC_RADIO[RadioID]->CMD |= 0x20;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->radioid[AC_RADIO[RadioID]->Radio_L_ID] += 1;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->setCMD = 1;	
		//int WTPIndex = AC_RADIO[RadioID]->WTPID;
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if (gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			if (type == 1)
			{
			    msg.mqinfo.u.RadioInfo.Radio_Op = Radio_ampdu_op;
			}
			else
			{
			    msg.mqinfo.u.RadioInfo.Radio_Op = Radio_amsdu_op;
			}
			msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
			msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}

		}
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}
	else if ((AC_WTP[WTPIndex] != NULL))
	{
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WTPIndex%THREAD_NUM+1;
		msg.mqinfo.WTPID = WTPIndex;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = Radio_S_TYPE;
		if (type == 1)
		{
		    msg.mqinfo.u.RadioInfo.Radio_Op = Radio_ampdu_op;
		}
		else
		{
		    msg.mqinfo.u.RadioInfo.Radio_Op = Radio_amsdu_op;
		}
		msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
		msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
	
		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if (elem == NULL)
		{
			wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
			perror("malloc");
			return 0;
		}
		memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
		elem->next = NULL;
		memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
		WID_INSERT_CONTROL_LIST(WTPIndex, elem);
		elem = NULL;
	}
	
	return 0;
}

int wid_radio_set_ampdu_limit(unsigned int RadioID, unsigned char type)
{
	msgq msg;
	struct msgqlist *elem = NULL;
	
	int WTPIndex = RadioID/L_RADIO_NUM;
	if (AC_WTP[AC_RADIO[RadioID]->WTPID]->WTPStat == WID_RUN)
	{
		AC_RADIO[RadioID]->CMD |= 0x20;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->radioid[AC_RADIO[RadioID]->Radio_L_ID] += 1;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->setCMD = 1;	
			//int WTPIndex = AC_RADIO[RadioID]->WTPID;
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if (gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			if (type == 1)
    		{
    		    msg.mqinfo.u.RadioInfo.Radio_Op = Radio_ampdu_op;
    		}
    		else
    		{
    		    msg.mqinfo.u.RadioInfo.Radio_Op = Radio_amsdu_op;
    		}
			msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
			msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}
	else if ((AC_WTP[WTPIndex] != NULL))
	{
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WTPIndex%THREAD_NUM+1;
		msg.mqinfo.WTPID = WTPIndex;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = Radio_S_TYPE;
		if (type == 1)
		{
		    msg.mqinfo.u.RadioInfo.Radio_Op = Radio_ampdu_op;
		}
		else
		{
		    msg.mqinfo.u.RadioInfo.Radio_Op = Radio_amsdu_op;
		}
		msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
		msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
	
		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if (elem == NULL)
		{
			wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
			perror("malloc");
			return 0;
		}
		memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
		elem->next = NULL;
		memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
		WID_INSERT_CONTROL_LIST(WTPIndex, elem);
		elem = NULL;
	}
	
	return 0;
}
//qiuchen add it
int WID_RADIO_CHANGE_SUPPORT_RATE_BYGI_MCS_CWMODE_1(unsigned int RadioID, int count)
{
	int rate =0;
	int i = 0;
	if (AC_RADIO[RadioID] != NULL)
	{
		if (((AC_RADIO[RadioID]->cwmode == 0) || (AC_RADIO[RadioID]->cwmode == 3))
			&& (AC_RADIO[RadioID]->chainmask_num == 1)
			&& ((AC_RADIO[RadioID]->guardinterval == 1) || (AC_RADIO[RadioID]->guardinterval == 0)))  //ht20   
		{
			AC_RADIO[RadioID]->Support_Rate_Count = 8;
			destroy_support_rate_list(AC_RADIO[RadioID]->Radio_Rate);
			AC_RADIO[RadioID]->Radio_Rate = create_support_rate_list(1);
				
			rate = 65;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

			rate = 130;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

			rate = 190;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

			rate = 260;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
			
			rate = 390;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

			rate = 520;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

			rate = 585;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
			
			rate = 650;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);					

			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,0);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
			for (i = 0; i < count; i++)
			{
				if (AC_RADIO[RadioID]->mcs_list[i] == 6)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,650);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
    			else if (AC_RADIO[RadioID]->mcs_list[i] == 5)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,650);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,585);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
    			else if (AC_RADIO[RadioID]->mcs_list[i] == 4)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,650);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,585);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,520);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
    			else if (AC_RADIO[RadioID]->mcs_list[i] == 3)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,650);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,585);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,520);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,390);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
    			else if (AC_RADIO[RadioID]->mcs_list[i] == 2)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,650);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,585);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,520);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,390);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,260);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
    			else if (AC_RADIO[RadioID]->mcs_list[i] == 1)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,650);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,585);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,520);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,390);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,260);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,190);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
    			else if (AC_RADIO[RadioID]->mcs_list[i] == 0)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,650);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,585);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,520);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,390);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,260);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,190);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,130);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}	
			}
		}
		else if (((AC_RADIO[RadioID]->cwmode == 0) || (AC_RADIO[RadioID]->cwmode == 3))
				&& (AC_RADIO[RadioID]->chainmask_num == 2)
				&& ((AC_RADIO[RadioID]->guardinterval == 1) || (AC_RADIO[RadioID]->guardinterval == 0)))  //ht20  
		{
			AC_RADIO[RadioID]->Support_Rate_Count = 8;
			destroy_support_rate_list(AC_RADIO[RadioID]->Radio_Rate);
			AC_RADIO[RadioID]->Radio_Rate = create_support_rate_list(1);
								
			rate = 130;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

			rate = 260;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

			rate = 390;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

			rate = 520;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
			
			rate = 780;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

			rate = 1040;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

			rate = 1170;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
			
			rate = 1300;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);					

			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,0);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
			for (i = 0; i < count; i++)
			{
				if (AC_RADIO[RadioID]->mcs_list[i] == 14)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1300);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 13)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1300);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1170);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
    			else if (AC_RADIO[RadioID]->mcs_list[i] == 12)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1300);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1170);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1040);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 11)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1300);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1170);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1040);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,780);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 10)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1300);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1170);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1040);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,780);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,520);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 9)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1300);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1170);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1040);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,780);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,520);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,390);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 8)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1300);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1170);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1040);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,780);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,520);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,390);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,260);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
			}
		}
		else if (((AC_RADIO[RadioID]->cwmode == 0) || (AC_RADIO[RadioID]->cwmode == 3))
				&& (AC_RADIO[RadioID]->chainmask_num == 3)
				&& ((AC_RADIO[RadioID]->guardinterval == 1)||(AC_RADIO[RadioID]->guardinterval == 0)))  //ht20  
		{
			AC_RADIO[RadioID]->Support_Rate_Count = 8;
			destroy_support_rate_list(AC_RADIO[RadioID]->Radio_Rate);
			AC_RADIO[RadioID]->Radio_Rate = create_support_rate_list(1);
								
			rate = 195;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

			rate = 390;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

			rate = 585;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

			rate = 780;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
			
			rate = 1170;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

			rate = 1560;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

			rate = 1755;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
			
			rate = 1950;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);					

			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,0);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
			
			for (i = 0; i < count; i++)
			{
				if (AC_RADIO[RadioID]->mcs_list[i] == 22)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1950);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 21)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1950);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1755);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 20)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1950);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1755);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1560);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
    			}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 19)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1950);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1755);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1560);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1170);
    				AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 18)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1950);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1755);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1560);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1170);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,780);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 17)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1950);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1755);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1560);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1170);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,780);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,585);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 16)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1950);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1755);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1560);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1170);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,780);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,585);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,390);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
			}
		}
		else if (((AC_RADIO[RadioID]->cwmode == 1)||(AC_RADIO[RadioID]->cwmode == 2)||(AC_RADIO[RadioID]->cwmode == 4))
				&& (AC_RADIO[RadioID]->chainmask_num == 1)
				&& (AC_RADIO[RadioID]->guardinterval == 0))//ht20/40 or ht40, GI800
		{
			AC_RADIO[RadioID]->Support_Rate_Count = 8;
			destroy_support_rate_list(AC_RADIO[RadioID]->Radio_Rate);
			AC_RADIO[RadioID]->Radio_Rate = create_support_rate_list(1);
								
			rate = 135;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

			rate = 270;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

			rate = 405;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

			rate = 540;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
			
			rate = 810;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

			rate = 1080;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

			rate = 1215;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
			
			rate = 1350;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);					

			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,0);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);

			for (i = 0; i < count; i++)
			{
				if (AC_RADIO[RadioID]->mcs_list[i] == 6)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 5)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1215);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 4)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1215);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1080);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 3)
				{
	 				AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1215);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1080);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,810);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
    			else if (AC_RADIO[RadioID]->mcs_list[i] == 2)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1215);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1080);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,810);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,540);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 1)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1215);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1080);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,810);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,540);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,405);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 0)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1215);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1080);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,810);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,540);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,405);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,270);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
			}
		}
		else if (((AC_RADIO[RadioID]->cwmode == 1) || (AC_RADIO[RadioID]->cwmode == 2) || (AC_RADIO[RadioID]->cwmode == 4))
				&& (AC_RADIO[RadioID]->chainmask_num == 2)
				&& (AC_RADIO[RadioID]->guardinterval == 0))//ht20/40 or ht40, GI800
		{
			AC_RADIO[RadioID]->Support_Rate_Count = 8;
			destroy_support_rate_list(AC_RADIO[RadioID]->Radio_Rate);
			AC_RADIO[RadioID]->Radio_Rate = create_support_rate_list(1);
								
			rate = 270;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
			rate = 540;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
			rate = 810;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
			rate = 1080;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
			
			rate = 1620;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
			rate = 2160;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
			rate = 2430;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
			
			rate = 2700;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);					
		
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,0);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);

			for (i = 0; i < count; i++)
			{
				if (AC_RADIO[RadioID]->mcs_list[i] == 14)
	 			{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 13)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2430);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 12)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2430);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2160);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 11)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2430);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2160);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1620);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 10)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2430);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2160);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1620);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1080);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 9)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2430);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2160);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1620);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1080);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,810);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 8)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2430);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2160);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1620);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1080);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,810);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,540);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
			}
		}
		else if (((AC_RADIO[RadioID]->cwmode == 1)||(AC_RADIO[RadioID]->cwmode == 2)||(AC_RADIO[RadioID]->cwmode == 4))
				&& (AC_RADIO[RadioID]->chainmask_num == 3)
				&& (AC_RADIO[RadioID]->guardinterval == 0))//ht20/40 or ht40,  GI 800
		{
			AC_RADIO[RadioID]->Support_Rate_Count = 8;
			destroy_support_rate_list(AC_RADIO[RadioID]->Radio_Rate);
			AC_RADIO[RadioID]->Radio_Rate = create_support_rate_list(1);
								
			rate = 405;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
			rate = 810;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
			rate = 1215;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
			rate = 1620;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
			
			rate = 2430;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
			rate = 3240;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
			rate = 3645;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
			
			rate = 4050;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);					
		
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,0);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);

			for (i = 0; i < count; i++)
			{
				if (AC_RADIO[RadioID]->mcs_list[i] == 22)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4050);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 21)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4050);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3645);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 20)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4050);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3645);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3240);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 19)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4050);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3645);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3240);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2430);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 18)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4050);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3645);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3240);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2430);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1620);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 17)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4050);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3645);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3240);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2430);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1620);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1215);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 16)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4050);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3645);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3240);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2430);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1620);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1215);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,810);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
			}
		}
		else if (((AC_RADIO[RadioID]->cwmode == 1)||(AC_RADIO[RadioID]->cwmode == 2)||(AC_RADIO[RadioID]->cwmode == 4))
		        &&(AC_RADIO[RadioID]->chainmask_num == 1)
		        &&(AC_RADIO[RadioID]->guardinterval == 1))//ht20/40 or ht40, GI400
		{
			AC_RADIO[RadioID]->Support_Rate_Count = 8;
			destroy_support_rate_list(AC_RADIO[RadioID]->Radio_Rate);
			AC_RADIO[RadioID]->Radio_Rate = create_support_rate_list(1);
								
			rate = 150;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
			rate = 300;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
			rate = 450;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
			rate = 600;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
			
			rate = 900;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
			rate = 1200;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
			rate = 1350;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
			
			rate = 1500;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);					
		
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,0);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);

			for (i = 0; i < count; i++)
			{
				if (AC_RADIO[RadioID]->mcs_list[i] == 6)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1500);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 5)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1500);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 4)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1500);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1200);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 3)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1500);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1200);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,900);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 2)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1500);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1200);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,900);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,600);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 1)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1500);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1200);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,900);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,600);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,450);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 0)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1500);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1200);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,900);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,600);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,450);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,300);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
			}
		}
		else if (((AC_RADIO[RadioID]->cwmode == 1)||(AC_RADIO[RadioID]->cwmode == 2)||(AC_RADIO[RadioID]->cwmode == 4))
				&& (AC_RADIO[RadioID]->chainmask_num == 2)
				&& (AC_RADIO[RadioID]->guardinterval == 1))//ht20/40 or ht40, GI400
		{
			AC_RADIO[RadioID]->Support_Rate_Count = 8;
			destroy_support_rate_list(AC_RADIO[RadioID]->Radio_Rate);
			AC_RADIO[RadioID]->Radio_Rate = create_support_rate_list(1);
								
			rate = 300;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
			rate = 600;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
			rate = 900;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
			rate = 1200;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
			
			rate = 1800;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
			rate = 2400;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
			rate = 2700;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
			
			rate = 3000;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);					
		
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,0);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);

			for (i = 0; i < count; i++)
			{
				if(AC_RADIO[RadioID]->mcs_list[i] == 14)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3000);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 13)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3000);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 12)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3000);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2400);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 11)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3000);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2400);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1800);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 10)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3000);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2400);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1800);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1200);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 9)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3000);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2400);
 					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1800);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1200);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,900);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 8)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3000);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2400);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1800);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1200);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,900);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,600);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
			}
		}
		else if (((AC_RADIO[RadioID]->cwmode == 1) || (AC_RADIO[RadioID]->cwmode == 2) || (AC_RADIO[RadioID]->cwmode == 4))
				&& (AC_RADIO[RadioID]->chainmask_num == 3)
				&& (AC_RADIO[RadioID]->guardinterval == 1))//ht20/40 or ht40, GI400
		{
			AC_RADIO[RadioID]->Support_Rate_Count = 8;
			destroy_support_rate_list(AC_RADIO[RadioID]->Radio_Rate);
			AC_RADIO[RadioID]->Radio_Rate = create_support_rate_list(1);
								
			rate = 450;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
			rate = 900;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
			rate = 1350;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
			rate = 1800;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
			
			rate = 2700;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
			rate = 3600;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
			rate = 4050;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
			
			rate = 4500;
			AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);					
		
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,0);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);

			for (i = 0; i < count; i++)
    		{
				if (AC_RADIO[RadioID]->mcs_list[i] == 22)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4500);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 21)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4500);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4050);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 20)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4500);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4050);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3600);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 19)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4500);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4050);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3600);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 18)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4500);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4050);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3600);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1800);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 17)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4500);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4050);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3600);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1800);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
				else if (AC_RADIO[RadioID]->mcs_list[i] == 16)
				{
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4500);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4050);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3600);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1800);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,900);
					AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
				}
			}
		}
	}
	//printf("AC_RADIO[%d]->mcs = %d \n",RadioID,AC_RADIO[RadioID]->mcs);
	return 0;
}
/*fengwenchao add 20110408*/
int WID_RADIO_CHANGE_SUPPORT_RATE_BYGI_MCS_CWMODE(unsigned int RadioID)
{
	int rate = 0;
	if (NULL == AC_RADIO[RadioID])
	{
		return RADIO_ID_NOT_EXIST;
	}
	if (((AC_RADIO[RadioID]->cwmode == 0) || (AC_RADIO[RadioID]->cwmode == 3))
	    && (AC_RADIO[RadioID]->chainmask_num == 1)
	    && ((AC_RADIO[RadioID]->guardinterval == 1) || (AC_RADIO[RadioID]->guardinterval == 0)))  //ht20   
	{
		AC_RADIO[RadioID]->Support_Rate_Count = 8;
		destroy_support_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		AC_RADIO[RadioID]->Radio_Rate = create_support_rate_list(1);
			
		rate = 65;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

		rate = 130;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

		rate = 195;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

		rate = 260;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		rate = 390;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

		rate = 520;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

		rate = 585;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		rate = 650;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);					

		AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,0);
		AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);

		if(AC_RADIO[RadioID]->mcs == 6)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,650);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 5)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,650);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,585);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 4)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,650);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,585);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,520);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 3)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,650);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,585);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,520);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,390);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 2)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,650);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,585);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,520);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,390);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,260);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 1)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,650);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,585);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,520);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,390);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,260);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,195);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 0)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,650);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,585);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,520);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,390);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,260);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,195);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,130);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}				
	}
	else if(((AC_RADIO[RadioID]->cwmode == 0)||(AC_RADIO[RadioID]->cwmode == 3))
	        &&(AC_RADIO[RadioID]->chainmask_num == 2)
	        &&((AC_RADIO[RadioID]->guardinterval ==1)||(AC_RADIO[RadioID]->guardinterval == 0)))  //ht20  
	{
		AC_RADIO[RadioID]->Support_Rate_Count = 8;
		destroy_support_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		AC_RADIO[RadioID]->Radio_Rate = create_support_rate_list(1);
							
		rate = 130;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

		rate = 260;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

		rate = 390;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

		rate = 520;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		rate = 780;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

		rate = 1040;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

		rate = 1170;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		rate = 1300;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);					

		AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,0);
		AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		
		if(AC_RADIO[RadioID]->mcs == 14)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1300);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 13)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1300);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1170);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 12)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1300);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1170);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1040);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 11)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1300);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1170);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1040);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,780);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 10)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1300);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1170);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1040);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,780);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,520);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 9)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1300);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1170);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1040);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,780);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,520);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,390);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 8)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1300);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1170);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1040);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,780);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,520);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,390);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,260);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}					
	}
	else if(((AC_RADIO[RadioID]->cwmode == 0)||(AC_RADIO[RadioID]->cwmode == 3))
	        &&(AC_RADIO[RadioID]->chainmask_num == 3)
	        &&((AC_RADIO[RadioID]->guardinterval == 1)||(AC_RADIO[RadioID]->guardinterval == 0)))  //ht20  
	{
		AC_RADIO[RadioID]->Support_Rate_Count = 8;
		destroy_support_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		AC_RADIO[RadioID]->Radio_Rate = create_support_rate_list(1);
							
		rate = 195;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

		rate = 390;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

		rate = 585;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

		rate = 780;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		rate = 1170;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

		rate = 1560;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

		rate = 1755;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		rate = 1950;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);					

		AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,0);
		AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		
		if(AC_RADIO[RadioID]->mcs == 22)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1950);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 21)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1950);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1755);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 20)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1950);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1755);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1560);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 19)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1950);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1755);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1560);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1170);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 18)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1950);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1755);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1560);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1170);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,780);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 17)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1950);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1755);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1560);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1170);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,780);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,585);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 16)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1950);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1755);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1560);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1170);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,780);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,585);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,390);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}					
	}		
	else if(((AC_RADIO[RadioID]->cwmode == 1)||(AC_RADIO[RadioID]->cwmode == 2)||(AC_RADIO[RadioID]->cwmode == 4))
	        &&(AC_RADIO[RadioID]->chainmask_num == 1)
	        &&(AC_RADIO[RadioID]->guardinterval == 0))//ht20/40 or ht40, GI800
	{
		AC_RADIO[RadioID]->Support_Rate_Count = 8;
		destroy_support_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		AC_RADIO[RadioID]->Radio_Rate = create_support_rate_list(1);
							
		rate = 135;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

		rate = 270;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

		rate = 405;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

		rate = 540;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		rate = 810;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

		rate = 1080;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);

		rate = 1215;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		rate = 1350;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);					

		AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,0);
		AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		
		if(AC_RADIO[RadioID]->mcs == 6)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 5)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1215);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 4)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1215);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1080);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 3)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1215);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1080);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,810);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 2)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1215);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1080);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,810);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,540);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 1)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1215);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1080);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,810);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,540);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,405);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 0)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1215);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1080);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,810);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,540);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,405);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,270);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}			
	}
	else if(((AC_RADIO[RadioID]->cwmode == 1)||(AC_RADIO[RadioID]->cwmode == 2)||(AC_RADIO[RadioID]->cwmode == 4))
	        &&(AC_RADIO[RadioID]->chainmask_num == 2)
	        &&(AC_RADIO[RadioID]->guardinterval == 0))//ht20/40 or ht40, GI800
	{
		AC_RADIO[RadioID]->Support_Rate_Count = 8;
		destroy_support_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		AC_RADIO[RadioID]->Radio_Rate = create_support_rate_list(1);
							
		rate = 270;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
	
		rate = 540;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
	
		rate = 810;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
	
		rate = 1080;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		rate = 1620;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
	
		rate = 2160;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
	
		rate = 2430;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		rate = 2700;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);					
	
		AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,0);
		AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		
		if(AC_RADIO[RadioID]->mcs == 14)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 13)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2430);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 12)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2430);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2160);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 11)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2430);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2160);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1620);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 10)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2430);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2160);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1620);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1080);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 9)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2430);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2160);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1620);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1080);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,810);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 8)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2430);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2160);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1620);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1080);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,810);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,540);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}			
	}
	else if(((AC_RADIO[RadioID]->cwmode == 1)||(AC_RADIO[RadioID]->cwmode == 2)||(AC_RADIO[RadioID]->cwmode == 4))
	        &&(AC_RADIO[RadioID]->chainmask_num == 3)
	        &&(AC_RADIO[RadioID]->guardinterval == 0))//ht20/40 or ht40,  GI 800
	{
		AC_RADIO[RadioID]->Support_Rate_Count = 8;
		destroy_support_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		AC_RADIO[RadioID]->Radio_Rate = create_support_rate_list(1);
							
		rate = 405;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
	
		rate = 810;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
	
		rate = 1215;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
	
		rate = 1620;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		rate = 2430;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
	
		rate = 3240;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
	
		rate = 3645;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		rate = 4050;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);					
	
		AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,0);
		AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		
		if(AC_RADIO[RadioID]->mcs == 22)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4050);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 21)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4050);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3645);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 20)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4050);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3645);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3240);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 19)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4050);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3645);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3240);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2430);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 18)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4050);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3645);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3240);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2430);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1620);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 17)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4050);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3645);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3240);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2430);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1620);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1215);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 16)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4050);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3645);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3240);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2430);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1620);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1215);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,810);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}			
	}		
	else if(((AC_RADIO[RadioID]->cwmode == 1)||(AC_RADIO[RadioID]->cwmode == 2)||(AC_RADIO[RadioID]->cwmode == 4))
	        &&(AC_RADIO[RadioID]->chainmask_num == 1)
	        &&(AC_RADIO[RadioID]->guardinterval == 1))//ht20/40 or ht40, GI400
	{
		AC_RADIO[RadioID]->Support_Rate_Count = 8;
		destroy_support_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		AC_RADIO[RadioID]->Radio_Rate = create_support_rate_list(1);
							
		rate = 150;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
	
		rate = 300;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
	
		rate = 450;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
	
		rate = 600;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		rate = 900;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
	
		rate = 1200;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
	
		rate = 1350;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		rate = 1500;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);					
	
		AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,0);
		AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		
		if(AC_RADIO[RadioID]->mcs == 6)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1500);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 5)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1500);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 4)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1500);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1200);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 3)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1500);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1200);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,900);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 2)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1500);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1200);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,900);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,600);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 1)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1500);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1200);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,900);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,600);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,450);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 0)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1500);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1200);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,900);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,600);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,450);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,300);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}			
	}		
	else if(((AC_RADIO[RadioID]->cwmode == 1)||(AC_RADIO[RadioID]->cwmode == 2)||(AC_RADIO[RadioID]->cwmode == 4))
	        &&(AC_RADIO[RadioID]->chainmask_num == 2)
	        &&(AC_RADIO[RadioID]->guardinterval == 1))//ht20/40 or ht40, GI400
	{
		AC_RADIO[RadioID]->Support_Rate_Count = 8;
		destroy_support_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		AC_RADIO[RadioID]->Radio_Rate = create_support_rate_list(1);
							
		rate = 300;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
	
		rate = 600;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
	
		rate = 900;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
	
		rate = 1200;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		rate = 1800;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
	
		rate = 2400;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
	
		rate = 2700;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		rate = 3000;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);					
	
		AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,0);
		AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		
		if(AC_RADIO[RadioID]->mcs == 14)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3000);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 13)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3000);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 12)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3000);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2400);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 11)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3000);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2400);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1800);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 10)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3000);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2400);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1800);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1200);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 9)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3000);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2400);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1800);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1200);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,900);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 8)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3000);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2400);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1800);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1200);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,900);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,600);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}			
	}				
	else if(((AC_RADIO[RadioID]->cwmode == 1)||(AC_RADIO[RadioID]->cwmode == 2)||(AC_RADIO[RadioID]->cwmode == 4))
	        &&(AC_RADIO[RadioID]->chainmask_num == 3)
	        &&(AC_RADIO[RadioID]->guardinterval == 1))//ht20/40 or ht40, GI400
	{
		AC_RADIO[RadioID]->Support_Rate_Count = 8;
		destroy_support_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		AC_RADIO[RadioID]->Radio_Rate = create_support_rate_list(1);
							
		rate = 450;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
	
		rate = 900;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
	
		rate = 1350;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
	
		rate = 1800;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		rate = 2700;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
	
		rate = 3600;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
	
		rate = 4050;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);
		
		rate = 4500;
		AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate,rate);					
	
		AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,0);
		AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		
		if(AC_RADIO[RadioID]->mcs == 22)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4500);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 21)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4500);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4050);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 20)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4500);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4050);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3600);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 19)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4500);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4050);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3600);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 18)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4500);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4050);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3600);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1800);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 17)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4500);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4050);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3600);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1800);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}
		else if(AC_RADIO[RadioID]->mcs == 16)
		{
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4500);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,4050);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,3600);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,2700);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1800);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,1350);
			AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate,900);
			AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
		}			
	}			
	
	//printf("AC_RADIO[%d]->mcs = %d \n",RadioID,AC_RADIO[RadioID]->mcs);
	return 0;
}
/*fengwenchao add end*/

int WID_RADIO_CHANGE_SUPPORT_RATE_BYGI_MCS(unsigned int RadioID)
{
	int rate = 0;
	if(NULL == AC_RADIO[RadioID])
	{
	    return RADIO_ID_NOT_EXIST;
	}

	if(AC_RADIO[RadioID]->guardinterval == 1)
    {
		if(AC_RADIO[RadioID]->chainmask_num == 1)
		{
			if((AC_RADIO[RadioID]->cwmode == 0) || (AC_RADIO[RadioID]->cwmode == 3))
			{
				if(AC_RADIO[RadioID]->Radio_Rate != NULL)
				{
				    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 65);
				    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 130);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 195);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 260);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 390);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 520);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 585);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);

				    rate = 72;
    				AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);  				

					rate = 144;
					AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);
					
                    rate = 217;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 289;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

					rate = 433;
    				AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 578;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);
                    
                    rate = 650;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);
                  
                    rate = 722;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);
    				
                    if(AC_RADIO[RadioID]->mcs == 6)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 722);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 5)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 722);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 4)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 722);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 578);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 3)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 722);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 578);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 433);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 2)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 722);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 578);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 433);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 289);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 1)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 722);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 578);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 433);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 289);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 217);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 0)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 722);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 578);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 433);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 289);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 217);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 144);
                    }             
				}					
			}
			else if((AC_RADIO[RadioID]->cwmode == 1) || (AC_RADIO[RadioID]->cwmode == 2)||(AC_RADIO[RadioID]->cwmode == 4))
			{
				if(AC_RADIO[RadioID]->Radio_Rate != NULL)
                {                
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 135);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 270);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 405);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 540);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 810);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1080);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1215);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);

                    rate = 150;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);
                    
                    rate = 300;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);
                    
                    rate = 450;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);
                    
                    rate = 600;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);
                 
                    rate = 900;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);
                    
                    rate = 1200;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);
                    
                    rate = 1350;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);
                    
                    rate = 1500;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);
                    
                    if(AC_RADIO[RadioID]->mcs == 6)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1500);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 5)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1500);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 4)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1500);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1200);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 3)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1500);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1200);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 900);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 2)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1500);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1200);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 900);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 600);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 1)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1500);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1200);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 900);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 600);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 450);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 0)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1500);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1200);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 900);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 600);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 450);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 300);
                    }             
                }
			}
		}
		else if(AC_RADIO[RadioID]->chainmask_num == 2)
		{
			if((AC_RADIO[RadioID]->cwmode == 0) || (AC_RADIO[RadioID]->cwmode == 3))
			{
				if(AC_RADIO[RadioID]->Radio_Rate != NULL)
                {   
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 130);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 260);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 390);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 520);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 780);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1040);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1170);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);

                    rate = 144;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 289;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 433;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 578;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 867;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 1156;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 1300;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 1444;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    if(AC_RADIO[RadioID]->mcs == 14)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1444);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 13)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1444);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 12)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1444);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1156);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 11)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1444);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1156);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 867);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 10)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1444);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1156);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 867);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 578);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 9)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1444);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1156);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 867);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 578);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 433);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 8)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1444);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1156);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 867);                        
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 578);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 433);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 289);
                    }             
                }							
			}
			else if((AC_RADIO[RadioID]->cwmode == 1)||(AC_RADIO[RadioID]->cwmode == 2)||(AC_RADIO[RadioID]->cwmode == 4))
			{
				if(AC_RADIO[RadioID]->Radio_Rate != NULL)
				{
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 270);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 540);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 810);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1080);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1620);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2160);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2430);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);

                    rate = 300;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 600;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 900;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 1200;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 1800;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 2400;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);
                    
                    rate = 2700;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

					rate = 3000;
					AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    if(AC_RADIO[RadioID]->mcs == 14)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 3000);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 13)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 3000);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 12)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 3000);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2400);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 11)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 3000);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2400);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1800);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 10)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 3000);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2400);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1800);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1200);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 9)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 3000);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2400);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1800);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1200);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 900);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 8)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 3000);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2400);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1800);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1200);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 900);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 600);
                    }             
                }
			}
		}
	}
	else if(0 == AC_RADIO[RadioID]->guardinterval)
    {
        if(AC_RADIO[RadioID]->chainmask_num == 1)
        {
            if((AC_RADIO[RadioID]->cwmode == 0) || (AC_RADIO[RadioID]->cwmode == 3))
            {
                if(AC_RADIO[RadioID]->Radio_Rate != NULL)
                {
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 72);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 144);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 217);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 289);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 433);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 578);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 722);

                    rate = 65;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 130;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 195;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 260;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 390;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 520;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 585;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);
                    
                    rate = 650;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    if(AC_RADIO[RadioID]->mcs == 6)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 5)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 585);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 4)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 585);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 520);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 3)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 585);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 520);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 390);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 2)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 585);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 520);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 390);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 260);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 1)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 585);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 520);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 390);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 260);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 195);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 0)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 585);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 520);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 390);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 260);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 195);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 130);
                    }             
                }                   
            }
            else if((AC_RADIO[RadioID]->cwmode == 1)||(AC_RADIO[RadioID]->cwmode == 2)||(AC_RADIO[RadioID]->cwmode == 4))
            {
                if(AC_RADIO[RadioID]->Radio_Rate != NULL)
                {
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 150);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 300);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 450);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 600);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 900);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1200);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1500);

                    rate = 135;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 270;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 405;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 540;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 810;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 1080;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 1215;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);
                    
                    rate = 1350;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    if(AC_RADIO[RadioID]->mcs == 6)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 5)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1215);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 4)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1215);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1080);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 3)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1215);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1080);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 810);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 2)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1215);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1080);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 810);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 540);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 1)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1215);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1080);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 810);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 540);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 405);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 0)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1215);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1080);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 810);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 540);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 405);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 270);
                    }             
                }
            }
        }
        else if(AC_RADIO[RadioID]->chainmask_num == 2)
        {
            if((AC_RADIO[RadioID]->cwmode == 0) || (AC_RADIO[RadioID]->cwmode == 3))
            {
                if(AC_RADIO[RadioID]->Radio_Rate != NULL)
                {                          
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 144);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 289);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 433);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 578);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 867);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1156);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1444);

                    rate = 130;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 260;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 390;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 520;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 780;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 1040;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 1170;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);
                    
                    rate = 1300;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    if(AC_RADIO[RadioID]->mcs == 14)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 13)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1170);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 12)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1170);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1040);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 11)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1170);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1040);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 780);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 10)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1170);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1040);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 780);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 520);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 9)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1170);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1040);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 780);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 520);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 390);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 8)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1170);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1040);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 780);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 520);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 390);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 260);
                    }             
                }                           
            }            
            else if((AC_RADIO[RadioID]->cwmode == 1)||(AC_RADIO[RadioID]->cwmode == 2)||(AC_RADIO[RadioID]->cwmode == 4))
            {
                if(AC_RADIO[RadioID]->Radio_Rate != NULL)
                {  
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 300);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 600);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 900);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1200);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1800);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2400);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 3000);

                    rate = 270;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 540;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 810;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 1080;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 1620;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 2160;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 2430;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);
                   
                    rate = 2700;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    if(AC_RADIO[RadioID]->mcs == 14)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 13)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2430);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 12)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2430);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2160);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 11)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2430);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2160);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1620);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 10)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2430);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2160);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1620);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1080);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 9)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2430);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2160);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1620);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1080);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 810);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 8)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2430);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2160);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1620);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1080);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 810);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 540);
                    }             
                }
            }
        }
    }
    
    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 0);
    delsame_rate_from_list(AC_RADIO[RadioID]->Radio_Rate);
    AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
    
	return 0;
}

unsigned int wid_bss_balance_switch(unsigned int wtpid, unsigned char l_radioid, unsigned char wlanid)
{
	int bssindex = 0;
	msgq msg;

	bssindex = AC_WLAN[wlanid]->S_WTP_BSS_List[wtpid][l_radioid];	
	if((bssindex != 0) && (check_bssid_func(bssindex)) && (AC_WTP[wtpid] != NULL))
	{											
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = wtpid % THREAD_NUM+1;
		msg.mqinfo.WTPID = wtpid;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WTP_S_TYPE;
		msg.mqinfo.u.WtpInfo.Wtp_Op = WLAN_LOAD_BALANCE;
		msg.mqinfo.u.WtpInfo.c1 = l_radioid;
		msg.mqinfo.u.WtpInfo.c2 = wlanid;
		msg.mqinfo.u.WtpInfo.value1 = AC_WLAN[wlanid]->balance_method;

		if(AC_WTP[wtpid]->WTPStat == WID_RUN)
		{	
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}											
	}
	
	return WID_DBUS_SUCCESS;
}


int WID_RADIO_CHANGE_SUPPORT_RATE_BYCWMODE_MCS(unsigned int RadioID)
{
	int rate = 0;
	if(NULL == AC_RADIO[RadioID])
	{
	    return RADIO_ID_NOT_EXIST;
	}

	if((AC_RADIO[RadioID]->cwmode == 0)||(AC_RADIO[RadioID]->cwmode == 3))
    {
		if(AC_RADIO[RadioID]->chainmask_num == 1)
		{
			if(AC_RADIO[RadioID]->guardinterval == 1)
			{
				if(AC_RADIO[RadioID]->Radio_Rate != NULL)
				{ 
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 150);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 300);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 450);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 600);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 900);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1200);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1500);

                    rate = 72;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 144;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 217;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 289;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 433;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 578;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 650;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);
                    
                    rate = 722;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    if(AC_RADIO[RadioID]->mcs == 6)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 722);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 5)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 722);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 4)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 722);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 578);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 3)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 722);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 578);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 433);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 2)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 722);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 578);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 433);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 289);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 1)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 722);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 578);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 433);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 289);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 217);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 0)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 722);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 578);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 433);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 289);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 217);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 144);
                    }             
				}					
			}
			else if(AC_RADIO[RadioID]->guardinterval == 0)
			{
				if(AC_RADIO[RadioID]->Radio_Rate != NULL)
                {                          
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 135);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 270);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 405);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 540);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 810);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1080);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1215);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);

                    rate = 65;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 130;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 195;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 260;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 390;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 520;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 585;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

					rate = 650;
					AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);
                
                    if(AC_RADIO[RadioID]->mcs == 6)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 5)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 585);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 4)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 585);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 520);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 3)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 585);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 520);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 390);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 2)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 585);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 520);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 390);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 260);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 1)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 585);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 520);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 390);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 260);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 195);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 0)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 585);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 520);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 390);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 260);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 195);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 130);
                    }             
                }
			}
		}
		else if(AC_RADIO[RadioID]->chainmask_num == 2)
		{
			if(AC_RADIO[RadioID]->guardinterval == 1)
			{
				if(AC_RADIO[RadioID]->Radio_Rate != NULL)
                {                          
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 300);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 600);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 900);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1200);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1800);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2400);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 3000);

                    rate = 144;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 289;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 433;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 578;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 867;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 1156;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 1300;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

					rate = 1444;
					AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);
                    
                    if(AC_RADIO[RadioID]->mcs == 14)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1444);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 13)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1444);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 12)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1444);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1156);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 11)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1444);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1156);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 867);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 10)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1444);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1156);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 867);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 578);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 9)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1444);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1156);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 867);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 578);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 433);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 8)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1444);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1156);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 867);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 578);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 433);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 289);
                    }             
                }							
			}
			else if(AC_RADIO[RadioID]->guardinterval == 0)
			{
				if(AC_RADIO[RadioID]->Radio_Rate != NULL)
				{ 
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 270);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 540);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 810);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1080);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1620);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2160);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2430);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                    
                    rate = 130;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 260;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);
                    
                    rate = 390;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 520;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 780;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 1040;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 1170;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

					rate = 1300;
					AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);
                    
                    if(AC_RADIO[RadioID]->mcs == 14)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 13)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1170);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 12)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1170);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1040);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 11)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1170);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1040);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 780);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 10)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1170);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1040);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 780);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 520);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 9)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1170);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1040);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 780);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 520);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 390);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 8)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1170);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1040);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 780);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 520);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 390);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 260);
                    }             
                }
			}
		}
	}
	else if((AC_RADIO[RadioID]->cwmode == 1)||(AC_RADIO[RadioID]->cwmode == 2)||(AC_RADIO[RadioID]->cwmode == 4))
    {
        if(AC_RADIO[RadioID]->chainmask_num == 1)
        {
            if(AC_RADIO[RadioID]->guardinterval == 1)
            {
                if(AC_RADIO[RadioID]->Radio_Rate != NULL)
                {   
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 72);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 144);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 217);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 289);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 433);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 578);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);
					AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 722);

                    rate = 150;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 300;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 450;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 600;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 900;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 1200;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 1350;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

					rate = 1500;
					AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);
				    
                    if(AC_RADIO[RadioID]->mcs == 6)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1500);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 5)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1500);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 4)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1500);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1200);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 3)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1500);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1200);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 900);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 2)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1500);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1200);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 900);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 600);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 1)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1500);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1200);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 900);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 600);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 450);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 0)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1500);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1200);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 900);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 600);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 450);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 300);
                    }             
                }                   
            }
            else if(AC_RADIO[RadioID]->guardinterval == 0)
            {
                if(AC_RADIO[RadioID]->Radio_Rate != NULL)
                {                          
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 65);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 130);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 195);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 260);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 390);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 520);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 585);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 650);

                    rate = 135;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 270;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 405;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 540;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 810;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 1080;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 1215;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 1350;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);
                    
                    if(AC_RADIO[RadioID]->mcs == 6)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 5)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1215);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 4)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1215);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1080);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 3)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1215);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1080);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 810);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 2)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1215);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1080);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 810);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 540);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 1)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1215);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1080);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 810);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 540);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 405);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 0)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1350);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1215);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1080);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 810);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 540);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 405);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 270);
                    }             
                }
            }
        }
        else if(AC_RADIO[RadioID]->chainmask_num == 2)
        {
            if(AC_RADIO[RadioID]->guardinterval == 1)
            {
                if(AC_RADIO[RadioID]->Radio_Rate != NULL)
                {                          
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 144);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 289);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 433);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 578);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 867);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1156);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1444);

                    rate = 300;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 600;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 900;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 1200;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 1800;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 2400;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 2700;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 3000;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);
                    
                    if(AC_RADIO[RadioID]->mcs == 14)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 3000);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 13)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 3000);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 12)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 3000);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2400);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 11)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 3000);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2400);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1800);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 10)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 3000);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2400);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1800);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1200);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 9)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 3000);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2400);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1800);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1200);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 900);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 8)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 3000);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2400);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1800);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1200);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 900);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 600);
                    }             
                }                           
            }            
            else if(AC_RADIO[RadioID]->guardinterval == 0)
            {
                if(AC_RADIO[RadioID]->Radio_Rate != NULL)
                {                          
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 130);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 260);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 390);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 520);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 780);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1040);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1170);
                    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1300);

                    rate = 270;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 540;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 810;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 1080;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 1620;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 2160;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 2430;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);

                    rate = 2700;
                    AC_RADIO[RadioID]->Radio_Rate = insert_rate_into_list(AC_RADIO[RadioID]->Radio_Rate, rate);
                    
                    if(AC_RADIO[RadioID]->mcs == 14)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 13)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2430);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 12)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2430);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2160);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 11)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2430);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2160);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1620);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 10)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2430);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2160);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1620);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1080);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 9)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2430);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2160);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1620);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1080);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 810);
                    }
                    else if(AC_RADIO[RadioID]->mcs == 8)
                    {
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2700);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2430);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 2160);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1620);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 1080);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 810);
                        AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 540);
                    }             
                }
            }
        }
    }
    
    AC_RADIO[RadioID]->Radio_Rate = delete_rate_from_list(AC_RADIO[RadioID]->Radio_Rate, 0);
    delsame_rate_from_list(AC_RADIO[RadioID]->Radio_Rate);
    AC_RADIO[RadioID]->Support_Rate_Count = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);
    
	return 0;
}

int wid_radio_set_ampdu_subframe(unsigned int RadioID, unsigned char type)
{
	msgq msg;
	struct msgqlist *elem;
	//if((gWTPs[AC_RADIO[RadioID]->WTPID].currentState == CW_ENTER_RUN)&&(AC_RADIO[RadioID]->AdStat == 2))
	{
	//	return RADIO_IS_DISABLE;
	}


			int WTPIndex = RadioID/L_RADIO_NUM;
		if(AC_WTP[AC_RADIO[RadioID]->WTPID]->WTPStat == 5)
		{
			AC_RADIO[RadioID]->CMD |= 0x20;
			AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->radioid[AC_RADIO[RadioID]->Radio_L_ID] += 1;
			AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->setCMD = 1;	
				//int WTPIndex = AC_RADIO[RadioID]->WTPID;
			CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
			if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
			{
				memset((char*)&msg, 0, sizeof(msg));
				msg.mqid = WTPIndex%THREAD_NUM+1;
				msg.mqinfo.WTPID = WTPIndex;
				msg.mqinfo.type = CONTROL_TYPE;
				msg.mqinfo.subtype = Radio_S_TYPE;
            if(type == 1)
    		{
    		    msg.mqinfo.u.RadioInfo.Radio_Op = Radio_ampdu_op;
    		}
    		else
    		{
    		    msg.mqinfo.u.RadioInfo.Radio_Op = Radio_amsdu_op;
    		}
				msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
				msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
				if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
				{
					wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
					perror("msgsnd");
				}

			}
			CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
			}else if((AC_WTP[WTPIndex] != NULL)){
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
        if(type == 1)
		{
		    msg.mqinfo.u.RadioInfo.Radio_Op = Radio_ampdu_op;
		}
		else
		{
		    msg.mqinfo.u.RadioInfo.Radio_Op = Radio_amsdu_op;
		}
			msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
			msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
		
			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if(elem == NULL){
				wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
				perror("malloc");
				return 0;
			}
			memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
			elem->next = NULL;
			memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
			WID_INSERT_CONTROL_LIST(WTPIndex, elem);
			elem = NULL;
		}

	return 0;

}
/* zhangshu add for set 11n para END*/


int wid_radio_set_mixed_puren_switch(unsigned int RadioID, unsigned char WlanID)
{
	msgq msg;
	struct msgqlist *elem = NULL;
	//if((gWTPs[AC_RADIO[RadioID]->WTPID].currentState == CW_ENTER_RUN)&&(AC_RADIO[RadioID]->AdStat == 2))
	{
		//return RADIO_IS_DISABLE;
	}

	int WTPIndex = RadioID/L_RADIO_NUM;
	if(AC_WTP[AC_RADIO[RadioID]->WTPID]->WTPStat == WID_RUN)
	{
		AC_RADIO[RadioID]->CMD |= 0x20;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->radioid[AC_RADIO[RadioID]->Radio_L_ID] += 1;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->setCMD = 1;	
		//int WTPIndex = AC_RADIO[RadioID]->WTPID;
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_puren_mixed_op;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
			msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
			msg.mqinfo.u.RadioInfo.wlanid = WlanID;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
				perror("msgsnd");
			}

		}
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}
	else if((AC_WTP[WTPIndex] != NULL))
    {
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WTPIndex%THREAD_NUM+1;
		msg.mqinfo.WTPID = WTPIndex;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = Radio_S_TYPE;
		msg.mqinfo.u.RadioInfo.Radio_Op = Radio_puren_mixed_op;
		msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
		msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
		msg.mqinfo.u.RadioInfo.wlanid = WlanID;
		
		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if(elem == NULL)
		{
			wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
			perror("malloc");
			return 0;
		}
		memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
		elem->next = NULL;
		memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
		WID_INSERT_CONTROL_LIST(WTPIndex, elem);
		elem = NULL;
	}
	
	wid_syslog_debug_debug(WID_DEFAULT,"set radio %d wlan %d Mixed_Greenfield is %s",
	                        RadioID,WlanID,(AC_RADIO[RadioID]->MixedGreenfield.Mixed_Greenfield == 1)?"puren":"mixed");
	return 0;
}

void wid_check_radio_max_min_channel(unsigned int RadioID,unsigned int *max_channel,unsigned int *min_channel)
{
	if(AC_RADIO[RadioID] != NULL)
	{
		switch(AC_RADIO[RadioID]->Radio_country_code)/*wcl modify for AUTELAN-2765*/
		{
			case COUNTRY_CHINA_CN : 
							if (WAI_RADIO5G_TYPE(AC_RADIO[RadioID]->Radio_Type)&& \
								(WAI_RADIO5G_CHANN_CN(AC_RADIO[RadioID]->Radio_Chan)))
							{
								*max_channel = 159;
								*min_channel = 7;
							}
							else
							{
								*max_channel = 9;
								*min_channel = 5;
							}

							break;
									
			case COUNTRY_EUROPE_EU : 
							if (WAI_RADIO5G_TYPE(AC_RADIO[RadioID]->Radio_Type)&& \
								(WAI_RADIO5G_CHANN_EU(AC_RADIO[RadioID]->Radio_Chan))) 
							{ /*wcl modify for AUTELAN-2765*/
								*max_channel = 134;
								*min_channel = 7;
							}
							else
							{
								*max_channel = 9;
								*min_channel = 5;
							}	
							break;
																	
			case COUNTRY_USA_US : 
							if (WAI_RADIO5G_TYPE(AC_RADIO[RadioID]->Radio_Type)&& \
								(WAI_RADIO5G_CHANN_US(AC_RADIO[RadioID]->Radio_Chan) ))
							{ /*wcl modify for AUTELAN-2765*/
								*max_channel = 159;
								*min_channel = 7;
							}
							else
							{
								*max_channel = 7;
								*min_channel = 5;
							}
							break;
																	
			case COUNTRY_JAPAN_JP : 
							if (WAI_RADIO5G_TYPE(AC_RADIO[RadioID]->Radio_Type)&&  \
								(WAI_RADIO5G_CHANN_JP(AC_RADIO[RadioID]->Radio_Chan)))
							{ /*wcl modify for AUTELAN-2765*/
								*max_channel = 40;
								*min_channel = 7;
							}
							else
							{
								*max_channel = 10;
								*min_channel = 5;
							}										
							break;
																	
			case COUNTRY_FRANCE_FR : 
							if (WAI_RADIO5G_TYPE(AC_RADIO[RadioID]->Radio_Type)&& \
								(WAI_RADIO5G_CHANN_FR(AC_RADIO[RadioID]->Radio_Chan)))
							{ /*wcl modify for AUTELAN-2765*/
								*max_channel = 134;
								*min_channel = 7;
							}
							else
							{
								*max_channel = 7;
								*min_channel = 7;
							}	
							break;
																	
			case COUNTRY_SPAIN_ES : 
							if (WAI_RADIO5G_TYPE(AC_RADIO[RadioID]->Radio_Type)&& \
							    (WAI_RADIO5G_CHANN_SPAIN(AC_RADIO[RadioID]->Radio_Chan))) 
							{ /*wcl modify for AUTELAN-2765*/
								*max_channel = 134;
								*min_channel = 7;
							}
							else
							{
								*max_channel = 5;
								*min_channel = 7;
							}	
							break;
		
			default : 
			break;
		}		
	}
	return;
}


int WID_RADIO_SET_CHANNEL(unsigned int RadioID, unsigned char RadioChan)
{
	unsigned int max_chanenl = 5;
	unsigned int min_channel = 7;
	int check_channel = 0;
	int ret = WID_DBUS_ERROR;
	int ret1 = COUNTRY_CODE_ERROR;
	int ret2 = CHANNEL_CWMODE_SUCCESS;
	
	WID_CHECK_G_RADIOID_STANDARD_RET(RadioID,RADIO_ID_NOT_EXIST);
	
	check_channel = (int)RadioChan;
	if(AC_RADIO[RadioID] == NULL)
	{
		return RADIO_ID_NOT_EXIST;
	}
	
	switch(AC_RADIO[RadioID]->Radio_country_code)
	{
		case COUNTRY_CHINA_CN : 
		
			if(check_channel >= 14)
			{
				ret1 = COUNTRY_CHINA_CN;
			}
			if(((AC_RADIO[RadioID]->Radio_Type & IEEE80211_11A)||(AC_RADIO[RadioID]->Radio_Type & IEEE80211_11AC))
				&&((check_channel == 149)||(check_channel == 153)||(check_channel == 157)||(check_channel == 161)||(check_channel == 165)))
			{
				ret1 = COUNTRY_CODE_SUCCESS;
				max_chanenl = 159;
				min_channel = 7;
			}
			else
			{
				max_chanenl = 9;
				min_channel = 5;
			}
			
			break;
			
		case COUNTRY_EUROPE_EU :
		
			if(check_channel >= 14)
			{
				ret1 = COUNTRY_EUROPE_EU;
			}
			if(((AC_RADIO[RadioID]->Radio_Type & IEEE80211_11A)||(AC_RADIO[RadioID]->Radio_Type & IEEE80211_11AC))
				&&((check_channel == 36)||(check_channel == 40)||(check_channel == 44)||(check_channel == 48)
					||(check_channel == 52)||(check_channel == 56)||(check_channel == 60)||(check_channel == 64)
					||(check_channel == 100)||(check_channel == 104)||(check_channel == 108)||(check_channel == 112)
					||(check_channel == 116)||(check_channel == 120)||(check_channel == 124)||(check_channel == 128)
					||(check_channel == 132)||(check_channel == 136)||(check_channel == 140))) /*wcl modify for AUTELAN-2765*/
			{
				ret1 = COUNTRY_CODE_SUCCESS;
				max_chanenl = 134;
				min_channel = 7;
			}
			else
			{
				max_chanenl = 9;
				min_channel = 5;
			}	
			break;
			
		case COUNTRY_USA_US : 
		
			if((check_channel >= 12))
			{
				ret1 = COUNTRY_USA_US;
			}
			if(((AC_RADIO[RadioID]->Radio_Type & IEEE80211_11A)||(AC_RADIO[RadioID]->Radio_Type & IEEE80211_11AC))
				&&((check_channel == 36)||(check_channel == 40)||(check_channel == 44)||(check_channel == 48)
					||(check_channel == 52)||(check_channel == 56)||(check_channel == 60)||(check_channel == 64)
					||(check_channel == 100)||(check_channel == 104)||(check_channel == 108)||(check_channel == 112)
					||(check_channel == 116)||(check_channel == 120)||(check_channel == 124)||(check_channel == 128)
					||(check_channel == 132)||(check_channel == 136)||(check_channel == 140)||(check_channel == 149)
					||(check_channel == 153)||(check_channel == 157)||(check_channel == 161)||(check_channel == 165)))/*wcl modify for AUTELAN-2765*/
			{
				ret1 = COUNTRY_CODE_SUCCESS;
				max_chanenl = 159;
				min_channel = 7;
			}
			else
			{
				max_chanenl = 7;
				min_channel = 5;
			}
			break;
			
		case COUNTRY_JAPAN_JP :
		
			if((check_channel >= 15))
			{
				ret1 = COUNTRY_JAPAN_JP;
			}
			if(((AC_RADIO[RadioID]->Radio_Type & IEEE80211_11A)||(AC_RADIO[RadioID]->Radio_Type & IEEE80211_11AC))
				&&((check_channel == 36)||(check_channel == 40)||(check_channel == 44)||(check_channel == 48)
					||(check_channel == 52)||(check_channel == 56)||(check_channel == 60)||(check_channel == 64)
					||(check_channel == 100)||(check_channel == 104)||(check_channel == 108)||(check_channel == 112)
					||(check_channel == 116)||(check_channel == 120)||(check_channel == 124)||(check_channel == 128)
					||(check_channel == 132)||(check_channel == 136)||(check_channel == 140)||(check_channel == 184)
					||(check_channel == 188)||(check_channel == 192)||(check_channel == 196)))/*wcl modify for AUTELAN-2765*/
			{
				ret1 = COUNTRY_CODE_SUCCESS;
				max_chanenl = 40;
				min_channel = 7;
			}
			else
			{
				max_chanenl = 10;
				min_channel = 5;
			}
			break;
																
		case COUNTRY_FRANCE_FR :
		
			if((check_channel != 0)&&(check_channel != 10)&&(check_channel != 11)&&(check_channel != 12)&&(check_channel != 13))
			{
				ret1 = COUNTRY_FRANCE_FR;
			}
			if (((AC_RADIO[RadioID]->Radio_Type & IEEE80211_11A)||(AC_RADIO[RadioID]->Radio_Type & IEEE80211_11AC))
				&&((check_channel == 36)||(check_channel == 40)||(check_channel == 44)||(check_channel == 48)
					||(check_channel == 52)||(check_channel == 56)||(check_channel == 60)||(check_channel == 64)
					||(check_channel == 100)||(check_channel == 104)||(check_channel == 108)||(check_channel == 112)
					||(check_channel == 116)||(check_channel == 120)||(check_channel == 124)||(check_channel == 128)
					||(check_channel == 132)||(check_channel == 136)||(check_channel == 140))) /*wcl modify for AUTELAN-2765*/
			{
				ret1 = COUNTRY_CODE_SUCCESS;
				max_chanenl = 134;
				min_channel = 7;
			}
			else
			{
				max_chanenl = 7;
				min_channel = 7;
			}	
			break;
			
		case COUNTRY_SPAIN_ES :

			if((check_channel != 0)&&(check_channel != 10)&&(check_channel != 11))
			{
				ret1 = COUNTRY_SPAIN_ES;
			}
			if (((AC_RADIO[RadioID]->Radio_Type & IEEE80211_11A)||(AC_RADIO[RadioID]->Radio_Type & IEEE80211_11AC))
				&&((check_channel == 36)||(check_channel == 40)||(check_channel == 44)||(check_channel == 48)
					||(check_channel == 52)||(check_channel == 56)||(check_channel == 60)||(check_channel == 64)
					||(check_channel == 100)||(check_channel == 104)||(check_channel == 108)||(check_channel == 112)
					||(check_channel == 116)||(check_channel == 120)||(check_channel == 124)||(check_channel == 128)
					||(check_channel == 132)||(check_channel == 136)||(check_channel == 140))) /*wcl modify for AUTELAN-2765*/
			{
				ret1 = COUNTRY_CODE_SUCCESS;
				max_chanenl = 134;
				min_channel = 7;
			}
			else
			{
				max_chanenl = 5;
				min_channel = 7;
			}	
			break;
			
		default : 
			ret1 = COUNTRY_CODE_SUCCESS;
			break;
	}
	/*11n channel offset check*/
	if((AC_RADIO[RadioID]->Radio_Type & IEEE80211_11N) || (AC_RADIO[RadioID]->Radio_Type & IEEE80211_11AC))
	{
		ret2 = WID_RADIO_CHANNEL_OFFSET_CWMODE_CHECK(RadioID,check_channel,max_chanenl,min_channel);
	}

	if(ret2 == CHANNEL_CWMODE_SUCCESS)
	{
		if (ret1 == COUNTRY_CODE_SUCCESS)
		{
			ret = WID_RADIO_SET_CHAN(RadioID,RadioChan);
		}	
	}
		
	return ret;	
}

int WID_RADIO_SET_CHANNEL_OFFSET(unsigned int RadioID, char policy)
{
	unsigned int max_channel = 0;
	unsigned int min_channel = 0;
	int ret = WID_DBUS_SUCCESS;
	
	WID_CHECK_G_RADIOID_STANDARD_RET(RadioID,RADIO_ID_NOT_EXIST);
	
	if(AC_RADIO[RadioID] == NULL)
	{
		return RADIO_ID_NOT_EXIST;
	}
	
	wid_check_radio_max_min_channel(RadioID,&max_channel,&min_channel);
	
	if(AC_RADIO[RadioID]->isBinddingWlan == 0)
	{
		return WTP_IS_NOT_BINDING_WLAN_ID;
	}
	
	if(((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11N) != IEEE80211_11N)
		&&((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11AC) != IEEE80211_11AC))
	{
		return RADIO_MODE_IS_11N;
	}
	/*zhaoruijia,20100817,4020/40 .start*/
	if((((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11N) == IEEE80211_11N)
			||((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11AC) == IEEE80211_11AC))
		&&((AC_RADIO[RadioID]->cwmode == 0) || (AC_RADIO[RadioID]->cwmode == 3) || (AC_RADIO[RadioID]->cwmode == 5)))
	{
		return RADIO_HT_IS_NOT_40;
	}
	/*zhaoruijia,20100817,40end*/
	/*if the current channel is larger than the max_channel or less than the min_channel ,we dont allow for set channel offset,start*/
	if(policy == 1)
	{               
		if(AC_RADIO[RadioID]->Radio_Chan > max_channel)
		{
			return CHANNEL_CWMODE_HT40;
		}   
	}
	else if(policy == -1)
	{
		if(AC_RADIO[RadioID]->Radio_Chan < min_channel)
		{
			return CHANNEL_CWMODE_HT40;
		}   
	}
	/*if the current channel is larger than the max_channel or less than the min_channel ,we dont allow for set channel offset,end*/
	if(ret == WID_DBUS_SUCCESS)
	{
		if(AC_RADIO[RadioID]->channel_offset == policy)
		{
			return WID_DBUS_SUCCESS;
		}
		else
		{
			AC_RADIO[RadioID]->channel_offset = policy;
			ret = wid_radio_set_channel_Extoffset(RadioID);
		}   
	}
	
	return ret;   
}


int WID_RADIO_SET_CWMMODE(unsigned int RadioID, unsigned short cwmode)
{
	int ret = 0;
	unsigned int max_channel = 0;
	unsigned int min_channel = 0;
	
	WID_CHECK_G_RADIOID_STANDARD_RET(RadioID,RADIO_ID_NOT_EXIST);
	
	wid_check_radio_max_min_channel(RadioID,&max_channel,&min_channel);
	
	if(AC_RADIO[RadioID] == NULL)
	{
		return RADIO_ID_NOT_EXIST;
	}
	if(AC_RADIO[RadioID]->isBinddingWlan == 0)
	{
		//return WTP_IS_NOT_BINDING_WLAN_ID;
	}
	if(((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11N) != IEEE80211_11N)
		&&((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11AC) != IEEE80211_11AC))
	{
		return RADIO_MODE_IS_11N;
	}
	if(((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11AC) != IEEE80211_11AC)
		&&((3 == cwmode) || (4 == cwmode) || (5 == cwmode)))
	{
		return RADIO_MODE_IS_NOT_11AC;
	}
	/*fengwenchao add 20110322,ht20ht20/40,ht40 start*/
	if((AC_RADIO[RadioID]->Radio_Chan > max_channel)
		&&((1 == cwmode) || (2 == cwmode) || (4 == cwmode))
		&&((AC_RADIO[RadioID]->cwmode == 0) || (AC_RADIO[RadioID]->cwmode == 3)))
	{    
		return CHANNEL_CROSS_THE_BORDER;       /**/
	}
	
	/*fengwenchao add 20110322,ht20ht20/40,ht40 end*/ 
	
	/*zhaoruijia,20100825, 40 20/40 20.start*/
	/*zhaoruijia,20101220, 40 20/40 200.start*/
	
	if(((AC_RADIO[RadioID]->channel_offset == 1) || (AC_RADIO[RadioID]->channel_offset == -1))
		&&((0 == cwmode) || (3 == cwmode) || (5 == cwmode)))
	{ 
		AC_RADIO[RadioID]->channel_offset = 0;
	}
	/*zhaoruijia,20101220, 40 20/40 200.end*/
	/*zhaoruijia,20100825, 40 20/40 20.end*/
	/*fengwenchao add 20110421,20 20/4040NONE*/
	if((AC_RADIO[RadioID]->cwmode == 0) && ((1 == cwmode)||(2 == cwmode)||(4 == cwmode)))
	{      
		AC_RADIO[RadioID]->channel_offset = 1;
	}
	/*fengwenchao add end*/
	if(AC_RADIO[RadioID]->cwmode == cwmode)
	{
		return 0;
	}
	else
	{
		AC_RADIO[RadioID]->cwmode = cwmode;
		ret = wid_radio_set_cmmode(RadioID);
		WID_RADIO_CHANGE_SUPPORT_RATE_BYCWMODE_MCS(RadioID);
		ret = wid_radio_change_rate(RadioID);
	}       
	
	return ret;
}

int wid_set_ap_statistics_v1(int WTPID,int apstatics)
{
	msgq msg;
	if((AC_WTP[WTPID] != NULL)&&(AC_WTP[WTPID]->WTPStat == WID_RUN))
	{
		AC_WTP[WTPID]->WTP_Radio[0]->CMD |= 0x0100;
		AC_WTP[WTPID]->CMD->radioid[0] += 1;
		AC_WTP[WTPID]->CMD->setCMD = 1; 
		int WTPIndex = WTPID;
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STATISTICS_REPORT;
			msg.mqinfo.u.WtpInfo.value2 = apstatics;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_info("%s msgsend %s",__func__,strerror(errno));
				perror("msgsnd");
			}
		}		
	}
	return 0;
}

int wid_radio_set_channel_Extoffset(unsigned int RadioID)
{
	msgq msg;
	struct msgqlist *elem;
	//if((gWTPs[AC_RADIO[RadioID]->WTPID].currentState == CW_ENTER_RUN)&&(AC_RADIO[RadioID]->AdStat == 2))
	{
		//return RADIO_IS_DISABLE;
	}

	int WTPIndex = RadioID/L_RADIO_NUM;
	if(AC_WTP[AC_RADIO[RadioID]->WTPID]->WTPStat == WID_RUN)
	{
		AC_RADIO[RadioID]->CMD |= 0x20;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->radioid[AC_RADIO[RadioID]->Radio_L_ID] += 1;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->setCMD = 1;	
		//int WTPIndex = AC_RADIO[RadioID]->WTPID;
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_channel_ext_offset;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
			msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
				perror("msgsnd");
			}

		}
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}
	else if((AC_WTP[WTPIndex] != NULL))
	{
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WTPIndex%THREAD_NUM+1;
		msg.mqinfo.WTPID = WTPIndex;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = Radio_S_TYPE;
		msg.mqinfo.u.RadioInfo.Radio_Op = Radio_channel_ext_offset;
		msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
		msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
	
		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if(elem == NULL)
		{
			wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
			perror("malloc");
			return 0;
		}
		memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
		elem->next = NULL;
		memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
		WID_INSERT_CONTROL_LIST(WTPIndex, elem);
		elem = NULL;
	}
	wid_syslog_debug_debug(WID_DEFAULT,"set radio id is:%d, channel_offset is %d",RadioID,AC_RADIO[RadioID]->channel_offset);

	return 0;
}

#if 0
int wid_radio_set_tx_chainmask(unsigned int RadioID)
{
	//printf("in fuc wid_radio_set_tx_chainmask\n");
	msgq msg;
	struct msgqlist *elem;
	//if((gWTPs[AC_RADIO[RadioID]->WTPID].currentState == CW_ENTER_RUN)&&(AC_RADIO[RadioID]->AdStat == 2))
	{
		//return RADIO_IS_DISABLE;
	}
	//printf("in fuc %d\n",state);
	//printf("in fuc %d\n",AC_RADIO[RadioID]->tx_chainmask_state_value);
	wid_syslog_debug_debug(WID_DEFAULT,"set radio id is:%d, tx_chainmask_state_value %d",RadioID,AC_RADIO[RadioID]->tx_chainmask_state_value);
	int WTPIndex = RadioID/L_RADIO_NUM;
	if(AC_WTP[AC_RADIO[RadioID]->WTPID]->WTPStat == 5)
	{
		AC_RADIO[RadioID]->CMD |= 0x20;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->radioid[AC_RADIO[RadioID]->Radio_L_ID] += 1;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->setCMD = 1;	
		//int WTPIndex = AC_RADIO[RadioID]->WTPID;
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = RAdio_tx_chainmask;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
			msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
				perror("msgsnd");
			}

		}
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}	else if((AC_WTP[WTPIndex] != NULL)){
				memset((char*)&msg, 0, sizeof(msg));
				msg.mqid = WTPIndex%THREAD_NUM+1;
				msg.mqinfo.WTPID = WTPIndex;
				msg.mqinfo.type = CONTROL_TYPE;
				msg.mqinfo.subtype = Radio_S_TYPE;
				msg.mqinfo.u.RadioInfo.Radio_Op = RAdio_tx_chainmask;
				msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
				msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
			
				elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
				if(elem == NULL){
					wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
					perror("malloc");
					return 0;
				}
				memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
				elem->next = NULL;
				memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
				WID_INSERT_CONTROL_LIST(WTPIndex, elem);
				elem = NULL;
			}

	return 0;

}
#endif

/* zhangshu add for set chainmask, 2010-10-09 */
int wid_radio_set_chainmask(unsigned int RadioID, unsigned char type)
{
	msgq msg;
	struct msgqlist *elem = NULL;
	int WTPIndex = RadioID/L_RADIO_NUM;
	
	wid_syslog_debug_debug(WID_DEFAULT,"%s:%d set radio%u-%u chainmask type: %d tx_chainmask_state_value %d rx_chainmask_state_value %d\n",
							__func__,__LINE__,WTPIndex,RadioID%L_RADIO_NUM,type,AC_RADIO[RadioID]->tx_chainmask_state_value,AC_RADIO[RadioID]->rx_chainmask_state_value);
	
	if(AC_WTP[AC_RADIO[RadioID]->WTPID]->WTPStat == WID_RUN)
	{
		AC_RADIO[RadioID]->CMD |= 0x20;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->radioid[AC_RADIO[RadioID]->Radio_L_ID] += 1;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->setCMD = 1;	
		//int WTPIndex = AC_RADIO[RadioID]->WTPID;
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			if(type == 1)
			{
			    msg.mqinfo.u.RadioInfo.Radio_Op = RAdio_tx_chainmask;
			}
			else
			{
			    msg.mqinfo.u.RadioInfo.Radio_Op = RAdio_rx_chainmask;
			}
			msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
			msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
				perror("msgsnd");
			}
		}
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}
	else if((AC_WTP[WTPIndex] != NULL))
	{
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WTPIndex%THREAD_NUM+1;
		msg.mqinfo.WTPID = WTPIndex;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = Radio_S_TYPE;
		if(type == 1)
		{
		    msg.mqinfo.u.RadioInfo.Radio_Op = RAdio_tx_chainmask;
		}
		else
		{
		    msg.mqinfo.u.RadioInfo.Radio_Op = RAdio_rx_chainmask;
		}
		msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
		msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
	
		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if(elem == NULL)
		{
			wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
			perror("malloc");
			return 0;
		}
		memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
		elem->next = NULL;
		memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
		WID_INSERT_CONTROL_LIST(WTPIndex, elem);
		elem = NULL;
	}

	return 0;
}
/* zhangshu add for set chainmask END */


int wid_radio_set_cpe_channel(unsigned int WTPIndex,unsigned char local_radio_id,unsigned int bind_wlan)
{	
	msgq msg;
	struct msgqlist *elem = NULL;
	struct vlan_id *tmp = NULL;

	wid_syslog_debug_debug(WID_DEFAULT,"%s: wtp%d radio %d wlan %d cpe channel set\n",__func__,WTPIndex,local_radio_id,bind_wlan);
	
	if(AC_WTP[WTPIndex]->WTPStat == WID_RUN)
	{
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			if(AC_WTP[WTPIndex]->WTP_Radio[local_radio_id]->cpe_intf[bind_wlan].wlanid != 0)
			{
				tmp = AC_WTP[WTPIndex]->WTP_Radio[local_radio_id]->cpe_intf[bind_wlan].vlanid;
				while(tmp)
				{
					if(tmp->vlanId != 0)
					{
						memset((char*)&msg, 0, sizeof(msg));
						msg.mqid = WTPIndex%THREAD_NUM+1;
						msg.mqinfo.WTPID = WTPIndex;
						msg.mqinfo.type = CONTROL_TYPE;
						msg.mqinfo.subtype = Radio_S_TYPE;
						msg.mqinfo.u.RadioInfo.op = 1;//enable
						msg.mqinfo.u.RadioInfo.Radio_Op = Radio_set_cpe_channel;
						msg.mqinfo.u.RadioInfo.wlanid = AC_WTP[WTPIndex]->WTP_Radio[local_radio_id]->cpe_intf[bind_wlan].wlanid;
						msg.mqinfo.u.RadioInfo.vlan_id = tmp->vlanId;
						msg.mqinfo.u.RadioInfo.Radio_L_ID = local_radio_id;
						msg.mqinfo.u.RadioInfo.Radio_G_ID = AC_WTP[WTPIndex]->WTP_Radio[local_radio_id]->Radio_G_ID;
						if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
						{
							wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
						}		
					}
					tmp=tmp->next;
				}
			}
		}
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}//delete unuseful cod
	else if((AC_WTP[WTPIndex] != NULL) && AC_WTP[WTPIndex]->WTPStat != CW_QUIT)
	{
		if(AC_WTP[WTPIndex]->WTP_Radio[local_radio_id]->cpe_intf[bind_wlan].wlanid != 0)
		{
			tmp = AC_WTP[WTPIndex]->WTP_Radio[local_radio_id]->cpe_intf[bind_wlan].vlanid;
			while(tmp)
			{
				if(tmp->vlanId != 0)
				{
					memset((char*)&msg, 0, sizeof(msg));
					msg.mqid = WTPIndex%THREAD_NUM+1;
					msg.mqinfo.WTPID = WTPIndex;
					msg.mqinfo.type = CONTROL_TYPE;
					msg.mqinfo.subtype = Radio_S_TYPE;
					msg.mqinfo.u.RadioInfo.op = 1;//enable
					msg.mqinfo.u.RadioInfo.Radio_Op = Radio_set_cpe_channel;
					msg.mqinfo.u.RadioInfo.wlanid = AC_WTP[WTPIndex]->WTP_Radio[local_radio_id]->cpe_intf[bind_wlan].wlanid;
					msg.mqinfo.u.RadioInfo.vlan_id = tmp->vlanId;
					msg.mqinfo.u.RadioInfo.Radio_L_ID = local_radio_id;
					msg.mqinfo.u.RadioInfo.Radio_G_ID = AC_WTP[WTPIndex]->WTP_Radio[local_radio_id]->Radio_G_ID;
					elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
					if (NULL == elem)
					{
						WID_MALLOC_ERR();
						return MALLOC_ERROR;
					}
					
					memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
					elem->next = NULL;
					memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
					WID_INSERT_CONTROL_LIST(WTPIndex, elem);
					elem = NULL;	
				}
				tmp = tmp->next;
			}
		}
	}

	return 0;
}


int wid_radio_set_mcs(unsigned int RadioID)
{
	msgq msg;
	//if((gWTPs[AC_RADIO[RadioID]->WTPID].currentState == CW_ENTER_RUN)&&(AC_RADIO[RadioID]->AdStat == 2))
	{
		//return RADIO_IS_DISABLE;
	}

	wid_syslog_debug_debug(WID_DEFAULT,"set radio%d, mcs",RadioID);
	int WTPIndex = AC_RADIO[RadioID]->WTPID;
	if(AC_WTP[AC_RADIO[RadioID]->WTPID]->WTPStat == WID_RUN)
	{
		AC_RADIO[RadioID]->CMD |= 0x20;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->radioid[AC_RADIO[RadioID]->Radio_L_ID] += 1;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->setCMD = 1;	
	//	int WTPIndex = AC_RADIO[RadioID]->WTPID;
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_11N_GI_MCS_CMMODE;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
			msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s", __func__, strerror(errno));
			}
		}
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}
	else if((AC_WTP[WTPIndex] != NULL))
	{
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WTPIndex%THREAD_NUM+1;
		msg.mqinfo.WTPID = WTPIndex;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = Radio_S_TYPE;
		msg.mqinfo.u.RadioInfo.Radio_Op = Radio_11N_GI_MCS_CMMODE;
		msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
		msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
		struct msgqlist *elem;
		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if(elem == NULL)
		{
			WID_MALLOC_ERR();
			return 0;
		}
		memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
		elem->next = NULL;
		memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
		WID_INSERT_CONTROL_LIST(WTPIndex, elem);
		elem = NULL;
	}

	return 0;

}
/*fengwenchao add 20120314 for requirements-407*/
int check_ac_whether_or_not_set_mcs_list(unsigned int WTPIndex,unsigned int l_radioid)
{
	int ret =0;
	int j =0;
	if(AC_WTP[WTPIndex]->WTP_Radio[l_radioid]->chainmask_num == 1)
	{
		if(AC_WTP[WTPIndex]->WTP_Radio[l_radioid]->mcs_count != 8)
		{
			ret = 1;
			return ret;
		}
		for(j=0;j < 8; j++)
		{
			if(AC_WTP[WTPIndex]->WTP_Radio[l_radioid]->mcs_list[j] != j)
			{
				ret = 1;
				return ret;
			}
		}
	}
	else if(AC_WTP[WTPIndex]->WTP_Radio[l_radioid]->chainmask_num == 2)
	{
		if(AC_WTP[WTPIndex]->WTP_Radio[l_radioid]->mcs_count != 16)
		{
			ret = 1;
			return ret;
		}

		for(j=0;j < 16; j++)
		{
			if(AC_WTP[WTPIndex]->WTP_Radio[l_radioid]->mcs_list[j] != j)
			{
				ret = 1;
				return ret;
			}
		}
	}
	else if(AC_WTP[WTPIndex]->WTP_Radio[l_radioid]->chainmask_num == 3)
	{
		if(AC_WTP[WTPIndex]->WTP_Radio[l_radioid]->mcs_count != 24)
		{
			ret = 1;
			return ret;
		}

		for(j=0;j < 24; j++)
		{
			if(AC_WTP[WTPIndex]->WTP_Radio[l_radioid]->mcs_list[j] != j)
			{
				ret = 1;
				return ret;
			}
		}		
	}
	return ret;
}
int wid_radio_set_mcs_list(unsigned int RadioID)
{
	msgq msg;
	int WTPIndex = AC_RADIO[RadioID]->WTPID;
	
	wid_syslog_debug_debug(WID_DEFAULT,"%s:%d radio%d-%d type(%d) %s, set mcs list\n",
							__func__,__LINE__,WTPIndex,RadioID%L_RADIO_NUM,AC_RADIO[RadioID]->Radio_Type,WAI_RADIO_TYPE_STR(AC_RADIO[RadioID]->Radio_Type));
	if(AC_WTP[AC_RADIO[RadioID]->WTPID]->WTPStat == WID_RUN)
	{
		AC_RADIO[RadioID]->CMD |= 0x20;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->radioid[AC_RADIO[RadioID]->Radio_L_ID] += 1;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->setCMD = 1;	
	//	int WTPIndex = AC_RADIO[RadioID]->WTPID;
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_11N_MCS_LIST;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
			msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}
	else if((AC_WTP[WTPIndex] != NULL))
	{
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WTPIndex%THREAD_NUM+1;
		msg.mqinfo.WTPID = WTPIndex;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = Radio_S_TYPE;
		msg.mqinfo.u.RadioInfo.Radio_Op = Radio_11N_MCS_LIST;
		msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
		msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
		struct msgqlist *elem;
		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if(elem == NULL)
		{
			wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
			perror("malloc");
			return 0;
		}
		memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
		elem->next = NULL;
		memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
		WID_INSERT_CONTROL_LIST(WTPIndex, elem);
		elem = NULL;
	}

	return 0;
}
/*fengwenchao add end*/

int wid_radio_set_cmmode(unsigned int RadioID)
{
	msgq msg;
	//if((gWTPs[AC_RADIO[RadioID]->WTPID].currentState == CW_ENTER_RUN)&&(AC_RADIO[RadioID]->AdStat == 2))
	{
		//return RADIO_IS_DISABLE;
	}
	
	wid_syslog_debug_debug(WID_DEFAULT,"%s:%d set radio%d cmmode %s(%d)\n",__func__,__LINE__,RadioID,WAI_RADIO_CWMODE_STR(AC_RADIO[RadioID]->cwmode),AC_RADIO[RadioID]->cwmode);
	int WTPIndex = AC_RADIO[RadioID]->WTPID;
	if(AC_WTP[AC_RADIO[RadioID]->WTPID]->WTPStat == WID_RUN)
	{
		AC_RADIO[RadioID]->CMD |= 0x20;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->radioid[AC_RADIO[RadioID]->Radio_L_ID] += 1;
		AC_WTP[AC_RADIO[RadioID]->WTPID]->CMD->setCMD = 1;	
		//int WTPIndex = AC_RADIO[RadioID]->WTPID;
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_11N_GI_MCS_CMMODE;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
			msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}

		}
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}
	else if((AC_WTP[WTPIndex] != NULL))
	{
		memset((char*)&msg, 0, sizeof(msg));
		msg.mqid = WTPIndex%THREAD_NUM+1;
		msg.mqinfo.WTPID = WTPIndex;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = Radio_S_TYPE;
		msg.mqinfo.u.RadioInfo.Radio_Op = Radio_11N_GI_MCS_CMMODE;
		msg.mqinfo.u.RadioInfo.Radio_L_ID = RadioID%L_RADIO_NUM;
		msg.mqinfo.u.RadioInfo.Radio_G_ID = RadioID;
		struct msgqlist *elem = NULL;
		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if(elem == NULL)
		{
			wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
			return 0;
		}
		memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
		elem->next = NULL;
		memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
		WID_INSERT_CONTROL_LIST(WTPIndex, elem);
		elem = NULL;
	}

	return 0;
}

int wid_radio_change_rate(unsigned int radioid)
{
	msgq msg;
	
	WID_CHECK_G_RADIOID_STANDARD_RET(radioid, RADIO_ID_NOT_EXIST);
	if(NULL == AC_RADIO[radioid])
	{
		return RADIO_ID_NOT_EXIST;
	}
	
	if(AC_WTP[AC_RADIO[radioid]->WTPID]->WTPStat == WID_RUN)
	{
		AC_RADIO[radioid]->CMD |= 0x4;
		AC_WTP[AC_RADIO[radioid]->WTPID]->CMD->radioid[AC_RADIO[radioid]->Radio_L_ID] += 1;
		AC_WTP[AC_RADIO[radioid]->WTPID]->CMD->setCMD = 1;	
		int WTPIndex = AC_RADIO[radioid]->WTPID;
	
		CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
		if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = Radio_S_TYPE;
			msg.mqinfo.u.RadioInfo.Radio_Op = Radio_Rates;
			msg.mqinfo.u.RadioInfo.Radio_L_ID = radioid%L_RADIO_NUM;
			msg.mqinfo.u.RadioInfo.Radio_G_ID = radioid;
			if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
			{
				wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
			}
		}
		CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
	}
	return 0;
}

int WID_BINDING_IF_APPLY_WTP_ipv6_ioctl(unsigned int WtpID, char * ifname)
{
	
	if(AC_WTP[WtpID]->isused == 1)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"*** error this WTP is used and active, you can not binding interface ***\n");
		return WTP_BE_USING;
	}

	int isystemindex = 1;
	int ret;
	int i = 0;
	struct ifi * tmp;
	struct ifi * tmp2;
	struct ifi_info *ifi_tmp = (struct ifi_info*)calloc(1, sizeof(struct ifi_info));
	memset(ifi_tmp->ifi_name,0,sizeof(ifi_tmp->ifi_name));
	strncpy(ifi_tmp->ifi_name,ifname,sizeof(ifi_tmp->ifi_name));

	struct tag_ipv6_addr_list *ipv6list = NULL;
	struct tag_ipv6_addr *ipv6addr = NULL;
	
	if(WID_IF_V6 == NULL)
	{
		//get ipv6 adress
		ipv6list = get_ipv6_addr_list(ifname);
		
		if(ipv6list != NULL)
		{
			//display_ipv6_addr_list(ipv6list);
			tmp = (struct ifi*)malloc(sizeof(struct ifi));
			memset(tmp,0,sizeof(struct ifi));
			memcpy(tmp->ifi_name,ifname,strlen(ifname));
			tmp->ifi_index = ipv6list->ifindex;
			ifi_tmp->ifi_index = ipv6list->ifindex; 
			WID_IF_V6 = tmp;
		}
		else
		{
			free(ifi_tmp->ifi_addr6);
			ifi_tmp->ifi_addr6 = NULL;
			free(ifi_tmp);
			ifi_tmp = NULL;
			free_ipv6_addr_list(ipv6list);
			return -1;
		}
		
		ipv6addr = ipv6list->ipv6list;
			
		ifi_tmp->ifi_addr6 = (struct sockaddr*)calloc(1, sizeof(struct sockaddr_in6));
		isystemindex = ipv6list->ifindex;

		for(i=0; i<ipv6list->ipv6num; i++)
		{
			inet_pton(AF_INET6, (char*)ipv6addr->ipv6addr, &(((struct sockaddr_in6*)ifi_tmp->ifi_addr6)->sin6_addr));
			ret = ipv6_bind_interface_for_wid(ifi_tmp,CW_CONTROL_PORT);
			//ret = ipv6_bind_interface_for_wid(ifi_tmp,CW_CONTROL_PORT_AU);
			WIDWsm_VRRPIFOp_IPv6(ifi_tmp,VRRP_REG_IF);
			ipv6addr = ipv6addr->next;
		}	

		if(ipv6list->ipv6num == 0)
		{
			free(ifi_tmp->ifi_addr6);
			ifi_tmp->ifi_addr6 = NULL;
			free(ifi_tmp);
			ifi_tmp = NULL;
			free_ipv6_addr_list(ipv6list);
			return ret;
		}
		
	}
	else
	{
		tmp = WID_IF_V6;
		while(tmp != NULL)
		{
			printf("ifname = %s name = %s\n",tmp->ifi_name,ifname);
			if(( strlen(ifname) ==	strlen(tmp->ifi_name))&&(strcmp(tmp->ifi_name,ifname)==0))
			{	
				free(ifi_tmp->ifi_addr6);
				ifi_tmp->ifi_addr6 = NULL;
				free(ifi_tmp);
				ifi_tmp = NULL;
				free_ipv6_addr_list(ipv6list);

				if(AC_WTP[WtpID] != NULL)
				{
					
					AC_WTP[WtpID]->BindingSystemIndex= tmp->ifi_index;
					//printf("AC_WTP[WtpID]->BindingSystemIndex = %d\n",AC_WTP[WtpID]->BindingSystemIndex);
					AC_WTP[WtpID]->isipv6addr = 1;
					memset(AC_WTP[WtpID]->BindingIFName, 0, ETH_IF_NAME_LEN);
					memcpy(AC_WTP[WtpID]->BindingIFName,ifname, strlen(ifname));
					
					wid_syslog_debug_debug(WID_DEFAULT,"*** binding iterface name to wtp success ***\n");
					return 0;
				}
				else
				{
					wid_syslog_debug_debug(WID_DEFAULT,"*** can't binding iterface name, please make sure you have create wtp ***\n");
					return WTP_ID_NOT_EXIST;
				}
				
				return 0;
			}
			tmp = tmp->ifi_next;
		}

		//get ipv6 address list
		
		ipv6list = get_ipv6_addr_list(ifname);
		
		if(ipv6list != NULL)
		{
			display_ipv6_addr_list(ipv6list);
			tmp = (struct ifi*)malloc(sizeof(struct ifi));
			memset(tmp,0,sizeof(struct ifi));
			memcpy(tmp->ifi_name,ifname,strlen(ifname));
			tmp->ifi_index = ipv6list->ifindex;
			ifi_tmp->ifi_index = ipv6list->ifindex;
			tmp2 = WID_IF_V6;
			WID_IF_V6 = tmp;
			WID_IF_V6->ifi_next = tmp2;	

		}
		else
		{
			free(ifi_tmp->ifi_addr6);
			ifi_tmp->ifi_addr6 = NULL;
			free(ifi_tmp);
			ifi_tmp = NULL;
			free_ipv6_addr_list(ipv6list);
			return -1;
		}

		ipv6addr = ipv6list->ipv6list;
			
		ifi_tmp->ifi_addr6 = (struct sockaddr*)calloc(1, sizeof(struct sockaddr_in6));
		isystemindex = ipv6list->ifindex;

		
		for(i=0; i<ipv6list->ipv6num; i++)
		{
			inet_pton(AF_INET6, (char*)ipv6addr->ipv6addr, &(((struct sockaddr_in6*)ifi_tmp->ifi_addr6)->sin6_addr));
			ret = ipv6_bind_interface_for_wid(ifi_tmp,CW_CONTROL_PORT);
			//ret = ipv6_bind_interface_for_wid(ifi_tmp,CW_CONTROL_PORT_AU);
			WIDWsm_VRRPIFOp_IPv6(ifi_tmp,VRRP_REG_IF);
			ipv6addr = ipv6addr->next;
		}	

		if(ipv6list->ipv6num == 0)
		{
			free(ifi_tmp->ifi_addr6);
			ifi_tmp->ifi_addr6 = NULL;
			free(ifi_tmp);
			ifi_tmp = NULL;
			free_ipv6_addr_list(ipv6list);
			return ret;
		}

	
	}	
		
	gInterfacesCount = CWNetworkCountInterfaceAddresses(&gACSocket);
	gInterfacesCountIpv4 = CWNetworkCountInterfaceAddressesIpv4(&gACSocket);
	gInterfacesCountIpv6 = CWNetworkCountInterfaceAddressesIpv6(&gACSocket);
	free(ifi_tmp->ifi_addr6);
	ifi_tmp->ifi_addr6 = NULL;
	free(ifi_tmp);
	ifi_tmp = NULL;
	free_ipv6_addr_list(ipv6list);

	if(ret != 0)
	return ret;

	
	if(AC_WTP[WtpID] != NULL)
	{
		
		AC_WTP[WtpID]->BindingSystemIndex= isystemindex;
		AC_WTP[WtpID]->isipv6addr = 1;
		memset(AC_WTP[WtpID]->BindingIFName, 0, ETH_IF_NAME_LEN);
		memcpy(AC_WTP[WtpID]->BindingIFName,ifname, strlen(ifname));
		
		wid_syslog_debug_debug(WID_DEFAULT,"*** binding iterface name to wtp success ***\n");
		return 0;
	}
	else
	{
		wid_syslog_debug_debug(WID_DEFAULT,"*** can't binding iterface name, please make sure you have create wtp ***\n");
		return WTP_ID_NOT_EXIST;
	}
		
}

int WID_ADD_IF_APPLY_WLAN_ipv6_ioctl(unsigned char WlanID, char * ifname)
{
	struct ifreq ifr;
	struct ifi *wif = NULL;
	struct ifi *wifnext = NULL;	
	struct ifi * tmp = NULL;
	struct ifi * tmp2 = NULL;
	int i = 0;
	int ret = 0;
	int isystemindex = 0;
	struct ifi_info *ifi_tmp = NULL;
	struct tag_ipv6_addr_list *ipv6list = NULL;
	struct tag_ipv6_addr *ipv6addr = NULL;
	
	if(!ifname)
	{
		wid_syslog_err("%s line %d ifname NULL pointer!\n",__func__,__LINE__);
		return PARAM_NULL_POINTER;
	}
	if(!check_wlanid_func(WlanID))
	{
		wid_syslog_err("%s line %d WlanID %d out of bounds!\n",\
			__func__,__LINE__,WlanID);
		return WLAN_ID_NOT_EXIST;
	}
	if(AC_WLAN[WlanID]->Status == 0)
	{
		return WLAN_BE_ENABLE;
	}	
	
	ret = Check_And_Bind_Interface_For_WID(ifname);
	if(ret != 0)
		return ret;
		
	ifi_tmp = (struct ifi_info*)calloc(1, sizeof(struct ifi_info));
	if(!ifi_tmp)
	{	
		wid_syslog_err("%s line %d calloc failed!\n", __func__, __LINE__);
		return MALLOC_ERROR;
	}
	memset(ifi_tmp->ifi_name,0,sizeof(ifi_tmp->ifi_name));
	strncpy(ifi_tmp->ifi_name,ifname,sizeof(ifi_tmp->ifi_name));
	
	ifi_tmp->ifi_addr6 = (struct sockaddr*)calloc(1, sizeof(struct sockaddr_in6));
	if(!ifi_tmp->ifi_addr6)
	{
		wid_syslog_err("%s line %d calloc failed!\n", __func__, __LINE__);
		CW_FREE_OBJECT(ifi_tmp);
		return MALLOC_ERROR;
	}
	
	if(WID_IF_V6 == NULL)
	{
		//printf("get addr before\n");
		ipv6list = get_ipv6_addr_list(ifname);
		
		if(ipv6list != NULL)
		{
			//display_ipv6_addr_list(ipv6list);
			tmp = (struct ifi*)malloc(sizeof(struct ifi));
			memset(tmp,0,sizeof(struct ifi));
			memcpy(tmp->ifi_name,ifname,strlen(ifname));
			
			tmp->ifi_index = ipv6list->ifindex;
			ifi_tmp->ifi_index  = ipv6list->ifindex;
			printf("tmp->ifi_index = %d\n",tmp->ifi_index);
			tmp->isipv6addr = 1;
			WID_IF_V6 = tmp;
		}
		else
		{
			CW_FREE_OBJECT(ifi_tmp->ifi_addr6);
			CW_FREE_OBJECT(ifi_tmp);
			free_ipv6_addr_list(ipv6list);
			return -1;
		}
		
		ipv6addr = ipv6list->ipv6list;

		isystemindex = ipv6list->ifindex;

		for(i = 0; i < ipv6list->ipv6num; i++)
		{
			inet_pton(AF_INET6, (char*)ipv6addr->ipv6addr, &(((struct sockaddr_in6*)ifi_tmp->ifi_addr6)->sin6_addr));
			ret = ipv6_bind_interface_for_wid(ifi_tmp,CW_CONTROL_PORT);
			//ret = ipv6_bind_interface_for_wid(ifi_tmp,CW_CONTROL_PORT_AU);
			WIDWsm_VRRPIFOp_IPv6(ifi_tmp,VRRP_REG_IF);
			ipv6addr = ipv6addr->next;
		}	

		if(ipv6list->ipv6num == 0)
		{
			free(ifi_tmp->ifi_addr6);
			ifi_tmp->ifi_addr6 = NULL;
			free(ifi_tmp);
			ifi_tmp = NULL;
			free_ipv6_addr_list(ipv6list);
			return ret;
		}
	}
	else
	{
		tmp = WID_IF_V6;
		while(tmp != NULL)
		{
			if((strlen(ifname) == strlen(tmp->ifi_name))&&(strcmp(tmp->ifi_name,ifname)==0))
			{
				/*wcl add*/
				ipv6list = get_ipv6_addr_list(ifname);
				tmp->ifi_index = ipv6list->ifindex;
				/*end*/				
				isystemindex = tmp->ifi_index;
				break;
			}
			tmp = tmp->ifi_next;
		}

		if(tmp == NULL)
		{
			ipv6list = get_ipv6_addr_list(ifname);
			
			if(ipv6list != NULL)
			{
				display_ipv6_addr_list(ipv6list);
				tmp = (struct ifi*)malloc(sizeof(struct ifi));
				memset(tmp,0,sizeof(struct ifi));
				memcpy(tmp->ifi_name,ifname,strlen(ifname));
				tmp->ifi_index = ipv6list->ifindex;
				ifi_tmp->ifi_index = ipv6list->ifindex;
				tmp->isipv6addr = 1;
				tmp2 = WID_IF_V6;
				WID_IF_V6 = tmp;
				WID_IF_V6->ifi_next = tmp2;
			}
			else
			{
				CW_FREE_OBJECT(ifi_tmp->ifi_addr6);
				CW_FREE_OBJECT(ifi_tmp);
				free_ipv6_addr_list(ipv6list);
				return -1;
			}
			ipv6addr = ipv6list->ipv6list;
			
			isystemindex = ipv6list->ifindex;
			for(i = 0; i < ipv6list->ipv6num; i++)
			{
				inet_pton(AF_INET6, (char*)ipv6addr->ipv6addr, &(((struct sockaddr_in6*)ifi_tmp->ifi_addr6)->sin6_addr));
				ret = ipv6_bind_interface_for_wid(ifi_tmp,CW_CONTROL_PORT);
				//ret = ipv6_bind_interface_for_wid(ifi_tmp,CW_CONTROL_PORT_AU);
				WIDWsm_VRRPIFOp_IPv6(ifi_tmp,VRRP_REG_IF);
				ipv6addr = ipv6addr->next;
			}	

			if(ipv6list->ipv6num == 0)
			{
				CW_FREE_OBJECT(ifi_tmp->ifi_addr6);
				CW_FREE_OBJECT(ifi_tmp);
				free_ipv6_addr_list(ipv6list);
				return ret;
			}
		}
	}	
		
	gInterfacesCount = CWNetworkCountInterfaceAddresses(&gACSocket);
	gInterfacesCountIpv4 = CWNetworkCountInterfaceAddressesIpv4(&gACSocket);
	gInterfacesCountIpv6 = CWNetworkCountInterfaceAddressesIpv6(&gACSocket);
	CW_FREE_OBJECT(ifi_tmp->ifi_addr6);
	CW_FREE_OBJECT(ifi_tmp);
	free_ipv6_addr_list(ipv6list);

	if(ret != 0)
    	return ret;

	ifr.ifr_ifindex = isystemindex;

	wif = (struct ifi*)malloc(sizeof(struct ifi));
	memset(wif->ifi_name,0,ETH_IF_NAME_LEN);
	memcpy(wif->ifi_name,ifname,strlen(ifname));
	wif->ifi_index = ifr.ifr_ifindex;
	printf("wif->ifi_index = %d\n",wif->ifi_index);
	wif->nas_id_len = 0;//zhanglei add
	memset(wif->nas_id,0,NAS_IDENTIFIER_NAME);//zhanglei add
	wif->ifi_next = NULL;
	wif->isipv6addr = 1;
	
	if(AC_WLAN[WlanID]->Wlan_Ifi == NULL)
	{
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d wlan%d binding ifname:%s sysindex:%d**\n",__func__,__LINE__,WlanID,ifname,wif->ifi_index);
		AC_WLAN[WlanID]->Wlan_Ifi = wif ;
		AC_WLAN[WlanID]->Wlan_Ifi->ifi_next = NULL;
	}
	else
	{
		wifnext = AC_WLAN[WlanID]->Wlan_Ifi;
		while(wifnext != NULL)
		{	
			if(wifnext->ifi_index == wif->ifi_index)
			{
				//printf("warnning you have binding this wlan eth ,please do not binding this again");
				CW_FREE_OBJECT(wif);
				return 0;
			}
			wifnext = wifnext->ifi_next;
		}
		
		wid_syslog_debug_debug(WID_DEFAULT,"%s:%d wlan%d binding ifname:%s sysindex:%d**\n",__func__,__LINE__,WlanID,ifname,wif->ifi_index);
		wifnext = AC_WLAN[WlanID]->Wlan_Ifi;
		while(wifnext->ifi_next!= NULL)
		{	
			wifnext = wifnext->ifi_next;
		}
		
		wifnext->ifi_next= wif;
		//wifnext->ifi_next = NULL;
	}
	AC_WLAN[WlanID]->ifcount++;

	//add wlan to the auto ap login if list
	if((g_auto_ap_login.ifnum != 0)||(g_auto_ap_login.auto_ap_if != NULL))
	{
		int i = 0;
		int result = 0;
		wid_auto_ap_if *iflist = NULL;
		iflist = g_auto_ap_login.auto_ap_if;
		while(iflist != NULL)
		{
			if(iflist->ifindex == ifr.ifr_ifindex)
			{
				if(iflist->wlannum >= L_BSS_NUM)
				{
					//printf("interface %s has already binded to %d wlan\n",ifname,L_BSS_NUM);
					break;
				}
				else
				{
					for(i=0;i<L_BSS_NUM;i++)
					{
						if(iflist->wlanid[i] == WlanID)
						{
							//printf("wlan %d has already in the list\n",WlanID);
							result = 1;
							break;
						}
					}
					if(result != 1)
					{
						for(i = 0; i < L_BSS_NUM; i++)
						{
							if(iflist->wlanid[i] == 0)
							{
								iflist->wlanid[i] = WlanID;
								iflist->wlannum++;
								result = 1;
								//printf("add wlan %d at i %d\n",WlanID,i);
								break;
							}
						}
					}
				}
			}
			iflist = iflist->ifnext;		
		}
		if(result == 0)
		{
			//printf("interface %s is not in the auto ap login list\n",ifname);
		}
	}
	
	return 0;
}

int wid_set_ethereal_bridge_add_uplink(unsigned int ID,char *ifname)

{

	int ret = 0;
	int reason = 0;
	char ebrname[ETH_IF_NAME_LEN];
	char syscmd[WID_SYSTEM_CMD_LENTH];
	WTPQUITREASON quitreason = WTP_INIT;
		
	memset(ebrname,0,ETH_IF_NAME_LEN);
	memset(syscmd,0,WID_SYSTEM_CMD_LENTH);
	if(local)
		sprintf(ebrname,"ebrl%d-%d-%d",slotid,vrrid,ID);
	else
		sprintf(ebrname,"ebr%d-%d-%d",slotid,vrrid,ID);		
	ret = Check_Interface_Exist(ebrname,&quitreason);
	if(ret != WID_DBUS_SUCCESS)
	{
		return WID_EBR_ERROR;
	}
	
	ret = Check_Interface_Exist(ifname,&quitreason);
	if(ret != WID_DBUS_SUCCESS)
	{
		return ret;
	}	
	
	EBR_IF_LIST *ebrif = WID_EBR[ID]->iflist;

	if(ebrif == NULL)
	{
		return WID_EBR_IF_NOEXIT;
	}
	else
	{
		while(ebrif != NULL)
		{	
			if((strlen(ifname) == strlen(ebrif->ifname))&&(strncmp(ebrif->ifname,ifname,strlen(ifname)) == 0))
			{
				break;
			}
			ebrif = ebrif->ifnext;
		}
	}
	
	if(ebrif == NULL)
	{
		return WID_EBR_IF_NOEXIT;
	}

	
	sprintf(syscmd,"brctl adduplink %s %s",ebrname,ifname);

	ret = system(syscmd);
	reason = WEXITSTATUS(ret);
	if(reason == WID_DBUS_SUCCESS)
	{
		EBR_IF_LIST *wif;
		EBR_IF_LIST *wifnext;
		
		wif = (EBR_IF_LIST *)malloc(sizeof(EBR_IF_LIST));
		memset(wif,0,sizeof(EBR_IF_LIST));
		wif->ifname = (char *)malloc(ETH_IF_NAME_LEN);
		memset(wif->ifname,0,ETH_IF_NAME_LEN);
		memcpy(wif->ifname,ifname,strlen(ifname));
		wif->ifnext = NULL;
		
		if(WID_EBR[ID]->uplinklist== NULL)
		{
			WID_EBR[ID]->uplinklist = wif ;
			WID_EBR[ID]->uplinklist->ifnext = NULL;
		}
		else
		{
			wifnext = WID_EBR[ID]->uplinklist;
			while(wifnext != NULL)
			{	
				if((strlen(ifname) == strlen(wifnext->ifname))&&(strncmp(wifnext->ifname,ifname,strlen(ifname)) == 0))
				{
					free(wif->ifname);
					free(wif);
					wif = NULL;
					return 0;
				}
				wifnext = wifnext->ifnext;
			}

			wifnext = WID_EBR[ID]->uplinklist;
			while(wifnext->ifnext != NULL)
			{	
				wifnext = wifnext->ifnext;
			}
			
			wifnext->ifnext = wif;
			
		}
		return 0;
	}
	else
	{
		return SYSTEM_CMD_ERROR;
	}
	
}

int wid_set_ethereal_bridge_del_uplink(unsigned int ID,char *ifname)
{
	int ret = 0;
	int reason = 0;
	char ebrname[ETH_IF_NAME_LEN];
	char syscmd[WID_SYSTEM_CMD_LENTH];
	WTPQUITREASON quitreason = WTP_INIT;
		
	memset(ebrname,0,ETH_IF_NAME_LEN);
	memset(syscmd,0,WID_SYSTEM_CMD_LENTH);
	if(local)
		sprintf(ebrname,"ebrl%d-%d-%d",slotid,vrrid,ID);
	else
		sprintf(ebrname,"ebr%d-%d-%d",slotid,vrrid,ID);		
	ret = Check_Interface_Exist(ebrname,&quitreason);
	if(ret != WID_DBUS_SUCCESS)
	{
		return ret;
	}
	
	ret = Check_Interface_Exist(ifname,&quitreason);
	if(ret != WID_DBUS_SUCCESS)
	{
		return ret;
	}
	
	EBR_IF_LIST *ebrif = WID_EBR[ID]->uplinklist;

	if(ebrif == NULL)
	{
		return WID_EBR_IF_NOEXIT;
	}
	else
	{
		while(ebrif != NULL)
		{	
			if((strlen(ifname) == strlen(ebrif->ifname))&&(strncmp(ebrif->ifname,ifname,strlen(ifname)) == 0))
			{
				break;
			}
			ebrif = ebrif->ifnext;
		}
	}
	
	if(ebrif == NULL)
	{
		return WID_EBR_IF_NOEXIT;
	}

	sprintf(syscmd,"brctl deluplink %s %s",ebrname,ifname);

	ret = system(syscmd);
	reason = WEXITSTATUS(ret);

	if(reason == WID_DBUS_SUCCESS)
	{
		EBR_IF_LIST *wif;
		EBR_IF_LIST *wifnext;

		wifnext = WID_EBR[ID]->uplinklist;
		
		if(WID_EBR[ID]->uplinklist != NULL)
		{
			if((strlen(ifname) == strlen(wifnext->ifname))&&(strncmp(wifnext->ifname,ifname,strlen(ifname)) == 0))
			{
				WID_EBR[ID]->uplinklist = wifnext->ifnext;
				free(wifnext->ifname);
				free(wifnext);
				wifnext = NULL;		
			}
			else
			{
				while(wifnext->ifnext != NULL)
				{	
					if((strlen(ifname) == strlen(wifnext->ifnext->ifname))&&(strncmp(wifnext->ifnext->ifname,ifname,strlen(ifname)) == 0))
					{
						wif = wifnext->ifnext;
						wifnext->ifnext = wifnext->ifnext->ifnext;
						free(wif->ifname);
						free(wif);
						wif = NULL;				
						return 0;
					}
					wifnext = wifnext->ifnext;
				}
			}
		}
		return 0;
	}
	else
	{
		return SYSTEM_CMD_ERROR;
	}
}
int wid_wds_remote_bridge_mac_op(int RadioID, int is_add, unsigned char *mac)
{
	struct wds_rbmac * tmp; 
	struct wds_rbmac * tmp1;

	if(AC_RADIO[RadioID] == NULL){
		return RADIO_ID_NOT_EXIST;
	}
	if(is_add == 1){
		if(AC_RADIO[RadioID]->rbmac_list == NULL)
		{
			tmp = (struct wds_rbmac *)malloc(sizeof(struct wds_rbmac));
			memset(tmp,0,sizeof(struct wds_rbmac));
			memcpy(tmp->mac,mac,MAC_LEN);
			AC_RADIO[RadioID]->rbmac_list = tmp;
			AC_RADIO[RadioID]->rbmacNum++;
			tmp = NULL;
		}else{
			tmp = AC_RADIO[RadioID]->rbmac_list; 
			while((memcmp(tmp->mac,mac,MAC_LEN)!=0)&&(tmp->next != NULL)){
				tmp = tmp->next;
			}
			if(memcmp(tmp->mac,mac,MAC_LEN)==0)
				return 0;
			tmp1 = (struct wds_rbmac *)malloc(sizeof(struct wds_rbmac));
			memset(tmp1,0,sizeof(struct wds_rbmac));
			memcpy(tmp1->mac,mac,MAC_LEN);
			tmp->next = tmp1;
			AC_RADIO[RadioID]->rbmacNum++;
		}
	}else{
		if(AC_RADIO[RadioID]->rbmac_list == NULL)
			return 0;
		tmp = AC_RADIO[RadioID]->rbmac_list;
		if((memcmp(tmp->mac,mac,MAC_LEN) == 0)){
			AC_RADIO[RadioID]->rbmac_list = tmp->next;
			free(tmp);
			tmp = NULL;
			AC_RADIO[RadioID]->rbmacNum--;
			return 0;
		}
		while(tmp->next){
			tmp1 = tmp->next;
			if(memcmp(tmp1->mac,mac,MAC_LEN) == 0){
				tmp->next = tmp1->next;
				free(tmp1);
				tmp1 = NULL;
				AC_RADIO[RadioID]->rbmacNum--;
				return 0;
			}
			tmp = tmp->next;
		}		

	}
	return 0;
}

int wid_wds_remote_bridge_mac_set_aes_key(int RadioID, unsigned char *mac, char *key)
{
	struct wds_rbmac * tmp; 

	if(AC_RADIO[RadioID] == NULL){
		return RADIO_ID_NOT_EXIST;
	}
	if(AC_RADIO[RadioID]->rbmac_list == NULL)
	{
		return RADIO_BRMAC_NOT_EXIST;
	}else{
		tmp = AC_RADIO[RadioID]->rbmac_list; 
		while((tmp != NULL)){
			if(memcmp(tmp->mac,mac,MAC_LEN)==0){
				memset(tmp->key, 0, 32);
				memcpy(tmp->key, key, 32);
				return 0;
			}
			tmp = tmp->next;
		}		
	}
	
	return RADIO_BRMAC_NOT_EXIST;
}



void wid_wtp_radio_extern_command_check(unsigned int WTPIndex,int L_Radio_ID)
{
	unsigned int RadioID = WTPIndex*L_RADIO_NUM+L_Radio_ID;
	char buf[DEFAULT_LEN];
	int len = 0;
	int s_id = 0;
	int s_state = 0;
	struct wds_rbmac *tmp = NULL;
	if(AC_RADIO[RadioID] == NULL){
		return;
	}
	if(AC_RADIO[RadioID]->distance != 0){
		memset(buf,0,DEFAULT_LEN);
		sprintf(buf,"set wbeDistance %d",AC_RADIO[RadioID]->distance);
		wid_syslog_debug_debug(WID_DEFAULT,"cmd buf %s\n",buf);
		wid_radio_set_extension_command(WTPIndex,buf);
	}
	tmp = AC_RADIO[RadioID]->rbmac_list;
	if(AC_RADIO[RadioID]->cipherType == 1){
		memset(buf,0,DEFAULT_LEN);
		sprintf(buf,"set cipher wep");
		wid_syslog_debug_debug(WID_DEFAULT,"cmd buf %s\n",buf);
		wid_radio_set_extension_command(WTPIndex,buf);		
		memset(buf,0,DEFAULT_LEN);
		len = strlen(AC_RADIO[RadioID]->wepkey);
		if(len > 0){
			if((len == 5)||(len == 10)){
				len = 40;
			}
			else if((len == 13)||(len == 26)){
				len = 104;
			}
			sprintf(buf,"set key 1 %d %s",len,AC_RADIO[RadioID]->wepkey); 		
			wid_syslog_debug_debug(WID_DEFAULT,"cmd buf %s\n",buf);
			wid_radio_set_extension_command(WTPIndex,buf);
		}
	}
	if(AC_RADIO[RadioID]->cipherType == 2){
		memset(buf,0,DEFAULT_LEN);
		sprintf(buf,"set cipher aes");
		wid_syslog_debug_debug(WID_DEFAULT,"cmd buf %s\n",buf);
		wid_radio_set_extension_command(WTPIndex,buf);		
		memset(buf,0,DEFAULT_LEN);
	}	
	while(tmp){
		memset(buf,0,DEFAULT_LEN);
		sprintf(buf,"add remoteWbr %02x:%02x:%02x:%02x:%02x:%02x",tmp->mac[0],tmp->mac[1],tmp->mac[2],tmp->mac[3],tmp->mac[4],tmp->mac[5]);
		wid_syslog_debug_debug(WID_DEFAULT,"cmd buf %s\n",buf);
		wid_radio_set_extension_command(WTPIndex,buf);
		if(AC_RADIO[RadioID]->cipherType == 2){
			memset(buf,0,DEFAULT_LEN);
			sprintf(buf,"set bridgekey %02x:%02x:%02x:%02x:%02x:%02x %s",tmp->mac[0],tmp->mac[1],tmp->mac[2],tmp->mac[3],tmp->mac[4],tmp->mac[5],tmp->key);
			wid_syslog_debug_debug(WID_DEFAULT,"cmd buf %s\n",buf);
			wid_radio_set_extension_command(WTPIndex,buf);
		}
		tmp = tmp->next;
	}
	if(AC_RADIO[RadioID]->supper_g.supper_g_type & 0x1){
		memset(buf,0,DEFAULT_LEN);
		sprintf(buf,"set bursting enable");
		wid_syslog_debug_debug(WID_DEFAULT,"cmd buf %s\n",buf);
		wid_radio_set_extension_command(WTPIndex,buf);		
	}
	if(AC_RADIO[RadioID]->supper_g.supper_g_type & 0x2){
		memset(buf,0,DEFAULT_LEN);
		sprintf(buf,"set fastFrame enable");
		wid_syslog_debug_debug(WID_DEFAULT,"cmd buf %s\n",buf);
		wid_radio_set_extension_command(WTPIndex,buf);		
	}
	if(AC_RADIO[RadioID]->supper_g.supper_g_type & 0x4){
		memset(buf,0,DEFAULT_LEN);
		sprintf(buf,"set compression enable");
		wid_syslog_debug_debug(WID_DEFAULT,"cmd buf %s\n",buf);
		wid_radio_set_extension_command(WTPIndex,buf);		
	}
	
	if(AC_RADIO[RadioID]->sector_state_value != 0){
		memset(buf,0,DEFAULT_LEN);
		sprintf(buf,"set sector %x",AC_RADIO[RadioID]->sector_state_value);
		wid_syslog_debug_debug(WID_DEFAULT,"wid_set_sector apcmd %s\n",buf);
		wid_radio_set_extension_command(WTPIndex,buf);
	}
	{
		for(s_id=0;s_id<4;s_id++){
			s_state += AC_RADIO[RadioID]->sector[s_id]->state;
		}
		if(s_state == 4){
			memset(buf,0,DEFAULT_LEN);
			sprintf(buf,"set power all %d",AC_RADIO[RadioID]->sector[0]->tx_power);
			wid_radio_set_extension_command(WTPIndex,buf);
		}else if(s_state < 4){
			
			 /* coverity-CID: 10133 Out-of-bounds read */ 
			for(s_id = 0; s_id < 4; s_id++)
			{
				if(AC_RADIO[RadioID]->sector[s_id]->state)
				{
					memset(buf,0,DEFAULT_LEN);
					sprintf(buf,"set power %d %d",s_id,AC_RADIO[RadioID]->sector[s_id]->tx_power);
					wid_radio_set_extension_command(WTPIndex,buf);
				}
			}
		}
	}
	/*countr code for a8*/
	{
		if(gCOUNTRYCODE == COUNTRY_USA_US){
			memset(buf,0,DEFAULT_LEN);
			sprintf(buf,"set regdmn FCC");	
		}
		else if(gCOUNTRYCODE == COUNTRY_EUROPE_EU){
			memset(buf,0,DEFAULT_LEN);
			sprintf(buf,"set regdmn ETSI");	
		}
		else {
			memset(buf,0,DEFAULT_LEN);
			sprintf(buf,"set regdmn RoW");	
		}
		wid_radio_set_extension_command(WTPIndex,buf);
	}

	if(AC_RADIO[RadioID]->inter_vap_able == 1){
		memset(buf,0,DEFAULT_LEN);
		sprintf(buf,"set interVF enable");	
		wid_radio_set_extension_command(WTPIndex,buf);
		wid_syslog_debug_debug(WID_DEFAULT,"cmd buf %s\n",buf);
	}
	if(AC_RADIO[RadioID]->intra_vap_able == 1){
		memset(buf,0,DEFAULT_LEN);
		sprintf(buf,"set intraVF enable");	
		wid_radio_set_extension_command(WTPIndex,buf);
		wid_syslog_debug_debug(WID_DEFAULT,"cmd buf %s\n",buf);
	}

	
	if(AC_RADIO[RadioID]->keep_alive_period != 3600){
		memset(buf,0,DEFAULT_LEN);
		sprintf(buf,"set keepaliveperiod %d",AC_RADIO[RadioID]->keep_alive_period);	
		wid_radio_set_extension_command(WTPIndex,buf);
		wid_syslog_debug_debug(WID_DEFAULT,"cmd buf %s\n",buf);
	}
	if(AC_RADIO[RadioID]->keep_alive_idle_time != 3600){
		memset(buf,0,DEFAULT_LEN);
		sprintf(buf,"set keepaliveidletime %d",AC_RADIO[RadioID]->keep_alive_idle_time);	
		wid_radio_set_extension_command(WTPIndex,buf);
		wid_syslog_debug_debug(WID_DEFAULT,"cmd buf %s\n",buf);
	}

	
	if(AC_RADIO[RadioID]->congestion_avoidance == 1){
		memset(buf,0,DEFAULT_LEN);
		sprintf(buf,"set caScheme tail-drop");	
		wid_radio_set_extension_command(WTPIndex,buf);
		wid_syslog_debug_debug(WID_DEFAULT,"cmd buf %s\n",buf);
	}
	if(AC_RADIO[RadioID]->congestion_avoidance == 2){
		memset(buf,0,DEFAULT_LEN);
		sprintf(buf,"set caScheme RED");	
		wid_radio_set_extension_command(WTPIndex,buf);
		wid_syslog_debug_debug(WID_DEFAULT,"cmd buf %s\n",buf);
	}
	if(AC_RADIO[RadioID]->congestion_avoidance == 3){
		memset(buf,0,DEFAULT_LEN);
		sprintf(buf,"set caScheme FWRED");	
		wid_radio_set_extension_command(WTPIndex,buf);
		wid_syslog_debug_debug(WID_DEFAULT,"cmd buf %s\n",buf);
	}
	
	return ;
}
/*---------------------BEGIN-------------------------------
---------------liuzhenhua append for wid show fdb--------------*/
static inline void __jiffies_to_tv(struct timeval *tv, unsigned long jiffies)
{
	unsigned long long tvusec;

	tvusec = 10000ULL*jiffies;
	tv->tv_sec = tvusec/1000000;
	tv->tv_usec = tvusec - 1000000 * tv->tv_sec;
}
static inline void __copy_fdb(struct fdb_entry *ent, 
			      const struct __fdb_entry *f)
{
	memcpy(ent->mac_addr, f->mac_addr, 6);
	ent->port_no = ((f->port_hi << 8)|f->port_no);
	ent->is_local = f->is_local;
	__jiffies_to_tv(&ent->ageing_timer_value, f->ageing_timer_value);
}

int br_read_fdb(const char *bridge, struct fdb_entry *fdbs, 
		unsigned long offset, int num)
{
	FILE *f = NULL;
	int i = 0, n = 0;
    struct __fdb_entry fe[WID_READ_FDB_CHUNK];
	char path[SYSFS_PATH_MAX] = {0};
	
    /* coverity-CID: 10221 Uninitialized scalar variable*/
    memset(fe, 0, sizeof(struct __fdb_entry)*WID_READ_FDB_CHUNK);
    if(num > WID_READ_FDB_CHUNK)
	{
		num = WID_READ_FDB_CHUNK;
	}
        
	/* open /sys/class/net/brXXX/brforward */
	snprintf(path, SYSFS_PATH_MAX, SYSFS_CLASS_NET "%s/brforward", bridge);
	f = fopen(path, "r");
	
	if (f) {
        printf("open file %s succuss\n",path);
		if (fseek(f, offset*sizeof(struct __fdb_entry), SEEK_SET) < 0)
		{
			wid_syslog_err("%s: fseek failed %s\n", __func__);
			fclose(f);
			return 0;
		}
        /* coverity-CID: 10222 Uninitialized scalar variable */
		memset(fe, 0, sizeof(struct __fdb_entry)*num);
		n = fread(fe, sizeof(struct __fdb_entry), num, f);
		fclose(f);
	}
	else{
		printf("open file %s failed\n",path);
		}
	for (i = 0; i < n; i++) 
		__copy_fdb(fdbs+i, fe+i);

	return n;
}
/*-------------liuzhenhua append for wid show fdb----------------
-----------------------END-------------------------------*/


struct WTP_GROUP_MEMBER *wtp_group_get_ap(WID_WTP_GROUP *group, unsigned int WTPID)
{
	struct WTP_GROUP_MEMBER *s;

	s = group->WTP_HASH[WTP_ID_HASH(WTPID)];
	while (s != NULL && s->WTPID != WTPID)
		s = s->hnext;
	return s;
}


void wtp_group_list_del(WID_WTP_GROUP *group, struct WTP_GROUP_MEMBER *wtp)
{
	struct WTP_GROUP_MEMBER *tmp;

	if (group->WTP_M == wtp) {
		group->WTP_M = wtp->next;
		return;
	}

	tmp = group->WTP_M;
	while (tmp != NULL && tmp->next != wtp)
		tmp = tmp->next;
	if (tmp == NULL) {
		printf("tmp == NULL\n");
	} else
		tmp->next = wtp->next;
}


void wtp_group_hash_add(WID_WTP_GROUP *group, struct WTP_GROUP_MEMBER *wtp)
{
	wtp->hnext = group->WTP_HASH[WTP_ID_HASH(wtp->WTPID)];
	 group->WTP_HASH[WTP_ID_HASH(wtp->WTPID)] = wtp;
}


static void wtp_group_hash_del(WID_WTP_GROUP *group, struct WTP_GROUP_MEMBER *wtp)
{
	struct WTP_GROUP_MEMBER *s;

	s = group->WTP_HASH[WTP_ID_HASH(wtp->WTPID)];
	if (s == NULL) return;
	if (s->WTPID == wtp->WTPID) {
		group->WTP_HASH[WTP_ID_HASH(wtp->WTPID)] = s->hnext;
		return;
	}

	while (s->hnext != NULL &&
	       s->hnext->WTPID == wtp->WTPID)
		s = s->hnext;
	if (s->hnext != NULL)
		s->hnext = s->hnext->hnext;
}

int create_ap_group(unsigned int ID,char *NAME)
{
	int ret = 0;
	int i = 0, j = 0, ii = 0, jj = 0;

	/* coverity-CID: 10889 10888 Uninitialized scalar variable */
	unsigned int RadioExternFlag[L_RADIO_NUM] = {0};
	unsigned int gwtpid = 0;
	printf("%s ID %d\n",__func__,ID);
	WTP_GROUP[ID] = (WID_WTP_GROUP*)malloc(sizeof(WID_WTP_GROUP));
	memset(WTP_GROUP[ID], 0, sizeof(WID_WTP_GROUP));
	WTP_GROUP[ID]->GID = ID;
	WTP_GROUP[ID]->GNAME = (unsigned char*)malloc(strlen(NAME)+1);
	memset(WTP_GROUP[ID]->GNAME, 0, strlen(NAME)+1);
	memcpy(WTP_GROUP[ID]->GNAME, NAME, strlen(NAME));

	WTP_GROUP[ID]->WTP_CONFIG.wtp_allowed_max_sta_num=gWTP_MAX_STA; //xm/*wcl modify for globle variable*/
	WTP_GROUP[ID]->WTP_CONFIG.wtp_triger_num=1; //xm
	WTP_GROUP[ID]->WTP_CONFIG.wtp_flow_triger= gWTP_FLOW_TRIGER; //xm/*wcl modify for globle variable*/
	WTP_GROUP[ID]->WTP_CONFIG.EchoTimer = gEchoRequestTimer;
	WTP_GROUP[ID]->WTP_CONFIG.ap_sta_wapi_report_interval = gAP_STA_WAPI_REPORT_INTERVAL;/*wcl modify for globle variable*/
	WTP_GROUP[ID]->WTP_CONFIG.ap_sta_wapi_report_switch = gAP_STA_WAPI_REPORT_SWITCH;/*wcl add for globle variable*/
	
	WTP_GROUP[ID]->WTP_CONFIG.updateversion = NULL;
	WTP_GROUP[ID]->WTP_CONFIG.updatepath = NULL;
	WTP_GROUP[ID]->WTP_CONFIG.isipv6addr = 0;
	
	WTP_GROUP[ID]->WTP_CONFIG.sendsysstart = 2;	
	WTP_GROUP[ID]->WTP_CONFIG.WTPStat = 7;
	WTP_GROUP[ID]->WTP_CONFIG.isused = 0;
	WTP_GROUP[ID]->WTP_CONFIG.quitreason = WTP_UNUSED;
	WTP_GROUP[ID]->WTP_CONFIG.tunnel_mode = CW_LOCAL_BRIDGING;
	WTP_GROUP[ID]->WTP_CONFIG.CTR_ID = 0;
	WTP_GROUP[ID]->WTP_CONFIG.DAT_ID = 0;
	WTP_GROUP[ID]->WTP_CONFIG.BindingSock= -1;
	WTP_GROUP[ID]->WTP_CONFIG.BindingSystemIndex= -1;
	memset(WTP_GROUP[ID]->WTP_CONFIG.BindingIFName,0, ETH_IF_NAME_LEN);
	WTP_GROUP[ID]->WTP_CONFIG.wtp_login_mode = 0;
	WTP_GROUP[ID]->WTP_CONFIG.WFR_Index = 0;
	for(j = 0; j < L_RADIO_NUM; j ++)
	{
        WTP_GROUP[ID]->WTP_CONFIG.NeighborAPInfos[j] = NULL;
        WTP_GROUP[ID]->WTP_CONFIG.rouge_ap_infos[j] = NULL;    
	}
	WTP_GROUP[ID]->WTP_CONFIG.wids_device_list = NULL;	
	WTP_GROUP[ID]->WTP_CONFIG.rx_echocount = 0;
	WTP_GROUP[ID]->WTP_CONFIG.ap_ipadd = 0;
	WTP_GROUP[ID]->WTP_CONFIG.ap_gateway = 0;
	WTP_GROUP[ID]->WTP_CONFIG.ap_mask_new = 0;
	WTP_GROUP[ID]->WTP_CONFIG.ap_dnsfirst = 0;
	WTP_GROUP[ID]->WTP_CONFIG.ap_dnssecend = 0;
	WTP_GROUP[ID]->WTP_CONFIG.resetflag = 0;
	WTP_GROUP[ID]->WTP_CONFIG.ap_mask = 0;
	WTP_GROUP[ID]->WTP_CONFIG.sysver = NULL;
	WTP_GROUP[ID]->WTP_CONFIG.ver = NULL;
	WTP_GROUP[ID]->WTP_CONFIG.codever = NULL;
	WTP_GROUP[ID]->WTP_CONFIG.add_time = NULL;
	WTP_GROUP[ID]->WTP_CONFIG.imagedata_time = 0;
	WTP_GROUP[ID]->WTP_CONFIG.config_update_time = 0;
	WTP_GROUP[ID]->WTP_CONFIG.ElectrifyRegisterCircle = 0;
	WTP_GROUP[ID]->WTP_CONFIG.updateStat = 0;
	WTP_GROUP[ID]->WTP_CONFIG.updatefailcount = 0;
	WTP_GROUP[ID]->WTP_CONFIG.updatefailstate = 0;
	WTP_GROUP[ID]->WTP_CONFIG.manual_update_time = 0;	
	WTP_GROUP[ID]->WTP_CONFIG.location = NULL;
	WTP_GROUP[ID]->WTP_CONFIG.option60_param = NULL;
	//memset(WTP_GROUP[ID]->WTP_CONFIG.wep_flag,0,WTP_WEP_NUM);
	WTP_GROUP[ID]->WTP_CONFIG.ControlList = NULL;
	WTP_GROUP[ID]->WTP_CONFIG.ControlWait = NULL;
	memset(WTP_GROUP[ID]->WTP_CONFIG.cpuType,0,WTP_TYPE_DEFAULT_LEN);
	memcpy(WTP_GROUP[ID]->WTP_CONFIG.cpuType,"soc",3);
	memset(WTP_GROUP[ID]->WTP_CONFIG.memType,0,WTP_TYPE_DEFAULT_LEN);
	memcpy(WTP_GROUP[ID]->WTP_CONFIG.memType,"flash",5);
	memset(WTP_GROUP[ID]->WTP_CONFIG.flashType,0,WTP_TYPE_DEFAULT_LEN);
	memcpy(WTP_GROUP[ID]->WTP_CONFIG.flashType,"flash",5);/*wuwl add.when wtp didn't into run ,display this*/
	WTP_GROUP[ID]->WTP_CONFIG.wtp_trap_switch = 1;/*enable*/
	WTP_GROUP[ID]->WTP_CONFIG.wtp_seqnum_switch = 1;  /*wcl add*/
	WTP_GROUP[ID]->WTP_CONFIG.wtp_trap_lev = 1;
	WTP_GROUP[ID]->WTP_CONFIG.wtp_cpu_use_threshold = gWTP_CPU_USE_THRESHOLD;/*wcl modify for globle variable*/
	WTP_GROUP[ID]->WTP_CONFIG.wtp_mem_use_threshold = gWTP_MEM_USE_THRESHOLD;/*wcl modify for globle variable*/
	WTP_GROUP[ID]->WTP_CONFIG.wtp_rogue_ap_threshold = gWTP_ROGUE_AP_THRESHOLD;/*wcl modify for globle variable*/
	WTP_GROUP[ID]->WTP_CONFIG.wtp_rogue_terminal_threshold = gWTP_ROGUE_TERMINAL_THRESHOLD;/*wcl modify for globle variable*/

	for(i = 0; i < L_RADIO_NUM; i++)
	{
		WTP_GROUP[ID]->WTP_CONFIG.WTP_Radio[i] = NULL;
	}

	WTP_GROUP[ID]->WTP_CONFIG.RadioCount = 4;
	for(i = 0; (i < L_RADIO_NUM); i++)
	{
		WID_WTP_RADIO *radio = NULL;
		radio = (WID_WTP_RADIO*)malloc(sizeof(WID_WTP_RADIO));
		memset(radio, 0, sizeof(WID_WTP_RADIO));
		radio->WTPID = 0;
		radio->Radio_G_ID = gwtpid;
		radio->Radio_L_ID = i;
		radio->Radio_Chan = 0;
		radio->Radio_TXP = 20;
		radio->Radio_TXPOF= 0;
		radio->channelsendtimes = 1;

		radio->ishighpower = 0;

		radio->Support_Rate_Count = 0;
		radio->Radio_Rate = NULL;
		radio->FragThreshold = 2346;
		radio->BeaconPeriod = 100;
		radio->IsShortPreamble = 1;
		radio->DTIMPeriod = 1; //
		radio->ShortRetry = 7; //
		radio->LongRetry = 4; //
		radio->rtsthreshold = 2347;//zhangshu modify 2010-10-28
		radio->AdStat = 2;
		radio->OpStat = 2;
		radio->CMD = 0x0;
		for( ii = 0; ii < L_BSS_NUM; ii++)
		{
			radio->BSS[ii] = NULL;
		}
		radio->QOSID = 0;
		radio->QOSstate = 0;
		radio->bandwidth = 108;
		radio->auto_channel = 0;
		radio->auto_channel_cont = 0;
		radio->txpowerautostate = 1;
		radio->wifi_state = 1;
		radio->channelchangetime = 0;
		radio->excommand = NULL;
		radio->diversity = 0;//default is 0
		radio->txantenna = 1;//default is main
		radio->isBinddingWlan = 0;
		radio->BindingWlanCount = 0;
		radio->upcount = 0;
		radio->downcount = 0;
		radio->guardinterval = 1;
		radio->mcs = 0;
		radio->cwmode = 0;
		radio->Wlan_Id = NULL;
		radio->REFlag = RadioExternFlag[i];//zhanglei add for A8
		/*11n set begin*/
		radio->Ampdu.Op= Ampdu_op;//zhangshu add
		radio->Ampdu.Type= RADIO; //zhangshu add
		radio->Ampdu.Able = 1;/*enable*/
		radio->Ampdu.AmpduLimit = 65535;
		radio->Ampdu.subframe = 32;

        /*zhangshu add*/
		radio->Amsdu.Op= Amsdu_op;
		radio->Amsdu.Type= RADIO;
		radio->Amsdu.Able = 0;/*enable*/
		radio->Amsdu.AmsduLimit = 4000;
		radio->Amsdu.subframe = 32;
		
		radio->MixedGreenfield.Mixed_Greenfield = 0;/*enable*/ //book modify
		memset(radio->MixedGreenfield.Wlan_Mixed, 0, WLAN_NUM);
		radio->channel_offset =0;
		radio->tx_chainmask_state_value = 3;
		radio->rx_chainmask_state_value = 3; //zhangshu add for rx_chainmask 2010-10-09

		/*a8 chushihua start*/
		if(radio->REFlag == 1)
		{
			radio->sector_state_value = 0 ;
			radio->inter_vap_able = 0;
			radio->intra_vap_able = 0;
			radio->keep_alive_period = 3600;
			radio->keep_alive_idle_time = 3600;
			radio->congestion_avoidance = 0;
		}
	
		for(ii = 0; ii < SECTOR_NUM; ii++)
		{	
			//CW_CREATE_OBJECT_ERR(AC_RADIO[gwtpid]->sector[ii],WID_oem_sector,return NULL;);
			radio->sector[ii] = (WID_oem_sector*)malloc(sizeof(WID_oem_sector));
			radio->sector[ii]->state = 0;
			radio->sector[ii]->tx_power = 0;
		}
		for(jj=0;jj<TX_CHANIMASK_NUM;jj++)
		{	
			radio->tx_chainmask[jj] = (WID_oem_tx_chainmask*)malloc(sizeof(WID_oem_tx_chainmask));
			radio->tx_chainmask[jj]->state = 0;
		}
		if((radio->Radio_Type & 0x08) == 0x08)//if mode is 11n,beacon interval set to 400
		{
			radio->BeaconPeriod = 400;
			radio->diversity = 1;// 11 n default is 1
			radio->txantenna = 0;// 11n default is 0
		}
	
		radio->Radio_Rate = create_support_rate_list(1);//here add 10 first
		int rate = 0;
		if((radio->Radio_Type&IEEE80211_11B) > 0)
		{
			radio->Support_Rate_Count = 4;
			
			rate = 10;
			radio->Radio_Rate = insert_rate_into_list(radio->Radio_Rate,rate);
			
			rate = 20;
			radio->Radio_Rate = insert_rate_into_list(radio->Radio_Rate,rate);
			
			rate = 55;
			radio->Radio_Rate = insert_rate_into_list(radio->Radio_Rate,rate);
	
			rate = 110;
			radio->Radio_Rate = insert_rate_into_list(radio->Radio_Rate,rate);
	
			radio->Radio_Rate = delete_rate_from_list(radio->Radio_Rate, 0);
			radio->Support_Rate_Count = length_of_rate_list(radio->Radio_Rate);
		}
		if((radio->Radio_Type&IEEE80211_11A) > 0)
		{
			radio->Support_Rate_Count = 8;
			
			rate = 60;
			radio->Radio_Rate = insert_rate_into_list(radio->Radio_Rate,rate);
	
			rate = 90;
			radio->Radio_Rate = insert_rate_into_list(radio->Radio_Rate,rate);
	
			rate = 120;
			radio->Radio_Rate = insert_rate_into_list(radio->Radio_Rate,rate);
	
			rate = 180;
			radio->Radio_Rate = insert_rate_into_list(radio->Radio_Rate,rate);
	
			rate = 240;
			radio->Radio_Rate = insert_rate_into_list(radio->Radio_Rate,rate);
	
			rate = 360;
			radio->Radio_Rate = insert_rate_into_list(radio->Radio_Rate,rate);
	
			rate = 480;
			radio->Radio_Rate = insert_rate_into_list(radio->Radio_Rate,rate);
	
			rate = 540;
			radio->Radio_Rate = insert_rate_into_list(radio->Radio_Rate,rate);

			radio->Radio_Rate = delete_rate_from_list(radio->Radio_Rate, 0);
			delsame_rate_from_list(radio->Radio_Rate);
			radio->Support_Rate_Count = length_of_rate_list(radio->Radio_Rate);
		}
		if((radio->Radio_Type&IEEE80211_11G) > 0)
		{
			radio->Support_Rate_Count = 8;
	
			rate = 60;
			radio->Radio_Rate = insert_rate_into_list(radio->Radio_Rate,rate);
	
			rate = 90;
			radio->Radio_Rate = insert_rate_into_list(radio->Radio_Rate,rate);
	
			rate = 120;
			radio->Radio_Rate = insert_rate_into_list(radio->Radio_Rate,rate);
	
			rate = 180;
			radio->Radio_Rate = insert_rate_into_list(radio->Radio_Rate,rate);
	
			rate = 240;
			radio->Radio_Rate = insert_rate_into_list(radio->Radio_Rate,rate);
	
			rate = 360;
			radio->Radio_Rate = insert_rate_into_list(radio->Radio_Rate,rate);
	
			rate = 480;
			radio->Radio_Rate = insert_rate_into_list(radio->Radio_Rate,rate);
	
			rate = 540;
			radio->Radio_Rate = insert_rate_into_list(radio->Radio_Rate,rate);

			radio->Radio_Rate = delete_rate_from_list(radio->Radio_Rate, 0);
			delsame_rate_from_list(radio->Radio_Rate);
			radio->Support_Rate_Count = length_of_rate_list(radio->Radio_Rate);
		}
		if((radio->Radio_Type&IEEE80211_11N) > 0)
		{
			rate = 72;
			radio->Radio_Rate = insert_rate_into_list(radio->Radio_Rate,rate);

			radio->Radio_Rate = delete_rate_from_list(radio->Radio_Rate, 0);
			delsame_rate_from_list(radio->Radio_Rate);
			radio->Support_Rate_Count = length_of_rate_list(radio->Radio_Rate);							
		}

		WTP_GROUP[ID]->WTP_CONFIG.WTP_Radio[i] = radio;
	}
	//wid_init_wtp_info_in_create(WTPID);
	WTP_GROUP[ID]->WTP_CONFIG.wids_statist.floodingcount = 0;
	WTP_GROUP[ID]->WTP_CONFIG.wids_statist.sproofcount = 0;
	WTP_GROUP[ID]->WTP_CONFIG.wids_statist.weakivcount = 0;
	return ret;
}
int delete_ap_group(unsigned int ID)
{
	int num = 4;
	int i = 0;
	int j = 0;
	int ii = 0;
	int k = 0;
	WID_WTP_RADIO *radio = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *tmp1 = NULL;

	for(i=0; i<num; i++)
	{
		radio = WTP_GROUP[ID]->WTP_CONFIG.WTP_Radio[i];
		WTP_GROUP[ID]->WTP_CONFIG.WTP_Radio[i] = NULL;
		for(k = 0; k < L_BSS_NUM; k++)
		{
			if(radio->BSS[k] != NULL)
			{				
				radio->BSS[k]->WlanID = 0;
				radio->BSS[k]->Radio_G_ID = 0;
				radio->BSS[k]->Radio_L_ID = 0;
				radio->BSS[k]->State = 0;
				radio->BSS[k]->BSSIndex = 0;
				memset(radio->BSS[k]->BSSID, 0, 6);
				free(radio->BSS[k]->BSSID);
				radio->BSS[k]->BSSID = NULL;
				free(radio->BSS[k]);
				radio->BSS[k] = NULL;			
			}
		}
		//added end 20080806
		
		if (radio->Support_Rate_Count != 0)
		{
			radio->Support_Rate_Count = 0;
			destroy_support_rate_list(radio->Radio_Rate);
		}		
		struct wlanid *wlan_id = radio->Wlan_Id;
		struct wlanid *wlan_id_next = NULL;
		
		while(wlan_id != NULL)
		{			
			wlan_id_next = wlan_id->next;
		
			CW_FREE_OBJECT(wlan_id);
		
			wlan_id = wlan_id_next;
		}
		for(j=0;j<SECTOR_NUM;j++)
		{	
			if(radio->sector[j]){
				free(radio->sector[j]);
				radio->sector[j] = NULL;
			}
		}
		for(ii=0;ii<TX_CHANIMASK_NUM;ii++)
		{	
			if(radio->tx_chainmask[ii]){
				free(radio->tx_chainmask[ii]);
				radio->tx_chainmask[ii] = NULL;
			}
		}
		
		free(radio);
		radio = NULL;		
	}
	tmp = WTP_GROUP[ID]->WTP_M;
	tmp1 = WTP_GROUP[ID]->WTP_M; 
	while(tmp){
		tmp = tmp1->next;
		free(tmp1);
	}
	if(WTP_GROUP[ID]->GNAME != NULL){
		free(WTP_GROUP[ID]->GNAME);
		WTP_GROUP[ID]->GNAME = NULL;
	}	
	free(WTP_GROUP[ID]);
	WTP_GROUP[ID] = NULL;

	return 0;

}

int do_check_ap_group_config(unsigned int GID, unsigned int WTPID){
	return 0;
}

int add_ap_group_member(unsigned int GID,unsigned int WTPID){
	struct WTP_GROUP_MEMBER *tmp = NULL;
	printf("%s GID %d\n",__func__,GID);
	if(WTP_GROUP[GID]== NULL){
		return GROUP_ID_NOT_EXIST;
	}
	if(AC_WTP[WTPID] == NULL){
		return WTP_ID_NOT_EXIST;
	}else if(AC_WTP[WTPID]->APGroupID != 0){
		return WTP_BE_USING;
	}
	tmp = wtp_group_get_ap(WTP_GROUP[GID],WTPID);
	if(tmp){
		return 0;
	}
	tmp = (struct WTP_GROUP_MEMBER *)malloc(sizeof(struct WTP_GROUP_MEMBER));
	memset(tmp, 0, sizeof(struct WTP_GROUP_MEMBER));
	tmp->WTPID = WTPID;
	tmp->next = WTP_GROUP[GID]->WTP_M;
	WTP_GROUP[GID]->WTP_M = tmp;
	wtp_group_hash_add(WTP_GROUP[GID],tmp);
	WTP_GROUP[GID]->WTP_COUNT += 1;
	AC_WTP[WTPID]->APGroupID = GID;
	return 0;
}
int del_ap_group_member(unsigned int GID,unsigned int WTPID){
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *tmp1 = NULL;
	if(WTP_GROUP[GID]== NULL){
		return GROUP_ID_NOT_EXIST;
	}
	if((AC_WTP[WTPID] != NULL)&&(AC_WTP[WTPID]->APGroupID != GID)){
		return WTP_BE_USING;
	}
	tmp = wtp_group_get_ap(WTP_GROUP[GID],WTPID);
	if(tmp == NULL){
		return 0;
	}
	if(AC_WTP[WTPID] != NULL){
		AC_WTP[WTPID]->APGroupID = 0;
	}
	tmp1 = WTP_GROUP[GID]->WTP_M;
	if(tmp1 == tmp){
		WTP_GROUP[GID]->WTP_M = tmp1->next;
	}else{
		while(tmp1->next != NULL){
			if(tmp1->next == tmp){
				tmp1->next = tmp->next;
				break;
			}	
			tmp1 = tmp1->next;
		}
	}
	wtp_group_hash_del(WTP_GROUP[GID],tmp);	
	WTP_GROUP[GID]->WTP_COUNT -= 1;
	free(tmp);
	tmp = NULL;
	return 0;
}

CWBool check_radio_bind_wlan(unsigned int wtpid,unsigned char radio_l_id,unsigned char wlanId){

	CWBool  retValue = CW_FALSE;

	struct wlanid *wlan_id = AC_WTP[wtpid]->WTP_Radio[radio_l_id]->Wlan_Id;
	while(wlan_id != NULL)
		{	
		   
            printf("AC_WTP[%d]->WTP_Radio[%d]->Wlan_Id; = %d\n",wtpid,radio_l_id,wlan_id->wlanid);

			if(wlan_id->wlanid == wlanId)
			{
				retValue = CW_TRUE;
				break;
			}
			wlan_id = wlan_id->next;
		}

    return retValue;
}
/*fengwenchao add 20111117 for GM-3*/
int wid_prase_heart_time_avarge(unsigned int wtpid)
{
	int ret = WID_DBUS_SUCCESS;
	unsigned int echotimer = 0;
	unsigned int total_node_length = 0 ;
	struct heart_time_value_head*heart_time_node = NULL;
	ret = WID_CHECK_WTP_ID(wtpid);

	if(ret != WID_DBUS_SUCCESS)
	{
		wid_syslog_debug_debug(WID_WTPINFO," wtpid %d error in func %s",wtpid,__func__);
		return -1;
	}

	if(AC_WTP[wtpid] == NULL)
	{
		wid_syslog_debug_debug(WID_WTPINFO,"input wtpid %d error",wtpid);
		return -1;
	}

	echotimer = AC_WTP[wtpid]->EchoTimer;
	if(echotimer <= 0){
		wid_syslog_debug_debug(WID_WTPINFO,"echotimer <= 0 \n");
		return -1;
	}

	total_node_length = (AC_WTP[wtpid]->heart_time.heart_statistics_collect + echotimer - 1)/echotimer;
	if(total_node_length == 0){
		wid_syslog_debug_debug(WID_WTPINFO,"heart total_node_num == 0 \n");
		return -1;
	}	

	/*save value for list, begin*/
		if((heart_time_node = (struct heart_time_value_head*)malloc(sizeof(struct heart_time_value_head))) == NULL)
		{
			wid_syslog_debug_debug(WID_WTPINFO,"malloc fail in %s. \n",__func__);
			return -1;
		}
		else
		{
			heart_time_node->heart_time_value = AC_WTP[wtpid]->heart_time.heart_time_delay;
			heart_time_node->next = NULL;
			if(AC_WTP[wtpid]->heart_time.heart_time_value_head == NULL)
			{
				AC_WTP[wtpid]->heart_time.heart_time_value_head = heart_time_node;
				AC_WTP[wtpid]->heart_time.heart_time_value_length++;
				wid_syslog_debug_debug(WID_WTPINFO,"head AC_WTP[%d]->heart_time.heart_time_value_length =  %d.   %d\n",wtpid,AC_WTP[wtpid]->heart_time.heart_time_value_length,__LINE__);
			}
			else
			{
				heart_time_node->next = AC_WTP[wtpid]->heart_time.heart_time_value_head;
				AC_WTP[wtpid]->heart_time.heart_time_value_head = heart_time_node;
				AC_WTP[wtpid]->heart_time.heart_time_value_length++;
				wid_syslog_debug_debug(WID_WTPINFO,"node AC_WTP[%d]->heart_time.heart_time_value_length =  %d.   %d\n",wtpid,AC_WTP[wtpid]->heart_time.heart_time_value_length,__LINE__);
			}
		}
	/*save value for list, end*/

	/*delete exceed num,begin*/
	wid_syslog_debug_debug(WID_WTPINFO,"AC_WTP[%d]->heart_time.heart_time_value_length =  %d.   %d\n",wtpid,AC_WTP[wtpid]->heart_time.heart_time_value_length,__LINE__);
	wid_syslog_debug_debug(WID_WTPINFO,"total_node_length =  %d.   %d\n",total_node_length,__LINE__);
	if(AC_WTP[wtpid]->heart_time.heart_time_value_length > total_node_length)
	{
		struct heart_time_value_head  *p = AC_WTP[wtpid]->heart_time.heart_time_value_head ;
		struct heart_time_value_head  *tmp = NULL;
		int i=0;
	
		for(i=0;i<total_node_length;i++)
		{
			if (p!= NULL)
			{
				tmp = p;
				p = p->next;
			}
		}
		tmp->next = NULL;
	
		while(p!=NULL){
			tmp = p;
			p = p->next;
			tmp->next = NULL;
			free(tmp);
			tmp = NULL;
			AC_WTP[wtpid]->heart_time.heart_time_value_length--;
			wid_syslog_debug_debug(WID_WTPINFO,"AC_WTP[%d]->heart_time.heart_time_value_length--  =%d.   %d\n",wtpid,AC_WTP[wtpid]->heart_time.heart_time_value_length,__LINE__);
	 	}		
		//wid_syslog_debug_debug(WID_WTPINFO,"AC_WTP[%d]->heart_time.heart_time_value_length = %d\n",wtpid,AC_WTP[wtpid]->heart_time.heart_time_value_length);	
	}
	/*delete exceed num,end*/

	/*calculate average ,begin*/
	if((AC_WTP[wtpid]->heart_time.heart_time_value_length > 0)&&(AC_WTP[wtpid]->heart_time.heart_time_value_head != NULL))
	{
		unsigned int i_sample = 0;/**/
		unsigned int j = 0, k = 0;/*j k */
		unsigned int i_node = 0;/**/
		unsigned int D_value = 0;/**/
		unsigned int sum_heart_value = 0;/*heart */
		unsigned int sample_times = 0;/**/
		unsigned int total_sample_time = 0;/**/	
		
		if(sample_infor_interval <= 0)
		{
			wid_syslog_debug_debug(WID_WTPINFO,"sample_infor_interval = %d at %s\n",\
								sample_infor_interval,__func__);
			return -1 ;
		}	

		total_sample_time = (AC_WTP[wtpid]->heart_time.heart_time_value_length) 
							*AC_WTP[wtpid]->EchoTimer;
		if(total_sample_time <= 0){
			wid_syslog_debug_debug(WID_WTPINFO,"total_sample_time = %d at %s\n",\
										total_sample_time,__func__);
			return -1 ;
		}
		
		sample_times = total_sample_time/sample_infor_interval;
		
		if(sample_times <= 0)
		{
			wid_syslog_debug_debug(WID_WTPINFO,"sample_times = %d at %s\n",\
								sample_times,__func__);
			return -1 ;
		}	

		struct heart_time_value_head  *Node_heart = AC_WTP[wtpid]->heart_time.heart_time_value_head;

		for(i_sample=0;i_sample<sample_times;i_sample++)
		{
			if(0 == i_sample )
			{
				sum_heart_value = Node_heart->heart_time_value;
			}
			else
			{
				k = (((i_sample * sample_infor_interval) + AC_WTP[wtpid]->EchoTimer))
					/AC_WTP[wtpid]->EchoTimer;
				j = ((((i_sample-1) * sample_infor_interval) + AC_WTP[wtpid]->EchoTimer))
					/AC_WTP[wtpid]->EchoTimer;
				D_value = k - j;
				for(i_node = 0;i_node < D_value;i_node++)
				{
					if(Node_heart!= NULL&&Node_heart->next != NULL)
					{
						Node_heart = Node_heart->next;
					}
				}
				sum_heart_value += Node_heart->heart_time_value;
			}
		}
		AC_WTP[wtpid]->heart_time.heart_time_avarge = sum_heart_value / sample_times ;
		wid_syslog_debug_debug(WID_WTPINFO,"maddersky %s  sum_heart_value = %d \n",__func__,sum_heart_value);
		wid_syslog_debug_debug(WID_WTPINFO,"maddersky %s  sample_times = %d \n",__func__,sample_times);
		wid_syslog_debug_debug(WID_WTPINFO,"maddersky %s  AC_WTP[%d]->heart_time.heart_time_avarge = %d \n",__func__,wtpid,AC_WTP[wtpid]->heart_time.heart_time_avarge);
		if(AC_WTP[wtpid]->heart_time.heart_time_avarge == 0)
		{
			AC_WTP[wtpid]->heart_time.heart_time_avarge = AC_WTP[wtpid]->heart_time.heart_time_value_head->heart_time_value;
			wid_syslog_debug_debug(WID_WTPINFO,"%s  AC_WTP[%d]->heart_time.heart_time_avarge = %d \n",__func__,wtpid,AC_WTP[wtpid]->heart_time.heart_time_avarge);
		}
	}
	/*calculate average ,end*/
	return 0;
}

CWBool oui_mac_filters(unsigned char *mac){
	CWBool match = CW_FALSE;

	CWOUIInfo* pnode = NULL;

	pnode = ((OUI_FILTER_BLACK == gOuiListType) ? gBlackOuiInfoList :\
		  	(OUI_FILTER_WHITE == gOuiListType) ? gWhiteOuiInfoList : NULL);
	
	while(pnode != NULL)
	{
		if(memcmp(pnode->oui_mac,mac,OUI_LEN) == 0)
		{
			match = CW_TRUE;
		}
		pnode = pnode->next;
	}

	return ((OUI_FILTER_BLACK == gOuiListType) ? match: ((OUI_FILTER_WHITE == gOuiListType) ? (!match) : CW_FALSE));
}
//xiaodawei add, 20110312
int measure_quality_of_network_link(char *wtpip, struct NetworkQuality *networkquality)
{
	char command[IPERF_LINE_CONTENT];
	char **string;
	char **str;
	char *tmp_str = NULL;
	char *iperf_ms = "ms";
	char *iperf_dataloss = "%";
	int i = 0;
	int j = 0;
	int k = 0;

	string = (char **)malloc(IPERF_LINE_NUM*sizeof(char *));
	for(i=0; i<IPERF_LINE_NUM; i++){
		string[i] = (char *)malloc(IPERF_LINE_CONTENT*sizeof(char));
		memset(string[i], 0, IPERF_LINE_CONTENT);
	}
	str = (char **)malloc(IPERF_LINE_NUM*sizeof(char *));
	for(i=0; i<IPERF_LINE_NUM; i++){
		str[i] = malloc(IPERF_LINE_CONTENT*sizeof(char));
		memset(str[i], 0, IPERF_LINE_CONTENT);
	}
	
	system("rm -rf /home/wtp_iperf");			//delete file wtp_iperf if exist
	memset(command, 0, IPERF_LINE_CONTENT);
	sprintf(command,"iperf -u -c %s >>/home/wtp_iperf",wtpip);
	system(command);							//e.g. iperf -uc 100.1.1.15, write in file /home/wtp_iperf
	//parse file wtp_iperf, return jitter and datagram loss percent
	FILE *fp;
	if((fp = fopen("/home/wtp_iperf", "r")) == NULL)
	{
		wid_syslog_debug_debug(WID_DBUS,"the file wtp_iperf cannot be opened! or  it may not exist!!\n");
		FREE(string);
		FREE(str);
		return -1;
	}
	else
	{
		for(i=0; fgets(string[i], IPERF_LINE_CONTENT, fp) != NULL && i<IPERF_LINE_NUM; i++){
			wid_syslog_debug_debug(WID_DBUS,"line %d-string[%i]: %s\n",i+1,i,string[i]);
			//[  6]  0.0-10.0 sec  1.24 MBytes  1.03 Mbits/sec  0.048 ms   10/  893 (1.1%)
			//find the line above by "ms" & "%"
			if(strstr(string[i],iperf_ms)&&strstr(string[i],iperf_dataloss)){
				wid_syslog_debug_debug(WID_DBUS,"iperf result found! line: %d\n",i+1);
				wid_syslog_debug_debug(WID_DBUS,"%s\n",string[i]);
				while(string[i]){
					tmp_str = strsep(&string[i]," ");//separate the result with blank
					if(strcmp(tmp_str,"")){
						strncpy(str[k++], tmp_str, strlen(tmp_str));
					}
				}
				for(j=0; j<k&&str[j]!=NULL; j++){
					wid_syslog_debug_debug(WID_DBUS,"str[%d]: %s\n",j,str[j]);
					if(!strcmp(str[j],"ms")){		//jitter
						if(j>1 && str[j-1]){
							networkquality->jitter = (double)atof(str[j-1]);
							wid_syslog_debug_debug(WID_DBUS,"jitter: %s\n",str[j-1]);
							wid_syslog_debug_debug(WID_DBUS,"jitter of float: %.3f\n",networkquality->jitter);
						}
						else{
							FREE(string);
							FREE(str);
							
							/* coverity-CID:10944  Resource leak */
							fclose(fp);
							return -1;
						}
						if(k>1 && str[k-1]){		//datagram loss
							strsep(&str[k-1],"(");
							if(str[k-1]){
								tmp_str = strsep(&str[k-1],"%");
								networkquality->datagramloss = (double)atof(tmp_str);
								wid_syslog_debug_debug(WID_DBUS,"datagramloss: %s\%\n",tmp_str);
								wid_syslog_debug_debug(WID_DBUS,"datagramloss of float: %.3f\n",networkquality->datagramloss);
							}
							else{
								FREE(string);
								FREE(str);

								/* coverity-CID:10944  Resource leak */
								fclose(fp);
								return -1;
							}
						}
						else{
							FREE(string);
							FREE(str);
							
							/* coverity-CID:10944  Resource leak */
							fclose(fp);
							return -1;
						}
						FREE(string);
						FREE(str);

						/* coverity-CID:10944  Resource leak */
						fclose(fp);
						return 0;
					}
				}
			}
		}
		//no response
		wid_syslog_debug_debug(WID_DBUS,"iperf gets no response!\n");
		FREE(string);
		FREE(str);

		/* coverity-CID:10944  Resource leak */
		fclose(fp);
		return -1;
	}	
}
int check_channel(int check_channel){
	int ret1 = COUNTRY_CODE_SUCCESS;
		switch(gCOUNTRYCODE)
		{
			case COUNTRY_CHINA_CN : 
									if(check_channel >= 14)
									{
										ret1 = COUNTRY_CHINA_CN;
									}
									break;
			case COUNTRY_EUROPE_EU : 
									if(check_channel >= 14)
									{
										ret1 = COUNTRY_EUROPE_EU;
										printf("33\n");
									}
									break;
			case COUNTRY_USA_US : 
									if((check_channel >= 12))
									{
										ret1 = COUNTRY_USA_US;
									}
									break;
			case COUNTRY_JAPAN_JP : 
									if((check_channel >= 15))
									{
										ret1 = COUNTRY_JAPAN_JP;
									}
									break;
			case COUNTRY_FRANCE_FR : 
									if((check_channel != 0)&&(check_channel != 10)&&(check_channel != 11)&&(check_channel != 12)&&(check_channel != 13))
									{
										ret1 = COUNTRY_FRANCE_FR;
									}
									break;
			case COUNTRY_SPAIN_ES : 
									if((check_channel != 0)&&(check_channel != 10)&&(check_channel != 11))
									{
										ret1 = COUNTRY_SPAIN_ES;
									}
									break;
			default : ret1 = COUNTRY_CODE_SUCCESS;break;
		}
		return ret1;
}

int wid_set_ap_scanning_wtp(unsigned int wtpid,APScanningSetting scansetting,unsigned char mode)
{
	int i = 0;
	msgq msg;
	i = wtpid;
	{
		if((AC_WTP[i] != NULL)&&(AC_WTP[i]->WTPStat == 5))
		{
//			printf("##002 wtp id= %d##\n",i);
			
			AC_WTP[i]->WTP_Radio[0]->CMD |= 0x40;
			AC_WTP[i]->CMD->radioid[0] += 1;
			AC_WTP[i]->CMD->setCMD = 1;	
			int WTPIndex = i;
			CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
			if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
			{
				memset((char*)&msg, 0, sizeof(msg));
				msg.mqid = WTPIndex%THREAD_NUM+1;
				msg.mqinfo.WTPID = WTPIndex;
				msg.mqinfo.type = CONTROL_TYPE;
				msg.mqinfo.subtype = WTP_S_TYPE;
				msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_SCANNING_OP;
				msg.mqinfo.u.WtpInfo.value1 = scansetting.opstate;
				msg.mqinfo.u.WtpInfo.value2 = scansetting.reportinterval;
				if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
					wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
					perror("msgsnd");
				}
			}		
			CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
			if(gtrapflag>=4){
				if(gtrap_rrm_change_trap_switch == 1)
				{
					#if NOSOFTAC
					wid_dbus_trap_ap_rrm_state_change(WTPIndex,AC_WTP[i]->WIDS.scanningMode);
					#endif
				}
			}
		}
	}

	return 0;

}

CWBool wid_multicast_listen_setting(CWMultiHomedSocket *sockPtr, int port){
	CWNetworkLev4Address wildaddr;
	int yes = 1;
	CWSocket sock;
	struct CWMultiHomedInterface *p;
	if((sock = socket(AF_INET,SOCK_DGRAM, 0)) < 0) goto fail;
	
	goto success;
	
fail:
	CWNetworkRaiseSystemError(CW_ERROR_CREATING); // this wil return
	
success:
	// reuse address
	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));

	CW_ZERO_MEMORY(&wildaddr, sizeof(wildaddr));		
	if (gNetworkPreferredFamily == CW_IPv6) {
		// fill wildaddr considering it an IPv6 addr
		struct sockaddr_in6 *a = (struct sockaddr_in6 *) &wildaddr;
		a->sin6_family = AF_INET6;
		a->sin6_addr = in6addr_any;
		a->sin6_port = htons(port);
	}
	
	if(bind(sock, (struct sockaddr*) &wildaddr, CWNetworkGetAddressSize(&wildaddr)) < 0) {
		close(sock);
		CWNetworkRaiseSystemError(CW_ERROR_CREATING);
	}

	/* coverity-CID:10945 Resource leak */
	CW_CREATE_OBJECT_ERR(p, struct CWMultiHomedInterface,
			{close(sock); return CWErrorRaise(CW_ERROR_OUT_OF_MEMORY, NULL);});
	memset(p->ifname, 0, IFI_NAME);
	memcpy(p->ifname,"LocalHost",9);
	p->sock = sock;
	p->kind = CW_BROADCAST_OR_ALIAS;
	p->systemIndex = -1; // make sure this can't be confused with an interface
	p->systemIndexbinding = -1;
	
	p->if_next = NULL;
	// addrIPv4 field for the wildcard address cause it is garbage in both cases (IPv4 + IPv6)
	p->addrIPv4.ss_family = AF_UNSPEC;

	CW_COPY_NET_ADDR_PTR(&(p->addr), &wildaddr);
	
	struct CWMultiHomedInterface* inf = sockPtr->interfaces;
	if(sockPtr->interfaces == NULL)
		sockPtr->interfaces = p;
	else{
		while(inf->if_next != NULL)
			inf = inf->if_next;
		inf->if_next = p;			
		p->if_next = NULL;
	}
	sockPtr->count++;
			
	return CW_TRUE;
}

CWBool wid_multicast_listen_close(CWMultiHomedSocket *sockPtr){
	struct CWMultiHomedInterface* inf = sockPtr->interfaces;
	struct CWMultiHomedInterface* inf1 = sockPtr->interfaces;

	if(sockPtr->interfaces == NULL)
		return CW_TRUE;
	else{
		if(inf->kind == CW_BROADCAST_OR_ALIAS){
			sockPtr->interfaces = inf->if_next;
			sockPtr->count--;
			close(inf->sock);
			free(inf);
			return CW_TRUE;
		}	
	}

	while(inf->if_next != NULL){
		inf1 = inf->if_next;
		if(inf->if_next->kind == CW_BROADCAST_OR_ALIAS){
			inf->if_next = inf1->if_next;
			close(inf1->sock);
			free(inf1);
			sockPtr->count--;
			break;						
		}
		inf = inf->if_next;
	}

	return CW_TRUE;

}


/*
** get 11n rate paras from 11n_rate_table 
** and check stream num
** book add, 2011-10-20
*/
int wid_radio_get_11n_rate_paras(struct n_rate_info *nRateInfo, unsigned char stream_num)
{
    int ret = WTP_NO_SURPORT_Rate;
    int index = 0;
    index = CWHash11nRate(nRateInfo->rate);
    wid_syslog_debug_debug(WID_DEFAULT,"%s:%d, rate = %d, index = %d, chainmask_num = %d",
                           __func__, __LINE__, nRateInfo->rate, index, stream_num);

    if((index < 0) || (index >= 32))
    {
        wid_syslog_err("failed to find rate %d int 11n rate table\n",nRateInfo->rate);
    }

    struct n_rate_list *p;
    p = g11nRateTable[index].rate_info_list;

    while(p != NULL)
    {
        if(p->rate_info.rate == nRateInfo->rate)
        {
            if(p->rate_info.stream_num == stream_num)
            {
                nRateInfo->stream_num = stream_num;
                nRateInfo->mcs = p->rate_info.mcs;
                nRateInfo->cwmode = p->rate_info.cwmode;
                nRateInfo->guard_interval = p->rate_info.guard_interval;
                wid_syslog_debug_debug(WID_DEFAULT,"%s:%d, mcs = %d, cwmode = %d, gi = %d",
                        __func__,__LINE__,nRateInfo->mcs,nRateInfo->cwmode,nRateInfo->guard_interval);
                ret = 0;
                break;
            }
            else
            {
                ret = RADIO_MODE_IS_11N;
            }
        }
        p = p->next;
    }
    
    return ret;
}

int wid_radio_set_11n_rate_paras(int ID, struct n_rate_info nRateInfo, unsigned char channel)
{
    wid_syslog_debug_debug(WID_DEFAULT,"call wid_radio_set_11n_rate_paras\n");
    int ret = 0;
    wid_syslog_debug_debug(WID_DEFAULT,"mcs = %d, gi = %d, cwmode = %d, channel = %d\n",nRateInfo.mcs,nRateInfo.guard_interval,nRateInfo.cwmode,channel);
    
    if(AC_RADIO[ID] != NULL)
    {
        if(AC_RADIO[ID]->mcs != nRateInfo.mcs)
	        AC_RADIO[ID]->mcs = nRateInfo.mcs;
        if(AC_RADIO[ID]->guardinterval != nRateInfo.guard_interval)
	        AC_RADIO[ID]->guardinterval = nRateInfo.guard_interval;
	    
		/* change channel offset */
		if((AC_RADIO[ID]->cwmode == 0)&&((1 == nRateInfo.cwmode)||(2 == nRateInfo.cwmode)))
		{      
		    if(channel != 0)
			{
			    AC_RADIO[ID]->Radio_Chan = channel;
			    ret = WID_RADIO_SET_CHAN(ID, channel);
			}
			/* change channel */
			if(ret == 0)
			{
		        AC_RADIO[ID]->channel_offset = 1;
		        ret = wid_radio_set_channel_Extoffset(ID);
		        if(ret != 0)
		        {
		            wid_syslog_err("failed to change channel offset");
		            return -1;
		        }
		    }
		    else
		    {
		        wid_syslog_err("failed to change channel");
		        return -1;
		    }
	    }
		else if((AC_RADIO[ID]->cwmode != 0) && (nRateInfo.cwmode == 0))
		{
		    AC_RADIO[ID]->channel_offset = 0;
		    ret = wid_radio_set_channel_Extoffset(ID);
		    if(ret != 0)
		    {
		        wid_syslog_err("failed to change channel offset");
	        return -1;
		    }
		}

		if(ret == 0)
		{
		    if(AC_RADIO[ID]->cwmode != nRateInfo.cwmode)
    	    AC_RADIO[ID]->cwmode = nRateInfo.cwmode;
    	    ret = wid_radio_set_cmmode(ID);
    	    if(ret == 0)
    	    {
    	        WID_RADIO_CHANGE_SUPPORT_RATE_BYGI_MCS_CWMODE(ID);
    	    }
    	    else
    		    ret = -1;
    	}
    }
    else
        ret = -1;
        
    return ret;
}


void muti_user_optimize_switch(unsigned char wlanid, unsigned int radio_g_id,unsigned char type)
{
	wid_syslog_debug_debug(WID_DEFAULT,"now in func : %s\n",__func__);
	wid_syslog_debug_debug(WID_DEFAULT,"the wlanid is %d\n",wlanid);
	wid_syslog_debug_debug(WID_DEFAULT,"the radioid is %d\n",radio_g_id);

	msgq msg;
	struct msgqlist *elem = NULL;
	unsigned char radio_l_id = 0;
	unsigned int wtpid;
	wtpid = radio_g_id/4;
	radio_l_id = radio_g_id%4;
	
	wid_syslog_debug_debug(WID_DEFAULT,"the wtpid is %d\n",wtpid);
	wid_syslog_debug_debug(WID_DEFAULT,"the radio_l_id is %d\n",radio_l_id);
	if(AC_WTP[wtpid] != NULL) 
	{
	
		wid_syslog_debug_debug(WID_DEFAULT,"the radio_l_id is %d\n",radio_l_id);
		if(AC_WTP[wtpid]->WTPStat == WID_RUN)
		{
			
			CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));
			if(gWTPs[wtpid].isNotFree && (gWTPs[wtpid].currentState == CW_ENTER_RUN))
			{
				memset((char*)&msg, 0, sizeof(msg));
				msg.mqid = wtpid%THREAD_NUM+1;
				msg.mqinfo.WTPID = wtpid;
				msg.mqinfo.type = CONTROL_TYPE;
				msg.mqinfo.subtype = WTP_S_TYPE;
				msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_MULTI_USER_OPTIMIZE;
				msg.mqinfo.u.WlanInfo.	multi_user_optimize_switch = type;
				msg.mqinfo.u.WlanInfo.Radio_L_ID =  radio_l_id;
				msg.mqinfo.u.WlanInfo.WLANID = wlanid;
				if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
					wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
				}
			}
			CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));
			
		}
		else {
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = wtpid%THREAD_NUM+1;
			msg.mqinfo.WTPID = wtpid;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_MULTI_USER_OPTIMIZE;
			msg.mqinfo.u.WlanInfo.	multi_user_optimize_switch = type;
			msg.mqinfo.u.WlanInfo.Radio_L_ID = radio_l_id;
			msg.mqinfo.u.WlanInfo.WLANID = wlanid;
			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if(elem == NULL){
				wid_syslog_info("%s malloc %s",__func__,strerror(errno));
				perror("malloc");
				return ;
			}
			memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
			elem->next = NULL;
			memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
			WID_INSERT_CONTROL_LIST(wtpid, elem);
		}
	}
	return ;
}
int add_mac_in_maclist(struct acl_config *conf, unsigned char *addr, char type)
{
	struct maclist *entry = NULL, *prev = NULL,*tmp = NULL;

	if(addr==NULL||(type!=1&&type!=2))
		return -1;
/* Coverity: CID: 10188  Error-Type: Resource leak */
	if(conf == NULL) {
#if 0		
		conf = (struct acl_config*)malloc(sizeof(struct acl_config));
		if(conf == NULL) return -1;
		conf->macaddr_acl = 0;
		conf->accept_mac = NULL;
		conf->num_accept_mac = 0;
		conf->deny_mac = NULL;
		conf->num_accept_mac = 0;
#endif
   		return  -1;
	}

	tmp = malloc(sizeof(*tmp));
	if (tmp == NULL) {
		wid_syslog_debug_debug(WID_DEFAULT,"%s :malloc fail.\n",__func__);
		exit(1);
	}else {
		memset(tmp,0,sizeof(*tmp));
		memcpy(tmp->addr, addr, ETH_ALEN);
		tmp->next = NULL;
	}

	if(1==type){
		entry = conf->deny_mac;
		prev = NULL;
		while (entry) {
			if (memcmp(entry->addr, addr, ETH_ALEN) == 0) {
				wid_syslog_debug_debug(WID_DEFAULT,"entry->add_reason = %d\n",entry->add_reason);
				if(entry->add_reason) {
					entry->add_reason = 0;
					conf->num_deny_mac++;
					conf->num_wids_mac--;
					wid_syslog_debug_debug(WID_DEFAULT,MACSTR" is put in black list from wids black list.\n",MAC2STR(addr));
				}else 
					wid_syslog_debug_debug(WID_DEFAULT,MACSTR" is already in the black list.\n",MAC2STR(addr));
				free(tmp);
				tmp = NULL;
				return 1;
			}
			prev = entry;
			entry = entry->next;
		}
		if(prev == NULL)
			conf->deny_mac = tmp;
		else 
			prev->next = tmp;
		conf->num_deny_mac++;
		wid_syslog_debug_debug(WID_DEFAULT,MACSTR"add success!\n",MAC2STR(tmp->addr));
		return 0;			
	}else {
		entry = conf->accept_mac;
		prev = NULL;
		while (entry) {
			if (memcmp(entry->addr, addr, ETH_ALEN) == 0) {
				wid_syslog_debug_debug(WID_DEFAULT,MACSTR" is already in the white list.\n",MAC2STR(addr));
				free(tmp);
				tmp = NULL;
				return 1;
			}
			prev = entry;
			entry = entry->next;
		}
		if(prev == NULL)
			conf->accept_mac = tmp;
		else 
			prev->next = tmp;
		conf->num_accept_mac++;
		return 0;			
	}

}

int del_mac_in_maclist(struct acl_config *conf, unsigned char  *addr, char type)
{
	struct maclist *entry = NULL, *prev = NULL, *tmp = NULL;
	
	wid_syslog_debug_debug(WID_DEFAULT,"%s :type = %d\n",__func__,type);
	if(addr==NULL||(type!=1&&type!=2)|| NULL == conf)	//1--black list, 2--white list
		return -1;
/* Coverity: CID: 10191  Error-Type: Resource leak */
	if(conf == NULL) {
		conf = (struct acl_config*)malloc(sizeof(struct acl_config));
		if(conf == NULL) return -1;
		conf->macaddr_acl = 0;
		conf->accept_mac = NULL;
		conf->num_accept_mac = 0;
		conf->deny_mac = NULL;
		conf->num_accept_mac = 0;
	}

	if(1==type){
		entry = conf->deny_mac;
		prev = NULL;
		while (entry) {
			if ((memcmp(entry->addr, addr, ETH_ALEN) == 0) && (entry->add_reason == 0)) {
				
				wid_syslog_debug_debug(WID_DEFAULT,"%s :find the mac!\n",__func__);
				if (prev)
					prev->next = entry->next;
				else
					conf->deny_mac = entry->next;
				tmp = entry;
				tmp->next = NULL;
				CW_FREE_OBJECT(tmp);
				conf->num_deny_mac--;
				return 0;
			}
			prev = entry;
			entry = entry->next;
		}
		wid_syslog_debug_debug(WID_DEFAULT,MACSTR" is not in the black list.\n",MAC2STR(addr));
		return -1;			
	}else {
		entry = conf->accept_mac;
		prev = NULL;
		while (entry) {
			if (memcmp(entry->addr, addr, ETH_ALEN) == 0) {
				if (prev)
					prev->next = entry->next;
				else
					conf->accept_mac = entry->next;
				tmp = entry;
				tmp->next = NULL;
				CW_FREE_OBJECT(tmp);
				conf->num_accept_mac--;
				return 0;
			}
			prev = entry;
			entry = entry->next;
		}
		wid_syslog_debug_debug(WID_DEFAULT,MACSTR" is not in the white list.\n",MAC2STR(addr));
		return -1;			
	}

}
int change_maclist_security(struct acl_config *conf, char type)
{
	wid_syslog_debug_debug(WID_DEFAULT,"%s:type = %d\n",__func__,type);
	if(type!=0&&type!=1&&type!=2)
		return -1;
/* Coverity: CID: 10189  Error-Type: Resource leak */
	if(conf == NULL) {
		#if 0
		conf = (struct acl_config*)malloc(sizeof(struct acl_config));
		if(conf == NULL) return -1;
		conf->macaddr_acl = 0;
		conf->accept_mac = NULL;
		conf->num_accept_mac = 0;
		conf->deny_mac = NULL;
		conf->num_accept_mac = 0;
		#else
		return -1;
		#endif
	}
	
	if(0==type)
		conf->macaddr_acl = 0;
	else if(1==type)
		conf->macaddr_acl = 1;
	else if(2==type)
		conf->macaddr_acl = 2;

	return 0;
}
void free_maclist(struct acl_config *conf, struct maclist *list)
{
	wid_syslog_debug_debug(WID_DEFAULT,"%s:\n",__func__);
	struct maclist *entry, *tmp;

	entry = list;
	while(entry != NULL){
		tmp = entry;
		entry = entry->next;
		memset(tmp,0,sizeof(struct maclist));
		free(tmp);
		tmp = NULL;
	}
}
int wid_wlan_set_sta_silence_period(unsigned char WlanID, unsigned int silence_period)
{
	if (WLAN_NUM <= WlanID)
	{
		return WID_DBUS_ERROR;
	}
	
	if(NULL == AC_WLAN[WlanID])
	{
		return WLAN_ID_NOT_EXIST;
	}

	if (!AC_WLAN[WlanID]->Status)	/* 0 : enable 1 : disable */
	{
		return WLAN_BE_ENABLE;
	}

	AC_WLAN[WlanID]->sp_head.sp_time = silence_period;
			
	AsdWsm_WLANOp(WlanID, WID_MODIFY, 0);

	return WID_DBUS_SUCCESS;
}
//weichao add
int wid_set_ap_username_password(unsigned int wtpid,char *username,char *passwd)
{
	wid_syslog_debug_debug(WID_DEFAULT,"the wtpid is %s\n",__func__);
	msgq msg;
	struct msgqlist *elem = NULL;
	int i = 0;
	if(wtpid == 0)
	{
		for(i = 0 ; i < WTP_NUM;i++)
		{
			if(AC_WTP[i] != NULL) 
			{
				wtpid = i;
				wid_syslog_debug_debug(WID_DEFAULT,"the wtpid is %d\n",wtpid);
				if(AC_WTP[wtpid]->WTPStat == WID_RUN)
				{
					CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));
					if(gWTPs[wtpid].isNotFree && (gWTPs[wtpid].currentState == CW_ENTER_RUN))
					{
						memset((char*)&msg, 0, sizeof(msg));
						msg.mqid = wtpid%THREAD_NUM+1;
						msg.mqinfo.WTPID = wtpid;
						msg.mqinfo.type = CONTROL_TYPE;
						msg.mqinfo.subtype = WTP_S_TYPE;
						msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_SET_NAME_PASSWD;
						memcpy(msg.mqinfo.u.WtpInfo.username,username,strlen(username));
						memcpy(msg.mqinfo.u.WtpInfo.passwd,passwd,strlen(passwd));
						
						if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
						{
							wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
						}
					}
					CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));
				}
				else if((AC_WTP[wtpid] != NULL))
				{
					memset((char*)&msg, 0, sizeof(msg));
					msg.mqid = wtpid%THREAD_NUM+1;
					msg.mqinfo.WTPID = wtpid;
					msg.mqinfo.type = CONTROL_TYPE;
					msg.mqinfo.subtype = WTP_S_TYPE;
					msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_SET_NAME_PASSWD;
					memcpy(msg.mqinfo.u.WtpInfo.username,username,strlen(username));
					memcpy(msg.mqinfo.u.WtpInfo.passwd,passwd,strlen(passwd));
					elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
					if(elem == NULL)
					{
						wid_syslog_info("%s malloc %s",__func__,strerror(errno));
						return 0;
					}
					memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
					elem->next = NULL;
					memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
					WID_INSERT_CONTROL_LIST(wtpid, elem);
				}
			}
		}
	}
	else if(AC_WTP[wtpid] != NULL)
	{
			if(AC_WTP[wtpid]->WTPStat == WID_RUN)
			{
				CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));
				if(gWTPs[wtpid].isNotFree && (gWTPs[wtpid].currentState == CW_ENTER_RUN))
				{
					memset((char*)&msg, 0, sizeof(msg));
					msg.mqid = wtpid%THREAD_NUM+1;
					msg.mqinfo.WTPID = wtpid;
					msg.mqinfo.type = CONTROL_TYPE;
					msg.mqinfo.subtype = WTP_S_TYPE;
					msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_SET_NAME_PASSWD;
					memcpy(msg.mqinfo.u.WtpInfo.username,username,strlen(username));
					memcpy(msg.mqinfo.u.WtpInfo.passwd,passwd,strlen(passwd));
					
					if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
					{
						wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
					}
				}
				CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));
			}
		else if((AC_WTP[wtpid] != NULL))
		{
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = wtpid%THREAD_NUM+1;
			msg.mqinfo.WTPID = wtpid;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_SET_NAME_PASSWD;
			memcpy(msg.mqinfo.u.WtpInfo.username,username,strlen(username));
			memcpy(msg.mqinfo.u.WtpInfo.passwd,passwd,strlen(passwd));
			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if(elem == NULL)
			{
				wid_syslog_info("%s malloc %s",__func__,strerror(errno));
				return 0;
			}
			memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
			elem->next = NULL;
			memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
			WID_INSERT_CONTROL_LIST(wtpid, elem);
		}
	}
	return 0;
	
}

int init_wid_lic_socket(){
	int sock;
	int yes = 1;
	int sndbuf = 65525;
	int rcvbuf = 65525;
	struct sockaddr_in my_addr;
	if ((sock = socket(PF_INET, SOCK_DGRAM, 0)) ==-1)
	{	printf("udp socket create failed\n");		
		exit(1);	
	}
	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
	my_addr.sin_family = AF_INET;	
	my_addr.sin_port = htons(WID_LIC_AC_PORT+ local*MAX_INSTANCE +vrrid);	
	my_addr.sin_addr.s_addr = INADDR_ANY;	
	memset(my_addr.sin_zero, '\0', sizeof(my_addr.sin_zero));	
	if (bind(sock, (struct sockaddr *)&my_addr, sizeof(struct sockaddr)) == -1)
	{	
		wid_syslog_info("udp bind failed\n");	
		return -1;
	}	
	setsockopt(sock,SOL_SOCKET,SO_SNDBUF,&sndbuf,sizeof(sndbuf));
	setsockopt(sock,SOL_SOCKET,SO_RCVBUF,&rcvbuf,sizeof(rcvbuf));
	return sock;
}

void *lic_active_thread(void *arg){
	wid_pid_write_v2("lic_active_thread",0,vrrid);
	int sockid = (long)arg;
	wid_syslog_info("%s,%d,sock=%d.\n",__func__,__LINE__,sockid); 
	int len = 0;
	socklen_t addr_len;
	char buf[4096];

	while(Lic_ip.isActive == 1){
		fd_set fdset;
		FD_ZERO(&fdset);
		FD_SET(sockid,&fdset);
		addr_len = sizeof(struct sockaddr);
		struct timeval tv;			
		tv.tv_sec = 3;
		tv.tv_usec = 5000;
		wid_syslog_debug_debug(WID_DBUS,"%s,%d,before select.",__func__,__LINE__);
		if(-1 == select(sockid+1,&fdset,(fd_set*)0,(fd_set*)0,&tv)){
			if(Lic_ip.isActive == 1){
				wid_syslog_debug_debug(WID_DBUS,"%s,%d,select fail and continue.",__func__,__LINE__);
				continue;
			}else{
				wid_syslog_debug_debug(WID_DBUS,"%s,%d,select fail and break.",__func__,__LINE__);
				break;
			}
		}
		if(FD_ISSET(sockid,&fdset)){
			len = recvfrom(sockid,buf,4095,0,(struct sockaddr *)&Lic_bak_addr, &addr_len);
			if(len < 0){
				wid_syslog_err("%s,%d,len=%d.\n",__func__,__LINE__,len);
				continue;
			}
			unsigned int ip = 0;
			struct sockaddr_in * temp = (struct sockaddr_in *)&Lic_bak_addr;
			ip = temp->sin_addr.s_addr;
			wid_syslog_debug_debug(WID_DBUS,"%s,%d,sockfd=%d,ip=%d.%d.%d.%d.\n",__func__,__LINE__,sockid,(ip>>24)&0xFF,(ip>>16)&0xFF,(ip>>8)&0xFF,(ip)&0xFF);
			wid_syslog_debug_debug(WID_DBUS,"%s,%d,recvfrom receive msg.",__func__,__LINE__);
			B_Msg *msg = (B_Msg*) buf;			
			switch(msg->Type){
				case B_LICENSE_REQUEST:
					wid_syslog_debug_debug(WID_DBUS,"%s,%d,sockfd=%d,.\n",__func__,__LINE__,sockid,(ip>>24)&0xFF,(ip>>16)&0xFF,(ip>>8)&0xFF,(ip)&0xFF);
					compare_license(msg);
					update_license(sockid , (struct sockaddr_in *)&Lic_bak_addr);

					wid_syslog_debug_debug(WID_DBUS,"%s,%d,case B_LICENSE_REQUEST.",__func__,__LINE__);
					break;
				case B_CHECK_LICENSE:
					compare_license(msg);
					break;
				default:
					wid_syslog_debug_debug(WID_DBUS,"%s,%d,case default.",__func__,__LINE__);
					break;
			}
		}
	}


	pthread_exit((void *) 0);
	
}

int set_active_ac_listenning()
{
	long sock = 0;
	pthread_t LIC_ACTIVE;
	sock = init_wid_lic_socket();
	lic_active_fd = sock;
	pthread_attr_t attr;
	int s = PTHREAD_CREATE_DETACHED;
	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr,s);
	wid_syslog_info("%s,%d,sock=%d.\n",__func__,__LINE__,sock); 
	if(pthread_create(&LIC_ACTIVE, &attr, lic_active_thread, (char*)sock) != 0) {
		return -1;
	}
	wid_syslog_info("%s,%d.\n",__func__,__LINE__); 
	return 0;
}
void*lic_bak_thread(){
	int sndbuf = 65525;
	int rcvbuf = 65525;
	char buf[2048];
	struct sockaddr tmp_addr;
	socklen_t addr_len;
	wid_pid_write_v2("lic_bak_thread",0,vrrid);
	int numbytes = 0;
	while(Lic_ip.isActive == 2){
		if((lic_bak_fd = socket(PF_INET,SOCK_DGRAM,0)) == -1){
			wid_syslog_err("%s,%d,create sock %d fail.\n",__func__,__LINE__,lic_bak_fd);
			return NULL;
		}
		setsockopt(lic_bak_fd,SOL_SOCKET,SO_SNDBUF,&sndbuf,sizeof(sndbuf));
		setsockopt(lic_bak_fd,SOL_SOCKET,SO_RCVBUF,&rcvbuf,sizeof(rcvbuf));
		wid_syslog_info("sendto active ac.\n");
		update_license_req(lic_bak_fd , (struct sockaddr_in *)&Lic_Active_addr);
		if(!CWErr(CWTimerRequest(LicBakReqInterval, NULL, &(Lic_bak_req_timer), 901, 0))) { 
			wid_syslog_err("%s,%d,Lic_bak_req_timer request err.\n",__func__,__LINE__);
		}

		while(Lic_ip.isActive == 2){
			
			memset(buf,0,2048);
			fd_set fdset;
			FD_ZERO(&fdset);
			FD_SET(lic_bak_fd,&fdset);
			struct timeval tv;
			tv.tv_sec =2;
			tv.tv_usec = 2500;
			wid_syslog_debug_debug(WID_DEFAULT,"%s,%d,wait for active ac response.\n",__func__,__LINE__);
			if(select(lic_bak_fd+1,&fdset,(fd_set*)0,(fd_set*)0,&tv)==-1){
				if(Lic_ip.isActive == 2){
					continue;
				}else{
					break;
				}
			}
			if(FD_ISSET(lic_bak_fd,&fdset)){
				numbytes = recvfrom(lic_bak_fd,buf,2047,0,&tmp_addr,&addr_len);
				wid_syslog_debug_debug(WID_DEFAULT,"%s,%d,numbytes=%d.\n",__func__,__LINE__,numbytes);
				if(numbytes <= 0){
					wid_syslog_err("%s,recvfrom err,numbytes=%d.\n",numbytes);
					break;
				}
				CWTimerCancel(&Lic_bak_req_timer,1);
				wid_syslog_debug_debug(WID_DEFAULT,"%s,%d,recive from active master.\n",__func__,__LINE__);
				if(Lic_ip.isActive == 2){
					B_Msg *msg = (B_Msg*) buf;
					switch(msg->Type){
						case B_CHECK_LICENSE:
							compare_license(msg);
							wid_syslog_debug_debug(WID_DEFAULT,"%s,%d,B_CHECK_LICENSE.\n",__func__,__LINE__);
							break;
						case B_LICENSE_REQUEST:
							wid_syslog_info("%s B_LICENSE_REQUEST\n",__func__);
							compare_license(msg);
							update_license(lic_bak_fd , (struct sockaddr_in *)&Lic_Active_addr);
							wid_syslog_debug_debug(WID_DEFAULT,"%s,%d,B_LICENSE_REQUEST.\n",__func__,__LINE__);
							break;
						default:
							
							wid_syslog_debug_debug(WID_DEFAULT,"%s,%d,default.\n",__func__,__LINE__);
							break;
					}
				}
			}
			
		}
		close(lic_bak_fd);
	}
	pthread_exit((void *) 0);
	return 0;
}

int set_bakup_ac_update_license(){

	pthread_t LIC_BAK;
	pthread_attr_t attr;
	int s = PTHREAD_CREATE_DETACHED;	
	struct sockaddr_in *inaddr = (struct sockaddr_in *)&Lic_Active_addr;
	inaddr->sin_family = AF_INET;	
	inaddr->sin_port = htons(WID_LIC_AC_PORT+ local*MAX_INSTANCE+vrrid);
	inaddr->sin_addr.s_addr = Lic_ip.lic_active_ac_ip;	
	memset(inaddr->sin_zero, '\0', sizeof(inaddr->sin_zero));

	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr,s);
	if(pthread_create(&LIC_BAK, &attr, lic_bak_thread, NULL) != 0) {
		return -1;
	}				
	return 0;	
}

int set_wlan_tunnel_mode(unsigned char WlanID, unsigned char state){
	int ret = -1;
	int i=0;
	int j=0;
	int k = 0;
	int fd = 0;
	if_batch_info if_b_info;
	memset(&if_b_info, 0 , sizeof(if_b_info));
	if(AC_WLAN[WlanID] == NULL) //fengwenchao add 20121203 for AXSSZFI-1283
	{
		return WLAN_ID_NOT_EXIST;
	}
	if(AC_WLAN[WlanID]->Status == 0)
	{
		return WLAN_BE_ENABLE;
	}
	if(state == 1)
	{		
		if(AC_WLAN[WlanID]->wlan_if_policy != NO_INTERFACE){
			return WID_DBUS_SUCCESS;
		}
		AC_WLAN[WlanID]->wlan_if_policy = BSS_INTERFACE;
		for(i=0; i<WTP_NUM; i++)
		{
			//if((AC_WTP[i]!=NULL)&&(AC_WTP[i]->isused == 1))
			if(AC_WTP[i]!=NULL)
			{
				for(j=0; j<AC_WTP[i]->RadioCount; j++)
				{
					if(AC_WLAN[WlanID]->S_WTP_BSS_List[i][j] != 0)
					{
						int bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[i][j];
						if(!check_bssid_func(bssindex)){
							wid_syslog_err("bssindex %d not exist\n",WlanID);
						}else{						
							if(AC_BSS[bssindex]->BSS_IF_POLICY == NO_INTERFACE)
							{
								if_b_info.ifinfo[k].wlanID = 0;
								if_b_info.ifinfo[k].BSSIndex = bssindex;
								if_b_info.ifinfo[k].vrid = local*MAX_INSTANCE+vrrid;								
								if(local)
									snprintf(if_b_info.ifinfo[k].if_name,ETH_IF_NAME_LEN,"r%d-%d-%d.%d",vrrid,i,AC_BSS[bssindex]->Radio_L_ID,WlanID);
								else
									snprintf(if_b_info.ifinfo[k].if_name,ETH_IF_NAME_LEN,"r%d-%d-%d-%d.%d",slotid,vrrid,i,AC_BSS[bssindex]->Radio_L_ID,WlanID);
								memset(AC_BSS[bssindex]->BSS_IF_NAME,0,ETH_IF_NAME_LEN);
								memcpy(AC_BSS[bssindex]->BSS_IF_NAME, if_b_info.ifinfo[k].if_name, ETH_IF_NAME_LEN-1);
								AC_BSS[bssindex]->BSS_IF_POLICY = BSS_INTERFACE;
								AC_BSS[bssindex]->BSS_TUNNEL_POLICY = CW_802_DOT_11_TUNNEL;
								if((is_secondary != 2)&&(set_vmac_state == 1)){
									hwaddr_set(AC_BSS[bssindex]->BSS_IF_NAME,v_mac,MAC_LEN);
									AC_BSS[bssindex]->vMAC_STATE = 1;
								}
								k++;
								if(k == 320){
									if_b_info.count = k;									
									fd = open("/dev/wifi0", O_RDWR);
									
									if(fd < 0)
									{
										return WID_DBUS_ERROR;
									}
									ret = ioctl(fd, WIFI_IOC_BATCH_IF_CREATE, &if_b_info);
									close(fd);
									if(ret < 0)
									{
										return WID_DBUS_ERROR;
									}
									k = 0;
									memset(&if_b_info, 0 , sizeof(if_b_info));
								}
							}
						}
					}
				}
			}
		}
		if(k != 0){
			if_b_info.count = k;									
			fd = open("/dev/wifi0", O_RDWR);
			
			if(fd < 0)
			{
				return WID_DBUS_ERROR;
			}
			ret = ioctl(fd, WIFI_IOC_BATCH_IF_CREATE, &if_b_info);
			close(fd);
			if(ret < 0)
			{
				return WID_DBUS_ERROR;
			}
			k = 0;
			memset(&if_b_info, 0 , sizeof(if_b_info));
		}
	}	else{		
		if(AC_WLAN[WlanID]->wlan_if_policy == NO_INTERFACE){
			return WID_DBUS_SUCCESS;
		}
		AC_WLAN[WlanID]->wlan_if_policy = NO_INTERFACE;
		for(i=0; i<WTP_NUM; i++)
		{
			//if((AC_WTP[i]!=NULL)&&(AC_WTP[i]->isused == 1))
			if(AC_WTP[i]!=NULL)
			{
				for(j=0; j<AC_WTP[i]->RadioCount; j++)
				{
					if(AC_WLAN[WlanID]->S_WTP_BSS_List[i][j] != 0)
					{
						int bssindex = AC_WLAN[WlanID]->S_WTP_BSS_List[i][j];
						if(!check_bssid_func(bssindex)){
							wid_syslog_err("bssindex %d not exist\n",WlanID);
						}else{						
							if(AC_BSS[bssindex]->BSS_IF_POLICY != NO_INTERFACE)
							{
								if_b_info.ifinfo[k].wlanID = 0;
								if_b_info.ifinfo[k].BSSIndex = bssindex;
								if_b_info.ifinfo[k].vrid = local*MAX_INSTANCE+vrrid;								
								if(local)
									snprintf(if_b_info.ifinfo[k].if_name,ETH_IF_NAME_LEN,"r%d-%d-%d.%d",vrrid,i,AC_BSS[bssindex]->Radio_L_ID,WlanID);
								else
									snprintf(if_b_info.ifinfo[k].if_name,ETH_IF_NAME_LEN,"r%d-%d-%d-%d.%d",slotid,vrrid,i,AC_BSS[bssindex]->Radio_L_ID,WlanID);
								memset(AC_BSS[bssindex]->BSS_IF_NAME,0,ETH_IF_NAME_LEN);
								AC_BSS[bssindex]->BSS_IF_POLICY = NO_INTERFACE;
								AC_BSS[bssindex]->BSS_TUNNEL_POLICY = CW_802_DOT_11_TUNNEL;
								k++;
								if(k == 320){
									if_b_info.count = k;									
									fd = open("/dev/wifi0", O_RDWR);
									
									if(fd < 0)
									{
										return WID_DBUS_ERROR;
									}
									ret = ioctl(fd, WIFI_IOC_BATCH_IF_DELETE, &if_b_info);
									close(fd);
									if(ret < 0)
									{
										return WID_DBUS_ERROR;
									}
									k = 0;
									memset(&if_b_info, 0 , sizeof(if_b_info));
								}
							}
						}
					}
				}
			}
		}
		if(k != 0){
			if_b_info.count = k;									
			fd = open("/dev/wifi0", O_RDWR);
			
			if(fd < 0)
			{
				return WID_DBUS_ERROR;
			}
			ret = ioctl(fd, WIFI_IOC_BATCH_IF_DELETE, &if_b_info);
			close(fd);
			if(ret < 0)
			{
				return WID_DBUS_ERROR;
			}
			k = 0;
			memset(&if_b_info, 0 , sizeof(if_b_info));
		}
	}
	if(state == 1){
		if(AC_WLAN[WlanID]->WLAN_TUNNEL_POLICY != g_WLAN_TUNNEL_POLICY){
			char nodeFlag = 2;
			ret = WID_RADIO_WLAN_TUNNEL_MODE(WlanID,g_WLAN_TUNNEL_POLICY,nodeFlag);
		}
	}
	return 0;
}
void wtp_get_ifindex_check_nas_id(u_int32_t WTPID){
	unsigned char WlanID = 0;
	int localradio_id,k1;
	for(localradio_id = 0 ; localradio_id < AC_WTP[WTPID]->RadioCount ; localradio_id++)
	{
		if(AC_WTP[WTPID]->WTP_Radio[localradio_id] != NULL)
		{
			for(k1 = 0 ; k1 < L_BSS_NUM ; k1++)
			{
				if(AC_WTP[WTPID]->WTP_Radio[localradio_id]->BSS[k1] != NULL)
				{
					WlanID = AC_WTP[WTPID]->WTP_Radio[localradio_id]->BSS[k1]->WlanID;
					if(AC_WLAN[WlanID]&&(AC_WLAN[WlanID]->Wlan_Ifi != NULL)&&(AC_WTP[WTPID]->BindingSystemIndex != -1))
					{
						struct ifi * wlan_ifi = AC_WLAN[WlanID]->Wlan_Ifi;
						while(wlan_ifi != NULL)
						{

							if(AC_WTP[WTPID]->BindingSystemIndex == wlan_ifi->ifi_index)
							{
								if((wlan_ifi->nas_id_len > 0)&&(AC_WTP[WTPID]->WTP_Radio[localradio_id]->BSS[k1]->nas_id_len == 0))
								{
									AC_WTP[WTPID]->WTP_Radio[localradio_id]->BSS[k1]->nas_id_len= wlan_ifi->nas_id_len;
									memcpy(AC_WTP[WTPID]->WTP_Radio[localradio_id]->BSS[k1]->nas_id,wlan_ifi->nas_id,NAS_IDENTIFIER_NAME);
								}
								break;
							}
							wlan_ifi = wlan_ifi->ifi_next;
						}
					}
				}
			}
		}
	}			
}
int wid_set_wlan_hotspotid(unsigned char Wlanid,unsigned int hotspotid)
{
	if (AC_WLAN[Wlanid]->hotspot_id == hotspotid)
	{
		return WID_DBUS_SUCCESS;
	}
	
	AC_WLAN[Wlanid]->hotspot_id = hotspotid;
	
	{
		int i,j;
		for(i=0; i<WTP_NUM; i++)
		{
			if(AC_WTP[i]!=NULL)
			{
				for(j=0; j<AC_WTP[i]->RadioCount; j++)
				{
					if(AC_WLAN[Wlanid]->S_WTP_BSS_List[i][j] != 0)
					{
						int bssindex = AC_WLAN[Wlanid]->S_WTP_BSS_List[i][j];
						if(!check_bssid_func(bssindex)){
							wid_syslog_err("<error>%s\n",__func__);
						}else{						
							AC_BSS[bssindex]->hotspot_id = hotspotid;
						}
					}
				}
			}
		}
	}
	return WID_DBUS_SUCCESS;
}


unsigned int set_ap_spectrum_analysis(unsigned int radioid)
{
	msgq msg;
	unsigned int wtpid = 0;
	unsigned char l_radioid = 0;
	struct msgqlist *elem = NULL;	

	wtpid = radioid / L_RADIO_NUM;
	l_radioid = radioid % L_RADIO_NUM;
	
	if (WTP_NUM <= wtpid)
	{
		return WTP_ID_LARGE_THAN_MAX;
	}
	if (NULL == AC_WTP[wtpid])
	{
		return WTP_ID_NOT_EXIST;
	}
	
	if (NULL == AC_RADIO[radioid])
	{
		return WTP_ID_NOT_EXIST;
	}

	memset((char*)&msg, 0, sizeof(msg));
	msg.mqid = wtpid%THREAD_NUM+1;
	msg.mqinfo.WTPID = wtpid;
	msg.mqinfo.type = CONTROL_TYPE;
	msg.mqinfo.subtype = WTP_S_TYPE;
	msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_SPECTRUM_ANALYSIS;
	msg.mqinfo.u.WtpInfo.WTPID = wtpid;
	
	msg.mqinfo.u.WtpInfo.i1 = radioid;
	msg.mqinfo.u.WtpInfo.s1 = AC_RADIO[radioid]->spec_analysis.scan_cycle;
	msg.mqinfo.u.WtpInfo.s2 = AC_RADIO[radioid]->spec_analysis.scan_time;
	msg.mqinfo.u.WtpInfo.s3 = AC_RADIO[radioid]->spec_analysis.report_interval;
	msg.mqinfo.u.WtpInfo.c1 = l_radioid;	/* only 2.4G support spectrum analysis */
	msg.mqinfo.u.WtpInfo.c2 = AC_RADIO[radioid]->spec_analysis.enalbe;

	wid_syslog_info("%s: radio%d-%d sa cycle %d scan %d report interval %d %s", 
		__func__, wtpid, l_radioid, 
		AC_RADIO[radioid]->spec_analysis.scan_cycle,
		AC_RADIO[radioid]->spec_analysis.scan_time,
		AC_RADIO[radioid]->spec_analysis.report_interval,
		AC_RADIO[radioid]->spec_analysis.enalbe ? "enable" : "disable");

	if (WID_RUN == AC_WTP[wtpid]->WTPStat)
	{
		if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
		{
			wid_syslog_info("%s: wtp%d msgsend %s",__func__, wtpid, strerror(errno));
			return UNKNOWN_ERROR;
		}
	}		
	else if(AC_WTP[wtpid] != NULL)
	{
		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if(elem == NULL)
		{
			WID_MALLOC_ERR();
			return 0;
		}
		memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
		elem->next = NULL;
		memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
		WID_INSERT_CONTROL_LIST(wtpid, elem);
	}
	return 0;
}


unsigned int set_wtp_lan_vlan(unsigned int wtpid)
{
	msgq msg;
	struct msgqlist *elem = NULL;	

	if (WTP_NUM <= wtpid)
	{
		return WTP_ID_LARGE_THAN_MAX;
	}
	if (NULL == AC_WTP[wtpid])
	{
		return WTP_ID_NOT_EXIST;
	}

	memset((char*)&msg, 0, sizeof(msg));

	if((AC_WTP[wtpid] != NULL)&&(WID_RUN == AC_WTP[wtpid]->WTPStat))
	{
		CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));
		if (gWTPs[wtpid].isNotFree && (CW_ENTER_RUN == gWTPs[wtpid].currentState))
		{
			msg.mqid = wtpid%THREAD_NUM+1;
			msg.mqinfo.WTPID = wtpid;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_LAN_VLAN;
			msg.mqinfo.u.WtpInfo.value1 = AC_WTP[wtpid]->lan_vlan.state;
			msg.mqinfo.u.WtpInfo.value3 = AC_WTP[wtpid]->lan_vlan.vlanid;
			
			if (-1 == msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0))
			{
				wid_syslog_err("%s: msgsend %s", __func__, strerror(errno));
			}
		}		
		CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));
	}
	else if ((AC_WTP[wtpid] != NULL))
	{	
		msg.mqid = wtpid%THREAD_NUM+1;
		msg.mqinfo.WTPID = wtpid;
		msg.mqinfo.type = CONTROL_TYPE;
		msg.mqinfo.subtype = WTP_S_TYPE;
		msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_LAN_VLAN;
		msg.mqinfo.u.WtpInfo.value1 = AC_WTP[wtpid]->lan_vlan.state;
		msg.mqinfo.u.WtpInfo.value3 = AC_WTP[wtpid]->lan_vlan.vlanid;

		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if(elem == NULL)
		{
			wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
			perror("malloc");
			return 0;
		}
		memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
		elem->next = NULL;
		memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
		WID_INSERT_CONTROL_LIST(wtpid, elem);
		elem = NULL;
	}

	return 0;	
}

/*******************************************************************************
 *  FUNCTION: 
 *      wid_check_radio_is_apply_wlan
 *      : check the Radio is apply wlan
 *  
 *  INPUT:
 *
 *
 *  OUTPUT:
 *
 *
 *  RETURN VALUE:
 *       ret    -1: check fail
 *               0: check succes, and radio no apply wlan
 *               1: check succes, and radio has apply wlan
 *
 ******************************************************************************/
int wid_check_radio_is_apply_wlan
(
	unsigned int RadioID,
	unsigned char WlanID
)
{
	int ret = -1;
	struct wlanid *wlan_id_next = NULL;

	WID_CHECK_WLAN_EXIST_RET(WlanID, ret);
	WID_CHECK_G_RADIOID_STANDARD_RET(RadioID,ret);
	wid_syslog_debug_debug(WID_DEFAULT, "*** check radio%d bind wlan%d\n",RadioID, WlanID);

	if (NULL != AC_RADIO[RadioID])
	{
		wlan_id_next = AC_RADIO[RadioID]->Wlan_Id;
		while (wlan_id_next != NULL)
		{	
			if (wlan_id_next->wlanid == WlanID)
			{
				wid_syslog_debug_debug(WID_DEFAULT,"radio%d has binding wlan%d\n",RadioID, WlanID);
				return 1;
			}
			wlan_id_next = wlan_id_next->next;
		}
	}

	return 0;
}

int set_ap_5g_first(unsigned int WtpID)
{
	msgq msg;
	struct msgqlist *elem = NULL;	

	if (WTP_NUM <= WtpID)
	{
		return WTP_ID_LARGE_THAN_MAX;
	}
	
	if (NULL == AC_WTP[WtpID])
	{
		return WTP_ID_NOT_EXIST;
	}
		
	if (WID_RUN == AC_WTP[WtpID]->WTPStat)
	{
		CWThreadMutexLock(&(gWTPs[WtpID].WTPThreadMutex));
		if (gWTPs[WtpID].isNotFree && (CW_ENTER_RUN == gWTPs[WtpID].currentState))
		{
			memset((char*)&msg, 0, sizeof(msg));
			
			msg.mqid                      = WtpID % THREAD_NUM + 1;
			msg.mqinfo.WTPID              = WtpID;
			msg.mqinfo.type               = CONTROL_TYPE;
			msg.mqinfo.subtype            = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op   = WTP_SET_AP_5G_FIRST;
			msg.mqinfo.u.WtpInfo.value[0] = AC_WTP[WtpID]->join5g.join5g_switch;
			msg.mqinfo.u.WtpInfo.value[1] = AC_WTP[WtpID]->join5g.discard_count;
			msg.mqinfo.u.WtpInfo.value[2] = AC_WTP[WtpID]->join5g.sta_count;
			msg.mqinfo.u.WtpInfo.value[3] = AC_WTP[WtpID]->join5g.signal_strength;
			msg.mqinfo.u.WtpInfo.value2   = AC_WTP[WtpID]->join5g.aging_time;
			msg.mqinfo.u.WtpInfo.value3   = AC_WTP[WtpID]->join5g.scan_time;
			
			if (-1 == msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0))
			{
				wid_syslog_info("%s msgsend %s", __func__, strerror(errno));
			}
		}
		
		CWThreadMutexUnlock(&(gWTPs[WtpID].WTPThreadMutex));
	}
	else if (1 == AC_WTP[WtpID]->isused)
	{
		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if (NULL == elem)
		{
			WID_MALLOC_ERR();
			return MALLOC_ERROR;
		}
		memset(elem, 0, sizeof(struct msgqlist));
		
		elem->mqinfo.WTPID              = WtpID;
		elem->mqinfo.type               = CONTROL_TYPE;
		elem->mqinfo.subtype            = WTP_S_TYPE;
		elem->mqinfo.u.WtpInfo.Wtp_Op   = WTP_SET_AP_5G_FIRST;
		elem->mqinfo.u.WtpInfo.value[0] = AC_WTP[WtpID]->join5g.join5g_switch;
		elem->mqinfo.u.WtpInfo.value[1] = AC_WTP[WtpID]->join5g.discard_count;
		elem->mqinfo.u.WtpInfo.value[2] = AC_WTP[WtpID]->join5g.sta_count;
		elem->mqinfo.u.WtpInfo.value[3] = AC_WTP[WtpID]->join5g.signal_strength;
		elem->mqinfo.u.WtpInfo.value2   = AC_WTP[WtpID]->join5g.aging_time;
		elem->mqinfo.u.WtpInfo.value3   = AC_WTP[WtpID]->join5g.scan_time;
		
		WID_INSERT_CONTROL_LIST(WtpID, elem);
		elem = NULL;		
	}

	return 0;
}

int wid_wlan_ctr_list_enable(unsigned char WlanID, unsigned int enable)
{
	if (WLAN_NUM <= WlanID)
	{
		return -1;
	}
	
	if(NULL == AC_WLAN[WlanID])
	{
		return WLAN_ID_NOT_EXIST;
	}
	
	if (AC_WLAN[WlanID]->ctr_head.enable != enable)
	{
		AC_WLAN[WlanID]->ctr_head.enable = enable;
		
		AsdWsm_WLANOp(WlanID, WID_MODIFY, 0);
	}

	return 0;
}


int wid_wlan_ctr_list_time(unsigned char WlanID, unsigned int effective_time, unsigned int session_time)
{
	if (WLAN_NUM <= WlanID)
	{
		return WID_DBUS_ERROR;
	}
	
	if(NULL == AC_WLAN[WlanID])
	{
		return WLAN_ID_NOT_EXIST;
	}

	if (AC_WLAN[WlanID]->ctr_head.enable)
	{
		return WLAN_CTR_LIST_ENABLE;
	}
	
	AC_WLAN[WlanID]->ctr_head.activities_effective_time = effective_time;
	AC_WLAN[WlanID]->ctr_head.session_time = session_time;
			
	AsdWsm_WLANOp(WlanID, WID_MODIFY, 0);

	return WID_DBUS_SUCCESS;
}

int WID_CREATE_NEW_ACLGROUP(unsigned char *group_name, unsigned char group_id)
{
	int len = 0;
	
	if (NULL == group_name)
	{
		return WID_RETURN_CODE_BADPARAM;
	}
	
	if ((ACL_GROUP_NUM <= group_id) || (0 >= group_id))
	{
		return WID_RETURN_CODE_ACL_GROUP_ID_OVER_RANGE;
	}
	
	if (NULL != STA_ACL_GROUP[group_id])
	{
		return WID_RETURN_CODE_ACLGRP_EXISTS;
	}
	
	STA_ACL_GROUP[group_id] = (STA_ACLGRP *)malloc(sizeof(STA_ACLGRP));
	if (NULL == STA_ACL_GROUP[group_id])
	{
		wid_syslog_info("%s %d: ERR out of memory\n", __func__, __LINE__);
		return WID_RETURN_CODE_OUT_OF_MEMORY;
	}
	else
	{
		memset(STA_ACL_GROUP[group_id], 0, sizeof(STA_ACLGRP));
		STA_ACL_GROUP[group_id]->groupid = group_id;
		len = strlen((char *)group_name);
		STA_ACL_GROUP[group_id]->groupname = (unsigned char *)malloc(len + 1);
		if (NULL == STA_ACL_GROUP[group_id]->groupname)
		{
			CW_FREE_OBJECT(STA_ACL_GROUP[group_id]);
			wid_syslog_info("%s %d: ERR out of memory\n", __func__, __LINE__);
			return WID_RETURN_CODE_OUT_OF_MEMORY;				
		}
		else
		{
			memset(STA_ACL_GROUP[group_id]->groupname, 0, len + 1);
			memcpy(STA_ACL_GROUP[group_id]->groupname, group_name, len);
		}
	}
	
	return 0;
}

int WID_DELETE_ACLGROUP(unsigned char group_id)
{
	ACL_RULElist *rule_list = NULL;
	ACL_RULElist *rule_tmp = NULL;
	
	if ((ACL_GROUP_NUM <= group_id) || (0 >= group_id))
	{
		return WID_RETURN_CODE_ACL_GROUP_ID_OVER_RANGE;
	}
	
	if (NULL == STA_ACL_GROUP[group_id])
	{
		return WID_RETURN_CODE_ACLGRP_NOT_EXISTS;
	}
	
	if (NULL != STA_ACL_GROUP[group_id]->WlanList)
	{
		return WID_RETURN_CODE_ACLGRP_IS_BINDED;
	}

	if (NULL != STA_ACL_GROUP[group_id]->rule_list)
	{
		rule_list = STA_ACL_GROUP[group_id]->rule_list;
		while (NULL != rule_list)
		{
			rule_tmp = rule_list;
			rule_list = rule_list->next;
			STA_ACL_RULE[rule_tmp->rule_id]->acl_refcnt--;
			CW_FREE_OBJECT(rule_tmp);
		}
	}

	CW_FREE_OBJECT(STA_ACL_GROUP[group_id]->groupname);
	CW_FREE_OBJECT(STA_ACL_GROUP[group_id]);	

	return 0;
}

int WID_add_rule_to_aclgroup(unsigned char group_id, unsigned int rule_id)
{
	ACL_RULElist *rule_list = NULL;
	ACL_RULElist *rule_tmp = NULL;
	
	wid_syslog_debug_debug(WID_DEFAULT, "%s,  groupid %d ruleid %d\n",
						__func__,  group_id, rule_id);
	
	if ((ACL_GROUP_NUM <= group_id) || (0 >= group_id))
	{
		return WID_RETURN_CODE_ACL_GROUP_ID_OVER_RANGE;
	}
	
	if (NULL == STA_ACL_GROUP[group_id])
	{
		return WID_RETURN_CODE_ACLGRP_NOT_EXISTS;
	}

	if (NULL != STA_ACL_GROUP[group_id]->WlanList)
	{
		return WID_RETURN_CODE_ACLGRP_IS_BINDED;
	}
	
	if (GROUP_ACL_COUNT <= STA_ACL_GROUP[group_id]->rule_cnt)
	{
		return WID_RETURN_CODE_ACLGRP_RULE_IS_FULL;
	}
	
	if ((ACL_RULE_NUM <= rule_id) || (0 >= rule_id))
	{
		return WID_RETURN_CODE_ACL_RULE_ID_OVER_RANGE;
	}
	
	if (NULL == STA_ACL_RULE[rule_id])
	{
		return WID_RETURN_CODE_ACL_RULE_NOT_EXISTS;
	}

	rule_tmp = (ACL_RULElist *)malloc(sizeof(ACL_RULElist));
	if (NULL == rule_tmp)
	{
		wid_syslog_info("%s %d: ERR out of memory\n", __func__, __LINE__);
		return WID_RETURN_CODE_OUT_OF_MEMORY;
	}
	memset(rule_tmp, 0, sizeof(ACL_RULElist));
	rule_tmp->rule_id = rule_id;
	
	wid_syslog_debug_debug(WID_DEFAULT, "%s,  before lock \n", __func__);
	
	CWThreadMutexLock(&STA_ACL_GROUP[group_id]->AclGrpMutex);
	
	if (NULL == STA_ACL_GROUP[group_id]->rule_list)
	{
		STA_ACL_GROUP[group_id]->rule_list = rule_tmp;
		STA_ACL_GROUP[group_id]->rule_cnt++;
		STA_ACL_RULE[rule_id]->acl_refcnt++;
		CWThreadMutexUnlock(&STA_ACL_GROUP[group_id]->AclGrpMutex);
		wid_syslog_debug_debug(WID_DEFAULT, "%s, case 1  after lock \n", __func__);
		return 0;
	}
	else
	{
		rule_list = STA_ACL_GROUP[group_id]->rule_list;
		while (rule_list)
		{
			if (rule_id == rule_list->rule_id)
			{
				CW_FREE_OBJECT(rule_tmp);
				CWThreadMutexUnlock(&STA_ACL_GROUP[group_id]->AclGrpMutex);
				wid_syslog_debug_debug(WID_DEFAULT, "%s, case 2  after lock \n", __func__);
				return WID_RETURN_CODE_ACL_RULE_IN_ACLGRP;
			}
			rule_list = rule_list->next;
		}
		
		rule_list = STA_ACL_GROUP[group_id]->rule_list;
		while (rule_list->next)
		{
			rule_list = rule_list->next;
		}		
		rule_list->next = rule_tmp;
		STA_ACL_GROUP[group_id]->rule_cnt++;
		STA_ACL_RULE[rule_id]->acl_refcnt++;		
	}
	
	CWThreadMutexUnlock(&STA_ACL_GROUP[group_id]->AclGrpMutex);
	
	wid_syslog_debug_debug(WID_DEFAULT, "%s, case 3  after lock \n", __func__);
	
	return 0;
}

int WID_del_rule_from_aclgroup(unsigned char group_id, unsigned int rule_id)
{
	ACL_RULElist *rule_list = NULL;
	ACL_RULElist *rule_tmp = NULL;

	wid_syslog_debug_debug(WID_DEFAULT, "%s, groupid %d ruleid %d\n", __func__, group_id, rule_id);

	/* check group id */
	if ((ACL_GROUP_NUM <= group_id) || (0 >= group_id))
	{
		return WID_RETURN_CODE_ACL_GROUP_ID_OVER_RANGE;
	}
	if (NULL == STA_ACL_GROUP[group_id])
	{
		return WID_RETURN_CODE_ACLGRP_NOT_EXISTS;
	}
	/* check if group is binded */
	if (NULL != STA_ACL_GROUP[group_id]->WlanList)
	{
		return WID_RETURN_CODE_ACLGRP_IS_BINDED;
	}
	/* check acl rule id */
	if ((ACL_RULE_NUM <= rule_id) || (0 >= rule_id))
	{
		return WID_RETURN_CODE_ACL_RULE_ID_OVER_RANGE;
	}	
	if (NULL == STA_ACL_RULE[rule_id])
	{
		return WID_RETURN_CODE_ACL_RULE_NOT_EXISTS;
	}
	wid_syslog_debug_debug(WID_DEFAULT, "%s,  before lock \n", __func__);
	/* check rule if is in group  */
	CWThreadMutexLock(&STA_ACL_GROUP[group_id]->AclGrpMutex);
	if (NULL == STA_ACL_GROUP[group_id]->rule_list)
	{
		CWThreadMutexUnlock(&STA_ACL_GROUP[group_id]->AclGrpMutex);
		wid_syslog_debug_debug(WID_DEFAULT, "%s, case 1  after lock \n", __func__);
		return WID_RETURN_CODE_ACL_RULE_NOT_IN_ACLGRP;
	}
	else if (rule_id == STA_ACL_GROUP[group_id]->rule_list->rule_id)
	{
		rule_tmp = STA_ACL_GROUP[group_id]->rule_list;
		STA_ACL_GROUP[group_id]->rule_list = STA_ACL_GROUP[group_id]->rule_list->next;
		STA_ACL_GROUP[group_id]->rule_cnt--;
		STA_ACL_RULE[rule_id]->acl_refcnt--;
		CW_FREE_OBJECT(rule_tmp);
		CWThreadMutexUnlock(&STA_ACL_GROUP[group_id]->AclGrpMutex);
		wid_syslog_debug_debug(WID_DEFAULT, "%s, case 2  after lock \n", __func__);
		return 0;
	}
	else
	{
		rule_list = STA_ACL_GROUP[group_id]->rule_list;
		while (rule_list->next)
		{
			if (rule_id == (rule_list->next)->rule_id)
			{
				rule_tmp = rule_list->next;
				rule_list->next = rule_tmp->next;
				STA_ACL_GROUP[group_id]->rule_cnt--;
				STA_ACL_RULE[rule_id]->acl_refcnt--;
				CW_FREE_OBJECT(rule_tmp);
				CWThreadMutexUnlock(&STA_ACL_GROUP[group_id]->AclGrpMutex);
				wid_syslog_debug_debug(WID_DEFAULT, "%s, case 3  after lock \n", __func__);
				return 0;
			}
			rule_list = rule_list->next;
		}		
	}
	CWThreadMutexUnlock(&STA_ACL_GROUP[group_id]->AclGrpMutex);
	wid_syslog_debug_debug(WID_DEFAULT, "%s, case 4  after lock \n", __func__);
	return WID_RETURN_CODE_ACL_RULE_NOT_IN_ACLGRP;
}

/* bind a acl group to a wlan */
int WID_WLAN_BIND_STA_ACLGRP(unsigned char WlanID,unsigned char GROUPID)
{
	wid_syslog_debug_debug(WID_DEFAULT,"%s, WlanID %d GROUPID %d\n", __func__,WlanID,GROUPID);
	
	ACL_WLANlist *wlanlist = NULL;
	ACL_WLANlist *wlantmp = NULL;
	unsigned int BSSIndex = 0;
	msgq msg;
	struct msgqlist *elem = NULL;
	int m = 0, n = 0;	

	if (WLAN_NUM <= WlanID)
	{
		return WID_RETURN_CODE_WLAN_ID_OVER_RANGE;
	}
	if(NULL == AC_WLAN[WlanID])
	{
		return WID_RETURN_CODE_WLAN_NOT_EXISTS;
	}
	
	/* check group id */
	if (ACL_GROUP_NUM <= GROUPID)
	{
		return WID_RETURN_CODE_ACL_GROUP_ID_OVER_RANGE;
	}
	if (NULL == STA_ACL_GROUP[GROUPID])
	{
		return WID_RETURN_CODE_ACLGRP_NOT_EXISTS;
	}

	if(AC_WLAN[WlanID]->aclgrp_id == GROUPID)
	{
		return 0;
	}
	else if(0 != AC_WLAN[WlanID]->aclgrp_id)
	{
		return WID_RETURN_CODE_WLAN_BIND_ALCGRP;
	}
		
	AC_WLAN[WlanID]->aclgrp_id = GROUPID;	
	
	if(0 == AC_WLAN[WlanID]->Status)
	{
		/* loop all wtp */
		for(m = 0; m < WTP_NUM; m++)
		{
			if(AC_WTP[m] != NULL)
			{	
				/* loop all radio */
				for(n = 0; n < AC_WTP[m]->RadioCount; n++)
				{					
					if(0 != AC_WLAN[WlanID]->S_WTP_BSS_List[m][n])
					{	
						BSSIndex = AC_WLAN[WlanID]->S_WTP_BSS_List[m][n];
						if((check_bssid_func(BSSIndex))&&(AC_BSS[BSSIndex] != NULL))
						{
							memset((char*)&msg, 0, sizeof(msg));
							msg.mqid = m%THREAD_NUM+1;
							msg.mqinfo.WTPID = m;
							msg.mqinfo.type = CONTROL_TYPE;
							msg.mqinfo.subtype = WTP_S_TYPE;
							msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_ACL_LIST;
							msg.mqinfo.u.WtpInfo.value[0] = WlanID;
							msg.mqinfo.u.WtpInfo.value[1] = n;
							msg.mqinfo.u.WtpInfo.value[2] = OVERWRITE;
							msg.mqinfo.u.WtpInfo.value[3] = LEVEL_WLAN;
							msg.mqinfo.u.WtpInfo.value[4] = GROUPID;
							/*
							msg.mqinfo.u.WtpInfo.value3 = STA_ACL_GROUP[GROUPID]->rule_cnt;
							rulelist = STA_ACL_GROUP[GROUPID]->rule_list;
							for (i = 0; i < STA_ACL_GROUP[GROUPID]->rule_cnt; i++)
							{
								msg.mqinfo.u.WtpInfo.value[i] = rulelist->rule_id;
								rulelist = rulelist->next;
							}
							*/
							wid_syslog_debug_debug(WID_DEFAULT, "%s, wtp%d state %d AC_WTP[%d]->CMD->radiowlanid[%d][%d]= %d\n",
												__func__,m,AC_WTP[m]->WTPStat,m,n,WlanID,AC_WTP[m]->CMD->radiowlanid[n][WlanID]);
							
							if((AC_WTP[m]->WTPStat == WID_RUN)&&(AC_WTP[m]->CMD->radiowlanid[n][WlanID] == 2))
							{ 
								if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
								{
									wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
								}
							}
							else
							{
								elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
								if (NULL == elem)
								{			
									WID_MALLOC_ERR();			
									return WID_RETURN_CODE_OUT_OF_MEMORY;
								}			
								memset(elem, 0, sizeof(struct msgqlist));
								elem->mqinfo.WTPID = m;
								elem->mqinfo.type = CONTROL_TYPE;
								elem->mqinfo.subtype = WTP_S_TYPE;
								elem->mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_ACL_LIST;
								elem->mqinfo.u.WtpInfo.value[0] = WlanID;
								elem->mqinfo.u.WtpInfo.value[1] = n;
								elem->mqinfo.u.WtpInfo.value[2] = OVERWRITE;
								elem->mqinfo.u.WtpInfo.value[3] = LEVEL_WLAN;
								elem->mqinfo.u.WtpInfo.value[4] = GROUPID;
			
								WID_INSERT_CONTROL_LIST(m, elem);
							}
						}
					}
				}
			}
		}
	}
	
	if(NULL == STA_ACL_GROUP[GROUPID]->WlanList)		//instert to notice list
	{
		wlantmp = (ACL_WLANlist *)malloc(sizeof(ACL_WLANlist));
		if(NULL == wlantmp)
		{
			wid_syslog_info("%s %d: ERR out of memory\n", __func__, __LINE__);
			return WID_RETURN_CODE_OUT_OF_MEMORY;
		}
		wlantmp->WlanID = WlanID;
		wlantmp->next = NULL;
		STA_ACL_GROUP[GROUPID]->WlanList = wlantmp;
	}
	else if(STA_ACL_GROUP[GROUPID]->WlanList->WlanID == WlanID)
	{
		return 0;	//bssindex in the head,do nothing
	}
	else
	{
		wlanlist = STA_ACL_GROUP[GROUPID]->WlanList;
		while(NULL != wlanlist->next)
		{
			if(wlanlist->next->WlanID == WlanID)
			{
				return 0;
			}
			wlanlist = wlanlist->next;
		}

		wlantmp = (ACL_WLANlist *)malloc(sizeof(ACL_WLANlist));
		if(NULL == wlantmp)
		{
			wid_syslog_info("%s %d: ERR out of memory\n", __func__, __LINE__);
			return WID_RETURN_CODE_OUT_OF_MEMORY;
		}
		else
		{
			wlantmp->WlanID = WlanID;	
			wlantmp->next = NULL;
			wlanlist->next = wlantmp;
		}
		
	}	//insert tail		

	return 	0;
}

int WID_WLAN_UNBIND_STA_ACLGRP(unsigned char WlanID)
{
	ACL_WLANlist *wlanlist = NULL;
	ACL_WLANlist *wlantmp = NULL;
	unsigned int BSSIndex = 0;
	msgq msg;
	struct msgqlist *elem = NULL;
	int m = 0, n = 0;	
	unsigned char groupid = 0;

	/* check wlan id*/
	if (WLAN_NUM <= WlanID)
	{
		return WID_RETURN_CODE_WLAN_ID_OVER_RANGE;
	}
	if(NULL == AC_WLAN[WlanID])
	{
		return WID_RETURN_CODE_WLAN_NOT_EXISTS;
	}	

	if(0 == AC_WLAN[WlanID]->aclgrp_id)
	{
		return WID_RETURN_CODE_WLAN_NOT_BIND_ALCGRP;
	}

	groupid = AC_WLAN[WlanID]->aclgrp_id;
	AC_WLAN[WlanID]->aclgrp_id = 0;	
	
	if(0 == AC_WLAN[WlanID]->Status)
	{
		/* loop all wtp */
		for(m = 0; m < WTP_NUM; m++)
		{
			if(AC_WTP[m] != NULL)
			{	
				/* loop all radio */
				for(n = 0; n < AC_WTP[m]->RadioCount; n++)
				{					
					if(0 != AC_WLAN[WlanID]->S_WTP_BSS_List[m][n])
					{	
						BSSIndex = AC_WLAN[WlanID]->S_WTP_BSS_List[m][n];
						if((check_bssid_func(BSSIndex))&&(AC_BSS[BSSIndex] != NULL))
						{
							memset((char*)&msg, 0, sizeof(msg));
							msg.mqid = m%THREAD_NUM+1;
							msg.mqinfo.WTPID = m;
							msg.mqinfo.type = CONTROL_TYPE;
							msg.mqinfo.subtype = WTP_S_TYPE;
							msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_ACL_LIST;
							msg.mqinfo.u.WtpInfo.value[0] = WlanID;
							msg.mqinfo.u.WtpInfo.value[1] = n;
							msg.mqinfo.u.WtpInfo.value[2] = CANCEL;
							msg.mqinfo.u.WtpInfo.value[3] = LEVEL_WLAN;
		
							if((AC_WTP[m]->WTPStat == WID_RUN)&&(AC_WTP[m]->CMD->radiowlanid[n][WlanID] == 2))
							{ 
								if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
								{
									wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
								}
							}
							else
							{
								
								elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
								if (NULL == elem)
								{			
									WID_MALLOC_ERR();			
									return WID_RETURN_CODE_OUT_OF_MEMORY;
								}			
								memset(elem, 0, sizeof(struct msgqlist));
								elem->mqinfo.WTPID = m;
								elem->mqinfo.type = CONTROL_TYPE;
								elem->mqinfo.subtype = WTP_S_TYPE;
								elem->mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_ACL_LIST;
								elem->mqinfo.u.WtpInfo.value[0] = WlanID;
								elem->mqinfo.u.WtpInfo.value[1] = n;
								elem->mqinfo.u.WtpInfo.value[2] = CANCEL;
								elem->mqinfo.u.WtpInfo.value[3] = LEVEL_WLAN;
								
								WID_INSERT_CONTROL_LIST(m, elem);
							}
						}
					}
				}
			}
		}
	}
	
	if(NULL == STA_ACL_GROUP[groupid]->WlanList)		//instert to notice list
	{
		return 0;
	}
	else if(STA_ACL_GROUP[groupid]->WlanList->WlanID == WlanID)
	{
		wlantmp = STA_ACL_GROUP[groupid]->WlanList;
		STA_ACL_GROUP[groupid]->WlanList = STA_ACL_GROUP[groupid]->WlanList->next;
		CW_FREE_OBJECT(wlantmp);
		return 0;	
	}
	else
	{
		wlanlist = STA_ACL_GROUP[groupid]->WlanList;
		while(NULL != wlanlist->next)
		{
			if(wlanlist->next->WlanID == WlanID)
			{
				wlantmp = wlanlist->next;
				wlanlist->next = wlantmp->next;
				CW_FREE_OBJECT(wlantmp);
				return 0;
			}
			wlanlist = wlanlist->next;
		}		
	}	//insert tail		

	return 	0;
}

ACL_WLANlist *delete_wlan_from_aclgrp(ACL_WLANlist *wlanlist,unsigned char wlanid)
{
	ACL_WLANlist *ptr = NULL;
	ACL_WLANlist *temp = NULL;
	
	if(NULL == wlanlist)
	{
		return NULL;
	}
	
	if(wlanlist->WlanID == wlanid)
	{
		temp = wlanlist;
		wlanlist = wlanlist->next;
		CW_FREE_OBJECT(temp);
	}
	else
	{
		ptr = wlanlist;
		while(ptr->next != NULL)				
		{
			if(ptr->next->WlanID == wlanid)	  
			{
				temp = ptr->next;
				ptr->next = ptr->next->next;
				CW_FREE_OBJECT(temp);
				break;
			}
			ptr = ptr->next; 
		}
	}
	
	return wlanlist;
}


unsigned int wid_set_bss_wds
(
	unsigned int wtpid,
	unsigned char radioid,
	unsigned char wlanid,
	unsigned char state
)
{
	unsigned int ret = 0;	
	char apcmd[WID_SYSTEM_CMD_LENTH];
	char apcmd2[WID_SYSTEM_CMD_LENTH];

	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);
	memset(apcmd2,0,WID_SYSTEM_CMD_LENTH);

	if(state == WLAN_WDS_ENABLE)
	{
		sprintf(apcmd,"iwpriv ath.%d-%d wds 1",radioid,wlanid);
		sprintf(apcmd2,"iwpriv ath.%d-%d ap_bridge 0",radioid,wlanid);
	}
	else if(state == WLAN_WDS_DISABLE)
	{
		sprintf(apcmd,"iwpriv ath.%d-%d wds 0",radioid,wlanid);
	}
	else
	{
		return WID_DBUS_ERROR;
	}

	ret = wid_radio_set_extension_command(wtpid,apcmd);
	if (WID_DBUS_SUCCESS != ret)
	{
		return ret;
	}
	if(state == WLAN_WDS_ENABLE)
	{
		ret = wid_radio_set_extension_command(wtpid,apcmd2);
	}

	return 0;

}

/*******************************************************************************
	4-way handshake compatible table.
	|------------------------------|
	|  AP-model       |  AP-code   |
	|------------------------------|
	| AE5000-EG       |  2000-N    |
	| AE5000-ENH      |  2000-NH   |
	| AE6000-EGH      |  2000-NH   |
	| AQ2110-H        |  2000-SNH  |
	| AQ2010-H        |  2110-H    |
	| AQ2010V2        |  2010V2    |
	| AQ2010          |  2010      |
	| AQ2110-N        |  2110-N    |
	| AE5000-EN3      |  -APV6     |
	| AE5000-E2AN3    |  -APV6     |
	| AF4000-ENH3     |  -AF4000   |
	| AF4000-E2ANH3   |  -AF4000   |
	| AF4000-E2ANH3-O |  -AF4000   |
	| AF3220-N        |  -AF3000   |
	| AF3220-AN       |  -AF3000   |
	|------------------------------|
*******************************************************************************/
unsigned wid_four_way_handshake_compatible(unsigned int wtpid)
{
	int i = 0;
	char *compatible_wtp_list[] = 
								{
									"2000-SNH",  /* pepwave */
									"2000-NH",   /* 7240 */
									"2000-N",    /* 7240 */
									"2110-H",    /* cavium */
									"2010V2",    /* 2010V2 */
									"2010",      /* 2010 */
									"2110-N",    /* cavium */					
									"-APV6",
									"-AF4000",
									"-AF3000",
									NULL
								};

	if ((wtpid >= WTP_NUM)
		|| (NULL == AC_WTP[wtpid])
		|| (NULL == AC_WTP[wtpid]->APCode))
	{
		return 0;
	}

	for (i = 0; compatible_wtp_list[i]; i++)
	{
		if (0 == strcmp(compatible_wtp_list[i], AC_WTP[wtpid]->APCode))
		{
			AC_WTP[wtpid]->four_way_handshake_on_ac = 1;
			break;
		}
	}
	/*
	wid_syslog_info("wtp%d 4-way handshake on %s\n", wtpid,
		AC_WTP[wtpid]->four_way_handshake_on_ac ? "AC" : "AP");
	*/

	return 0;
}


unsigned int wid_wlan_deinit(wlan_t wlanid)
{	
	WID_CHECK_WLAN_EXIST_RET(wlanid, WLAN_ID_NOT_EXIST);

	if(AC_WLAN[wlanid]->Status == 0)
	{
		return WLAN_BE_ENABLE;
	}	

	struct ifi *wlan_ifi = AC_WLAN[wlanid]->Wlan_Ifi;
	while(wlan_ifi != NULL)
	{
		AC_WLAN[wlanid]->Wlan_Ifi = wlan_ifi->ifi_next;
		CW_FREE_OBJECT(wlan_ifi);
		wlan_ifi = AC_WLAN[wlanid]->Wlan_Ifi;		
	}
	
	CW_FREE_OBJECT(AC_WLAN[wlanid]->eap_mac);

	struct WID_TUNNEL_WLAN_VLAN *wlan_vlan = AC_WLAN[wlanid]->tunnel_wlan_vlan;
	while(wlan_vlan != NULL)
	{
		AC_WLAN[wlanid]->tunnel_wlan_vlan = wlan_vlan->ifnext;
		CW_FREE_OBJECT(wlan_vlan);
		wlan_vlan = AC_WLAN[wlanid]->tunnel_wlan_vlan;
	}

	//CW_FREE_OBJECT(AC_WLAN[wlanid]);

	return 0;
}

int wtp_upgrade_init(struct wtp_upgrade *upgrade)
{
	if (NULL == upgrade)
	{
		return -1;
	}

	memset(upgrade, 0, sizeof(struct wtp_upgrade));
	upgrade->state = WTP_UPGRADE_STATE_DONE;
	upgrade->mode = g_wtp_upgrade_mode;

	return 0;
}

int wtp_upgrade_reinit(struct wtp_upgrade *upgrade)
{
	if (NULL == upgrade)
	{
		return -1;
	}

	if (NULL != upgrade->fp)
	{
		fclose(upgrade->fp);
		upgrade->fp = NULL;
	}

	upgrade->state = WTP_UPGRADE_STATE_DONE;
	upgrade->pktcnt = 0;

	return 0;
}

void wid_set_upgrade_state(struct wtp_upgrade *upgrade, enum wtp_upgrade_state state)
{
	if (NULL == upgrade)
	{
		return;
	}

	upgrade->state = state;

	return;
}

int sum_of_strtoint(int index, int lastindex, unsigned char *dvlanlist)
{
	int sum = 0;
	switch(index - lastindex)
	{
		case 2:
			sum = dvlanlist[index-1]-'0';
			break;
		case 3:
			sum = 10*(dvlanlist[index-2]-'0') + (dvlanlist[index-1]-'0');
			break;
		case 4:
			sum = 100*(dvlanlist[index-3]-'0') + 10*(dvlanlist[index-2]-'0') + (dvlanlist[index-1]-'0');
			break;
		case 5:
			sum = 1000*(dvlanlist[index-4]-'0') + 100*(dvlanlist[index-3]-'0') + 10*(dvlanlist[index-2]-'0') + (dvlanlist[index-1]-'0');
			break;
		default:
			wid_syslog_err("%s:  in default branch, error!\n", __func__);
			break;
	}
	return sum;
}

void destroy_vlan_group_member(struct vlangrpm *memlist)
{
	struct vlangrpm *phead = NULL;
	struct vlangrpm *pnext = NULL;

	if(memlist == NULL)
	{
		return;
	}

	phead = memlist;
	memlist = NULL;	
	
	while(phead != NULL)
	{			
		pnext = phead->next;

		wid_syslog_debug_debug(WID_DEFAULT,"vlan group delete member radio %d\n",
											phead->radioid);
		CW_FREE_OBJECT(phead);

		phead = pnext;
	}
}

struct vlangrpm *find_radio_from_vlangrp(struct vlangrpm *memlist, unsigned int radioid)     
{
	struct vlangrpm *mem_search = NULL;       
	mem_search = memlist;  
		 
	while(mem_search != NULL)              
	{
		if(mem_search->radioid == radioid)     
		{
			return mem_search;
		}
		mem_search = mem_search->next;
	}

	return mem_search;//here return null
}

struct vlangrpm *insert_radio_to_vlangrp(struct vlangrpm *memlist, unsigned int radioid)
{
	struct vlangrpm *meminsert = NULL;
	struct vlangrpm *radionode = NULL;
		
	radionode = (struct vlangrpm*)malloc(sizeof(struct vlangrpm));
	if(NULL == radionode)
	{
		return NULL;
	}
	memset(radionode, 0, sizeof(struct vlangrpm));
	radionode->radioid = radioid;
	radionode->next = NULL;
					
	if(memlist == NULL)
	{		
		memlist = radionode;
	}
	else
	{	
		meminsert = memlist;
		while(meminsert->next != NULL)
		{	
			meminsert = meminsert->next;
		}
		
		meminsert->next = radionode;
	}

	return memlist;
}


struct vlangrpm *delete_radio_from_vlangrp(struct vlangrpm *memlist, unsigned int radioid)
{
	struct vlangrpm *ptr = NULL;
	struct vlangrpm *temp = NULL;
	
	if(NULL == memlist)
	{
		return NULL;
	}
	
	if(memlist->radioid == radioid)
	{
		temp = memlist;
		memlist = memlist->next;
		CW_FREE_OBJECT(temp);
	}
	else
	{
		ptr = memlist;
		while(ptr->next != NULL)				
		{
			if(ptr->next->radioid == radioid)	  
			{
				temp = ptr->next;
				ptr->next = ptr->next->next;
				CW_FREE_OBJECT(temp);
				break;
			}
			ptr = ptr->next; 
		}
	}
	
	return memlist;
}


unsigned int add_vlan_group_member(unsigned int groupid, unsigned int radioid)
{
	int i = 0;
	unsigned int ret = WID_DBUS_ERROR;
	struct wlanid *wlan_list = NULL;
	struct vlangrpm *mem_search = NULL;
	struct vlangrpm *mem_insert = NULL;
	
	WID_CHECK_G_RADIOID_STANDARD_RET(radioid, RADIO_ID_NOT_EXIST);
	
	if((VLAN_GROUP_NUM < groupid) || (0 == groupid) || (VLAN_GROUP[groupid] == NULL))
	{								
		return GROUP_ID_NOT_EXIST;
	}
	
	if(VLAN_GROUP[groupid]->radio_num > VLAN_GROUP_MAX_MEMBER)
	{
		return GROUP_MEMBER_OVER_MAX_NUM;
	}
	
	if(AC_RADIO[radioid]->Wlan_Id != NULL)
	{
		wlan_list = AC_RADIO[radioid]->Wlan_Id;
		while(wlan_list != NULL)
		{	
			if(wlan_list->wlanid == VLAN_GROUP[groupid]->wlan_id)
			{
				wid_syslog_debug_debug(WID_DBUS, "radio %d has binded wlan %d",
												 radioid, VLAN_GROUP[groupid]->wlan_id);
				ret = WID_DBUS_SUCCESS;
				break;
			}
			wlan_list = wlan_list->next;		
		}
	}
	
	if((AC_RADIO[radioid]->Wlan_Id == NULL) || (ret != WID_DBUS_SUCCESS))
	{
		return RADIO_NO_BINDING_WLAN;
	}
	
	CWThreadMutexLock(&VLAN_GROUP[groupid]->radioListMutex);
	if(VLAN_GROUP[groupid]->radio_member != NULL)
	{
		mem_search = find_radio_from_vlangrp(VLAN_GROUP[groupid]->radio_member, radioid);
		if(NULL != mem_search)
		{
			CWThreadMutexUnlock(&VLAN_GROUP[groupid]->radioListMutex);
			wid_syslog_debug_debug(WID_DBUS,"radio %d in vlan group %d memlist\n", radioid, groupid);
			return RADIO_ID_BE_USED;
		}
	}
    CWThreadMutexUnlock(&VLAN_GROUP[groupid]->radioListMutex);
			
	for(i = 1; (i <= VLAN_GROUP_NUM); i++)
	{
		if((VLAN_GROUP[i] == NULL) || (i == groupid))
		{
			continue;
		}
		
		if(VLAN_GROUP[i]->wlan_id == VLAN_GROUP[groupid]->wlan_id)
		{
			wid_syslog_debug_debug(WID_DBUS,"vlan group %d set up the same wlan %d\n",
											i, VLAN_GROUP[groupid]->wlan_id);
			
			CWThreadMutexLock(&VLAN_GROUP[i]->radioListMutex);
			if(VLAN_GROUP[i]->radio_member != NULL)
			{
				mem_search = find_radio_from_vlangrp(VLAN_GROUP[i]->radio_member, radioid);
				if(NULL != mem_search)
				{
					CWThreadMutexUnlock(&VLAN_GROUP[i]->radioListMutex);
					wid_syslog_debug_debug(WID_DBUS, "vlan group %d already add radio %d\n", i, radioid);						
					return BSS_IN_OTHER_VLANGRP;
				}				
			}
			CWThreadMutexUnlock(&VLAN_GROUP[i]->radioListMutex);
		}			
	}
	
    CWThreadMutexLock(&VLAN_GROUP[groupid]->radioListMutex);
	if(ret == WID_DBUS_SUCCESS)
	{	
		mem_insert = insert_radio_to_vlangrp(VLAN_GROUP[groupid]->radio_member, radioid);
		if(NULL == mem_insert)
		{
			CWThreadMutexUnlock(&VLAN_GROUP[groupid]->radioListMutex);
			wid_syslog_info("%s, malloc radionode error\n", __func__);
			return MALLOC_ERROR;
		}

		VLAN_GROUP[groupid]->radio_member = mem_insert;
		VLAN_GROUP[groupid]->radio_num++;
		wid_syslog_debug_debug(WID_DBUS,"vlan group %d add radio %d now radionum %d\n",
										groupid, radioid, VLAN_GROUP[groupid]->radio_num);

		unsigned int wtpid = radioid / L_RADIO_NUM;
		unsigned char l_radioid = radioid % L_RADIO_NUM;
		unsigned int bssindex = AC_WLAN[VLAN_GROUP[groupid]->wlan_id]->S_WTP_BSS_List[wtpid][l_radioid];
		if(NULL != AC_BSS[bssindex])
		{
			AC_BSS[bssindex]->vlangrpid = groupid;
			wid_syslog_debug_debug(WID_DBUS,"vlan group %d add radio %d-%d wlan %d bssindex %d\n",
											groupid, wtpid, l_radioid, VLAN_GROUP[groupid]->wlan_id, bssindex);
		}
	}
	
	CWThreadMutexUnlock(&VLAN_GROUP[groupid]->radioListMutex);
	
	return WID_DBUS_SUCCESS;
}


unsigned int del_vlan_group_member(unsigned int groupid, unsigned int radioid)
{
	struct vlangrpm *mem_search = NULL;
	
	WID_CHECK_G_RADIOID_STANDARD_RET(radioid, RADIO_ID_NOT_EXIST);
	
	if((VLAN_GROUP_NUM < groupid) || (0 == groupid) || (VLAN_GROUP[groupid] == NULL))
	{								
		return GROUP_ID_NOT_EXIST;
	}
	
	if(VLAN_GROUP[groupid]->radio_num == 0)
	{
		return NO_SET_GROUP_RADIO_MEMBER;
	}

	CWThreadMutexLock(&VLAN_GROUP[groupid]->radioListMutex);
	if(VLAN_GROUP[groupid]->radio_member != NULL)
	{
		mem_search = find_radio_from_vlangrp(VLAN_GROUP[groupid]->radio_member, radioid);
		if(NULL == mem_search)
		{
			CWThreadMutexUnlock(&VLAN_GROUP[groupid]->radioListMutex);
			wid_syslog_debug_debug(WID_DBUS,"radio %d not in vlan group %d\n", radioid, groupid);
			return RADIO_ID_NOT_IN_VLANGRP;
		}
		
		VLAN_GROUP[groupid]->radio_member = delete_radio_from_vlangrp(VLAN_GROUP[groupid]->radio_member, radioid);
		VLAN_GROUP[groupid]->radio_num--;

		unsigned int wtpid = radioid / L_RADIO_NUM;
		unsigned char l_radioid = radioid % L_RADIO_NUM;
		if(NULL != AC_WLAN[VLAN_GROUP[groupid]->wlan_id])
		{
    		unsigned int bssindex = AC_WLAN[VLAN_GROUP[groupid]->wlan_id]->S_WTP_BSS_List[wtpid][l_radioid];
    		if(NULL != AC_BSS[bssindex])
    		{
    			AC_BSS[bssindex]->vlangrpid = 0;
    			wid_syslog_debug_debug(WID_DBUS,"vlan group %d delete radio %d-%d wlan %d bssindex %d, now radionum %d\n",
    											groupid, wtpid, l_radioid, VLAN_GROUP[groupid]->wlan_id,
    											bssindex, VLAN_GROUP[groupid]->radio_num);
    		}
		}
	}	
	
	CWThreadMutexUnlock(&VLAN_GROUP[groupid]->radioListMutex);
    
	return WID_DBUS_SUCCESS;
}


unsigned int set_vlan_group_service_enable(unsigned int groupid)
{
	int i = 0;
	unsigned int g_radioid = 0;
	unsigned int ret = WID_DBUS_ERROR;
	struct vlangrpm *mem_list = NULL;

	if((VLAN_GROUP_NUM < groupid) || (0 == groupid) || (VLAN_GROUP[groupid] == NULL))
	{
		return GROUP_ID_NOT_EXIST;
	}
	
	CWThreadMutexLock(&VLAN_GROUP[groupid]->radioListMutex);
	if(VLAN_GROUP[groupid]->radio_member != NULL)
	{
		mem_list = VLAN_GROUP[groupid]->radio_member;
		while(mem_list != NULL)
		{
			g_radioid = mem_list->radioid;		
			if(NULL == AC_RADIO[g_radioid])	
			{
				wid_syslog_debug_debug(WID_DBUS,"%s: radio %d-%d not exist\n",__func__,g_radioid/L_RADIO_NUM,g_radioid%L_RADIO_NUM);
				
				mem_list = mem_list->next;          
				continue;
			}
			
			struct wlanid *wlan_list = NULL;	
			wlan_list = AC_RADIO[g_radioid]->Wlan_Id;
			while(wlan_list != NULL)
			{	
				if(wlan_list->wlanid == VLAN_GROUP[groupid]->wlan_id)
				{	
					wid_syslog_debug_debug(WID_DBUS,"Radio %d has bound the vlan-group wlan %d\n",
													g_radioid, VLAN_GROUP[groupid]->wlan_id);
					
					for(i = 0; i< L_BSS_NUM; i++)
					{
						if(NULL == AC_RADIO[g_radioid]->BSS[i])
						{
							continue;
						}
						
						if(AC_RADIO[g_radioid]->BSS[i]->WlanID == VLAN_GROUP[groupid]->wlan_id)
						{
							wid_syslog_debug_debug(WID_DBUS,"Radio %d bssindex %d wlan %d, vlan group wlan %d\n",
															g_radioid, AC_RADIO[g_radioid]->BSS[i]->BSSIndex, 
															AC_RADIO[g_radioid]->BSS[i]->WlanID,
															VLAN_GROUP[groupid]->wlan_id);
		
							unsigned int wtpid = g_radioid / L_RADIO_NUM;
							unsigned char l_radioid = g_radioid % L_RADIO_NUM;
							unsigned int bssindex = AC_WLAN[VLAN_GROUP[groupid]->wlan_id]->S_WTP_BSS_List[wtpid][l_radioid];
							AC_BSS[bssindex]->dyvlanid = VLAN_GROUP[groupid]->vlan_id;
					#if NOSOFTAC
							AsdWsm_BSSOp(bssindex, WID_MODIFY, 1);					
							wid_update_bss_to_wifi(bssindex, wtpid, 1); 
					#endif
							wid_syslog_debug_debug(WID_DBUS,"vlan-group service enable, set bssindex %d vlan %d,"
															" notice to AsdWsm and wifi\n",
															bssindex, AC_BSS[bssindex]->dyvlanid);
		
							ret = WID_DBUS_SUCCESS;
							break;
						}				
					}
					break;
				}
				wlan_list = wlan_list->next;
			}
			if (ret !=	WID_DBUS_SUCCESS)
			{
				wid_syslog_debug_debug(WID_DBUS,"Vlan-Group member radio %d is not bound to wlan %d\n", 
												g_radioid, VLAN_GROUP[groupid]->wlan_id);																
			}
			mem_list = mem_list->next;			
		}
	}
	
	CWThreadMutexUnlock(&VLAN_GROUP[groupid]->radioListMutex);
	
	if (ret !=  WID_DBUS_SUCCESS)
	{
		wid_syslog_debug_debug(WID_DBUS,"All vlan-group radio members are not binding wlan %d\n",
										VLAN_GROUP[groupid]->wlan_id);
		return RADIO_NO_BINDING_WLAN;
	}

	VLAN_GROUP[groupid]->service_policy = 1;
	
	return WID_DBUS_SUCCESS;
}



unsigned int set_vlan_group_service_disable(unsigned int groupid)
{
	int i = 0;
	int g_radioid = 0;
	unsigned int ret = WID_DBUS_ERROR;
	struct vlangrpm *mem_list = NULL;

	if((VLAN_GROUP_NUM < groupid) || (0 == groupid) || (VLAN_GROUP[groupid] == NULL))
	{
		return GROUP_ID_NOT_EXIST;
	}
	
	CWThreadMutexLock(&VLAN_GROUP[groupid]->radioListMutex);
	if(VLAN_GROUP[groupid]->radio_member != NULL)
	{
		mem_list = VLAN_GROUP[groupid]->radio_member;
		
		while(mem_list != NULL)
		{
			g_radioid = mem_list->radioid;		
			if(NULL == AC_RADIO[g_radioid]) 
			{
				wid_syslog_debug_debug(WID_DBUS,"%s: radio %d-%d not exist\n",__func__,
										g_radioid/L_RADIO_NUM,g_radioid%L_RADIO_NUM);
				mem_list = mem_list->next;      
				continue;
			}
			wid_syslog_debug_debug(WID_DBUS,"%s: VLAN_GROUP[%d] radionum %d find radio %d\n",
			                                __func__,groupid,VLAN_GROUP[groupid]->radio_num,g_radioid);
			
			struct wlanid *wlan_list = NULL;	
			wlan_list = AC_RADIO[g_radioid]->Wlan_Id;
			while(wlan_list != NULL)
			{	
				if(wlan_list->wlanid == VLAN_GROUP[groupid]->wlan_id)
				{
					wid_syslog_debug_debug(WID_DBUS,"Radio %d has bound the vlan-group wlan %d\n", 
													g_radioid, VLAN_GROUP[groupid]->wlan_id);
					
					for(i = 0; i < L_BSS_NUM; i++)
					{
						if(NULL == AC_RADIO[g_radioid]->BSS[i])
						{
							continue;
						}
						if(AC_RADIO[g_radioid]->BSS[i]->WlanID == VLAN_GROUP[groupid]->wlan_id)
						{
							wid_syslog_debug_debug(WID_DBUS,"Radio %d bssindex %d wlan %d, vlan group wlan %d\n",
															g_radioid, AC_RADIO[g_radioid]->BSS[i], 
															AC_RADIO[g_radioid]->BSS[i]->WlanID,
															VLAN_GROUP[groupid]->wlan_id);
							
							unsigned int wtpid = g_radioid / L_RADIO_NUM;
							unsigned char l_radioid = g_radioid % L_RADIO_NUM;
							unsigned int bssindex = AC_WLAN[VLAN_GROUP[groupid]->wlan_id]->S_WTP_BSS_List[wtpid][l_radioid];
							AC_BSS[bssindex]->dyvlanid = 0;
				#if NOSOFTAC
							AsdWsm_BSSOp(bssindex, WID_MODIFY, 1);
							wid_update_bss_to_wifi(bssindex, wtpid, 1);	
				#endif			
							wid_syslog_debug_debug(WID_DBUS, "vlan-group service disable, "
															"set bss %d vlan %d, notice to AsdWsm and wifi\n",
															bssindex, AC_BSS[bssindex]->dyvlanid);																
							ret = WID_DBUS_SUCCESS;
							break;
						}					
					}
					break;
				}
				wlan_list = wlan_list->next;
			}
			if (ret !=  WID_DBUS_SUCCESS)
			{
				wid_syslog_debug_debug(WID_DBUS,"Vlan-Group member radio %d is not bound to wlan %d\n",
												g_radioid, VLAN_GROUP[groupid]->wlan_id);																
			}
			mem_list = mem_list->next;
		}
	}
	CWThreadMutexUnlock(&VLAN_GROUP[groupid]->radioListMutex);
    
	if (ret !=  WID_DBUS_SUCCESS)
	{
		wid_syslog_debug_debug(WID_DBUS,"All vlan-group radio members are not binding wlan %d\n",
										VLAN_GROUP[groupid]->wlan_id);
	}
	VLAN_GROUP[groupid]->service_policy = 0;

	return WID_DBUS_SUCCESS;
}


unsigned int wid_wlan_set_dynamic_vlan_on_off(unsigned int wlanid, unsigned int dvlan_enable)
{
	unsigned int ret = 0;
	
	if (WLAN_NUM <= wlanid ||wlanid <1 ||(dvlan_enable != 0 && dvlan_enable != 1))
	{
		wid_syslog_info("WLAN_NUM <= wlanid ||wlanid <1 ||");
		return WID_DBUS_ERROR;
	}

	if (NULL == AC_WLAN[wlanid])
	{
		return WLAN_ID_NOT_EXIST;
	}

	if (0 == AC_WLAN[wlanid]->SecurityID)
	{
		ret = WLAN_APPLY_SECURITY_FIRST;
	}
	
	if (!AC_WLAN[wlanid]->Status)	/* 0 : enable 1 : disable */
	{
		return WLAN_BE_ENABLE;
	}

	if (AC_WLAN[wlanid]->dvlan.enable != dvlan_enable)
	{
		AC_WLAN[wlanid]->dvlan.enable = dvlan_enable;	
		ret = wid_to_asd_dynamic_vlan_state(wlanid, dvlan_enable);
	}
	wid_syslog_info("wlan %d dynamic vlan %s\n",wlanid, AC_WLAN[wlanid]->dvlan.enable? "enable":"disable");
	return ret;
}

unsigned int check_dynamic_vlan_list
(
	unsigned char *dvlanlist,
	unsigned int dvlanlen,
	unsigned short *array
)
{
	unsigned int ret = 0;
	int num = 0, index = 0,flag1 = 0, first = 0, number = 0, j = 0;
	int lastindex = -1;

	num = dvlanlen;
	
	if(!(dvlanlist[0]>'0' && dvlanlist[0]<='9') || !(dvlanlist[num-1]>='0' && dvlanlist[num-1]<='9'))
	{
	  	goto err;
	}
	
	for(index=0;index<num;index++)
	{
		if(((dvlanlist[index]<'0' && dvlanlist[index]>'9')
		   && dvlanlist[index] != '-'
		   && dvlanlist[index] != ',')
		   ||((dvlanlist[index] == '-' ||dvlanlist[index] == ',') && dvlanlist[index+1] == '0' )
		   )
		{
		  	goto err;
		}
	}

	for(index=0; index<num; index++)
	{
		//handle  '-'
		if ('-' == dvlanlist[index])
		{
			if (1 == flag1)
			{
				goto err;
			}
			flag1 = 1;

			if (-1 == lastindex)
			{
				if (index > 4)
				{
					goto err;
				}
				
				first = sum_of_strtoint(index, lastindex,dvlanlist);
				if (first > DYNAMIC_VLAN_MAX_ID)
				{
					goto err;
				}
			}
			else if ((index - lastindex)<2 ||(index - lastindex)>5)
			{
				goto err;
			}
			else 
			{
				first = sum_of_strtoint(index, lastindex, dvlanlist);  
				if (first > DYNAMIC_VLAN_MAX_ID)
				{
					goto err;
				}
			}
			lastindex = index;
		}
		
		//handle ','
		if (',' == dvlanlist[index])
		{
			
			if ( -1 == lastindex)
			{
				if (index > 4)
				{
					goto err;
				}

				number = sum_of_strtoint(index, lastindex, dvlanlist);
				if (number > DYNAMIC_VLAN_MAX_ID)
				{
					goto err;
				}
				array[number] = 1;
			}
			else if ((index - lastindex)<2 ||(index - lastindex)>5)
			{
				goto err;
			}
			else
			{
				number = sum_of_strtoint(index, lastindex, dvlanlist);
				if (number > DYNAMIC_VLAN_MAX_ID)
				{
					goto err;
				}
			}
			
			if (1 == flag1)
			{
				if (number < first)
				{
					goto err;
				}
				for(j=first; j<=number;j++)
				{
					array[j] = 1;
				}
			}
			else
			{
				array[number] = 1;
			}
			flag1 = 0;
			lastindex = index;
		}
		
        	//handle last numer 
		if (index == num-1)
		{
			if (index - lastindex > 4)
			{
				goto err;
			}

			number = sum_of_strtoint(index+1, lastindex, dvlanlist);
			if (number > DYNAMIC_VLAN_MAX_ID ||number < 1)
			{
				goto err;
			}
			
			if ( '-' == dvlanlist[lastindex])
			{
				if (number < first)
				{
					goto err;
				}
				for(j=first; j<=number; j++)
				{
					array[j] = 1;
				}
			}
			else
			{
				array[number] = 1;
			}
		}
	}
	return ret;
	
	err:
	return DYNAMIC_VLAN_PARAMTER_ERROR;
}

unsigned int add_dynamic_vlan_list
(
	unsigned int wlanid, 
	unsigned short *start_array,
	unsigned short *end_array,
	int *dvlan_count
)
{
	int j = 0, k = 0;
	unsigned int ret = 0;
	unsigned short association_array[DYNAMIC_VLAN_MAX_ID+1] ={0};
	
	for(j=0; j<AC_WLAN[wlanid]->dvlan.cnt; j++)
	{
		association_array[AC_WLAN[wlanid]->dvlan.vlan[j]] = 1;
	}

	for(j=0; j<=DYNAMIC_VLAN_MAX_ID; j++)
	{
		if (1 == start_array[j])
		{
			association_array[j] = 1;
		}
	}

	for(j=0; j<=DYNAMIC_VLAN_MAX_ID; j++)
	{
		if (1 == association_array[j])
		{
			
			if(k>=DYNAMIC_VLAN_MAX_AMOUNT)
			{
				return DYNAMIC_VLAN_ADD_ERROR;
			}
			end_array[k] = j;
			k++;
		}
	}

	*dvlan_count = k;
	return ret;
}
unsigned int delete_dynamic_vlan_list
(
	unsigned int wlanid, 
	unsigned short *start_array, 
	unsigned short *end_array,
	int *dvlan_count
)
{
	int j = 0, k = 0;
	unsigned int ret = 0;
	unsigned short association_array[DYNAMIC_VLAN_MAX_ID+1] ={0};
	
	if (0 == AC_WLAN[wlanid]->dvlan.cnt)
	{
		return DYNAMIC_VLAN_DELETE_ERROR;
	}

	for(j=0; j<AC_WLAN[wlanid]->dvlan.cnt; j++)
	{
		association_array[AC_WLAN[wlanid]->dvlan.vlan[j]] = 1;
	}

	for(j=0; j<=DYNAMIC_VLAN_MAX_ID; j++)
	{
		if (1 == start_array[j])
		{
			if (1 != association_array[j])
			{
				return DYNAMIC_VLAN_DELETE_ERROR;
			}
			association_array[j] = 0;
		}
	}

	for(j=0; j<=DYNAMIC_VLAN_MAX_ID; j++)
	{
		if (1 == association_array[j])
		{
			end_array[k] = j;
			k++;
		}
	}

	*dvlan_count = k;
	return ret;
}
unsigned int save_dynamic_vlan_list(unsigned int wlanid, unsigned short *array,  int dvlan_count)
{
	unsigned int ret = 0;
	if(NULL != AC_WLAN[wlanid]->dvlan.vlan)
	{
		free(AC_WLAN[wlanid]->dvlan.vlan);
		AC_WLAN[wlanid]->dvlan.vlan = NULL;
	}
	AC_WLAN[wlanid]->dvlan.vlan = (unsigned short*)malloc((dvlan_count)*sizeof(unsigned short)+1);
	if (NULL == AC_WLAN[wlanid]->dvlan.vlan)
	{			
		wid_syslog_err("%s: malloc %s",__func__, strerror(errno));
		return WID_DBUS_ERROR;
	}
	memset(AC_WLAN[wlanid]->dvlan.vlan, 0, (dvlan_count)*sizeof(unsigned short)+1);
	memcpy(AC_WLAN[wlanid]->dvlan.vlan, array, dvlan_count*sizeof(unsigned short));
	
	AC_WLAN[wlanid]->dvlan.cnt = dvlan_count;
	wid_syslog_info("add wlan%d dynamic vlan. new count: %d\n", wlanid, AC_WLAN[wlanid]->dvlan.cnt);
	return ret;
}

unsigned int wid_wlan_change_dynamic_vlan_list
(
	unsigned int add,
	unsigned int wlanid,
	unsigned char *dvlanlist,
	unsigned int dvlanlen
)
{
	int dvlan_count = 0;
	unsigned int ret = 0;
	unsigned short start_array[DYNAMIC_VLAN_MAX_ID+1] ={0};
	unsigned short  end_array[DYNAMIC_VLAN_MAX_AMOUNT] ={0}; 
	
	if (WLAN_NUM <= wlanid ||1>wlanid  ||(add != 0 && add != 1))
	{
		return WID_DBUS_ERROR;
	}
	
	if (NULL == AC_WLAN[wlanid])
	{
		return WLAN_ID_NOT_EXIST;
	}

	if (0 == AC_WLAN[wlanid]->SecurityID)
	{
		ret = WLAN_APPLY_SECURITY_FIRST;
	}

	if (!AC_WLAN[wlanid]->Status)	/* 0 : enable 1 : disable */
	{
		return WLAN_BE_ENABLE;
	}

	if (1 == AC_WLAN[wlanid]->dvlan.enable)
	{
		return DYNAMIC_VLAN_NOT_DISABLE;
	}

	ret = check_dynamic_vlan_list(dvlanlist, dvlanlen, start_array);
	if(DYNAMIC_VLAN_PARAMTER_ERROR == ret)
	{
		return ret;
	}

	if (ADD_DYNAMIC_VLAN == add)  //add dynamic-vlan
	{
		ret = add_dynamic_vlan_list(wlanid, start_array, end_array, &dvlan_count);
		if(DYNAMIC_VLAN_ADD_ERROR == ret)
		{
			return ret;
		}
	}
	else  //delete dynamic-vlan
	{
		ret = delete_dynamic_vlan_list(wlanid, start_array, end_array,&dvlan_count);
		if(DYNAMIC_VLAN_DELETE_ERROR == ret)
		{
			return ret;
		}

	}	
	ret = save_dynamic_vlan_list(wlanid, end_array, dvlan_count);
	if(WID_DBUS_ERROR == ret)
	{
		return ret;
	}
	ret = wid_to_asd_dynamic_vlan_list(wlanid);
	return ret;
}


int wid_ioctl_to_wifi(unsigned int cmd, void *data)
{
	static int fd = -1;
	int ret = -1;	

	if (!data)
	{
		return -1;
	}

	if (fd < 0)
	{
		fd = open(WID_WIFI_PATH, O_RDWR);
		if(fd < 0)
		{
			wid_syslog_info("%s:%d open file %s failed %s\n",
				__func__,__LINE__, strerror(errno));
			return -1;
		}
	}

	ret = ioctl(fd, cmd, data);	
	if(ret < 0)
	{
		wid_syslog_info("%s:%d ioctl cmd %x failed %s\n",
			__func__,__LINE__, cmd, strerror(errno));
		return -1;
	}

	return 0;

}



int update_qos_map_info_to_wifi(unsigned int bssindex, unsigned char type, unsigned char *qos_map)
{
	struct wifi_qos_map_info mapinfo;

	wid_syslog_debug("%s: qos map %p bssindex %d state %d \n", __func__, qos_map, bssindex, AC_BSS[bssindex]->State);

	if(NULL == qos_map)
	{
		return PARAM_NULL_POINTER;
	}
	if(!check_bssid_func(bssindex))
	{
		return BSS_NOT_EXIST;
	}

	if(0 == AC_BSS[bssindex]->State)
	{
		return 0;
	}

	memset(&mapinfo, 0, sizeof(struct wifi_qos_map_info));
	memcpy(mapinfo.BSSID, AC_BSS[bssindex]->BSSID, MAC_LEN);
	mapinfo.type = type;
	switch(type)
	{
		case QOS_MAP_11E_TO_1P:
			memcpy(mapinfo.map, qos_map, MAX_QOS_11E_VAL+1);
			break;
		case QOS_MAP_DSCP_TO_DSCP:
			memcpy(mapinfo.map, qos_map, MAX_QOS_DSCP_VAL+1);
			break;
		case QOS_MAP_DSCP_TO_1P:
			memcpy(mapinfo.map, qos_map, MAX_QOS_DSCP_VAL+1);
			break;
		default:
			wid_syslog_info("%s: bss[%d]ERR unknown type %d\n", __func__, bssindex, type);
			break;
		
	}

	if (wid_ioctl_to_wifi(WIFI_IOC_QOS_MAP_UPDATE, &mapinfo) < 0)
	{
		wid_syslog_err("%s: radio %d-%d wlan %d bssindex %d update qos map failed\n", __func__, 
			AC_BSS[bssindex]->Radio_G_ID / L_RADIO_NUM, AC_BSS[bssindex]->Radio_L_ID,
			AC_BSS[bssindex]->WlanID, bssindex);
		
		return UNKNOWN_ERROR;
	}
	wid_syslog_debug("%s: wlan %d radio %d-%d qos map updated successfully!\n", \
		__func__, AC_BSS[bssindex]->WlanID, AC_BSS[bssindex]->Radio_G_ID / L_RADIO_NUM, AC_BSS[bssindex]->Radio_L_ID);

	return 0;
}

int set_ap_bss_qos_map_info(unsigned int wtpid, 
									unsigned char l_radioid,
									unsigned char wlanid,
									unsigned char type,
									unsigned char index, 
									unsigned char mapval)
{
	msgq msg;
	int count = 1;
	
	if(WTP_NUM <= wtpid)
	{
		return WTP_ID_LARGE_THAN_MAX;
	}
	if(NULL == AC_WTP[wtpid])
	{
		return WTP_ID_NOT_EXIST;
	}	

	memset((char*)&msg, 0, sizeof(msg));
	msg.mqid = wtpid%THREAD_NUM+1;
	msg.mqinfo.WTPID = wtpid;
	msg.mqinfo.type = CONTROL_TYPE;
	msg.mqinfo.subtype = WTP_S_TYPE;
	msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_QOS_MAP_INFO;
	msg.mqinfo.u.WtpInfo.value1 = l_radioid;
	msg.mqinfo.u.WtpInfo.value4 = wlanid;
	msg.mqinfo.u.WtpInfo.value3 = type;
	msg.mqinfo.u.WtpInfo.value2 = count;
	msg.mqinfo.u.WtpInfo.value[0] = index;
	msg.mqinfo.u.WtpInfo.value[1] = mapval;

	if(WID_RUN == AC_WTP[wtpid]->WTPStat)
	{
		if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
		{
			wid_syslog_info("%s:WTP[%d] msgsend %s",__func__, wtpid, strerror(errno));
			return UNKNOWN_ERROR;
		}
	}
	else if(NULL != AC_WTP[wtpid])
	{	
		struct msgqlist *elem = NULL;

		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if (NULL == elem)
		{
			WID_MALLOC_ERR();
			return MALLOC_ERROR;
		}
		memset(elem, 0, sizeof(struct msgqlist));
		elem->mqinfo.WTPID = wtpid;
		elem->mqinfo.type = CONTROL_TYPE;
		elem->mqinfo.subtype = WTP_S_TYPE;
		elem->mqinfo.u.WtpInfo.Wtp_Op = WTP_QOS_MAP_INFO;
		elem->mqinfo.u.WtpInfo.value1 = l_radioid;
		elem->mqinfo.u.WtpInfo.value4 = wlanid;
		elem->mqinfo.u.WtpInfo.value3 = type;
		elem->mqinfo.u.WtpInfo.value2 = count;
		elem->mqinfo.u.WtpInfo.value[0] = index;
		elem->mqinfo.u.WtpInfo.value[1] = mapval;

		WID_INSERT_CONTROL_LIST(wtpid, elem);
	}
		
	return 0;
}

int set_ap_bss_qos_map_default(unsigned int wtpid, 
									unsigned char l_radioid, 
									unsigned char type,
									unsigned char wlanid)
{
	int i = 0, j = 0;
	msgq msg;
	int count = 0;
	struct msgqlist *elem = NULL;
	
	if(WTP_NUM <= wtpid)
	{
		return WTP_ID_LARGE_THAN_MAX;
	}
	if(NULL == AC_WTP[wtpid])
	{
		return WTP_ID_NOT_EXIST;
	}
	
	if(WLAN_NUM <= wlanid)
	{
		return WLAN_ID_LARGE_THAN_MAX;
	}	
	if(NULL == AC_WLAN[wlanid])
	{
		return WLAN_ID_NOT_EXIST;
	}
	
	memset((char*)&msg, 0, sizeof(msg));
	
	msg.mqid = wtpid%THREAD_NUM+1;
	msg.mqinfo.WTPID = wtpid;
	msg.mqinfo.type = CONTROL_TYPE;
	msg.mqinfo.subtype = WTP_S_TYPE;
	msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_QOS_MAP_INFO;
	msg.mqinfo.u.WtpInfo.value1 = l_radioid;
	msg.mqinfo.u.WtpInfo.value4 = wlanid;
	msg.mqinfo.u.WtpInfo.value3 = type;	
	
	if(QOS_MAP_11E_TO_1P == type)
	{
		count = MAX_QOS_11E_VAL+1;
		for(i = 0; i < count; i++)
		{
			msg.mqinfo.u.WtpInfo.value[j] = i ;
			msg.mqinfo.u.WtpInfo.value[j+1] = AC_WLAN[wlanid]->qos_ap_11e_to_1p[i];
			j += 2;
		}
	}
	else if(QOS_MAP_11E_TO_DSCP == type)
	{
		count = MAX_QOS_11E_VAL+1;
		for(i = 0; i < count; i++)
		{
			msg.mqinfo.u.WtpInfo.value[j] = i ;
			msg.mqinfo.u.WtpInfo.value[j+1] = AC_WLAN[wlanid]->qos_ap_11e_to_dscp[i];
			j += 2;
		}

	}
	else if(QOS_MAP_DSCP_TO_11E == type)
	{
		count = MAX_QOS_DSCP_VAL+1;
		for(i = 0; i < count; i++)
		{
			msg.mqinfo.u.WtpInfo.value[j] = i ;
			msg.mqinfo.u.WtpInfo.value[j+1] = AC_WLAN[wlanid]->qos_ap_dscp_to_11e[i];
			j += 2;
		}
	}
	else if(QOS_MAP_1P_TO_11E == type)
	{
		count = MAX_QOS_1P_VAL+1;
		for(i = 0; i < count; i++)
		{
			msg.mqinfo.u.WtpInfo.value[j] = i ;
			msg.mqinfo.u.WtpInfo.value[j+1] = AC_WLAN[wlanid]->qos_ap_1p_to_11e[i];
			j += 2;
		}
	}
	msg.mqinfo.u.WtpInfo.value2 = count;
	
	if(WID_RUN == AC_WTP[wtpid]->WTPStat)
	{
		if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
		{
			wid_syslog_info("%s:wtp %d msgsend %s",__func__, wtpid, strerror(errno));
			return UNKNOWN_ERROR;
		}
	}
	else
	{
		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if(NULL == elem)
		{
			WID_MALLOC_ERR();		
			return MALLOC_ERROR;
		}
		memset(elem, 0, sizeof(struct msgqlist));
		
		elem->mqinfo.WTPID = wtpid;
		elem->mqinfo.type = CONTROL_TYPE;
		elem->mqinfo.subtype = WTP_S_TYPE;
		elem->mqinfo.u.WtpInfo.Wtp_Op = WTP_QOS_MAP_INFO;
		elem->mqinfo.u.WtpInfo.value1 = l_radioid;
		elem->mqinfo.u.WtpInfo.value4 = wlanid;
		elem->mqinfo.u.WtpInfo.value3 = type;	

		if(QOS_MAP_11E_TO_1P == type)
		{
			count = MAX_QOS_11E_VAL+1;
			for(i = 0; i < count; i++)
			{
				elem->mqinfo.u.WtpInfo.value[j] = i ;
				elem->mqinfo.u.WtpInfo.value[j+1] = AC_WLAN[wlanid]->qos_ap_11e_to_1p[i];
				j += 2;
			}
		}
		else if(QOS_MAP_11E_TO_DSCP == type)
		{
			count = MAX_QOS_11E_VAL+1;
			for(i = 0; i < count; i++)
			{
				elem->mqinfo.u.WtpInfo.value[j] = i ;
				elem->mqinfo.u.WtpInfo.value[j+1] = AC_WLAN[wlanid]->qos_ap_11e_to_dscp[i];
				j += 2;
			}

		}
		else if(QOS_MAP_DSCP_TO_11E == type)
		{
			count = MAX_QOS_DSCP_VAL+1;
			for(i = 0; i < count; i++)
			{
				elem->mqinfo.u.WtpInfo.value[j] = i ;
				elem->mqinfo.u.WtpInfo.value[j+1] = AC_WLAN[wlanid]->qos_ap_dscp_to_11e[i];
				j += 2;
			}
		}
		else if(QOS_MAP_1P_TO_11E == type)
		{
			count = MAX_QOS_1P_VAL+1;
			for(i = 0; i < count; i++)
			{
				elem->mqinfo.u.WtpInfo.value[j] = i ;
				elem->mqinfo.u.WtpInfo.value[j+1] = AC_WLAN[wlanid]->qos_ap_1p_to_11e[i];
				j += 2;
			}
		}
		elem->mqinfo.u.WtpInfo.value2 = count;
			
		WID_INSERT_CONTROL_LIST(wtpid, elem);				
	}
	wid_syslog_debug_debug(WID_DEFAULT, "%s: wtp %d radio %d wlan %d  type %d\n", __func__, wtpid, l_radioid, wlanid, type);
	return 0;
}

int set_ap_bss_qos_map_switch(unsigned int wtpid, 
									unsigned char l_radioid,
									unsigned char wlanid,
									unsigned char type,																		
									unsigned char policy)
{
	msgq msg;
	struct msgqlist *elem = NULL;
	
	if (WTP_NUM <= wtpid)
	{
		return WTP_ID_LARGE_THAN_MAX;
	}
	if (NULL == AC_WTP[wtpid])
	{
		return WTP_ID_NOT_EXIST;
	}	

	memset((char*)&msg, 0, sizeof(msg));
	msg.mqid = wtpid%THREAD_NUM+1;
	msg.mqinfo.WTPID = wtpid;
	msg.mqinfo.type = CONTROL_TYPE;
	msg.mqinfo.subtype = WTP_S_TYPE;
	msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_QOS_MAP_SWITCH;
	msg.mqinfo.u.WtpInfo.value1 = l_radioid;
	msg.mqinfo.u.WtpInfo.value4 = wlanid;
	msg.mqinfo.u.WtpInfo.value3 = type;
	msg.mqinfo.u.WtpInfo.value2 = policy;

	if (WID_RUN == AC_WTP[wtpid]->WTPStat)
	{
		if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1)
		{
			wid_syslog_info("%s: wtp %d msgsend %s",__func__, wtpid, strerror(errno));
			return UNKNOWN_ERROR;
		}
	}
	else
	{
		elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
		if (NULL == elem)
		{
			WID_MALLOC_ERR();		
			return MALLOC_ERROR;
		}
		memset(elem, 0, sizeof(struct msgqlist));		

		elem->mqinfo.WTPID = wtpid;
		elem->mqinfo.type = CONTROL_TYPE;
		elem->mqinfo.subtype = WTP_S_TYPE;
		elem->mqinfo.u.WtpInfo.Wtp_Op = WTP_QOS_MAP_SWITCH;
		elem->mqinfo.u.WtpInfo.value1 = l_radioid;
		elem->mqinfo.u.WtpInfo.value4 = wlanid;
		elem->mqinfo.u.WtpInfo.value3 = type;
		elem->mqinfo.u.WtpInfo.value2 = policy;

		WID_INSERT_CONTROL_LIST(wtpid, elem);				
	}	
	wid_syslog_debug_debug(WID_DEFAULT, "%s: wtp %d radio %d wlan %d  type %d policy %d\n",
						__func__, wtpid, l_radioid, wlanid, type, policy);
	return 0;
}

int set_ap_bss_local_survival_switch
(
    unsigned int wtpid,
	unsigned char policy
)
{
    unsigned char wlanid = 0;
    unsigned char localradio_id = 0;
    msgq msg;
    struct msgqlist *elem = NULL;   
    
    WID_CHECK_WTP_STANDARD_RET(wtpid, WTP_ID_NOT_EXIST);

    if (NULL == AC_WTP[wtpid])
    {
        return WTP_ID_NOT_EXIST;
    }
        
    wid_syslog_debug_debug(WID_DEFAULT, "%s, wtp%d local-survival %s\n", __func__,
                                         wtpid,(policy) ? "enable" : "disable");
        
    if ((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPStat == WID_RUN))
    {
        CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));

        if (gWTPs[wtpid].isNotFree && (CW_ENTER_RUN == gWTPs[wtpid].currentState))
        {
            memset((char*)&msg, 0, sizeof(msg));
            msg.mqid = wtpid%THREAD_NUM+1;
            msg.mqinfo.WTPID = wtpid;
            msg.mqinfo.type = CONTROL_TYPE;
            msg.mqinfo.subtype = WTP_S_TYPE;
            msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_ELECTRONIC_MENU;
            msg.mqinfo.u.WtpInfo.value[0] = wlanid;
            msg.mqinfo.u.WtpInfo.value[1] = localradio_id;
            msg.mqinfo.u.WtpInfo.value[2] = LEVEL_AP;
            msg.mqinfo.u.WtpInfo.value[3] = policy;

            if (-1 == msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0))
            {
                wid_syslog_info("%s msgsend %s", __func__, strerror(errno));
            }
            
            wid_syslog_debug_debug(WID_DEFAULT, "%s: send wtp%d local-survival %d msg OK\n",
                                                __func__,wtpid,AC_WTP[wtpid]->electronic_menu);
                
        }       
        CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));
    }
    else if (NULL != AC_WTP[wtpid])
    {
        memset((char*)&msg, 0, sizeof(msg));
        msg.mqid = wtpid%THREAD_NUM+1;
        msg.mqinfo.WTPID = wtpid;
        msg.mqinfo.type = CONTROL_TYPE;
        msg.mqinfo.subtype = WTP_S_TYPE;
        msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_ELECTRONIC_MENU;
        msg.mqinfo.u.WtpInfo.value[0] = wlanid;
        msg.mqinfo.u.WtpInfo.value[1] = localradio_id;
        msg.mqinfo.u.WtpInfo.value[2] = LEVEL_AP;
        msg.mqinfo.u.WtpInfo.value[3] = policy;
            
        elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
        if (elem == NULL)
        {
            WID_MALLOC_ERR();
            return MALLOC_ERROR;
        }       
        else
        {
            memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
            elem->next = NULL;
            memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));

            WID_INSERT_CONTROL_LIST(wtpid, elem);       
            elem = NULL;
        
            wid_syslog_debug_debug(WID_DEFAULT, "%s: insert wtp%d local-survival %d msg to controllist OK\n",
                                                __func__, wtpid, AC_WTP[wtpid]->electronic_menu);
        }
    }

    return 0;   
}


int set_ap_bss_black_white_list
(
    unsigned int wtpid,
    unsigned int macgrpid
)
{
	int i = 0;
    unsigned char policy = 0;
    unsigned char wlanid = 0;
    unsigned char localradio_id = 0;
    WTPlist *wtplist = NULL;
    WTPlist *wtptemp = NULL;
    MAC_list *maclist = NULL;
	msgq msg;
	struct msgqlist *elem = NULL;
	
    if ((1 > macgrpid) || (MAC_GROUP_NUM <= macgrpid))
    {
        return GROUP_ID_LARGE_THAN_MAX;
    }
    if (NULL == MAC_GROUP[macgrpid])
    {
        return MAC_GROUP_NOT_EXIST;
    }       
    
    WID_CHECK_WTP_STANDARD_RET(wtpid, WTP_ID_NOT_EXIST);
    
    policy = AC_WTP[wtpid]->mac_grp_policy;
    
    if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPStat == WID_RUN))
    {
        CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));
        if (gWTPs[wtpid].isNotFree && (CW_ENTER_RUN == gWTPs[wtpid].currentState))
        {
            memset((char*)&msg, 0, sizeof(msg));
            msg.mqid = wtpid%THREAD_NUM+1;
            msg.mqinfo.WTPID = wtpid;
            msg.mqinfo.type = CONTROL_TYPE;
            msg.mqinfo.subtype = WTP_S_TYPE;
            msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_BLACK_WHITE_LIST;
            msg.mqinfo.u.WtpInfo.value[0] = wlanid;
            msg.mqinfo.u.WtpInfo.value[1] = localradio_id;
            msg.mqinfo.u.WtpInfo.value[2] = policy;
            msg.mqinfo.u.WtpInfo.value[3] = LEVEL_AP;
            msg.mqinfo.u.WtpInfo.value[4] = OVERWRITE;
            CWThreadMutexLock(&MAC_GROUP[macgrpid]->macListMutex);
            msg.mqinfo.u.WtpInfo.value[5] = MAC_GROUP[macgrpid]->count;
            maclist = MAC_GROUP[macgrpid]->macList;
            for (i = 0; (i < MAC_GROUP[macgrpid]->count) && (i < GROUP_MAC_COUNT); i++)
            {
                memcpy(msg.mqinfo.u.WtpInfo.macarry[i].mac, maclist->mac, sizeof(maclist->mac));
                maclist = maclist->next;
            }
            CWThreadMutexUnlock(&MAC_GROUP[macgrpid]->macListMutex);
        	
            if (-1 == msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0))
            {
                wid_syslog_info("%s msgsend %s", __func__, strerror(errno));
            }
        }       
        CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));
    }
    else if (NULL != AC_WTP[wtpid])
    {
        memset((char*)&msg, 0, sizeof(msg));
        msg.mqid = wtpid%THREAD_NUM+1;
        msg.mqinfo.WTPID = wtpid;
        msg.mqinfo.type = CONTROL_TYPE;
        msg.mqinfo.subtype = WTP_S_TYPE;
        msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_BLACK_WHITE_LIST;
        msg.mqinfo.u.WtpInfo.value[0] = wlanid;
        msg.mqinfo.u.WtpInfo.value[1] = localradio_id;
        msg.mqinfo.u.WtpInfo.value[2] = policy;
        msg.mqinfo.u.WtpInfo.value[3] = LEVEL_AP;
        msg.mqinfo.u.WtpInfo.value[4] = OVERWRITE;
        CWThreadMutexLock(&MAC_GROUP[macgrpid]->macListMutex);
        msg.mqinfo.u.WtpInfo.value[5] = MAC_GROUP[macgrpid]->count;
        maclist = MAC_GROUP[macgrpid]->macList;
        for (i = 0; (i < MAC_GROUP[macgrpid]->count) && (i < GROUP_MAC_COUNT); i++)
        {
            memcpy(msg.mqinfo.u.WtpInfo.macarry[i].mac, maclist->mac, sizeof(maclist->mac));
            maclist = maclist->next;
        }
        CWThreadMutexUnlock(&MAC_GROUP[macgrpid]->macListMutex);
            
        elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
        if (elem == NULL)
        {
            WID_MALLOC_ERR();
            return MALLOC_ERROR;
        }
        else
        {
            memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
            elem->next = NULL;
            memcpy((char*)&(elem->mqinfo), (char*)&(msg.mqinfo), sizeof(msg.mqinfo));
            WID_INSERT_CONTROL_LIST(wtpid, elem);
            elem = NULL;
        }
    }

    /* add wtp to notice chain */
    if (NULL == MAC_GROUP[macgrpid]->WTPList)
    {
        wtptemp = (WTPlist *)malloc(sizeof(WTPlist));
        if (NULL == wtptemp)
        {
            wid_syslog_info("%s malloc %s", __func__, strerror(errno));
            return MALLOC_ERROR;
        }
        wtptemp->WTPIndex = wtpid;
        wtptemp->next = NULL;
        MAC_GROUP[macgrpid]->WTPList = wtptemp;
    }
    else if (MAC_GROUP[macgrpid]->WTPList->WTPIndex == wtpid)
    {
        return 0;   //bssindex in the head,do nothing
    }
    else
    {
        wtplist = MAC_GROUP[macgrpid]->WTPList;
        while (NULL != wtplist->next)
        {
            if (wtplist->next->WTPIndex == wtpid)
            {
                return 0;
            }
            wtplist = wtplist->next;
        }

        wtptemp = (WTPlist *)malloc(sizeof(WTPlist));
        if (NULL == wtptemp)
        {
            wid_syslog_info("%s malloc %s", __func__, strerror(errno));
            return MALLOC_ERROR;
        }
        else
        {
            wtptemp->WTPIndex = wtpid;  
            wtptemp->next = NULL;
            wtplist->next = wtptemp;
        }       
    }       

    return  0;
}   


void select_sort_array(unsigned char *array, int count)
{
	/*from min to max*/
	int j = 0;
	int k = 0;
	int min = 0;
	unsigned char temp = 0;
	
	for (j = 0; j < count-1; j++)
	{
		min = j;
		
		for (k = j+1; k < count; k++)
		{
			if (array[k] < array[min])
			{
				min = k;
			}
		}

		if (min != j)
		{
			temp = array[min];
			array[min] = array[j];
			array[j] = temp;
		}
	}
}
